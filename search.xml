<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Git stage 1</title>
    <url>/2021/04/15/Git/Git%20lerning%20Notes/</url>
    <content><![CDATA[<h1 id="Git-Learning-Notes-from-廖老大！"><a href="#Git-Learning-Notes-from-廖老大！" class="headerlink" title="Git Learning Notes from 廖老大！"></a>Git Learning Notes from 廖老大！</h1><hr>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Git是目前世界上最先进的<strong>分布式版本控制系统</strong>。</p>
<h2 id="诞生"><a href="#诞生" class="headerlink" title="诞生"></a>诞生</h2><blockquote>
<p>BitKeepe<br>Gi –基于C</p>
</blockquote>
<h2 id="集中式-与-分布式"><a href="#集中式-与-分布式" class="headerlink" title="集中式 与 分布式"></a>集中式 与 分布式</h2><ul>
<li>集中式：<br>需先从中央服务器获得最新版本，改后交由服务器整合。—-联网工作</li>
<li>分布式：<br>每个人的电脑上都是一个完整的版本库，各个电脑可相互推送修改内容。—-不必联网</li>
</ul>
<p>所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的详细变化，Microsoft的Word格式是二进制格式</p>
<h2 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h2><ol>
<li>官网下载<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a><br>已安装可通过Git本身获得最新的开发版本<br><code>git clone https://github.com/git/git</code></li>
<li>设置 -指定仓库的用户名和Email地址<br><code>git config --global user.name &quot;Your Name&quot;</code><br><code>git config --global user.email &quot;email@example.com&quot;</code></li>
</ol>
<h2 id="创建版本库（仓库）"><a href="#创建版本库（仓库）" class="headerlink" title="创建版本库（仓库）"></a>创建版本库（仓库）</h2><ul>
<li>创建目录</li>
<li>初始化git </li>
</ul>
<p><code>git init</code></p>
<ul>
<li>添加 readme.txt 文件到git仓库<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add file1  &#x2F;&#x2F;git命令必须在git仓库目录中运行</span><br><span class="line">git add file2  &#x2F;&#x2F;add 文件时改文件必须在当前目录存在</span><br><span class="line"> ...	&#x2F;&#x2F;可以一次提交多个文件</span><br><span class="line">git commit -m &quot;有意义的提交说明&quot;    </span><br></pre></td></tr></table></figure></li>
<li><blockquote>
<p>注意不要使用记事本编写！！！！不要使用记事本编写！！！！不要使用记事本编写！！！！ 安装notepad++</p>
</blockquote>
</li>
</ul>
<h2 id="实时掌握工作区状态"><a href="#实时掌握工作区状态" class="headerlink" title="实时掌握工作区状态"></a>实时掌握工作区状态</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git status &#x2F;&#x2F;显示当前工作区的更改状态（判定是否有差异 差异对象目前不懂）</span><br><span class="line">git diff &#x2F;&#x2F;若存在差异，则可通过命令查看具体的差异   可指定commit_id</span><br><span class="line">git add file1 &#x2F;&#x2F;提交修改记录</span><br><span class="line">git commit -m &quot;修改说明&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="版本更替"><a href="#版本更替" class="headerlink" title="版本更替"></a>版本更替</h2><ol>
<li>查看</li>
</ol>
<ul>
<li>git log</li>
<li>查看<strong>从当前版本</strong>开始最近到最远的提交记录</li>
<li>记录commit_id版本号</li>
<li><blockquote>
<p>id:SHA1计算出来的一个非常大的数字，用十六进制表示,用于区分不同commit版本</p>
</blockquote>
</li>
</ul>
<ol start="2">
<li>回溯<br>git reset –hard commit_id （绝对）<br>git reset –hard head^ （相对）   </li>
</ol>
<ul>
<li>相对head指针指向的版本 ^个数为相对于当前head指向版本的上..版本</li>
<li>head~100 相当于 head^^^^(100个)</li>
</ul>
<ol start="3">
<li>未来</li>
</ol>
<ul>
<li>git reflog</li>
<li>查看<strong>所有</strong>commit版本历史 确定即将更替版本的版本号</li>
</ul>
<hr>
<p>待更新…</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Notes for Lecture 1 and 2</title>
    <url>/2021/04/12/CS106B/CS106B-Lecture1and2/</url>
    <content><![CDATA[<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><hr>
<h1 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h1><h1 id="函数参数工作原理"><a href="#函数参数工作原理" class="headerlink" title="函数参数工作原理"></a>函数参数工作原理</h1><blockquote>
<p>值传递</p>
</blockquote>
<blockquote>
<ul>
<li>创建副本，不影响原实参</li>
</ul>
</blockquote>
<blockquote>
<p>址传递</p>
</blockquote>
<blockquote>
<ul>
<li>传递地址，影响原实参</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>无法传递无任何没有存储位置的值 eg：数组索引,数值</li>
</ul>
</blockquote>
<hr>
<h1 id="程序分解"><a href="#程序分解" class="headerlink" title="程序分解"></a>程序分解</h1><hr>
<h1 id="String-1"><a href="#String-1" class="headerlink" title="String"></a>String</h1><h2 id="字符串处理函数"><a href="#字符串处理函数" class="headerlink" title="字符串处理函数"></a>字符串处理函数</h2><blockquote>
<p><code>#include&lt;string&gt;</code></p>
</blockquote>
<blockquote>
<blockquote>
<p><img src="/images/CS106B-Lecture1and2/functions_strings.png"></p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p><strong>string::npos</strong></p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>用来表示不存在的位置，若字符串不存在包含关系，则 find 函数返回值为 string::npos</p>
</blockquote>
</blockquote>
<blockquote>
<p><code>#include&lt;string.h&gt;</code></p>
</blockquote>
<blockquote>
<blockquote>
<p>strcpy(s1,s2)</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>复制字符串 s2 到 s1</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>strcat(s1,s2)</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>连接 s2 到 s1 的末尾</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>strlen(s1)</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>返回字符串 s1 的长度</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>strcmp(s1,s2)</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>若 s1 和 s2 是相同的，则返回 0，s1&lt; s2,返回值小于 0，若 s1&gt;s2，返回值大于 0</p>
</blockquote>
</blockquote>
<h2 id="常用类库"><a href="#常用类库" class="headerlink" title="常用类库"></a>常用类库</h2><blockquote>
<p><code>#include&quot;strlib.h&quot;</code></p>
</blockquote>
<blockquote>
<blockquote>
<p><img src="/images/CS106B-Lecture1and2/strlib.png"></p>
</blockquote>
</blockquote>
<h1 id="geline"><a href="#geline" class="headerlink" title="geline"></a>geline</h1><blockquote>
<p><img src="/images/CS106B-Lecture1and2/getline.png"></p>
</blockquote>
]]></content>
      <categories>
        <category>CS106B</category>
      </categories>
      <tags>
        <tag>CS106B</tag>
      </tags>
  </entry>
  <entry>
    <title>Notes for Lecture 3</title>
    <url>/2021/04/13/CS106B/CS106B-Lecture3/</url>
    <content><![CDATA[<h1 id="I-O-Streams-Vector-and-Grid"><a href="#I-O-Streams-Vector-and-Grid" class="headerlink" title="I/O Streams;Vector and Grid"></a>I/O Streams;Vector and Grid</h1><hr>
<h1 id="I-O-Streams"><a href="#I-O-Streams" class="headerlink" title="I/O Streams"></a>I/O Streams</h1><p><code>#incldue&lt;fstream&gt;</code></p>
<h1 id="类层次关系"><a href="#类层次关系" class="headerlink" title="类层次关系"></a>类层次关系</h1><blockquote>
<p><img src="/images/Lecture3/struct.png"></p>
</blockquote>
<h1 id="操作方式"><a href="#操作方式" class="headerlink" title="操作方式"></a>操作方式</h1><ol>
<li>创建文件流对象</li>
<li>打开磁盘文件</li>
</ol>
<ul>
<li>将该文件流对象与指定文件建立关联，使文件流能流向指定的磁盘文件</li>
<li>指定工作方式</li>
<li>实现方式:</li>
<li><blockquote>
<p>调用成员函数 open，如下 eg<br><code>object.open(文件路径,I/O模式);</code></p>
</blockquote>
</li>
<li><blockquote>
<p>创建文件流对象时指定参数<br><code>class_name object(文件路径,I/O模式); </code></p>
</blockquote>
</li>
</ul>
<ol start="3">
<li>输入输出</li>
</ol>
<ul>
<li>每次读写都从<strong>文件指针</strong>的当前位置开始，读入一个字节，指针就后移一个字节，读写至文件结束符停止</li>
<li>输入流常用方法<blockquote>
<p><img src="/images/Lecture3/functions.png"></p>
</blockquote>
</li>
</ul>
<ol start="4">
<li>关闭磁盘文件</li>
</ol>
<ul>
<li>obj.close();</li>
</ul>
<h1 id="eg"><a href="#eg" class="headerlink" title="eg:"></a>eg:</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;getline整行读入</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	ifstream input;</span><br><span class="line">	input.open(&quot;.&#x2F;files&#x2F;hello.txt&quot;);</span><br><span class="line">	if (input.fail()) &#123;</span><br><span class="line">		cout &lt;&lt; &quot;error!&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	string line;</span><br><span class="line">	while (getline(input, line))</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; line &lt;&lt; endl;   &#x2F;&#x2F;getline从输入流中读入整行字符，存到string变量，返回值类型为bool</span><br><span class="line">	&#125;</span><br><span class="line">	input.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&gt;&gt;流提取运算符逐个word读入</span><br><span class="line">	while (input &gt;&gt; line)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; line &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h1><hr>
<h2 id="STL-Vector"><a href="#STL-Vector" class="headerlink" title="STL Vector"></a>STL Vector</h2><p>vector 是向量类型，它可以容纳许多类型的数据，所以称其为容器，是由 STL 提供的一种<strong>序列式</strong>容器，它的底层其实就是一个<strong>动态数组</strong>。</p>
<h2 id="vector-常用构造函数"><a href="#vector-常用构造函数" class="headerlink" title="vector 常用构造函数"></a>vector 常用构造函数</h2><p>&#124; &#124;<br>&#124; :-: &#124; :-: &#124;<br>&#124; vector(); &#124; 创建一个没有任何元素的空向量 &#124;<br>&#124; vector(vector&amp;&amp; _Right); &#124; 创建一个向量，并使用向量_Right 初始化该向量 &#124;<br>&#124; vector(size_type Count); &#124; 创建一个大小为 Count 的向量 vect &#124;<br>&#124; vector(size_type Count,const Type&amp; Val); &#124; 创建一个大小为 Count 的向量，该向量中所有的元素都初始化为 Val &#124;<br>&#124; template<typename inputiterator> vector(InputIterator _first,InputIterator _last); &#124; 创建一个向量，并以迭代器_first 和_last 之间的元素初始化该向量 &#124;</typename></p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;vector&gt; &#x2F;&#x2F;需要包含头文件</span><br><span class="line">a.assign(c.begin(), c.begin() + 3); &#x2F;&#x2F;将c的0~2个元素构成的向量赋给a</span><br><span class="line">a.assign(4, 2); &#x2F;&#x2F;a只含4个元素，且每个元素为2</span><br><span class="line">a.back(); &#x2F;&#x2F;返回a的最后一个元素;</span><br><span class="line">a.front(); &#x2F;&#x2F;返回a的第一个元素</span><br><span class="line">a[i];&#x2F;&#x2F;返回a的第i个元素，当且仅当a[i]存在,才可使用下标索引</span><br><span class="line">a.clear(); &#x2F;&#x2F;清空a中的元素</span><br><span class="line">a.empty(); &#x2F;&#x2F;判断a是否为空，空则返回ture,不空则返回false</span><br><span class="line">a.pop_back(); &#x2F;&#x2F;删除a向量的最后一个元素</span><br><span class="line">a.push_back(5); &#x2F;&#x2F;在a的最后一个向量后插入一个元素，其值为5</span><br><span class="line">a.erase(a.begin() + 1, a.begin() + 3); &#x2F;&#x2F;删除a中第1个（从第0个算起）到第2个元素，也就是说删除的元素从a.begin()+1算起（包括它）一直到a.begin()+3（不包括它）</span><br><span class="line">a.insert(a.begin() + 1, 5); &#x2F;&#x2F;在a的第1个元素（从第0个算起）的位置插入数值5，如a为1,2,3,4，插入元素后为1,5,2,3,4</span><br><span class="line">a.insert(a.begin() + 1, 3, 5); &#x2F;&#x2F;在a的第1个元素（从第0个算起）的位置插入3个数，其值都为5</span><br><span class="line">a.insert(a.begin() + 1, b + 3, b + 6); &#x2F;&#x2F;b为数组，在a的第1个元素（从第0个算起）的位置插入b的第3个元素到第5个元素（不包括b+6），如b为1,2,3,4,5,9,8         ，插入元素后为1,4,5,9,2,3,4,5,9,8</span><br><span class="line">a.size(); &#x2F;&#x2F;返回a中元素的个数；</span><br><span class="line">a.resize(10); &#x2F;&#x2F;将a的现有元素个数调至10个，多则删，少则补，其值随机</span><br><span class="line">a.resize(10, 2); &#x2F;&#x2F;将a的现有元素个数调至10个，多则删，少则补，其值为2</span><br><span class="line">a.swap(c); &#x2F;&#x2F;c为向量，将a中的元素和c中的元素进行整体性交换</span><br></pre></td></tr></table></figure>

<h2 id="二维向量"><a href="#二维向量" class="headerlink" title="二维向量"></a>二维向量</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vector &lt;int*&gt; a;</span><br><span class="line">vector &lt;vector &lt;int&gt;&gt; b;  &#x2F;&#x2F;二维向量由若干一维向量组成</span><br></pre></td></tr></table></figure>

<h2 id="向量的遍历"><a href="#向量的遍历" class="headerlink" title="向量的遍历"></a>向量的遍历</h2><ol>
<li>下标</li>
<li>遍历器</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(vector&lt;int&gt;::iterator it&#x3D;b.begin();it!&#x3D;b.end();it++)</span><br><span class="line">    cout&lt;&lt;*it&lt;&lt;&quot; &quot;;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>for</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (type x : vector) &#123;x...&#125;  &#x2F;&#x2F;x需要与vector类型一致</span><br></pre></td></tr></table></figure>

<h2 id="重要算法"><a href="#重要算法" class="headerlink" title="重要算法"></a>重要算法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">sort(a.begin(),a.end()); &#x2F;&#x2F;对a中的从a.begin()（包括它）到a.end()（不包括它）的元素进行从小到大排列</span><br><span class="line"></span><br><span class="line">reverse(a.begin(),a.end()); &#x2F;&#x2F;对a中的从a.begin()（包括它）到a.end()（不包括它）的元素倒置，但不排列，如a中元素为1,3,2,4,倒置后为4,2,3,1</span><br><span class="line"></span><br><span class="line">copy(a.begin(),a.end(),b.begin()+1); &#x2F;&#x2F;把a中的从a.begin()（包括它）到a.end()（不包括它）的元素复制到b中，从b.begin()+1的位置（包括它）开        始复制，覆盖掉原有元素</span><br><span class="line"></span><br><span class="line">find(a.begin(),a.end(),10); &#x2F;&#x2F;在a中的从a.begin()（包括它）到a.end()（不包括它）的元素中查找10，若存在返回其在向量中的位置</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Standford-C-library-SPL-vector"><a href="#Standford-C-library-SPL-vector" class="headerlink" title="Standford C++ library SPL vector"></a>Standford C++ library SPL vector</h1><p>定义：</p>
<blockquote>
<p><img src="/images/Lecture3/SPL-vector1.png"><br>方法<br><img src="/images/Lecture3/SPL-vector2.png"></p>
</blockquote>
<h2 id="Grid-网格"><a href="#Grid-网格" class="headerlink" title="Grid 网格"></a>Grid 网格</h2><p>定义：</p>
<blockquote>
<p><img src="/images/Lecture3/grid1.png"><br>方法：<br><img src="/images/Lecture3/grid2.png"><br>遍历：<br><img src="/images/Lecture3/grid3.png"></p>
</blockquote>
<h1 id="！！！大作业待完成"><a href="#！！！大作业待完成" class="headerlink" title="！！！大作业待完成"></a>！！！大作业待完成</h1>]]></content>
      <categories>
        <category>CS106B</category>
      </categories>
      <tags>
        <tag>CS106B</tag>
      </tags>
  </entry>
  <entry>
    <title>Notes for Lecture 4</title>
    <url>/2021/04/15/CS106B/CS106B-Lecture4/</url>
    <content><![CDATA[<h1 id="Notes-for-Lecture-4"><a href="#Notes-for-Lecture-4" class="headerlink" title="Notes for Lecture 4"></a>Notes for Lecture 4</h1><hr>
<h1 id="Vector的嵌套"><a href="#Vector的嵌套" class="headerlink" title="Vector的嵌套"></a>Vector的嵌套</h1><hr>
<h1 id="ADT"><a href="#ADT" class="headerlink" title="ADT"></a>ADT</h1><h2 id="What-is-it？"><a href="#What-is-it？" class="headerlink" title="What is it？"></a>What is it？</h2><p>抽象数据类型 (ADT)；数据集合和定义在该数据集合上的<strong>操作规范</strong></p>
<p><img src="/images/Lecture4/ADT.png"></p>
<h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p><img src="/images/Lecture4/stack-def.png"></p>
<h3 id="应用："><a href="#应用：" class="headerlink" title="应用："></a>应用：</h3><p><img src="/images/Lecture4/stack-app.png"></p>
<h3 id="include-quot-stack-h-quot"><a href="#include-quot-stack-h-quot" class="headerlink" title="#include&quot;stack.h&quot;"></a><code>#include&quot;stack.h&quot;</code></h3><p><img src="/images/Lecture4/stack-func.png"></p>
<ul>
<li>size()方法返回值会动态变化,当用作条件判断时需注意是否需要使用初始长度or动态长度</li>
</ul>
<h3 id="栈的练习："><a href="#栈的练习：" class="headerlink" title="栈的练习："></a>栈的练习：</h3><p><img src="/images/Lecture4/stack-exec.png"></p>
<ul>
<li><h4 id="匹配思想："><a href="#匹配思想：" class="headerlink" title="匹配思想："></a>匹配思想：</h4></li>
<li><blockquote>
<p>从左至右扫描一个字符串(或表达式)，则每个右括号将与最近遇到的那个左括号相匹配。则可以在从左至右扫描过程中把所遇到的左括号存放到堆栈中。每当遇到一个右括号时，就将它与栈顶的左括号(如果存在)相匹配，同时从栈顶删除该左括号。</p>
</blockquote>
</li>
</ul>
<h3 id="Answer："><a href="#Answer：" class="headerlink" title="Answer："></a>Answer：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int check(string str)</span><br><span class="line">&#123;</span><br><span class="line">	Stack &lt;char&gt; stack;</span><br><span class="line">	int len &#x3D; str.length();</span><br><span class="line">	for (int i &#x3D; 0; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if (str[i] &#x3D;&#x3D; &#39;(&#39; || str[i] &#x3D;&#x3D; &#39;&#123;&#39;)</span><br><span class="line">		&#123;</span><br><span class="line">			stack.push(str[i]); &#x2F;&#x2F;左(花)括号均压入栈</span><br><span class="line">		&#125;</span><br><span class="line">		else if (str[i] &#x3D;&#x3D; &#39;)&#39; || str[i] &#x3D;&#x3D; &#39;&#125;&#39;)  &#x2F;&#x2F;将右(花)括号与栈中左花括号匹配</span><br><span class="line">		&#123;</span><br><span class="line">			if (!stack.isEmpty() &amp;&amp; stack.peek() &#x3D;&#x3D; str[i])  &#x2F;&#x2F;弹出栈顶元素是需判断栈是否为空</span><br><span class="line">			&#123;				</span><br><span class="line">				stack.pop();</span><br><span class="line">			&#125;</span><br><span class="line">			else if (!stack.isEmpty() &amp;&amp; stack.peek() !&#x3D; str[i)</span><br><span class="line">			&#123;</span><br><span class="line">				return i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if (!stack.isEmpty)  &#x2F;&#x2F;通过判断栈是否为空来判断是否存在左(花)括号的case</span><br><span class="line">	&#123;</span><br><span class="line">		return len;  </span><br><span class="line">	&#125;else</span><br><span class="line">	return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Quene"><a href="#Quene" class="headerlink" title="Quene"></a>Quene</h2><h3 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h3><p><img src="/images/Lecture4/quene-def.png"></p>
<h3 id="应用：-1"><a href="#应用：-1" class="headerlink" title="应用："></a>应用：</h3><p><img src="/images/Lecture4/quene-app.png"></p>
<h3 id="include-quot-quene-h-quot"><a href="#include-quot-quene-h-quot" class="headerlink" title="#include&quot;quene.h&quot;"></a><code>#include&quot;quene.h&quot;</code></h3><p><img src="/images/Lecture4/quene-func.png"></p>
<ul>
<li>size()方法返回值会动态变化,当用作条件判断时需注意是否需要使用初始长度or动态长度</li>
</ul>
<h3 id="队列的练习："><a href="#队列的练习：" class="headerlink" title="队列的练习："></a>队列的练习：</h3><p><img src="/images/Lecture4/quene-exec.png"></p>
<ul>
<li><h4 id="匹配思想：-1"><a href="#匹配思想：-1" class="headerlink" title="匹配思想："></a>匹配思想：</h4></li>
<li><blockquote>
<p>队列与栈的交互<br>栈暂存队列弹出的元素<br>队列弹出元素同时重新压回本身，恢复原状态<br>将栈中元素重新压入队列(LIFO) </p>
</blockquote>
</li>
</ul>
<h3 id="Answer：-1"><a href="#Answer：-1" class="headerlink" title="Answer："></a>Answer：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void mirror(Quene&lt;string&gt;&amp; quene)</span><br><span class="line">&#123;</span><br><span class="line">	int len &#x3D; quene.size(); &#x2F;&#x2F;记录队列长度</span><br><span class="line">	Stack &lt;string&gt; stack;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		string elem &#x3D; quene.dequene();</span><br><span class="line">		quene.enquene(elem); &#x2F;&#x2F;恢复</span><br><span class="line">		stack.push(elem);</span><br><span class="line">	&#125;</span><br><span class="line">	while (!stack.isEmpty())</span><br><span class="line">	&#123;</span><br><span class="line">		quene.enquene(stack.pop());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>CS106B</category>
      </categories>
      <tags>
        <tag>CS106B</tag>
      </tags>
  </entry>
  <entry>
    <title>Notes for Lecture 5</title>
    <url>/2021/04/24/CS106B/CS106B-Lecture5/</url>
    <content><![CDATA[<h1 id="Notes-for-Lecture-5"><a href="#Notes-for-Lecture-5" class="headerlink" title="Notes for Lecture 5"></a>Notes for Lecture 5</h1><hr>
<h1 id="Sets-and-Maps-Big-Oh-Notation"><a href="#Sets-and-Maps-Big-Oh-Notation" class="headerlink" title="Sets and Maps;Big-Oh Notation"></a>Sets and Maps;Big-Oh Notation</h1><hr>
<h1 id="Sets"><a href="#Sets" class="headerlink" title="Sets"></a>Sets</h1><hr>
<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><ul>
<li>非重复读入大文件中的所有单词</li>
<li>method：存储于向量中 每次输入遍历向量判重 不重存入</li>
<li><blockquote>
<p>每次输入均需要遍历整个向量 耗时</p>
</blockquote>
</li>
</ul>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><img src="/images/Lecture5/set_def.png"></p>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><ul>
<li>Set</li>
<li>HashSet</li>
</ul>
<p><img src="/images/Lecture5/set_type.png"></p>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p><img src="/images/Lecture5/set_func.png"></p>
<h2 id="运算符-集合交-并-差"><a href="#运算符-集合交-并-差" class="headerlink" title="运算符(集合交 并 差)"></a>运算符(集合交 并 差)</h2><p><img src="/images/Lecture5/set_operation.png"></p>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><hr>
<h1 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h1><hr>
<h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>a collection storing pairs</p>
<p><img src="/images/Lecture5/map_def.png"></p>
<h2 id="类型-1"><a href="#类型-1" class="headerlink" title="类型"></a>类型</h2><ul>
<li>Map</li>
<li>HashMap</li>
</ul>
<p><img src="/images/Lecture5/map_type.png"></p>
<h2 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h2><p><img src="/images/Lecture5/map_operators.png"></p>
<p><img src="/images/Lecture5/map_func.png"></p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul>
<li>tallying 计数 </li>
</ul>
<p><img src="/images/Lecture5/map_prac.png"></p>
<p><img src="/images/Lecture5/map_solu.png"></p>
<h2 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h2><hr>
<h1 id="Compound-Nested-Collections"><a href="#Compound-Nested-Collections" class="headerlink" title="Compound/Nested Collections"></a>Compound/Nested Collections</h1><hr>
<p>Lotto tictets<br>Buddy list</p>
<hr>
<h1 id="算法分析和Big-Oh符号"><a href="#算法分析和Big-Oh符号" class="headerlink" title="算法分析和Big-Oh符号"></a>算法分析和Big-Oh符号</h1><hr>
]]></content>
      <categories>
        <category>CS106B</category>
      </categories>
      <tags>
        <tag>CS106B</tag>
      </tags>
  </entry>
  <entry>
    <title>Notes for Lecture 6</title>
    <url>/2021/04/24/CS106B/CS106B-Lecture6/</url>
    <content><![CDATA[<h1 id="Notes-for-Lecture-6"><a href="#Notes-for-Lecture-6" class="headerlink" title="Notes for Lecture 6"></a>Notes for Lecture 6</h1><hr>
<h1 id="Recursion"><a href="#Recursion" class="headerlink" title="Recursion"></a>Recursion</h1><hr>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>递归是指一种算法在某种程度上以较小的形式引用它自己</p>
<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p><img src="/images/Lecture6/introduce1.png"></p>
<p><img src="/images/Lecture6/introduce2.png"></p>
<h2 id="递归程序设计"><a href="#递归程序设计" class="headerlink" title="递归程序设计"></a>递归程序设计</h2><h3 id="自相似"><a href="#自相似" class="headerlink" title="自相似"></a>自相似</h3><p><img src="/images/Lecture6/program.png"></p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h3><p><img src="/images/Lecture6/exercise1.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int factorial(int n) &#123;</span><br><span class="line"></span><br><span class="line">	if (n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		return 1;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		return n * factorial(n - 1);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="回文判断"><a href="#回文判断" class="headerlink" title="回文判断"></a>回文判断</h3><p><img src="/images/Lecture6/exercise2.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool plalindrome(string n) &#123;</span><br><span class="line"></span><br><span class="line">	if (n.length() &lt;&#x3D; 0) &#123;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		char start &#x3D; n[0];</span><br><span class="line">		char end &#x3D; n[n.length() - 1];</span><br><span class="line">		string sub &#x3D; n.substr(1, n.length() - 2);</span><br><span class="line">		if (start !&#x3D; end) &#123;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			return plalindrome(sub);</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;return start &#x3D;&#x3D; end &amp;&amp; plalindrome(sub);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="汉诺塔分治递归"><a href="#汉诺塔分治递归" class="headerlink" title="汉诺塔分治递归"></a>汉诺塔分治递归</h3><p><img src="/images/Lecture6/exercise3.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Hanoi(int n, string a, string b, string c)&#123;</span><br><span class="line">	static int num &#x3D; 0;</span><br><span class="line">	if (n &lt;&#x3D; 0)</span><br><span class="line">	&#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		Hanoi(n - 1, a, c, b);</span><br><span class="line">		cout &lt;&lt; &quot;第&quot; &lt;&lt; ++num &lt;&lt; &quot;次移动&quot; &lt;&lt; n &lt;&lt; &quot;号盘&quot; &lt;&lt; a &lt;&lt; &quot;-&gt;&quot; &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">		Hanoi(n - 1, b, a, c);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="递归与分治策略"><a href="#递归与分治策略" class="headerlink" title="递归与分治策略"></a>递归与分治策略</h2><p>原文链接：<a href="https://blog.csdn.net/zhongkelee/article/details/45485943">https://blog.csdn.net/zhongkelee/article/details/45485943</a></p>
<h3 id="分治的基本过程"><a href="#分治的基本过程" class="headerlink" title="分治的基本过程"></a>分治的基本过程</h3><ul>
<li>Divide：将问题的规模变小,直到问题规模足够小，很容易求出其解为止</li>
<li><blockquote>
<p>  分治法产生的子问题往往是原问题的较小模式，这就为使用递归技术提供了方便。原问题与子问题的唯一区别是输入规模不同。 </p>
</blockquote>
</li>
<li><blockquote>
<p>  分解的要点：<br>a.分解的条件要互斥；<br>b.分解后的所有结果加在一起，能够覆盖原始问题的所有情况。</p>
</blockquote>
</li>
<li>Conquer：递归的处理小规模问题（只需递归调用即可）</li>
<li>Combine：将小规模问题的解合并为原始问题的解</li>
</ul>
<p><img src="/images/Lecture6/recursion1.jpg"></p>
<p><img src="/images/Lecture6/recursion2.jpg"></p>
<p><img src="/images/Lecture6/recursion3.jpg"></p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="二分搜索技术"><a href="#二分搜索技术" class="headerlink" title="二分搜索技术"></a>二分搜索技术</h4><p>-分析<br>无论是在前面还是后面查找x，其方法都和在a中查找x一样，只不过是查找的规模缩小了，很显然此问题分解出的子问题相互独立，即在排好序数组的前面或后面查找x是独立的子问题，因此满足分治法的适用条件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int BinarySearch(int arr[], int x, int left, int right)&#123;</span><br><span class="line">    while(left &lt;&#x3D; right)&#123;</span><br><span class="line">        int middle &#x3D; (left + right)&#x2F;2;</span><br><span class="line">        if (arr[middle] &#x3D;&#x3D; x)</span><br><span class="line">            return middle;</span><br><span class="line">        if (arr[middle] &gt; x)</span><br><span class="line">            right &#x3D; middle - 1;</span><br><span class="line">        else</span><br><span class="line">            left &#x3D; middle + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CS106B</category>
      </categories>
      <tags>
        <tag>CS106B</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt 入门</title>
    <url>/2021/04/17/begin/beginner/</url>
    <content><![CDATA[<h1 id="Qt-入门"><a href="#Qt-入门" class="headerlink" title="Qt 入门"></a>Qt 入门</h1><hr>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介:"></a>简介:</h2><p>跨平台的c++开发库，主要用于GUI开发,也可用于CUI （纯C++开发）</p>
<ul>
<li>GUI ：Graphical User Interface</li>
<li>CUI ：Command User Interface</li>
</ul>
<p>KDE ：KDE 是 K Desktop Environment 的缩写，中文译为“K桌面环境”</p>
<hr>
<h2 id="术语与名词"><a href="#术语与名词" class="headerlink" title="术语与名词"></a>术语与名词</h2><h3 id="Project"><a href="#Project" class="headerlink" title="Project"></a>Project</h3><p>项目，指为实现某个相对独立功能的程序代码合集，这些代码不单单是放在一块，而是有相互之间的关联性，并且有专门负责管理该项目的项目文件</p>
<ul>
<li>Qt 使用 .pro 文件管理项目</li>
<li>VC++ 则使用 .vcproj 作为项目文件</li>
</ul>
<p>集成开发环境通常都是依据项目文件（.pro/.vcproj）管理和构建项目。</p>
<h3 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h3><p>规范化的生成脚本，<strong>生成器</strong> make 可以依据规范的 Makefile文件 自动生成目标程序或库文件</p>
<ul>
<li>Makefile 通常都有工具自动生成，如 qmake 工具</li>
</ul>
<h3 id="Debug-和-Release"><a href="#Debug-和-Release" class="headerlink" title="Debug 和 Release"></a>Debug 和 Release</h3><ul>
<li><p>均为二进制目标程序</p>
</li>
<li><p>Debug ,<strong>纠错</strong>调试 ,Debug 版本的程序是臃肿而不进行优化的<br>调试过程中需要源代码和二进制目标程序之间一一对应的关系， 这样才能定位到错误代码</p>
</li>
<li><p>Release,进行大量优化，提升性能后的二进制程序，运行效率高，冗杂代码少</p>
</li>
</ul>
<h2 id="编译执行过程"><a href="#编译执行过程" class="headerlink" title="编译执行过程"></a>编译执行过程</h2><ul>
<li>创建.pro文件</li>
<li><blockquote>
<p>.pro文件可记录项目的一些设置,组织管理项目包含文件</p>
</blockquote>
</li>
<li>qmake由.pro文件生成Makefile文件 (Makefile中<strong>保存</strong>了编译器和链接器的参数选项，还表述了所有源文件之间的关系(源文件需要的特定的包含文件，可执行文件要求包含的目标文件<strong>模块</strong>及库等)</li>
<li><blockquote>
<p>Qt 类库以模块的形式组织各种功能的类，根据项目涉及的功能需求，在项目中添加适当的类库模块支持</p>
</blockquote>
</li>
<li><strong>生成器</strong>(make)，<strong>读取</strong>Makefile文件</li>
<li><strong>激活</strong>编译器，汇编器，资源编译器和链接器等以便产生最后的输出，最后输出生成通常是可执行文件</li>
</ul>
<h2 id="项目的文件组成和管理"><a href="#项目的文件组成和管理" class="headerlink" title="项目的文件组成和管理"></a>项目的文件组成和管理</h2><ul>
<li>.pro文件为<strong>项目管理文件</strong>，包含对项目的设置项</li>
<li>Sources分组 .cpp c++源文件</li>
<li>Header分组 .h 头文件</li>
<li>Forms分组 .ui 界面文件</li>
</ul>
<h2 id="pro文件详解"><a href="#pro文件详解" class="headerlink" title=".pro文件详解"></a>.pro文件详解</h2><p><strong>qmake的概念:</strong></p>
<ul>
<li>qmake是用来为不同的平台的开发项目<strong>创建</strong>makefile的一个工具。qmake简化了makefile的生成，因此创建一个makefile只需要.pro中几行信息的文件。</li>
<li>qmake会注意<strong>所有</strong>的编译器和平台的依赖性，可以把开发者解放出来只关心他们的代码。</li>
</ul>
<p><strong>注释:</strong></p>
<ul>
<li>项目(.pro)文件中使用“#”作为注释</li>
</ul>
<p><strong>模板(TEMPLATE):</strong><br>模板变量告诉qmake为这个应用程序生成的<strong>makefile类型</strong>。下面是可供使用的选择：</p>
<ul>
<li>app - 建立一个应用程序的makefile。这是默认值，所以如果模板没有被指定，这个将被使用。示例如下：TEMPLATE = app</li>
<li>lib - 建立一个库的makefile</li>
<li>vcapp - 建立一个应用程序的Visual Studio项目文件</li>
<li>vclib - 建立一个库的Visual Studio项目文件</li>
<li>subdirs - 这是一个特殊的模板，它可以创建一个能够进入特定目录并且为一个项目文件生成makefile，并且为它调用make的makefile。</li>
</ul>
<p><strong>CONFIG变量:</strong><br>config变量指定<strong>编译器</strong>所要使用的选项和所需要被连接的库。配置变量中可以添加任何东西，但只有下面这些选项可以被qmake识别。</p>
<h2 id="刚入门的萌新-需求为基本了解qt编译-基本熟练使用Qt-Creator-待深入学习后再作其他补充吧！"><a href="#刚入门的萌新-需求为基本了解qt编译-基本熟练使用Qt-Creator-待深入学习后再作其他补充吧！" class="headerlink" title="刚入门的萌新 需求为基本了解qt编译 基本熟练使用Qt Creator 待深入学习后再作其他补充吧！"></a>刚入门的萌新 需求为基本了解qt编译 基本熟练使用Qt Creator 待深入学习后再作其他补充吧！</h2>]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt and Homeweok</title>
    <url>/2021/04/17/Qt/Qt/</url>
    <content><![CDATA[<h1 id="Qt心酸史"><a href="#Qt心酸史" class="headerlink" title="Qt心酸史"></a>Qt心酸史</h1><hr>
<p>用此博客来记录一下起初困扰几天的使用Qt的心酸史吧 顺便忘了还能回看回看</p>
<hr>
<h2 id="Qt安装"><a href="#Qt安装" class="headerlink" title="Qt安装"></a>Qt安装</h2><p>standford 下载地址: <a href="https://web.stanford.edu/class/cs106b/qt/install-windows">https://web.stanford.edu/class/cs106b/qt/install-windows</a><br>依附说明下载安装即可;</p>
<ul>
<li>安装过程莫名奇妙卡死？关闭有道词典(有道截屏取词不知道哪儿get到了)即可解决，一开必卡死</li>
<li>对于 2021 年春季季度，版本编号必须至少为Qt 5.15.0</li>
<li>必须选择 MinGW 32 位套件组件 MinGW 8.x.x 32 位 其余默认即可</li>
<li>Qt的安装目录不要有任何空格和特殊字符 老老实实英文字符就行</li>
<li>博主安装目录 （满足CS106B homework需求  不同应用需求请自行查询对应模块并选择哦）<br><img src="/images/Qt/1.png"><br><img src="/images/Qt/2.png"><br><img src="/images/Qt/3.png"></li>
</ul>
<h2 id="CS106B项目构建"><a href="#CS106B项目构建" class="headerlink" title="CS106B项目构建"></a>CS106B项目构建</h2><p>按步骤构建过程报错 编译输出为</p>
<ul>
<li>Error copying E:\Qt\CS106\Library\collections\basicgraph.h to C:\Users&quot;中文名”<br>…….<br>error: [Makefile.Release:10252: install_headers] Error 3</li>
</ul>
<p>解决：</p>
<ul>
<li>起初以为qmake问题 重装几次qt未解决</li>
<li>更改default build directory无果 （认为这个目录下有中文）</li>
<li>查看每条编译输出突然发现！！！！！！！！</li>
<li>这怎么把库给我copy到含中文的用户文件夹下了我天      —目前qt框架小白一枚未解why</li>
<li>所以copy就copy吧 更改用户文件夹名称为英文即可</li>
</ul>
<h2 id="更改用户文件夹名称"><a href="#更改用户文件夹名称" class="headerlink" title="更改用户文件夹名称"></a>更改用户文件夹名称</h2><h3 id="升级win10为专业版"><a href="#升级win10为专业版" class="headerlink" title="升级win10为专业版"></a>升级win10为专业版</h3><p>网上教程其实挺多的，万能key也可搜到</p>
<p>秘钥：</p>
<ul>
<li>设置-&gt;更新与安全-&gt;激活-&gt;激活-&gt;更改产品秘钥</li>
<li><blockquote>
<p>秘钥通过后升级过程可能报错  没关系过了秘钥就可 这时使用万能重启</p>
</blockquote>
</li>
<li>修改成功也建议重启</li>
</ul>
<p>激活：</p>
<ul>
<li>重启过后再次来到激活界面发现显示为未激活状态的win10专业版</li>
<li>管理员身份打开cmd，搜索框输入cmd，以管理员身份运行</li>
<li>卸载产品密钥：执行命令— slmgr.vbs /upk   并弹出窗口显为“已成功卸载了产品密钥”；</li>
<li>安装产品密钥：执行命令— slmgr /ipk W269N-WFGWX-YVC9B-4J6C9-T83GX   并弹出窗口提示：“成功的安装了产品密钥”；</li>
<li>修改指定名称：执行命令— slmgr /skms zh.us.to   并弹出窗口提示：“密钥管理服务计算机名成功的设置为zh.us.to”；</li>
<li>激活所需产品：执行命令— slmgr /ato    并弹出窗口提示：“成功的激活了产品”</li>
</ul>
<h3 id="重命名文件夹"><a href="#重命名文件夹" class="headerlink" title="重命名文件夹"></a>重命名文件夹</h3><ol>
<li>启用管理员账户</li>
</ol>
<ul>
<li>我的电脑-&gt;右击-&gt;管理-&gt;本地用户和组-&gt;用户-&gt;Administrator-&gt;属性-&gt;将“账户已禁用”前面的√去掉，点击确定。</li>
<li><blockquote>
<p>此处win10家庭版会不显示本地用户和组哦 因为它没这个功能呢</p>
</blockquote>
</li>
</ul>
<ol start="2">
<li>注销当前用户，进入管理员用户</li>
</ol>
<ul>
<li>给爷注销再登录管理员账户好嘛，不然无法修改名称</li>
<li>重命名</li>
</ul>
<ol start="3">
<li>修改注册表</li>
</ol>
<ul>
<li>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Profilelist 找到该路径下</li>
<li>找到Profilelist下子文件夹(这些文件夹为各个用户)下的ProfileImagePath数值数据值含有原用户文件夹名称的那个ProfileImagePath数值名称，把对应名称修改为新的用户文件夹名称</li>
</ul>
<ol start="4">
<li>修改对应环境变量</li>
</ol>
<h3 id="构建成功-起飞喽！"><a href="#构建成功-起飞喽！" class="headerlink" title="构建成功 起飞喽！"></a>构建成功 起飞喽！</h3>]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>Iterator</title>
    <url>/2021/04/24/C++Primer/Iterator/</url>
    <content><![CDATA[<h1 id="迭代器浅谈"><a href="#迭代器浅谈" class="headerlink" title="迭代器浅谈"></a>迭代器浅谈</h1><hr>
<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>只有少数容器同时支持下标索引，所有标准库类型容器均支持迭代器<br>string类型虽然不是容器，但是拥有与容器相似方法，因此也支持迭代器</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>迭代器可与其指向的容器中的元素建立关联，从而通过解引用来间接访问对应元素</p>
<h2 id="迭代器类型"><a href="#迭代器类型" class="headerlink" title="迭代器类型"></a>迭代器类型</h2><p>vector<int>为例<br>vector<int>::iterator 可读写访问迭代器指向元素<br>vector<int>::const_iterator 常量类型的迭代器，只能访问迭代器指向元素不可修改</int></int></int></p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>所有包含迭代器的容器类型均包含对应迭代器方法</p>
<ul>
<li>begin() 返回指向容器第一个元素的迭代器 </li>
<li>end() 返回指向容器最后一个元素下一个位置的的迭代器 尾(后)迭代器<blockquote>
<p>根据容器类型确定返回迭代器的类型，若为常量容器，则返回常量迭代器<br>如果容器为空 begin()与end()均返回尾迭代器</p>
</blockquote>
</li>
<li>cbegin() 返回指向容器第一个元素的迭代器 </li>
<li>cend() 返回指向容器最后一个元素下一个位置的的迭代器 尾迭代器<blockquote>
<p>返回指定类型的const_iterator的迭代器</p>
</blockquote>
</li>
</ul>
<h2 id="迭代器运算符"><a href="#迭代器运算符" class="headerlink" title="迭代器运算符"></a>迭代器运算符</h2><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">*itera</td>
<td align="center">解引用 返回itera所指元素的<strong>引用</strong></td>
</tr>
<tr>
<td align="center">itera-&gt;mem</td>
<td align="center">箭头运算符 可访问itera迭代器指向元素的mem成员，等价于(*itera).mem</td>
</tr>
<tr>
<td align="center">++itera</td>
<td align="center">使迭代器指向下一个元素位置</td>
</tr>
</tbody></table>
<ul>
<li>-itera|使迭代器指向上一个元素位置<br>itera1==itera2|当且仅当两迭代器属于同一个容器且指向同一个元素或均指向尾元素下一位置时相等<br>itera1!=itera2|当且仅当两迭代器属于同一个容器且指向同一个元素或均指向尾元素下一位置时相等</li>
</ul>
<h2 id="算数运算"><a href="#算数运算" class="headerlink" title="算数运算"></a>算数运算</h2><table>
<thead>
<tr>
<th align="center">运算</th>
<th align="center">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">itera + n</td>
<td align="center">使迭代器向后移动n个位置</td>
</tr>
<tr>
<td align="center">itera - n</td>
<td align="center">使迭代器向前移动n个位置</td>
</tr>
<tr>
<td align="center">itera += n</td>
<td align="center">使迭代器向后移动n个位置，同时修改该迭代器</td>
</tr>
<tr>
<td align="center">itera -= n</td>
<td align="center">使迭代器向前移动n个位置，同时修改该迭代器</td>
</tr>
<tr>
<td align="center">itera1 - itera2</td>
<td align="center">返回两迭代器之间的差值，类型为difference_type，同属一个一个容器的迭代器才可</td>
</tr>
<tr>
<td align="center">&lt; &lt;= &gt;= &gt;</td>
<td align="center">关系运算</td>
</tr>
</tbody></table>
<h2 id="vector某些操作使迭代器失效"><a href="#vector某些操作使迭代器失效" class="headerlink" title="vector某些操作使迭代器失效"></a>vector某些操作使迭代器失效</h2><p>在涉及迭代器的循环中不允许改变迭代器所属的容器长度</p>
]]></content>
      <categories>
        <category>C++Primer</category>
      </categories>
      <tags>
        <tag>C++Primer</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/04/03/begin/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>init</category>
      </categories>
      <tags>
        <tag>Offical</tag>
      </tags>
  </entry>
  <entry>
    <title>Vector</title>
    <url>/2021/04/24/C++Primer/Vector/</url>
    <content><![CDATA[<h1 id="Vector浅谈"><a href="#Vector浅谈" class="headerlink" title="Vector浅谈"></a>Vector浅谈</h1><hr>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>存储相同类型对象的集合，称为容器，长度可变的序列容器<br>vector是一个类模板不是类型，指定类型参数后可生成对应类型</p>
<hr>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="vector常用构造函数"><a href="#vector常用构造函数" class="headerlink" title="vector常用构造函数"></a>vector常用构造函数</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">vector();</td>
<td align="center">创建一个没有任何元素的空向量</td>
</tr>
<tr>
<td align="center">vector(vector&amp;&amp; _Right);</td>
<td align="center">创建一个向量，并使用向量_Right初始化该向量</td>
</tr>
<tr>
<td align="center">vector(size_type Count);</td>
<td align="center">创建一个大小为Count的向量vect</td>
</tr>
<tr>
<td align="center">vector(size_type Count,const Type&amp; Val);</td>
<td align="center">创建一个大小为Count的向量，该向量中所有的元素都初始化为Val</td>
</tr>
<tr>
<td align="center">template<typename inputiterator>  vector(InputIterator _first,InputIterator _last);</typename></td>
<td align="center">创建一个向量，并以迭代器_first和_last之间的元素初始化该向量</td>
</tr>
</tbody></table>
<ul>
<li>拷贝初始化 赋值运算初始化</li>
<li>直接初始化 构造函数指定参数 ()或{}</li>
</ul>
<h3 id="默认初始化"><a href="#默认初始化" class="headerlink" title="默认初始化"></a>默认初始化</h3><ul>
<li>不指定长度，不可通过向量索引添加元素</li>
</ul>
<h3 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h3><ul>
<li>{…}使用列表中元素为向量元素初始化</li>
<li>{}中元素类型与向量元素元素类型不匹配时，作()处理</li>
</ul>
<h3 id="值初始化"><a href="#值初始化" class="headerlink" title="值初始化"></a>值初始化</h3><ul>
<li>仅指定长度，剩余元素均默认初始化</li>
</ul>
<h3 id="创造指定数量的元素"><a href="#创造指定数量的元素" class="headerlink" title="创造指定数量的元素"></a>创造指定数量的元素</h3><ul>
<li>(num,value) 创建有num个值为value元素的向量</li>
</ul>
<h2 id="vector的操作"><a href="#vector的操作" class="headerlink" title="vector的操作"></a>vector的操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;vector&gt; &#x2F;&#x2F;需要包含头文件</span><br><span class="line">a.assign(c.begin(), c.begin() + 3); &#x2F;&#x2F;将c的0~2个元素构成的向量赋给a</span><br><span class="line">a.assign(4, 2); &#x2F;&#x2F;a只含4个元素，且每个元素为2</span><br><span class="line">a.back(); &#x2F;&#x2F;返回a的最后一个元素;</span><br><span class="line">a.front(); &#x2F;&#x2F;返回a的第一个元素</span><br><span class="line">a[i];&#x2F;&#x2F;返回a的第i个元素，当且仅当a[i]存在,才可使用下标索引</span><br><span class="line">a.clear(); &#x2F;&#x2F;清空a中的元素</span><br><span class="line">a.empty(); &#x2F;&#x2F;判断a是否为空，空则返回ture,不空则返回false</span><br><span class="line">a.pop_back(); &#x2F;&#x2F;删除a向量的最后一个元素</span><br><span class="line">a.push_back(5); &#x2F;&#x2F;在a的最后一个向量后插入一个元素，其值为5</span><br><span class="line">a.erase(a.begin() + 1, a.begin() + 3); &#x2F;&#x2F;删除a中第1个（从第0个算起）到第2个元素，也就是说删除的元素从a.begin()+1算起（包括它）一直到a.begin()+3（不包括它）</span><br><span class="line">a.insert(a.begin() + 1, 5); &#x2F;&#x2F;在a的第1个元素（从第0个算起）的位置插入数值5，如a为1,2,3,4，插入元素后为1,5,2,3,4</span><br><span class="line">a.insert(a.begin() + 1, 3, 5); &#x2F;&#x2F;在a的第1个元素（从第0个算起）的位置插入3个数，其值都为5</span><br><span class="line">a.insert(a.begin() + 1, b + 3, b + 6); &#x2F;&#x2F;b为数组，在a的第1个元素（从第0个算起）的位置插入b的第3个元素到第5个元素（不包括b+6），如b为1,2,3,4,5,9,8         ，插入元素后为1,4,5,9,2,3,4,5,9,8</span><br><span class="line">a.size(); &#x2F;&#x2F;返回a中元素的个数；</span><br><span class="line">a.resize(10); &#x2F;&#x2F;将a的现有元素个数调至10个，多则删，少则补，其值随机</span><br><span class="line">a.resize(10, 2); &#x2F;&#x2F;将a的现有元素个数调至10个，多则删，少则补，其值为2</span><br><span class="line">a.swap(c); &#x2F;&#x2F;c为向量，将a中的元素和c中的元素进行整体性交换</span><br></pre></td></tr></table></figure>
<h3 id="二维向量"><a href="#二维向量" class="headerlink" title="二维向量"></a>二维向量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vector &lt;int*&gt; a;</span><br><span class="line">vector &lt;vector &lt;int&gt;&gt; b;  &#x2F;&#x2F;二维向量由若干一维向量组成</span><br></pre></td></tr></table></figure>

<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>范围for循环不允许改变其遍历序列的大小</p>
<p>for (循环遍历声明  :  vector向量){}<br>该循环遍历若为引用声明 则修改引用变量值可修改vector向量元素内容</p>
]]></content>
      <categories>
        <category>C++Primer</category>
      </categories>
      <tags>
        <tag>C++Primer</tag>
      </tags>
  </entry>
  <entry>
    <title>Start all over again！</title>
    <url>/2021/04/04/begin/first-post/</url>
    <content><![CDATA[<h1 id="高山仰止，景行行止"><a href="#高山仰止，景行行止" class="headerlink" title="高山仰止，景行行止"></a>高山仰止，景行行止</h1>]]></content>
      <categories>
        <category>start</category>
      </categories>
      <tags>
        <tag>start</tag>
      </tags>
  </entry>
  <entry>
    <title>Notes for Lecture 7</title>
    <url>/2021/04/26/CS106B/CS106B-Lecture7/</url>
    <content><![CDATA[<h1 id="Notes-for-Lecture-7"><a href="#Notes-for-Lecture-7" class="headerlink" title="Notes for Lecture 7"></a>Notes for Lecture 7</h1><hr>
<h1 id="Recursion-and-Fractals"><a href="#Recursion-and-Fractals" class="headerlink" title="Recursion and Fractals"></a>Recursion and Fractals</h1><hr>
<h2 id="Fractals-分形"><a href="#Fractals-分形" class="headerlink" title="Fractals 分形"></a>Fractals 分形</h2><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li>分形是一种具有自相似的现象，在分形中，每一个组成部分都在特征上与整体相似，仅仅是规模更小而已</li>
</ul>
<p><img src="/images/Lecture7/fractals_def.png"></p>
<h2 id="特殊分形实例"><a href="#特殊分形实例" class="headerlink" title="特殊分形实例"></a>特殊分形实例</h2><ul>
<li><p>科赫雪花三角形</p>
</li>
<li><blockquote>
<p>从一个正三角形开始，把每条边分成三等份，然后以各边的中间长度为底边。分别向外作正三角形，再把“底边”线段抹掉,反复进行这一过程，就会得到一个“雪花”样子的曲线。这曲线叫做科赫曲线或雪花曲线。</p>
</blockquote>
</li>
<li><p>谢尔宾斯基三角形</p>
</li>
<li><blockquote>
<p>1.取一个<strong>实心</strong>的三角形。（多数使用等边三角形）<br>2.沿三边中点的连线，将它分成四个小三角形。<br>3.去掉中间的那一个小三角形。<br>4.对其余三个<strong>实心</strong>小三角形重复1</p>
</blockquote>
</li>
<li><p>Mandelbrot集合</p>
</li>
</ul>
<p><img src="/images/Lecture7/fractals_exa.png"></p>
<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include&quot;gwindow.h</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/images/Lecture7/fractals_func.png"></p>
<p><img src="/images/Lecture7/fractals_code.png"></p>
<h2 id="Canter-set-康托尔集"><a href="#Canter-set-康托尔集" class="headerlink" title="Canter set 康托尔集"></a>Canter set 康托尔集</h2><p>三分康托集的构造过程是：</p>
<ol>
<li>把线段平均分为三段，去掉中间的 1/3 部分段，而只剩下两边部分段</li>
<li>再将剩下的两边部分段各自平均分为三段，同样去掉中间的区间段，这时剩下四段部分段</li>
<li>重复删除每个小段中间的 1/3 段。如此不断的分割下去， 最后剩下的各个小段就构成了三分康托集。</li>
</ol>
<p><img src="/images/Lecture7/fractals_cantor.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void cantorSet(GWindow&amp; window,int x,int y,int length,int levels) &#123;</span><br><span class="line"></span><br><span class="line">	if(levels&gt;0) &#123;</span><br><span class="line">	</span><br><span class="line">		window.drawLine(x,y,x+length,y);</span><br><span class="line">		cantorSet(window,x,y+20,length&#x2F;3,levels-1);</span><br><span class="line">		cantorSet(window,x+2*length&#x2F;3,y+20,length&#x2F;3,levels-1);</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>








]]></content>
      <categories>
        <category>CS106B</category>
      </categories>
      <tags>
        <tag>CS106B</tag>
      </tags>
  </entry>
  <entry>
    <title>Git Learning End Version</title>
    <url>/2021/05/01/Git/Git%20learning%20Notes/</url>
    <content><![CDATA[<h1 id="Git-Learning-Notes-from-廖老大！"><a href="#Git-Learning-Notes-from-廖老大！" class="headerlink" title="Git Learning Notes from 廖老大！"></a>Git Learning Notes from 廖老大！</h1><hr>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Git是目前世界上最先进的<strong>分布式版本控制系统</strong>。</p>
<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>推荐一个个人认为讲得很不错链接吧<br>该讲师以类比于Tesla汽车公司的方式，给大家解释git的使用方法，以及GitHub的平台逻辑<br><a href="https://www.bilibili.com/video/BV1wW41167wR?t=478">https://www.bilibili.com/video/BV1wW41167wR?t=478</a></p>
<h2 id="诞生"><a href="#诞生" class="headerlink" title="诞生"></a>诞生</h2><blockquote>
<p>BitKeepe<br>Git –基于C</p>
</blockquote>
<h2 id="集中式-与-分布式"><a href="#集中式-与-分布式" class="headerlink" title="集中式 与 分布式"></a>集中式 与 分布式</h2><ul>
<li>集中式：<br>需先从中央服务器获得最新版本，改后交由服务器整合。—-联网工作</li>
<li>分布式：<br>每个人的电脑上都是一个完整的版本库，各个电脑可相互推送修改内容。—-不必联网</li>
</ul>
<p>所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的详细变化，Microsoft的Word格式是二进制格式</p>
<h2 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h2><ol>
<li>官网下载<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a><br>已安装可通过Git本身获得最新的开发版本<br><code>git clone https://github.com/git/git</code></li>
<li>设置 -指定仓库的用户名和Email地址<br><code>git config --global user.name &quot;Your Name&quot;</code><br><code>git config --global user.email &quot;email@example.com&quot;</code></li>
</ol>
<h2 id="创建版本库（仓库）"><a href="#创建版本库（仓库）" class="headerlink" title="创建版本库（仓库）"></a>创建版本库（仓库）</h2><ul>
<li>创建目录</li>
<li>初始化git </li>
</ul>
<blockquote>
<p><code>git init</code></p>
</blockquote>
<ul>
<li>添加 readme.txt 文件到git仓库<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add file1  &#x2F;&#x2F;git命令必须在git仓库目录中运行</span><br><span class="line">git add file2  &#x2F;&#x2F;add 文件时改文件必须在当前目录存在</span><br><span class="line"> ...	&#x2F;&#x2F;可以一次提交多个文件</span><br><span class="line">git commit -m &quot;有意义的提交说明&quot;    </span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意不要使用记事本编写！！！！不要使用记事本编写！！！！不要使用记事本编写！！！！ 安装notepad++</p>
</blockquote>
</li>
</ul>
<h2 id="实时掌握工作区状态"><a href="#实时掌握工作区状态" class="headerlink" title="实时掌握工作区状态"></a>实时掌握工作区状态</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git status &#x2F;&#x2F;显示当前工作区的更改状态（判定是否有差异 差异对象目前不懂）</span><br><span class="line">git diff &#x2F;&#x2F;若存在差异，则可通过命令查看具体的差异  可指定commit_id</span><br><span class="line">git add file1 &#x2F;&#x2F;提交修改记录</span><br><span class="line">git commit -m &quot;修改说明&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="版本更替"><a href="#版本更替" class="headerlink" title="版本更替"></a>版本更替</h2><ol>
<li>查看</li>
</ol>
<ul>
<li><p>git log [–graph] (该参数可查看分支合并图)</p>
<blockquote>
<p>星号表示一个commit， 注意不要管*在哪一条主线上<br>|表示分支前进<br>/表示分叉<br>\表示合入</p>
</blockquote>
</li>
<li><p>查看<strong>从当前版本</strong>开始最近到最远的提交记录</p>
</li>
<li><p>记录commit_id版本号</p>
<blockquote>
<p>id:SHA1计算出来的一个非常大的数字，用十六进制表示,用于区分不同commit版本</p>
</blockquote>
</li>
</ul>
<ol start="2">
<li>回溯</li>
</ol>
<p>  git reset –hard commit_id （绝对）<br>  git reset –hard head^ （相对）   </p>
<ul>
<li>相对head指针指向的版本 ^个数为相对于当前head指向版本的上..版本</li>
<li>head~100 相当于 head^^^^(100个)</li>
</ul>
<ol start="3">
<li>未来</li>
</ol>
<ul>
<li>git reflog</li>
<li>查看<strong>所有</strong>commit版本历史 确定即将更替版本的版本号</li>
</ul>
<hr>
<p>4.20</p>
<h1 id="工作区与暂存区"><a href="#工作区与暂存区" class="headerlink" title="工作区与暂存区"></a>工作区与暂存区</h1><h2 id="工作区（本地）"><a href="#工作区（本地）" class="headerlink" title="工作区（本地）"></a>工作区（本地）</h2><p>用户可视的目录</p>
<h2 id="版本库"><a href="#版本库" class="headerlink" title="版本库"></a>版本库</h2><p>.git隐藏文件为版本库</p>
<h3 id="暂存区-stage"><a href="#暂存区-stage" class="headerlink" title="暂存区 stage"></a>暂存区 stage</h3><p>git add filename 指令将文件修改添加到暂存区中</p>
<h3 id="master分支"><a href="#master分支" class="headerlink" title="master分支"></a>master分支</h3><p>git commit -m “说明”  将<strong>暂存区</strong>中的提交记录一并提交至master分支中</p>
<ul>
<li>注意是将暂存区的修改记录提交，若进行了第二次更改未添加至暂存区，则无法直接与第一次修改一并提交至master分支中</li>
</ul>
<h3 id="指向master分支的head指针"><a href="#指向master分支的head指针" class="headerlink" title="指向master分支的head指针"></a>指向master分支的head指针</h3><blockquote>
<p><img src="/images/Git/stage.png"></p>
</blockquote>
<h3 id="git-diff-总结"><a href="#git-diff-总结" class="headerlink" title="git diff 总结"></a>git diff 总结</h3><p>git diff查看工作区和暂存区差异</p>
<p>git diff –cached查看暂存区和仓库差异</p>
<p>git diff HEAD 查看工作区和仓库的差异</p>
<p>– filename 可指定查看具体文件在不同区的差异 有空格呢</p>
<h1 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h1><p>git checkout – filename   撤销工作区的修改 实际上是使用版本库最新版本替代工作区版本<br>git reset head filename  撤销暂存区的修改<br>git reset –head commit_id(head) 版本回退 撤销已提交但未推送到远程库的修改</p>
<h1 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h1><p>git rm filename</p>
<p>git checkout – filename 对于已经提交的文件，误删后可恢复<br>从来没有被添加到版本库就被删除的文件，是无法恢复的！</p>
<hr>
<p>4.21</p>
<h1 id="远程库"><a href="#远程库" class="headerlink" title="远程库"></a>远程库</h1><h2 id="关联远程库"><a href="#关联远程库" class="headerlink" title="关联远程库"></a>关联远程库</h2><p>git remote add origin [http|ssh秘钥]</p>
<p>要关联一个远程库，使用命令git remote add origin [http|ssh秘钥]<br>或者在.git目录下 config文件中直接修改url为[http|ssh秘钥]即可<br>关联一个远程库时必须给远程库指定一个名字，origin是默认习惯命名</p>
<h2 id="推送分支至远程库"><a href="#推送分支至远程库" class="headerlink" title="推送分支至远程库"></a>推送分支至远程库</h2><p>git push origin master </p>
<p>关联后，使用命令git push -u origin master第一次推送master分支的所有内容；<br>此后通过git push origin master推送最新修改；</p>
<h2 id="查看远程库信息"><a href="#查看远程库信息" class="headerlink" title="查看远程库信息"></a>查看远程库信息</h2><p>git remote -v</p>
<h2 id="“删除”远程库"><a href="#“删除”远程库" class="headerlink" title="“删除”远程库"></a>“删除”远程库</h2><p>git remote rm name</p>
<p>此处的“删除”其实是解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动。要真正删除远程库，需要登录到GitHub，在后台页面找到删除按钮再删除。</p>
<h2 id="克隆远程库"><a href="#克隆远程库" class="headerlink" title="克隆远程库"></a>克隆远程库</h2><p>git clone [http|ssh秘钥]</p>
<p>待更新</p>
<hr>
<p>4.22</p>
<h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><p>查看分支：git branch [-a]  -a参数可查看远程分支</p>
<p>创建分支：git branch <name></name></p>
<p>切换分支：git checkout <name>或者git switch <name></name></name></p>
<p>创建+切换分支：git checkout -b <name>或者git switch -c <name></name></name></p>
<p>合并某分支到当前分支：git merge <name>  快速合并</name></p>
<ul>
<li>合并冲突</li>
</ul>
<blockquote>
<p><img src="/images/Git/conflict1.png"></p>
</blockquote>
<blockquote>
<p><img src="/images/Git/confict2.png"></p>
</blockquote>
<ul>
<li><blockquote>
<p>手动解决冲突文件后重新add后提交</p>
</blockquote>
</li>
</ul>
<p>删除分支：git branch -d <name></name></p>
<p>删除远程分支：git push origin –delete dev</p>
<p>强行删除未被合并的分支: git branch -D <filename></filename></p>
<hr>
<p>4.29</p>
<h2 id="分支管理补充"><a href="#分支管理补充" class="headerlink" title="分支管理补充"></a>分支管理补充</h2><p>对于所有的分支而言，工作区与暂存区是公共的，所以在其他分支作的更改但是未add，commit的内容同样会在其他分支中呈现</p>
<h2 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h2><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><ul>
<li>Git默认Fast forward模式，删除分支后，会丢掉分支信息（其他分支的commit信息将丢失）</li>
</ul>
<blockquote>
<p><img src="/images/Git/merge_ff.png"></p>
</blockquote>
<ul>
<li><p>强制禁用Fast forward模式,添加–no-ff参数，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p>
</li>
<li><p><code>git merge --no-ff -m &quot;merge with no-ff&quot; dev</code></p>
</li>
</ul>
<blockquote>
<p><img src="/images/Git/merge_no.png"></p>
</blockquote>
<hr>
<p>4.30</p>
<h2 id="BUG分支"><a href="#BUG分支" class="headerlink" title="BUG分支"></a>BUG分支</h2><p>Untracked files (未被追踪的文件): 从未add到暂存区的文件<br>Changes not staged:已被add到暂存区但是最新更改未add</p>
<p>原则: commit的内容应该是当前版本的较完善版本，未完善的存在bug的内容不应该commit，否则即使最新commit修改了之前bug，但是用户仍可以通过log访问到未完善版本。</p>
<p>修改BUG: 创建bug分支，修改bug后，合并到主分支即可</p>
<p>注意: 如果当前正在其他分支工作，突然需要修改紧急bug，需要切换到master分支修改bug，并先提交修改bug后的版本(不应包含当前工作分支的内容)，但是本地工作区与暂存区为所有分支共享，如果当前分支所作更改不进行add-commit操作，则当前分支所作更改在其他分支仍然可见(可见代表其他分支也会不可避免的add-commit当前分支对项目所作的更改)，关键是这部分内容不能提交啊(代码太那啥),所以我们可以先把当前分支的更改”藏匿”到缓存堆栈中，这样其他分支尽情提交而看不到本分支修改内容，待master分支修改完bug并commit后，回到本分支取出，继续更改即可。</p>
<ul>
<li><code>git stash [save &quot;&quot;]</code></li>
</ul>
<blockquote>
<p>把所有未提交的修改（包括暂存的和非暂存(Changes not staged)的）都保存起来(当前目录就变干净),用于后续恢复当前工作目录。</p>
</blockquote>
<blockquote>
<p>保存之前确定无Untracked files，因为git stash不能将未被追踪的文件(Untracked file)压栈</p>
</blockquote>
<ul>
<li><p><code>git stash list</code><br>查看现有stash缓存堆栈内容</p>
</li>
<li><p><code>git stash pop</code><br>将缓存堆栈中的第一个stash删除，并将对应修改应用到当前的工作目录下。</p>
</li>
<li><p><code>git stash apply</code><br>将缓存堆栈中的第一个stash应用到工作目录中，但并不删除stash拷贝</p>
</li>
<li><p><code>git stash drop</code><br>默认删除缓存堆栈中第一个stash</p>
</li>
</ul>
<h2 id="Cherry-pick-与-merge"><a href="#Cherry-pick-与-merge" class="headerlink" title="Cherry_pick 与 merge"></a>Cherry_pick 与 merge</h2><ul>
<li><code>git cherry-pick commit_id</code><br>就是将指定的提交（commit）应用于其他分支,这会在当前分支产生一个新的提交.</li>
</ul>
<h3 id="代码冲突"><a href="#代码冲突" class="headerlink" title="代码冲突"></a>代码冲突</h3><ul>
<li>–continue<br>用户解决代码冲突后，将修改的文件重新加入暂存区，第二步执行如下命令，让 Cherry pick 过程继续执行。<br><code>git cherry_pick --continue</code></li>
<li>–abort<br>发生代码冲突后，放弃合并，回到操作前的样子。<br><code>git cherry_pick --abort</code></li>
<li>–quit<br>发生代码冲突后，退出 Cherry pick，但是不回到操作前的样子。<br><code>git cherry_pick --quit</code></li>
</ul>
<p>注意：两者均为将新分支更改更新至当前分支，但是merge会将整个分支的文件更新，cherry-pick为将指定提交应用于当前分支</p>
<hr>
<p>5.1</p>
<h2 id="克隆仓库"><a href="#克隆仓库" class="headerlink" title="克隆仓库"></a>克隆仓库</h2><ul>
<li>git clone [http|ssh秘钥]<br>整个仓库被克隆包括所有分支，但是最开始只能看到<strong>master分支</strong>，需要创建远程origin的对应分支到本地，才能看到对应分支<blockquote>
<p><code>git switch -c dev origin/dev</code></p>
</blockquote>
</li>
</ul>
<blockquote>
<p>如果需要提交最新更改，不要直接使用原作者项目下的秘钥，否则没有操作权限，需要fork到自己仓库下，再clone</p>
</blockquote>
<h2 id="推送分支"><a href="#推送分支" class="headerlink" title="推送分支"></a>推送分支</h2><ul>
<li><code>git push origin &lt;branch-name&gt;</code><br>将本地某个分支的更新推送到远程库</li>
</ul>
<h2 id="抓取分支-建立关联"><a href="#抓取分支-建立关联" class="headerlink" title="抓取分支 建立关联"></a>抓取分支 建立关联</h2><ul>
<li><code>git pull &lt;远程库名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</code><br>取回远程库某个分支的更新，再与本地的指定分支(默认当前分支)<strong>合并</strong>。</li>
<li>git pull = git fetch + git merge<blockquote>
<p>注意: 抓取分支之前，可以先指定本地分支与远程对应分支的链接，建立关联</p>
<p>  <code>git branch --set-upstream-to=origin/dev dev</code></p>
<p>关联目的: 如果在本地分支下进行pull 和push操作时 ，便不需要指定远程的分支。</p>
</blockquote>
</li>
</ul>
<h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><h2 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h2><p>发布一个版本时，我们通常先在版本库中打一个标签，这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。</p>
<ul>
<li><p>git tag tagname<br>默认给当前分支的最新提交打上标签</p>
</li>
<li><p>git tag<br>查看所有<strong>按字母排序</strong>的标签</p>
</li>
<li><p>git show tagname<br>查看标签的详细信息</p>
</li>
<li><p>git tag -a tagname -m “说明文字” commit_id<br>为指定commit打上名为tagname的带有说明文字的标签</p>
</li>
</ul>
<h2 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h2><ul>
<li>命令<code>git push origin &lt;tagname&gt;</code>可以推送一个本地标签；</li>
<li>命令<code>git push origin --tags</code>可以推送全部未推送过的本地标签；</li>
<li>命令<code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签；</li>
<li>命令<code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签。</li>
</ul>
<h1 id="经历总结"><a href="#经历总结" class="headerlink" title="经历总结"></a>经历总结</h1><p>看大佬都是一两天看完，惭愧哈哈哈，最近社团，考试(考的稀碎)，比赛等等实在是抽不出来时间更新笔记了，只能是拿每天零碎的时间更新一下，好在五一放假有更多的自由时间来完善,很舒服啊，总算是结课廖雪峰老师的git了，终于不用再百兆百兆的保存原始项目了！起飞好吧。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt Debugger Guidance</title>
    <url>/2021/05/01/Debugger/Debugger/</url>
    <content><![CDATA[

	<div class="row">
    <embed src="/pdf/Debugger.pdf" width="100%" height="550" type="application/pdf">
	</div>




]]></content>
      <categories>
        <category>Debugger</category>
      </categories>
      <tags>
        <tag>Debugger</tag>
      </tags>
  </entry>
  <entry>
    <title>Notes for Lecture 8</title>
    <url>/2021/05/04/CS106B/CS106B-Lecture8/</url>
    <content><![CDATA[<h1 id="Exhaustive-Search-and-Backtracking"><a href="#Exhaustive-Search-and-Backtracking" class="headerlink" title="Exhaustive Search and Backtracking"></a>Exhaustive Search and Backtracking</h1><hr>
<h2 id="Exhaustive-Search-穷举搜索"><a href="#Exhaustive-Search-穷举搜索" class="headerlink" title="Exhaustive Search -穷举搜索"></a>Exhaustive Search -穷举搜索</h2><p>穷举搜索法是对可能是解的众多候选解按某种顺序进行逐一枚举和检验，并从众找出那些符合要求的候选解作为问题的解。 </p>
<h3 id="递归格式"><a href="#递归格式" class="headerlink" title="递归格式"></a>递归格式</h3><p><img src="/images/Lecture8/Exhaustive_Search.png"></p>
<h3 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h3><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>自相似 : 对应digits下的每个数都是进制数码与上一级digits的各结果数拼接的结果 (就怎么suo呢，见下例digits=3的结果，是不是0,1与digits=2的结果全连接的结果)</p>
<blockquote>
<p><img src="/images/Lecture8/Binary2.png"></p>
</blockquote>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"> &#x2F;&#x2F;Lecture8 Exhaustive Search 2</span><br><span class="line"></span><br><span class="line">void binaryAllSearchHelper (int digits,string str) &#123;</span><br><span class="line"></span><br><span class="line">    if (digits&#x3D;&#x3D;0) &#123;</span><br><span class="line">        cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        binaryAllSearchHelper(digits-1,str+&quot;0&quot;);</span><br><span class="line">        binaryAllSearchHelper(digits-1,str+&quot;1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void binaryAllSearch (int digits) &#123;</span><br><span class="line">    binaryAllSearchHelper(digits,&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<blockquote>
<p><img src="/images/Lecture8/Binary10.png"></p>
</blockquote>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"> &#x2F;&#x2F;Lecture8 Exhaustive Search 2</span><br><span class="line"> </span><br><span class="line"> void binaryAllSearchHelper (int digits,string str) &#123;</span><br><span class="line"></span><br><span class="line">    if (digits&#x3D;&#x3D;0) &#123;</span><br><span class="line">        cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">        for(int i&#x3D;0;i&lt;10;i++) &#123;</span><br><span class="line">        binaryAllSearchHelper(digits-1,str+integerToString(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void binaryAllSearch (int digits) &#123;</span><br><span class="line">    binaryAllSearchHelper(digits,&quot;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h3><blockquote>
<p><img src="/images/Lecture8/Decision_tree.png"></p>
</blockquote>
<h2 id="BackTracking"><a href="#BackTracking" class="headerlink" title="BackTracking"></a>BackTracking</h2><h3 id="回溯格式"><a href="#回溯格式" class="headerlink" title="回溯格式"></a>回溯格式</h3><blockquote>
<p><img src="/images/Lecture8/BackTracking.png"></p>
</blockquote>
<h3 id="Sample-1"><a href="#Sample-1" class="headerlink" title="Sample"></a>Sample</h3><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>与上面类似，仍然需要将每次骰子的结果进行全连接，但是由于使用vector容器作<strong>追踪</strong>，因此每次add后同一级其他全连接受影响，因此每个点连接完成后，需要弹出尾部元素。 —回溯</p>
<blockquote>
<p><img src="/images/Lecture8/Dice.png"></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Lecture8 BackTracking Dice</span><br><span class="line"></span><br><span class="line">void diceSumHelper(int dice, int desierSum, Vector&lt;int&gt;&amp; chose) &#123;</span><br><span class="line">&#x2F;&#x2F;    cout &lt;&lt; recursionIndent() &lt;&lt; &quot;dicesum(&quot; &lt;&lt; dice &lt;&lt; &quot;, &quot;&lt;&lt;desierSum &lt;&lt; &quot;, &quot;&lt;&lt; chose &lt;&lt; &quot;)&quot; &lt;&lt; endl;</span><br><span class="line">    if(dice&#x3D;&#x3D;0)&#123;</span><br><span class="line">        if(desierSum &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            cout &lt;&lt; chose &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for(int i&#x3D;1;i&lt;&#x3D;6;i++) &#123;</span><br><span class="line">            chose.add(i);</span><br><span class="line">            diceSumHelper(dice-1,desierSum-i,chose);</span><br><span class="line">            chose.removeBack();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void diceSum(int dice, int desierSum) &#123;</span><br><span class="line">    Vector &lt;int&gt; v;</span><br><span class="line">    diceSumHelper(dice,desierSum,v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>CS106B</category>
      </categories>
      <tags>
        <tag>CS106B</tag>
      </tags>
  </entry>
  <entry>
    <title>Assign1 LifeGame</title>
    <url>/2021/05/04/CS106B_Assignments/Assign1_lifegame/assgin1-life/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>《生命游戏》是英国数学家J.H.康威于1970年构思的模拟，由马丁·加德纳在他的《科学美国人》专栏中推广。该游戏使用二维细胞网格对细菌的生命周期进行模型。根据最初的模式，游戏使用一套简单的规则模拟后代细胞的出生和死亡。在此任务中，您将实现 J.H.康威 模拟的简化版本和观看细菌随着时间而增长的基本用户界面。</p>
<p>模拟从网格上的细胞初始模式开始，并根据以下规则计算连续几代细胞：</p>
<ul>
<li>一个零或一个邻居的位置将在下一代空。如果一个细胞在那里，它就会死亡。</li>
<li>有两个邻居的位置是稳定的。如果它有一个细胞，它仍然包含一个细胞。如果是空的，还是空的。</li>
<li>一个有三个邻居的位置将包含下一代的细胞。如果它以前无人居住，一个新的细胞诞生了。如果它目前包含一个细胞，细胞仍然存在。</li>
<li>在下一代中，一个有四个或更多邻居的位置将空无一人。如果那个地方有一个牢房，它就会因人满为患而死亡。</li>
</ul>
<h2 id="功能模块"><a href="#功能模块" class="headerlink" title="功能模块"></a>功能模块</h2><h3 id="用户交互模块"><a href="#用户交互模块" class="headerlink" title="用户交互模块"></a>用户交互模块</h3><p>您的生命游戏计划应首先提示用户提供文件名称，并使用该文件的内容来设置细菌群落网格的初始状态。然后，它应该询问模拟是否应该环绕网格。然后，该计划将允许用户通过几代人的增长推进殖民地。用户可以键入 t 以”勾选”一代的细菌模拟，或开始一个动画循环，将模拟向前滴答作响几代人，每 50 毫秒一次：或q退出</p>
<p>选择初始游戏网格</p>
<ul>
<li>供用户选择初始游戏网格</li>
<li>fileExists(filePath) -Checks if a file with the corresponding fileName exists. Returns a bool.<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void input_File(string filePath, ifstream&amp; fin) &#123;</span><br><span class="line">    while(true) &#123;</span><br><span class="line">        string filename &#x3D; getLine(&quot;Grid input file name? &quot;);</span><br><span class="line">        filePath &#x3D; &quot;res&#x2F;&quot; + filename + &quot;.txt&quot;;</span><br><span class="line">        if(!fileExists(filePath)) &#123;</span><br><span class="line">            cout &lt;&lt; &quot;Can&#39;t locate the file, try again.\n&quot; &lt;&lt;endl;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>选择游戏模式(wrap)</p>
<p>模式1：wrap around the grid </p>
<blockquote>
<p>游戏网格无边界，显示的不足8个neighbor边界网格将以其他边界网格替代</p>
</blockquote>
<p>模式2: no wrap around the grid </p>
<blockquote>
<p>游戏网格存在边界，不足8个neighbor的边界网格不作填充</p>
</blockquote>
<p>游戏’ui‘</p>
<ul>
<li>animate 指定动画次数，自动每50ms显示下一代细胞繁衍情况</li>
<li>tick 手动点击显示下一代细胞繁衍情况</li>
<li>quit 停止游戏 退出</li>
</ul>
<h3 id="模拟算法模块"><a href="#模拟算法模块" class="headerlink" title="模拟算法模块"></a>模拟算法模块</h3><h5 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&quot;grid.h&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>采用grid存储而非二维vector因为grid更利于操作，例如g.inBounds(r,c)可判断(r,c)位置是否越界</li>
<li>grid需要严格设置边界为初始化网格的长宽，因为初始化文件中还有其他杂项(注释等)<br>g.resize(r,c)可重置网格维度</li>
</ul>
<h5 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h5><p>思路: 遍历网格的每一个单元格，计算其neighbor数，从而设置该单元格的显示内容(细胞的生命状态)<br>难点: 不同模式不同的单元格neighbor数的计算方式<br>解决方案:</p>
<blockquote>
<p>对于指定位置遍历其相邻8个网格的方法   –相对位置<br>与中心网格相邻的网格(’边界‘网格)与中心网格的横纵相对位置差值均在-1-+1中 (0为本身的情况需排除)</p>
</blockquote>
<p>模式1：wrap around the grid </p>
<blockquote>
<p>游戏网格无边界，显示的不足8个neighbor边界网格将以其他边界网格替代<br>无边界就是边界外部的网格对应到网格内的网格，%操作即可</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int neighbourNum_Wrap(const Grid&lt;char&gt;&amp; g, int r, int c) &#123;</span><br><span class="line">    int neighbour &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; count neighbours around each cell&#39;s 8 directioins</span><br><span class="line">    for (int i &#x3D; -1; i &lt; 2; i++) &#123;</span><br><span class="line">        for (int j &#x3D; -1; j &lt; 2; j++) &#123;</span><br><span class="line">            if (g[(r+i+g.numRows()) % g.numRows()][(c+j+g.numCols()) % g.numCols()] &#x3D;&#x3D; &#39;X&#39;) &#123;</span><br><span class="line">                neighbour++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; do not count itself if cell exists</span><br><span class="line">    if (g[r][c] &#x3D;&#x3D; &#39;X&#39;) &#123;</span><br><span class="line">        neighbour--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return neighbour;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>模式2: no wrap around the grid </p>
<blockquote>
<p>游戏网格存在边界，不足8个neighbor的边界网格不作填充<br>因为存在边界，因此边界外部的网格需要舍弃，添加inBounds判断即可</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int neighbourNum_NonWrap(const Grid&lt;char&gt;&amp; g, int r, int c) &#123;</span><br><span class="line">    int neighbour &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; count neighbours around each cell&#39;s 8 directioins</span><br><span class="line">    for (int i &#x3D; -1; i &lt; 2; i++) &#123;</span><br><span class="line">        for (int j &#x3D; -1; j &lt; 2; j++) &#123;</span><br><span class="line">            if (g.inBounds(r + i, c + j) &amp;&amp; g[r + i][c + j] &#x3D;&#x3D; &#39;X&#39;) &#123;</span><br><span class="line">                neighbour++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; do not count itself if cell exists</span><br><span class="line">    if (g[r][c] &#x3D;&#x3D; &#39;X&#39;) &#123;</span><br><span class="line">        neighbour--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return neighbour;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="知识点汇总"><a href="#知识点汇总" class="headerlink" title="知识点汇总"></a>知识点汇总</h3><h4 id="File-Pointer-文件指针"><a href="#File-Pointer-文件指针" class="headerlink" title="File Pointer 文件指针"></a>File Pointer 文件指针</h4><p>文件位置指针是一个整数值，用于标注文件当前读写位置。</p>
<p>文件指针以字节为单位，文件第一个字节位置号为0，长度为N字节的文件有效读写范围为0～N-1。指针位置在此之外进行读/写操作，则失败；</p>
<p>  istream 和 ostream 都提供了用于重新定位文件位置指针的成员函数。</p>
<p>  这些成员函数包括关于 istream 的 seekg（”seek get”）和关于 ostream 的 seekp（”seek put”）。</p>
<p>  seekg 和 seekp 的参数通常是一个长整型。第二个参数可以用于指定查找方向。查找方向可以是 ios::beg（默认的，从流的开头开始定位），<br>  也可以是 ios::cur（从流的当前位置开始定位），也可以是 ios::end（从流的末尾开始定位）。</p>
<p>  下面是关于定位 “get” 文件位置指针的实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定位到 fileObject 的第 n 个字节（假设是 ios::beg）</span><br><span class="line">fileObject.seekg( n );</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 把文件的读指针从 fileObject 当前位置向后移 n 个字节</span><br><span class="line">fileObject.seekg( n, ios::cur );</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 把文件的读指针从 fileObject 末尾往回移 n 个字节</span><br><span class="line">fileObject.seekg( n, ios::end );</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定位到 fileObject 的末尾</span><br><span class="line">fileObject.seekg( 0, ios::end );</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="I-O流"><a href="#I-O流" class="headerlink" title="I/O流"></a>I/O流</h4><p>cin.fail()  –文件流操作失败 读取的类型不匹配等 返回类型为bool<br>!cin  –相当于cin.fail() 返回类型为bool<br>cin.peek()  –返回文件指针当前指向的字符  返回类型为char字符</p>
<p>连续输入时操作失败处理方法<br>cin.rdstate() 查看错误错误标识符<br>cin.clear() 清除错误标识符(错误状态)<br>cin.sync() 清除输入错误时存入缓冲区的字符</p>
<p>cin.ignore(999, ‘\n’) 清除缓冲区前999个字符，第一个参数足够大可用于清除换行符之前的所有缓冲区字符，消除上一次输出对本次输入的影响</p>
]]></content>
      <categories>
        <category>CS106B-Assignments</category>
      </categories>
      <tags>
        <tag>CS106B-Assignments</tag>
      </tags>
  </entry>
  <entry>
    <title>Notes for Lecture 10</title>
    <url>/2021/05/07/CS106B/CS106B-Lecture10/</url>
    <content><![CDATA[<h1 id="Recursive-Backtracking"><a href="#Recursive-Backtracking" class="headerlink" title="Recursive Backtracking"></a>Recursive Backtracking</h1><hr>
<h2 id="SubLists"><a href="#SubLists" class="headerlink" title="SubLists"></a>SubLists</h2><h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><blockquote>
<p><img src="/images/Lecture10/question.png"></p>
</blockquote>
<h3 id="Decision-Tree"><a href="#Decision-Tree" class="headerlink" title="Decision Tree"></a>Decision Tree</h3><blockquote>
<p><img src="/images/Lecture10/decision_tree.png"></p>
</blockquote>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;Lecture10 subLists</span><br><span class="line">void subListsHelper (Vector&lt;string&gt;&amp; ori,Vector&lt;string&gt;&amp; chosen) &#123;</span><br><span class="line">    if(ori.isEmpty()) &#123;</span><br><span class="line">        cout &lt;&lt; chosen &lt;&lt;endl;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F;every possible choice  --include &quot;a&quot; or not</span><br><span class="line">        &#x2F;&#x2F;choose  -try with &quot;a&quot;  ...  try without &quot;a&quot;</span><br><span class="line">        cout&lt;&lt;recursionIndent()&lt;&lt;&quot;ori : &quot;&lt;&lt;ori&lt;&lt;&quot;chosen : &quot;&lt;&lt;chosen&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">        string store&#x3D;ori[0];</span><br><span class="line">        ori.remove(0);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;explore</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;case 1 explore exclude &quot;a&quot;</span><br><span class="line">        subListsHelper(ori,chosen);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;case 2 explore include&quot;a&quot;</span><br><span class="line">        chosen.add(store);</span><br><span class="line">        subListsHelper(ori,chosen);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;unchoose</span><br><span class="line">        ori.insert(0,store);</span><br><span class="line">        chosen.removeBack();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void subLists (Vector&lt;string&gt;&amp; ori) &#123;</span><br><span class="line">    Vector &lt;string&gt; chosen;</span><br><span class="line">    subListsHelper(ori,chosen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CS106B</category>
      </categories>
      <tags>
        <tag>CS106B</tag>
      </tags>
  </entry>
  <entry>
    <title>Recursion Conclusion</title>
    <url>/2021/05/07/CS106B/CS106B-Recursion/</url>
    <content><![CDATA[<h1 id="Recursion-Conclusion"><a href="#Recursion-Conclusion" class="headerlink" title="Recursion Conclusion"></a>Recursion Conclusion</h1><hr>
<h2 id="How-to-Write-a-Recursive-Function"><a href="#How-to-Write-a-Recursive-Function" class="headerlink" title="How to Write a Recursive Function"></a>How to Write a Recursive Function</h2><h2 id="Exhaustive-Search-穷举搜索"><a href="#Exhaustive-Search-穷举搜索" class="headerlink" title="Exhaustive Search 穷举搜索"></a>Exhaustive Search 穷举搜索</h2><p>递归对搜索空间进行详尽的探索，筛选符合条件的</p>
<h2 id="Struct"><a href="#Struct" class="headerlink" title="Struct"></a>Struct</h2><h4 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void explore(options, soFar)</span><br><span class="line">&#123;</span><br><span class="line">    if (no more decisions to make) &#123;</span><br><span class="line">        &#x2F;&#x2F; base case</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; recursive case, we have a decision to make</span><br><span class="line">        for (each available option) &#123;</span><br><span class="line">            choose (update options&#x2F;sofar)</span><br><span class="line">            explore (recur on updated options&#x2F;sofar)</span><br><span class="line">            unchoose (undo changes to options&#x2F;sofar)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>解读</strong></p>
<ul>
<li><p>base case 对很容易判断结果的情况做出处理，终止条件</p>
</li>
<li><p>recursive case </p>
<blockquote>
<p>// for each choices<br>choose 对decision下的每一种choice作处理 (update decision中的结点内容)<br>explore 根据自相似现象 对当前选择的choice做递归处理<br>[backtracking] 每一种decision下的choices于同一级，处理完choice1再处理choice2时需要恢复到处理choice1时的状态</p>
</blockquote>
</li>
</ul>
<h3 id="key-Point"><a href="#key-Point" class="headerlink" title="key Point"></a>key Point</h3><ol>
<li>选择使用什么来追踪choice选择情况，并存储结果 变量or容器？</li>
<li>是否需要helper接口函数来添加辅助参数，该辅助参数用来存储choice选择情况</li>
<li>Each choice如何处理 单独or循环？</li>
</ol>
<h3 id="Difficulty"><a href="#Difficulty" class="headerlink" title="Difficulty"></a>Difficulty</h3><p>问题决策树的绘制</p>
<h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><p>排列，组合，生成子集<br>详细代码可见CS106B笔记对应8-10章节</p>
<p><strong>注意:</strong></p>
<p>并非所有递归都是该格式，一般情况是尤其是穷举搜索问题采用该格式</p>
<h2 id="递归-分治-自相似"><a href="#递归-分治-自相似" class="headerlink" title="递归 分治 自相似"></a>递归 分治 自相似</h2><h3 id="非概念性区别"><a href="#非概念性区别" class="headerlink" title="非概念性区别"></a>非概念性区别</h3><p>递归：重复操作</p>
<p>分治：大问题划分为小问题，各小问题解的并集为大问题的解 是一种解决问题的<strong>思路</strong></p>
<p>自相似：现象 组成部分与整体的存在形同规模不同的现象 递归时recursive部分的着手点 </p>
]]></content>
      <categories>
        <category>CS106B</category>
        <category>Recursion</category>
      </categories>
      <tags>
        <tag>CS106B</tag>
        <tag>Recursion</tag>
      </tags>
  </entry>
  <entry>
    <title>Notes for Lecture 9</title>
    <url>/2021/05/07/CS106B/CS106B-Lecture9/</url>
    <content><![CDATA[<hr>
<h1 id="Recursive-Backtracking"><a href="#Recursive-Backtracking" class="headerlink" title="Recursive Backtracking"></a>Recursive Backtracking</h1><hr>
<h2 id="Maze"><a href="#Maze" class="headerlink" title="Maze"></a>Maze</h2><hr>
<h2 id="Permute"><a href="#Permute" class="headerlink" title="Permute"></a>Permute</h2><p><strong>简要</strong><br>对于给定vector(v1)中的元素进行全排列  eg:{“a”,”b”,”c”}</p>
<p><strong>解决方案</strong><br>1.寻找自相似 对于给定数目元素的全排列问题，观察结果可见排列结果为各元素与其余元素全排列结果的全连接，类比骰子(每次骰子结果与其余骰子结果的全连接)，但是骰子元素有重复，例如{1,1,1}。<br>2.采用另一vector(v2)来存储当前选择的元素，追踪连接结果</p>
<p><strong>Recursion</strong> </p>
<ul>
<li>base case<br>v1为空时输出v2的全排列结果 </li>
<li>choice<br>遍历v1的各元素，将当前元素存储到v2中，记录连接结果</li>
<li>explore<br>求其余元素的全排列结果 (注意是其余元素，因此需要先将当前选择的元素从v1中弹出)</li>
<li>unchoice  backtracking<br>continue时需要恢复v1，v2原始状态</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void PermuteHelper (Vector&lt;string&gt; ori,Vector&lt;string&gt; chosen) &#123;</span><br><span class="line">    if(ori.isEmpty()) &#123;</span><br><span class="line">        cout &lt;&lt; chosen &lt;&lt; endl;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for(int i&#x3D;0;i&lt;ori.size();i++) &#123;</span><br><span class="line">            &#x2F;&#x2F;dynamic</span><br><span class="line">            cout&lt;&lt;recursionIndent()&lt;&lt;&quot;ori : &quot;&lt;&lt;ori&lt;&lt;&quot;chosen : &quot;&lt;&lt;chosen&lt;&lt;endl;</span><br><span class="line">            &#x2F;&#x2F;choice</span><br><span class="line">            chosen.add(ori[i]);</span><br><span class="line">            &#x2F;&#x2F;expore following choice</span><br><span class="line">            string store&#x3D;ori[i];</span><br><span class="line">            ori.remove(i);</span><br><span class="line">            PermuteHelper(ori,chosen);</span><br><span class="line">            &#x2F;&#x2F;un-chocie</span><br><span class="line">            ori.insert(i,store);</span><br><span class="line">            chosen.removeBack();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Permute (Vector&lt;string&gt; ori) &#123;</span><br><span class="line">    Vector &lt;string&gt; chosen;</span><br><span class="line">    PermuteHelper(ori,chosen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CS106B</category>
      </categories>
      <tags>
        <tag>CS106B</tag>
      </tags>
  </entry>
  <entry>
    <title>Notes for Lecture 11-14</title>
    <url>/2021/05/26/CS106B/CS106B-L11-14/</url>
    <content><![CDATA[<h1 id="Notes-for-Lecture-11-12-13-14"><a href="#Notes-for-Lecture-11-12-13-14" class="headerlink" title="Notes for Lecture 11  12  13  14"></a>Notes for Lecture 11  12  13  14</h1><hr>
<h1 id="Classes-Arrays-Implementing-a-Collection"><a href="#Classes-Arrays-Implementing-a-Collection" class="headerlink" title="Classes.Arrays.Implementing a Collection"></a>Classes.Arrays.Implementing a Collection</h1><hr>
<h1 id="Linked-Lists"><a href="#Linked-Lists" class="headerlink" title="Linked Lists"></a>Linked Lists</h1><h2 id="Pointer"><a href="#Pointer" class="headerlink" title="Pointer"></a>Pointer</h2><p>区别:</p>
<ul>
<li><p>空指针<br>nullptr c++关键字<br>NULL 符号常量 = 0<br>值为0但是并不指向任何存储空间</p>
</li>
<li><p>未初始化的指针<br>不可使用为初始化的指针，因为该指针的指向随机</p>
</li>
</ul>
<h2 id="Linked-Lists-1"><a href="#Linked-Lists-1" class="headerlink" title="Linked Lists"></a>Linked Lists</h2><h3 id="component"><a href="#component" class="headerlink" title="component"></a>component</h3><p>template <class elemtype><br>struct LinkNode {<br>    ElemType data;<br>    LinkNode* next;<br>}</class></p>
<h3 id="traverse"><a href="#traverse" class="headerlink" title="traverse"></a>traverse</h3><p>在不改变front指针的情况下，适用临时指针来遍历，loop条件为temp != nullptr</p>
<h3 id="operate"><a href="#operate" class="headerlink" title="operate"></a>operate</h3><ul>
<li>链表头尾插入结点</li>
<li>删除头尾结点</li>
</ul>
<h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>在类生命期结束之前，由系统自动调动清理空间</p>
<h2 id="公用数据成员的保护"><a href="#公用数据成员的保护" class="headerlink" title="公用数据成员的保护"></a>公用数据成员的保护</h2><h2 id="运算符重载与友元函数"><a href="#运算符重载与友元函数" class="headerlink" title="运算符重载与友元函数"></a>运算符重载与友元函数</h2>]]></content>
      <categories>
        <category>CS106B</category>
      </categories>
      <tags>
        <tag>CS106B</tag>
      </tags>
  </entry>
  <entry>
    <title>Compile</title>
    <url>/2021/05/26/C++Primer/Compile/</url>
    <content><![CDATA[<h1 id="Compile"><a href="#Compile" class="headerlink" title="Compile"></a>Compile</h1><p>.cpp-&gt;(预处理).i-&gt;编译.s-&gt;汇编.o-&gt;链接.exe</p>
<p>c++中文件没有任何意义，仅仅告知编译器对待编译该文件的方式，以.cpp对待？以.s对待？等等</p>
<h2 id="预编译-i"><a href="#预编译-i" class="headerlink" title="预编译 .i"></a>预编译 .i</h2><p>在编译之前对程序内容进行取舍处理，使得一些语句参加编译，而另一些语句不参加编译</p>
<h3 id="预处理指令"><a href="#预处理指令" class="headerlink" title="预处理指令"></a>预处理指令</h3><p>在编译之前对文件的处理</p>
<h3 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h3><p>include指示预编译将包含的头文件内容附加在程序文件中，以<strong>参加</strong>编译</p>
<p>#include &lt;标准库文件&gt;<br>#include “用户自定义文件”</p>
<p>区别：&lt;&gt;包含的文件为标准库文件，编译器在搜索路径时会在默认系统头文件路径中搜索，而””包含的用户自定义文件，编译器会在源文件目录进行搜索，若搜索不到，再到默认头文件库中搜索</p>
<h3 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h3><ul>
<li>c++编译时不允许出现属性的重定义(不同cpp文件全局变量的重定义，单一cpp文件中变量的重定义，等等重定义均不允许)</li>
<li>头文件卫士<br>保护嵌套的include指令中的文件属性的名称不能被<strong>重复定义</strong><blockquote>
<p>#if #elif #else #ifdef #ifndef #endif</p>
</blockquote>
</li>
</ul>
<p><strong>防止头文件的重复包含和编译</strong><br>解决方案</p>
<ul>
<li><p>#ifndef name<br>#define name</p>
</li>
<li><blockquote>
<p>优点为可以防止多次包含不同名但相同内容的文件，因为是根据是否有同名变量来判断是否在此包含文件的</p>
</blockquote>
</li>
<li><p>pragma once</p>
</li>
<li><blockquote>
<p>交由编译器处理，可以防止该文件被多次包含，但是同内容不同名的文件仍会被包含进来，但是容易发现</p>
</blockquote>
</li>
</ul>
<h3 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h3><p>#define</p>
<p><strong>无参宏定义</strong></p>
<p>#define 宏名 字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#define INTEGER int</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用宏名来表示代码中的字符串，但是在预处理时会使用字符串来代换宏名，称为<strong>宏代换</strong>，<strong>宏展开</strong></p>
<ul>
<li>字符串可以是常数、表达式、格式串等 无需””括起</li>
<li>宏定义方便程序修改</li>
</ul>
<p><strong>带参宏定义</strong></p>
<p>#define 宏名(形参表) 字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#define Multiply(a,b) a*b</span><br><span class="line"></span><br><span class="line">int a &#x3D; Multiply(3,5)&#x2F;&#x2F;调用 a&#x3D;15</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>对于带参的宏，预编译时不仅要展开，还要将实参代入</li>
<li>使用带参数的宏定义可完成函数调用的功能，又能减少系统开销，提高运行效率</li>
</ul>
<p><strong>取消宏定义</strong></p>
<p>#undef</p>
<p>宏定义的作用域是宏定义命令其到宏定义源程序结束，可使用#undef来终止其作用域</p>
<p>#undef 宏名 字符串<br>#undef 宏名(形参表) 字符串</p>
<h2 id="编译-s"><a href="#编译-s" class="headerlink" title="编译 .s"></a>编译 .s</h2><ul>
<li><p>词法分析</p>
</li>
<li><p>语法分析</p>
</li>
<li><p>语义分析</p>
</li>
<li><p>代码优化</p>
</li>
</ul>
<p>编译主要将代码转成汇编代码，即一条一条的指令</p>
<h2 id="汇编-obj"><a href="#汇编-obj" class="headerlink" title="汇编 .obj"></a>汇编 .obj</h2><p>在汇编阶段主要是将指令代码翻译汇编成二进制文件</p>
<h2 id="链接-exe"><a href="#链接-exe" class="headerlink" title="链接 .exe"></a>链接 .exe</h2><p>编译器将生成的多个.o文件来链接到一起生成一个可执行的.exe文件</p>
<h2 id="VS2017配置预处理相关属性"><a href="#VS2017配置预处理相关属性" class="headerlink" title="VS2017配置预处理相关属性"></a>VS2017配置预处理相关属性</h2><p>在项目简介方案属性中可以设置预编译内容写入到文件，但是选定该选项为true时，不再编译生成obj文件，而是生成.i文件与debug目录下，因此无法生成.exe文件</p>
]]></content>
      <categories>
        <category>C++Primer</category>
      </categories>
      <tags>
        <tag>C++Primer</tag>
      </tags>
  </entry>
  <entry>
    <title>Notes for Lecture 15-16</title>
    <url>/2021/05/26/CS106B/CS106B-L15-16/</url>
    <content><![CDATA[<h1 id="Notes-for-Lecture-15-16"><a href="#Notes-for-Lecture-15-16" class="headerlink" title="Notes for Lecture 15-16"></a>Notes for Lecture 15-16</h1><hr>
<h1 id="Big-O"><a href="#Big-O" class="headerlink" title="Big-O"></a>Big-O</h1><p><strong>时间复杂度</strong></p>
<p>算法的时间复杂度记做 T(n) = O(f(n))</p>
<p>f(n) - 算法的<strong>基本操作</strong>重复执行的次数是模块n的某一函数f(n),</p>
<p>随着模块n的增大，算法执行的时间增长率与f(n)的增长率成正比，所以f(n)越小，算法的时间复杂度越低，算法的效率越高。</p>
<ul>
<li>而判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项（最高项）的阶数。</li>
</ul>
<p><strong>空间复杂度</strong></p>
<p>算法的时空间复杂度记做 S(n) = O(f(n))</p>
<p>f(n) - 语句关于n所占存储空间的函数</p>
<p>算法实现所需的存储空间大小，n为问题规模</p>
<h1 id="Trees"><a href="#Trees" class="headerlink" title="Trees"></a>Trees</h1><hr>
<p>有向无环的链接结点结构</p>
<blockquote>
<p><img src="../images/Lecture15-16/Tree.png"></p>
</blockquote>
<h2 id="Terminology-术语"><a href="#Terminology-术语" class="headerlink" title="Terminology 术语"></a>Terminology 术语</h2><blockquote>
<p><img src="../images/Lecture15-16/Terminology.png"></p>
</blockquote>
<h2 id="Binary-trees"><a href="#Binary-trees" class="headerlink" title="Binary trees"></a>Binary trees</h2><p>最多有两个孩子结点的树</p>
<h2 id="递归定义"><a href="#递归定义" class="headerlink" title="递归定义"></a>递归定义</h2><blockquote>
<p>Empty(nullptr) </p>
</blockquote>
<blockquote>
<p>Or 一个根节点 该根节点包含</p>
<ul>
<li> 数据成员</li>
<li> 左子树 可为空</li>
<li>右子树 可为空</li>
</ul>
</blockquote>
<h2 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h2><h2 id="Print"><a href="#Print" class="headerlink" title="Print"></a>Print</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void printTree(Tree* root) &#123;</span><br><span class="line"></span><br><span class="line">    if(root!&#x3D;nullptr) &#123;</span><br><span class="line"></span><br><span class="line">        cout&lt;&lt;root-&gt;data;</span><br><span class="line">        printTree(root-&gt;left);</span><br><span class="line">        printTree(root-&gt;right);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Size-求二叉树的高度"><a href="#Size-求二叉树的高度" class="headerlink" title="Size 求二叉树的高度"></a>Size 求二叉树的高度</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int size(Tree* root) &#123;</span><br><span class="line"></span><br><span class="line">    if(root&#x3D;&#x3D;nullptr) &#123;</span><br><span class="line"></span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    &#125;else &#123;</span><br><span class="line"></span><br><span class="line">        int left&#x3D;size(root-&gt;left);</span><br><span class="line">        int right&#x3D;size(root-&gt;right);</span><br><span class="line">        return left+right+1;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Contain-是否包含对应结点"><a href="#Contain-是否包含对应结点" class="headerlink" title="Contain 是否包含对应结点"></a>Contain 是否包含对应结点</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool Contain(Tree* root,int value) &#123;</span><br><span class="line"></span><br><span class="line">    if(root!&#x3D;nullptr)&#123;</span><br><span class="line">        if(root-&gt;data&#x3D;&#x3D;value) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if(Contain(root-&gt;left,value) || Contain(root-&gt;right,value)) &#123;</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Binary-search-trees-BST"><a href="#Binary-search-trees-BST" class="headerlink" title="Binary search trees - BST"></a>Binary search trees - BST</h1><h2 id="Defination"><a href="#Defination" class="headerlink" title="Defination"></a>Defination</h2><p>二叉树</p>
<ul>
<li>左子树的值均比根节点小</li>
<li>右子树的值均比根节点大</li>
</ul>
<h2 id="Traversal"><a href="#Traversal" class="headerlink" title="Traversal"></a>Traversal</h2><p>pre-order 先序遍历  root -&gt; 左子树 -&gt; 右子树<br>in-order 中序遍历  左子树 -&gt; root -&gt; 右子树<br>post-order 后序遍历  左子树  -&gt; 右子树 -&gt; root</p>
<h2 id="Application-1"><a href="#Application-1" class="headerlink" title="Application"></a>Application</h2><h2 id="Search-in-BST"><a href="#Search-in-BST" class="headerlink" title="Search in BST"></a>Search in BST</h2><p><strong>Solution：</strong></p>
<p>Empty 查找失败  Or</p>
<ul>
<li> value小于当前结点data递归查找左子树</li>
<li> value大于当前结点data递归查找右子树</li>
<li> value等于当前结点data 返回true</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool Contain(Tree* root,int value) &#123;</span><br><span class="line"></span><br><span class="line">    if(root!&#x3D;nullptr)&#123;</span><br><span class="line">        if(root-&gt;data&#x3D;&#x3D;value) &#123;</span><br><span class="line"></span><br><span class="line">            return true;</span><br><span class="line">        &#125;else if(root-&gt;data&gt;value) &#123;</span><br><span class="line"></span><br><span class="line">            Contain(Tree-&gt;left,value);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line"></span><br><span class="line">            Contain(Tree-&gt;right,value);</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="getMain-Max"><a href="#getMain-Max" class="headerlink" title="getMain/Max"></a>getMain/Max</h2><p><strong>Solution：</strong></p>
<p>Max:为根节点右子树中最右下的结点的值 —右子树为空的结点</p>
<p>Min:为根节点左子树中最左下的结点的值 —左子树为空的结点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;getMain&#x2F;Max 假设二分查找树非空</span><br><span class="line"></span><br><span class="line">int getMain(Tree* root) &#123;</span><br><span class="line"></span><br><span class="line">    if(root-&gt;left&#x3D;&#x3D;nullptr) &#123;</span><br><span class="line"></span><br><span class="line">        return root-&gt;data;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line"></span><br><span class="line">        return getMain(root-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int getMax(Tree* root) &#123;</span><br><span class="line"></span><br><span class="line">    if(root-&gt;right&#x3D;&#x3D;nullptr) &#123;</span><br><span class="line"></span><br><span class="line">        return root-&gt;data;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line"></span><br><span class="line">        return getMax(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Add-to-a-BST"><a href="#Add-to-a-BST" class="headerlink" title="Add to a BST"></a>Add to a BST</h2><p><strong>Solution：</strong></p>
<p>添加的结点为叶节点，二分搜索树中添加，比当前结点大，递归添加在其右子树中，否则，递归添加在左子树中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Add(Tree* &amp;root,int value) &#123;</span><br><span class="line"></span><br><span class="line">    if(root&#x3D;&#x3D;nullptr) &#123;</span><br><span class="line"></span><br><span class="line">        root&#x3D;new Tree(value);</span><br><span class="line">    &#125;else &#123;</span><br><span class="line"></span><br><span class="line">        if(root-&gt;data&lt;value) &#123;</span><br><span class="line"></span><br><span class="line">            Add(root-&gt;right,value);</span><br><span class="line">        &#125;else if(root-&gt;data&gt;value) &#123;</span><br><span class="line"></span><br><span class="line">            Add(root-&gt;left,value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Free-the-tree"><a href="#Free-the-tree" class="headerlink" title="Free the tree"></a>Free the tree</h2><p>后序递归delete</p>
<h2 id="Removal"><a href="#Removal" class="headerlink" title="Removal"></a>Removal</h2><p>BST中删除指定值</p>
<p><strong>Solution</strong></p>
<p>找到指定值，并删除</p>
<ul>
<li>叶子结点<blockquote>
<p>删除该结点并更新父节点的指向为null<br><code>delete node -- node = nullptr</code></p>
</blockquote>
</li>
<li>只有左子树<blockquote>
<p>需要暂存该节点的指针以便删除<br>删除该节点并将父节点指向更新指向到第一个左孩子<br><code>Tree* temp = node -- node = node-&gt;left -- delete temp</code></p>
</blockquote>
</li>
<li>只有右子树</li>
<li><blockquote>
<p>需要暂存该节点的指针以便删除<br>删除该节点并将父节点指向更新指向到第一个右孩子<br><code>Tree* temp = node -- node = node-&gt;right -- delete temp</code></p>
</blockquote>
</li>
<li>full 满树<blockquote>
<p>使用左子树的最大结点值或者右子树的最小结点值替代当前结点值并递归删除子树最值结点<br><code>node -&gt; data = min/max -- removal(node-&gt;left,min) / removal(node-&gt;right,max)</code></p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Removal(Tree*&amp; root,int value) &#123;</span><br><span class="line"></span><br><span class="line">    if(root!&#x3D;nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        if(root-&gt;data&#x3D;&#x3D;value)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            if(root-&gt;left&#x3D;&#x3D;nullptr &amp;&amp; root-&gt;right&#x3D;&#x3D;nullptr)</span><br><span class="line">            &#123;</span><br><span class="line">                delete root;</span><br><span class="line">                root&#x3D;nullptr;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(root-&gt;left&#x3D;&#x3D;nullptr)</span><br><span class="line">            &#123;</span><br><span class="line">                Tree* temp&#x3D;root;</span><br><span class="line"></span><br><span class="line">                root&#x3D;root-&gt;right;</span><br><span class="line"></span><br><span class="line">                delete temp;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            else if(root-&gt;right&#x3D;&#x3D;nullptr)</span><br><span class="line">            &#123;</span><br><span class="line">                Tree* temp&#x3D;root;</span><br><span class="line"></span><br><span class="line">                root&#x3D;root-&gt;left;</span><br><span class="line"></span><br><span class="line">                delete temp;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                int min&#x3D;getMin(root-&gt;right);</span><br><span class="line"></span><br><span class="line">                root-&gt;data&#x3D;min;</span><br><span class="line"></span><br><span class="line">                removal(root-&gt;right,min);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        else if(root-&gt;data&gt;value)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            Removal(Tree-&gt;left,value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            Removal(Tree-&gt;right,value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CS106B</category>
      </categories>
      <tags>
        <tag>CS106B</tag>
      </tags>
  </entry>
  <entry>
    <title>File Pointer</title>
    <url>/2021/05/26/C++Primer/File_pointer/</url>
    <content><![CDATA[<h1 id="File-Pointer-文件指针"><a href="#File-Pointer-文件指针" class="headerlink" title="File Pointer 文件指针"></a>File Pointer 文件指针</h1><p>  istream 和 ostream 都提供了用于重新定位文件位置指针的成员函数。</p>
<p>  这些成员函数包括关于 istream 的 seekg（”seek get”）和关于 ostream 的 seekp（”seek put”）。</p>
<p>  seekg 和 seekp 的参数通常是一个长整型。第二个参数可以用于指定查找方向。查找方向可以是 ios::beg（默认的，从流的开头开始定位），<br>  也可以是 ios::cur（从流的当前位置开始定位），也可以是 ios::end（从流的末尾开始定位）。</p>
<p>  文件位置指针是一个整数值，指定了从文件的起始位置到指针所在位置的字节数。下面是关于定位 “get” 文件位置指针的实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定位到 fileObject 的第 n 个字节（假设是 ios::beg）</span><br><span class="line">fileObject.seekg( n );</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 把文件的读指针从 fileObject 当前位置向后移 n 个字节</span><br><span class="line">fileObject.seekg( n, ios::cur );</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 把文件的读指针从 fileObject 末尾往回移 n 个字节</span><br><span class="line">fileObject.seekg( n, ios::end );</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定位到 fileObject 的末尾</span><br><span class="line">fileObject.seekg( 0, ios::end );</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Cin"><a href="#Cin" class="headerlink" title="Cin"></a>Cin</h1><p>cin.fail()  –文件流操作失败 读取的类型不匹配等 返回类型为bool<br>!cin  –相当于cin.fail() 返回类型为bool<br>cin.peek()  –返回文件指针当前指向的字符  返回类型为char字符</p>
]]></content>
      <categories>
        <category>C++Primer</category>
      </categories>
      <tags>
        <tag>C++Primer</tag>
      </tags>
  </entry>
  <entry>
    <title>Network</title>
    <url>/2021/07/07/Network/Network_Layor/</url>
    <content><![CDATA[<h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="网络层两种服务的比较"><a href="#网络层两种服务的比较" class="headerlink" title="网络层两种服务的比较"></a>网络层两种服务的比较</h2><ul>
<li><p>虚电路服务 (面向连接)</p>
<blockquote>
<p>参照电信网络，网络层间的通信需要 建立连接-&gt;通信-&gt;释放资源</p>
<ul>
<li>建立连接 <blockquote>
<p>该连接是在已有网络的基础上建立的逻辑的虚拟连接</p>
</blockquote>
</li>
<li>通信<br>除了建立连接时的数据报需要有目标地址字段外其余均只需要虚电路编号字段.</li>
</ul>
<p>由网络层来保证可靠传输</p>
</blockquote>
</li>
<li><p>数据报服务 (无连接)</p>
<blockquote>
<p>当前计算机网络所采用的服务<br>每个数据报均需要有目的地址字段且在转发时自行选择转发路由 </p>
<p>由主机来保证可靠传输,网络层仅提供灵活的,无连接的,尽最大努力的交付</p>
</blockquote>
</li>
</ul>
<h2 id="虚拟互联网"><a href="#虚拟互联网" class="headerlink" title="虚拟互联网"></a>虚拟互联网</h2><h2 id="网络互连的方式"><a href="#网络互连的方式" class="headerlink" title="网络互连的方式"></a>网络互连的方式</h2><ul>
<li>物理层 转发器，集线器</li>
<li>数据链路层 网桥</li>
</ul>
<blockquote>
<p>上述两层仅起到了拓展局域网的作用，并未实际上互连两个网络，因为互连网络的网络号是相同的</p>
</blockquote>
<ul>
<li>网络层 路由器</li>
<li>其它层 网关</li>
</ul>
<h2 id="虚拟互联网-IP网"><a href="#虚拟互联网-IP网" class="headerlink" title="虚拟互联网 -IP网"></a>虚拟互联网 -IP网</h2><p>不存在一个单一网络能满足各种需求，因此全球存在数百万的异构网络，但是使用IP协议进行通信的各网络，在网络层上可忽略异构性，看作一个统一的网络。</p>
<h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>分配给主机某接口的在全球互联网范围内唯一的32位的地址</p>
<blockquote>
<p>若某主机有多个接口，则该主机会拥有多IP地址，该主机称为多归属主机</p>
</blockquote>
<h3 id="IP地址的编址方式"><a href="#IP地址的编址方式" class="headerlink" title="IP地址的编址方式"></a>IP地址的编址方式</h3><blockquote>
<p>编址原则: 1.唯一性 2.连续性 3.实意性 4.可拓展性</p>
</blockquote>
<ul>
<li><strong>分类的IP地址</strong></li>
</ul>
<p>将各IP地址划分为若干个固定类，每个类均分为两个字段</p>
<ul>
<li>网络号</li>
</ul>
<blockquote>
<p>标识网络的在全球互联网范围内唯一的号</p>
</blockquote>
<ul>
<li>主机号</li>
</ul>
<blockquote>
<p>标识网络中主机的在指定网络中唯一的号</p>
</blockquote>
<p>分类的IP地址不仅能指明一台主机，还能指明该主机所在的网络地址</p>
<p><strong>类别</strong></p>
<blockquote>
<p><img src="/images/Network/Type.png"></p>
</blockquote>
<p>每一类地址的网络号中均含有类别位</p>
<p>点分十进制法<br>由于在计算机中表示为32位的二进制数，不好辨别，因此每8位为一组，并转换为10进制表示IP地址</p>
<p><strong>优势</strong></p>
<ul>
<li><p>分等级的IP地址可以使IP地址管理机构在给主机分配地址时     只分配第一级的网络号，且转发报文时也仅使用网络号作目的地址，可以简化路由器的转发表，而主机号由分配网络号的单位自行指定</p>
</li>
<li><p><strong>子网的划分</strong></p>
</li>
<li><p><strong>构成超网</strong></p>
</li>
</ul>
<h2 id="IP地址与物理地址"><a href="#IP地址与物理地址" class="headerlink" title="IP地址与物理地址"></a>IP地址与物理地址</h2><ul>
<li>物理地址<blockquote>
<p>48位的全球唯一的接口的链路层协议地址<br>为传输数据的每段链路标识出发送方和接收方</p>
</blockquote>
</li>
</ul>
<ul>
<li>IP地址<blockquote>
<p>32位全球唯一的接口的网络层协议地址<br>为传输数据的整个通路标识出原始发送方和最终接受方</p>
</blockquote>
</li>
</ul>
<h3 id="通信示意图"><a href="#通信示意图" class="headerlink" title="通信示意图"></a>通信示意图</h3><blockquote>
<p><img src="/images/Network/Map.png"></p>
<p><img src="/images/Network/Explain.png"></p>
</blockquote>
<p><strong>issues</strong></p>
<ul>
<li>主机H1向路由器R1发送MAC帧时怎么知道HA3接口的物理地址的？？？</li>
</ul>
<h2 id="ARP地址解析协议"><a href="#ARP地址解析协议" class="headerlink" title="ARP地址解析协议"></a>ARP地址解析协议</h2><p><strong>概要</strong></p>
<p>通过某接口的IP地址”解析“出其物理地址</p>
<blockquote>
<p><img src="/images/Network/ARP.png"></p>
</blockquote>
<ul>
<li>每台主机均配有ARP高速缓存器，用来存放IP地址与物理地址的映射关系</li>
</ul>
<p><strong>过程</strong></p>
<p><strong>简单总线网络</strong></p>
<ul>
<li><p>ARP请求 A-B</p>
<blockquote>
<p>发送方先检查缓存器有无对应IP地址的物理地址，无则发送ARP请求帧 帧格式 MA-IPA-M(广播)-IPB</p>
</blockquote>
</li>
<li><p>ARP应答 B-&gt;A</p>
<blockquote>
<p>接收方收到请求帧后检查IPB与自己的IP地址相同则填补自己的物理地址并发送应答帧</p>
</blockquote>
</li>
<li><p>更新表</p>
<blockquote>
<p>A收到应答帧后更新缓存器中映射关系，并发送MAC帧</p>
</blockquote>
</li>
</ul>
<p><strong>路由器连接的网络</strong></p>
<ul>
<li><p>ARP请求 H1-&gt;H2</p>
<blockquote>
<p>发送方先检查缓存器有无对应IP地址的物理地址，无则发送ARP请求帧 帧格式 MA-IPA-M(广播)-IPB</p>
</blockquote>
</li>
<li><p>ARP应答 R1-&gt;A    (欺骗)</p>
<blockquote>
<p>路由器收到请求帧后，将自己的物理地址填入发回应答帧</p>
</blockquote>
</li>
<li><p>更新表</p>
</li>
</ul>
<blockquote>
<p>A收到应答帧后更新缓存器中映射关系，并发送MAC帧，此时H1将HA3当做H2的物理地址，被欺骗</p>
</blockquote>
<p><strong>优化</strong></p>
<ul>
<li><p>每台主机启动时都会发送请求自己物理地址的ARP请求帧</p>
<blockquote>
<ul>
<li>用来更新其他主机高速缓存器的映射关系</li>
<li>用来检查链路中是否存在同名的IP地址</li>
</ul>
</blockquote>
</li>
<li><p>在其他主机发送请求帧与应答帧时，总线上的其他网络也可更新自己高速缓存器中的映射关系</p>
</li>
</ul>
<h2 id="IP数据报"><a href="#IP数据报" class="headerlink" title="IP数据报"></a>IP数据报</h2><h3 id="IP数据报格式"><a href="#IP数据报格式" class="headerlink" title="IP数据报格式"></a>IP数据报格式</h3><ul>
<li><p>首部</p>
</li>
<li><p>数据部分</p>
</li>
</ul>
<p>固定首部 20bit</p>
<p>32bit</p>
<ul>
<li>4bit 版本 IPV4 or IPV6</li>
<li>4bit 首部长度 以4字节为单位代表IP数据报首部的总长度 若不足4的倍数将由填充字段填充</li>
<li>区分服务 8bit</li>
<li>16bit 总长度 IP数据报的总长度 以1字节为单位 总长度受链路层数据MTU的限制可能需要进行分片</li>
</ul>
<p>32bit</p>
<ul>
<li>16bit 标识</li>
<li>3bit 标志 最低位MF 为1代表不是最后一个分片  中间位DF 为1代表该片不再允许分片</li>
<li>补充 分片:IP数据报数据部分超过链路层MTU限制 需要将数据报分片发送 将数据部分划分后添加首部(与原首部有不同)后发送</li>
<li>16bit 片偏移 以8字节为单位 代表该片的数据部分在原始IP数据报中距离首部的长度<br>因此IP数据报的数据部分必须为8的倍数，各分片数据部分也为8的倍数 若存在递归分片<br>片偏移仍然代表相对于原始IP数据报的偏移</li>
</ul>
<p>32bit</p>
<ul>
<li>8bit 生存时间TTL 防止数据报无限制的转发而无法交付(存在环)<br>以跳数为单位 路由器每转发一次该数据报TTL减一 减至0丢弃该数据报 </li>
<li>8bit 协议 决定该数据报交付于上层哪一协议</li>
<li>16bit 首部校验和 校验传送的数据报首部是否正确  只有首部<br>发送方:数据报首部每16bit为单元取反相加(16bit校验位取0)  结果取反作校验位<br>接受方:数据报首部每16bit为单元取反相加 结果为0则正确保留 否则丢弃  </li>
</ul>
<p>32bit<br>源地址</p>
<p>32bit<br>目的地址</p>
<p>可选字段 0-40bit 但是必须为4的倍数<br>填充</p>
<h2 id="路由转发算法"><a href="#路由转发算法" class="headerlink" title="路由转发算法"></a>路由转发算法</h2><ul>
<li>特定主机路由</li>
<li>默认主机路由</li>
</ul>
<ol>
<li>由IP数据报首部提取目的地址D，得目的网络地址N</li>
<li>若该路由器与目的主机直接相连，则直接交付，否则间接交付至3</li>
<li>查找该目的网络地址在路由表中有无特定主机路由 有则转 无则至4</li>
<li>查找该目的网络地址在路由表中有无下一条路由地址，无则至5</li>
<li>若有默认主机路由，则转发至默认主机路由接口 无则6</li>
<li>转发过程出错</li>
</ol>
<h2 id="划分子网"><a href="#划分子网" class="headerlink" title="划分子网"></a>划分子网</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><blockquote>
<ol>
<li>两级IP地址不灵活，无法马上在以网络单位开辟一个新网络</li>
<li>IP地址空间利用率低</li>
</ol>
</blockquote>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><blockquote>
<p>划分子网 </p>
<p>对外仍表现为一个网络，仅仅为网络内部划分，分组转发时，先由其他路由器按照目的网络号转发到与目的网络直接相连的路由器，再由该路由器按照目的网络的子网号找到目的子网，交付IP数据报</p>
<p>三级IP地址<br>网络号</p>
<p>子网号 </p>
<p>主机号</p>
</blockquote>
<h3 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><blockquote>
<p>用来标识网络号的位数和主机号的位数</p>
<p>32bit 对应bit为网络号bit则为1否则为0</p>
<p>将子网掩码与对应IP地址作&amp;运算即可得到子网的IP地址</p>
</blockquote>
<h4 id="默认子网掩码"><a href="#默认子网掩码" class="headerlink" title="默认子网掩码"></a>默认子网掩码</h4><blockquote>
<p>即使不划分子网也可使用子网掩码，这样便无需查找类别位来判断属于哪一类网络</p>
<p>A类地址 255.0.0.0</p>
<p>B类地址 255.255.0.0</p>
<p>C类地址 255.255.255.0</p>
</blockquote>
<h3 id="划分过程"><a href="#划分过程" class="headerlink" title="划分过程"></a>划分过程</h3><ol>
<li>确定子网的位数  总和考虑子网数与容纳主机数(考虑广播地址与网络地址)</li>
<li>确定每个子网的子网掩码</li>
<li>确定子网的网络地址 –主机号全为0</li>
<li>确定子网的广播地址 –主机号全为1</li>
<li>确定子网的可用IP范围</li>
</ol>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><ul>
<li><p>块大小等于256-子网掩码</p>
<blockquote>
<p>通过确定块大小 可以确定每个子网掩码的网络地址</p>
</blockquote>
</li>
<li><p>每个子网的广播地址等于下一子网的网路地址-1</p>
<blockquote>
<p>需考虑进位情况</p>
</blockquote>
</li>
</ul>
<h3 id="划分子网的路由转发算法"><a href="#划分子网的路由转发算法" class="headerlink" title="划分子网的路由转发算法"></a>划分子网的路由转发算法</h3><p>转发表中添加了一个子网掩码字段</p>
<ol>
<li>由IP数据报首部提取目的地址D</li>
<li>将D与每一行的子网掩码&amp;运算得到的目的网络地址N，若N与本行的目的网络地址匹配，若成功则转发至指明的下一条路由器，否则</li>
<li>转发失败</li>
</ol>
<p>特定主机路由对应的子网掩码为255.255.255.255，网路地址为特定主机IP</p>
<p>默认主机路由对应子网掩码为0.0.0.0，网络号为0</p>
<h2 id="构成超网"><a href="#构成超网" class="headerlink" title="构成超网"></a>构成超网</h2><h3 id="CIDR无分类编址"><a href="#CIDR无分类编址" class="headerlink" title="CIDR无分类编址"></a>CIDR无分类编址</h3><blockquote>
<p> IP地址  ::=  {&lt;网络位&gt;,&lt;主机位&gt;}</p>
<p>CIDR记法也成斜线记法  /+网络前缀所占的位数</p>
<p>*记法，网络前缀后加星号代表星号之前的为网络位</p>
</blockquote>
<h4 id="CIDR地址块"><a href="#CIDR地址块" class="headerlink" title="CIDR地址块"></a>CIDR地址块</h4><blockquote>
<p>CIDR无分类编址将网络前缀相同的<strong>连续的IP地址</strong>组成一个地址块</p>
<p>路由表使用CIDR地址块的地址来查找路由网络</p>
</blockquote>
<h4 id="地址掩码"><a href="#地址掩码" class="headerlink" title="地址掩码"></a>地址掩码</h4><blockquote>
<p>CIDR使用32位的地址掩码,斜线记法中/后面的数字为1的个数</p>
</blockquote>
<h4 id="最长前缀匹配"><a href="#最长前缀匹配" class="headerlink" title="最长前缀匹配"></a>最长前缀匹配</h4><blockquote>
<p>应当从匹配结果中选择具有最长网络前缀的路由，因为该路由地址块小，目的地址具体</p>
</blockquote>
<h2 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h2><blockquote>
<p>网际控制报文协议 Internet Control Message Protocol</p>
<p>为更有效的转发IP数据报和提高交付的机会</p>
</blockquote>
<p>ICMP报文</p>
<blockquote>
<p>ICMP报文封装在IP数据报中，作为其中的数据部分</p>
</blockquote>
<ul>
<li><p>ICMP差错报告报文</p>
<p>类型</p>
<blockquote>
<ol>
<li>终点不可达 3</li>
<li>时间超过 11</li>
<li>参数问题 12</li>
<li>改变路由 5</li>
</ol>
</blockquote>
<p>不发送的情况</p>
<blockquote>
<ol>
<li>对ICMP差错报告报文不发送ICMP差错报告报文</li>
<li>对多播地址的数据报不发送ICMP差错报告报文</li>
<li>对具有特殊地址的数据报不发送ICMP差错报告报文</li>
<li>对第一个分片的数据报片的所有后续数据报片不发送ICMP差错报告报文</li>
</ol>
</blockquote>
</li>
<li><p>ICMP询问报文</p>
<blockquote>
<ol>
<li><p>回送请求和应答 8/0 0/0</p>
<blockquote>
<p>了解目的站是否可达以及目的站状态</p>
</blockquote>
</li>
<li><p>时间戳请求和应答 13/14</p>
<blockquote>
<p>用于时钟同步和时间测量</p>
</blockquote>
</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h2><h3 id="内部网关协议-RIP"><a href="#内部网关协议-RIP" class="headerlink" title="内部网关协议 RIP"></a>内部网关协议 RIP</h3><blockquote>
<p><strong>分布式</strong>的<strong>基于距离向量</strong>的路由选择协议</p>
<p>每个路由表需要额外维护一个<strong>距离向量</strong>(到达目的网路经过的路由器数+1)</p>
</blockquote>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol>
<li>仅和相邻路由器交换信息</li>
<li>相邻路由交换整个路由表的信息</li>
<li><strong>按固定时间间隔与相邻路由交换整个路由表的信息</strong></li>
</ol>
<h4 id="收敛"><a href="#收敛" class="headerlink" title="收敛"></a>收敛</h4><blockquote>
<p>整个自治系统的所有结点都得到了该系统中所有正确的路由选择信息的过程</p>
</blockquote>
<h4 id="距离向量算法"><a href="#距离向量算法" class="headerlink" title="距离向量算法"></a>距离向量算法</h4><ol>
<li><p>A收到B的RIP报文, 将此RIP报文中的所有下一条地址置为B，所有距离+1</p>
</li>
<li><p>逐个使用RIP报文中的目的网络地址与A中路由表的目的网络地址进行匹配</p>
<blockquote>
<p>匹配成功</p>
<ol>
<li>判断下一跳地址是否与B相同，相同则更新</li>
<li>下一条地址与B不相同,但是RIP报文中对应条目下的下一跳地址与目的网络距离更短，更新</li>
<li>否则，什么也不做 </li>
</ol>
</blockquote>
</li>
<li><p>若3min还未收到相邻路由器的RIP报文，则将此路由器视为不可达的路由器且将与其距离设置为16</p>
</li>
</ol>
<p>End</p>
<h3 id="外部网关协议"><a href="#外部网关协议" class="headerlink" title="外部网关协议"></a>外部网关协议</h3>]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP/IP协议栈</title>
    <url>/2021/07/07/Network/TCP-IP%E5%8D%8F%E8%AE%AE%E6%A0%88/</url>
    <content><![CDATA[<h1 id="TCP-IP协议栈"><a href="#TCP-IP协议栈" class="headerlink" title="TCP/IP协议栈"></a>TCP/IP协议栈</h1><h2 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h2><blockquote>
<p>实现网络行业的兼容性</p>
</blockquote>
<ul>
<li><p>应用层</p>
<blockquote>
<p>为用户提供接口/interface</p>
<p>应用层协议: OICQ,HTTP,HTTPS,BT/P2P</p>
<p>qq底层协议为OICQ</p>
</blockquote>
</li>
<li><p>表示层</p>
<blockquote>
<p>呈现用户数据 (数据格式，数据加密)</p>
</blockquote>
</li>
<li><p>会话层</p>
<blockquote>
<p>会话管理(建立，维持，关闭，区分)</p>
</blockquote>
</li>
<li><p>运输层</p>
<blockquote>
<p>实现数据的可靠/不可靠传输</p>
<p>运输层协议: TCP UDP(QQ)</p>
</blockquote>
</li>
<li><p>网络层</p>
<blockquote>
<p>提供三层寻址/IP地址和三层通信(路由器)功能</p>
<p>IP协议</p>
<p>ipconfig可查看本机IP地址</p>
</blockquote>
</li>
<li><p>数据链路层</p>
<blockquote>
<p>提供二层寻址/MAC地址和二层通信(交换机)功能</p>
</blockquote>
</li>
<li><p>物理层</p>
<blockquote>
<p>提供通信介质和接口标准</p>
</blockquote>
</li>
</ul>
<h3 id="OSI实现过程"><a href="#OSI实现过程" class="headerlink" title="OSI实现过程"></a>OSI实现过程</h3><p>OSI数据封装与解封装</p>
<h2 id="Ethernet协议"><a href="#Ethernet协议" class="headerlink" title="Ethernet协议"></a>Ethernet协议</h2><blockquote>
<p>以太网协议，用于实现<strong>链路层</strong>的数据传输和地址封装(MAC)</p>
</blockquote>
<p>三个字段</p>
<blockquote>
<p>destination： 目的MAC地址</p>
<p>source: 发送端MAC地址</p>
<p>Type: 上层协议</p>
</blockquote>
<p>MAC地址</p>
<ul>
<li>MAC地址的前半部分”OUI代码”厂商唯一标识符</li>
</ul>
<blockquote>
<p>全球唯一的48bit的物理地址</p>
<p>冒号分16进制表示</p>
</blockquote>
<h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><blockquote>
<p>互联网协议，用于实现网络层的不可靠的面向无连接的分组传输</p>
</blockquote>
<p>组成</p>
<blockquote>
<p>…</p>
<p>区分服务/服务质量 1byte</p>
<ul>
<li>DSCP</li>
</ul>
<p>TTL生存时间 1byte</p>
<blockquote>
<p>本质是为了解决IP数据报的“环路问题”!</p>
<p>占据带宽，cpu资源</p>
</blockquote>
<p>协议</p>
<blockquote>
<p>运输层的端口号，链路层的type类型值，网络层的协议，使上层协议能选择适当的协议解封装</p>
</blockquote>
<p>首部校验和</p>
<blockquote>
<p>让接收方验证此数据报是否完成或发生改动 </p>
</blockquote>
<p>分片</p>
<p>标识: ID从属的进程</p>
<p>标志: 保留位+DF位置+MF位</p>
<p>片偏移: 8byte为单位的分片数据部分在原分组中距离首部的偏移量</p>
<p>…</p>
</blockquote>
<h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><blockquote>
<p>地址解析协议，用于实现从IP地址到MAC地址的映射，询问目标IP对应的MAC地址</p>
</blockquote>
<p>ARP Request</p>
<blockquote>
<p>广播请求</p>
</blockquote>
<p>ARP Reply</p>
<blockquote>
<p>单播回应</p>
</blockquote>
<p>ARP 缓存</p>
<blockquote>
<p>ARP缓存表基于”后到优先”原则，IP与MAC的地址映射会被后到的映射覆盖</p>
</blockquote>
<p>常用命令</p>
<blockquote>
<p>arp -a 查看ARP表</p>
<p>arp -d 删除ARP表项</p>
<p>ping IP 测试网络连通性</p>
</blockquote>
<h3 id="ARP攻击"><a href="#ARP攻击" class="headerlink" title="ARP攻击"></a>ARP攻击</h3><p> 中间人拦截</p>
<ul>
<li>断网攻击</li>
<li>限速</li>
<li>窃取用户隐私</li>
</ul>
<p><code>注意:</code>但凡明文传输的应用,都可以被窃取!</p>
<h4 id="底层原理分析"><a href="#底层原理分析" class="headerlink" title="底层原理分析"></a>底层原理分析</h4><p>ARP扫描</p>
<blockquote>
<p>获取本局域网的所有主机的IP+MAC地址，根据MAC地址中的OUI还可获得品牌信息</p>
</blockquote>
<p>ARP欺骗</p>
<blockquote>
<p>中间人持续的发送成百上千的ARP欺骗包，即被伪造的ARP回应包</p>
</blockquote>
<p>Vmvare虚拟机网卡模式</p>
<blockquote>
<ol>
<li>NAT地址翻转模式 允许访问互联网，各虚拟机共享主机的IP地址</li>
<li>桥接模式 允许访问互联网，各虚拟机使用自己的IP地址(存在一个逻辑上的交换机使得为每个虚拟机均分配了一个IP地址)</li>
<li>主机模式 不允许访问互联网</li>
</ol>
</blockquote>
<p>攻击/渗透工具</p>
<blockquote>
<p>p2pover,cain</p>
</blockquote>
<h3 id="ARP防御"><a href="#ARP防御" class="headerlink" title="ARP防御"></a>ARP防御</h3><ul>
<li>网络设备</li>
</ul>
<blockquote>
<p>丢弃ARP欺骗包</p>
</blockquote>
<p>原理</p>
<blockquote>
<p> DAI-动态ARP检测技术</p>
<ol>
<li><p>交换机记录接口与IP地址与MAC地址的映射 port&lt;-&gt;MAC&lt;-&gt;IP,生成DAI检测表</p>
<blockquote>
<p>DAI检测表的生成</p>
<ol>
<li>手工绑定</li>
<li>DHCP侦听生成DHCP侦听表</li>
</ol>
</blockquote>
</li>
<li><p>对每个接口发回的ARP回应根据DAI表判断是否违规，违规则丢弃并进行惩罚! </p>
</li>
</ol>
</blockquote>
<ul>
<li>电脑/手机端</li>
</ul>
<p>ARP防火墙</p>
<blockquote>
<p>绑定正确的IP与MAC地址的映射，收到攻击包时不被欺骗</p>
<p>根据网络数据包的特征，自动识别局域网存在的ARP扫描行为和欺骗行为，并做出攻击判断(谁他妈干的，给爷干回去)</p>
</blockquote>
<p>ARP双向绑定/静态绑定</p>
<blockquote>
<p>静态绑定IP与MAC地址的映射，后到的映射不会更新旧的映射</p>
</blockquote>
<h2 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h2><blockquote>
<p>网际控制报文协议</p>
<p>运行在运输层协议，服务于IP协议</p>
<p><strong>实现链路连通性测试和链路追踪，实现链路差错报告</strong></p>
</blockquote>
<p>协议字段组成</p>
<blockquote>
<p>类型值/代码值 8|0请求 0|0回复 区分数据包类型</p>
<p>校验和 数据完整性校验</p>
<p>标识符 用于标志不同的ping进程</p>
<p>序列号 表示在此进程下的第几个包</p>
</blockquote>
<h3 id="ICMP协议应用"><a href="#ICMP协议应用" class="headerlink" title="ICMP协议应用"></a>ICMP协议应用</h3><h4 id="Ping命令"><a href="#Ping命令" class="headerlink" title="Ping命令"></a>Ping命令</h4><blockquote>
<p>探测目的主机是否有问题，探测本地到目的主机的延迟</p>
<p>基于ICMP协议的请求和回复来实现</p>
<p>echo request 回显请求</p>
<p>echo imply 回显应答</p>
</blockquote>
<p>DDOS攻击</p>
<blockquote>
<p> Distribute deny of service / <strong>分布式拒绝服务式攻击</strong></p>
<p> 发送海量报文，占用服务器资源，使其无法提供服务</p>
<p> DDOS攻击工具</p>
<ul>
<li><p>LOIC 图形化</p>
</li>
<li><p>Hping3</p>
</li>
</ul>
</blockquote>
<h4 id="Trace-route-tracert"><a href="#Trace-route-tracert" class="headerlink" title="Trace route/tracert"></a>Trace route/tracert</h4><blockquote>
<p><strong>利用TTL超时来实现链路追踪，”网络踩点”</strong></p>
<p>TTL值从1开始递增设置，直至到达目的地</p>
<p>通过为请求包设置特殊的TTL值，使得每经过相应路由，因生命期结束各路由将回复包含IP地址信息的超时回应报文</p>
<blockquote>
<p>超时回应报文与端口不可达报文格式</p>
<p>ICMP回应报文嵌套请求报文，用于通知发送发哪个请求报文出现了问题</p>
</blockquote>
<p><strong>同一条ICMP请求包将发送三次</strong></p>
</blockquote>
<p>Windows 链路追踪的实现原理</p>
<blockquote>
<p>请求包封装ICMP请求报文(终点回复ICMP应答报文)</p>
</blockquote>
<p>Lniux/Unix 链路追踪的实现原理</p>
<blockquote>
<p>请求包封装高端口的UDP包(终点将回复端口不可达报文)</p>
</blockquote>
<h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><blockquote>
<p>运输层使用<strong>16bit</strong>的端口号来标志一个端口，仅具有本地意义</p>
</blockquote>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li><p>服务器使用的端口号</p>
<ul>
<li><p>熟知端口号</p>
<blockquote>
<p>系统端口号，最重要应用程序端口号</p>
</blockquote>
</li>
<li><p>登记端口号</p>
<blockquote>
<p>对应于重要应用程序的其他应用程序的端口号</p>
</blockquote>
</li>
</ul>
</li>
<li><p>客户端使用的端口号</p>
<ul>
<li><p>短暂端口号</p>
<blockquote>
<p>动态选择的客户端应用进程端口号，通信结束，端口号不再存在</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><blockquote>
<p>用户数据报协议，实现面向无连接不可靠的传输层协议</p>
<p>以UDP用户数据报为运输层协议数据单元</p>
<p>一次交付一个完整报文</p>
</blockquote>
<p>字段组成 8byte</p>
<blockquote>
<p>源端口 2byte</p>
<p>目标端口  2byte</p>
<p>长度  2byte</p>
<p>校验和(检查不止首部的全部数据报的完整性)  2byte</p>
</blockquote>
<p>特征</p>
<blockquote>
<p>数据报结构整洁</p>
<p>速度快</p>
<p>实时交互(视频流，实时交互，社交)</p>
</blockquote>
<p>基于UDP开发的协议</p>
<blockquote>
<p>DHCP,DNS,OICQ,TFTP</p>
</blockquote>
<h2 id="DNS协议"><a href="#DNS协议" class="headerlink" title="DNS协议"></a>DNS协议</h2><blockquote>
<p>域名解析协议 port: 53</p>
</blockquote>
<p>原理</p>
<blockquote>
<p>请求主机 -&gt; DNS域名请求 -&gt; DNS服务器 — Query 域名 -&gt; IP</p>
<blockquote>
<p>google: 8.8.8.8 / 8.8.4.4</p>
<p>114.114.114.114</p>
<p>阿里巴巴: 223.5.5.5</p>
</blockquote>
<p>DNS服务器 -&gt; DNS回复 -&gt; 请求主机 — Answers IP</p>
</blockquote>
<h2 id="DHCP-协议"><a href="#DHCP-协议" class="headerlink" title="DHCP 协议"></a>DHCP 协议</h2><blockquote>
<p>动态主机配置协议，用于实现对终端设备的动态IP信息分配</p>
<p><strong>先到先得，请求主机使用先到的IP地址作为其IP地址</strong></p>
<p>通过bootp(启动协议)抓包</p>
</blockquote>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul>
<li><p>DHCP Client -&gt; DHCP Server</p>
<blockquote>
<p>DHCP Discover包，广播探测寻找局域网的DHCP Server</p>
</blockquote>
</li>
<li><p>DHCP Client &lt;- DHCP Server</p>
<blockquote>
<p>DHCP Offer包，用于预回复客户端，告知其即将给的IP地址</p>
</blockquote>
</li>
<li><p>DHCP Client -&gt; DHCP Server</p>
<blockquote>
<p>DHCP Request包，请求IP地址</p>
</blockquote>
</li>
<li><p>DHCP Client &lt;- DHCP Server</p>
<blockquote>
<p>DHCP ACK包，对客户端进行最终的正式确认(将预分配的IP地址移除<strong>本地地址池</strong>)</p>
</blockquote>
</li>
</ul>
<h3 id="协议字段"><a href="#协议字段" class="headerlink" title="协议字段"></a>协议字段</h3><ul>
<li><p>DHCP Discover</p>
<blockquote>
<p><img src="/images/Network/image-20210617215444395.png" alt="image-20210617215444395"></p>
<p>请求IP的主机使用0.0.0.0作为源IP，表示不知道/无</p>
</blockquote>
</li>
<li><p>DHCP Offer</p>
<blockquote>
<p><img src="/images/Network/image-20210617215613641.png" alt="image-20210617215613641"></p>
</blockquote>
</li>
<li><p>DHCP Request</p>
<blockquote>
<p><img src="/images/Network/image-20210617215655420.png" alt="image-20210617215655420"></p>
<p>此时并未真正获得IP因此源IP仍为0.0.0.0</p>
<p>相较于Discover包多了Option: (50)选项字段，指定requested IP</p>
</blockquote>
</li>
<li><p>DHCP ACK</p>
<blockquote>
<p><img src="/images/Network/image-20210617215745589.png" alt="image-20210617215745589"></p>
</blockquote>
</li>
</ul>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><blockquote>
<p>为什么需要再次请求与确认？</p>
<ol>
<li>DHCP是基于UDP的不可靠协议，包在传输过程中可能存在丢失情况，若仅仅为discover-&gt;offer，导致已从DHCP池中已移除的地址未被主机使用，存在地址浪费问题</li>
<li>解决多Server环境下地址冲突问题，因DHCP池中信息不同步，导致已分配的IP被再次分配，导致地址冲突问题</li>
</ol>
</blockquote>
<p><code>注意:</code></p>
<ol start="2">
<li>DHCP交互过程中，服务端为67端口，客户端为68端口</li>
</ol>
<h3 id="不同系统下的差异"><a href="#不同系统下的差异" class="headerlink" title="不同系统下的差异"></a>不同系统下的差异</h3><h4 id="Linux-Unix"><a href="#Linux-Unix" class="headerlink" title="Linux/Unix"></a>Linux/Unix</h4><blockquote>
<p>DHCP的交互过程都是广播包形式来实现的，目的IP采用255.255.255.255</p>
<ul>
<li><p>保证客户端与服务器一定能收到数据包</p>
</li>
<li><p>多DHCP Server局域网下，DHCP池被所有Server共享，为了保持DHCP池同步更新，需要让其他Server知晓DHCP池中某个IP地址已被分配</p>
</li>
</ul>
<p>抗干扰/冲突能力强，不安全</p>
</blockquote>
<h4 id="Windows-Mac-os"><a href="#Windows-Mac-os" class="headerlink" title="Windows/Mac os"></a>Windows/Mac os</h4><blockquote>
<p>DHCP的交互过程仅 C -&gt; S 都是广播包形式来实现的，目的IP采用255.255.255.255</p>
<p>S -&gt; C 的包认定请求主机的IP就为预分配的IP，目的IP采用预分配的IP</p>
<p>抗干扰/冲突能力弱，安全</p>
</blockquote>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><blockquote>
<p>ipconfig /all 详细查看ip配置信息</p>
<p>ipconfig /release 释放IP地址</p>
<p>ipconfig /renew 重新分配IP地址</p>
</blockquote>
<h2 id="Soctet套接字"><a href="#Soctet套接字" class="headerlink" title="Soctet套接字"></a>Soctet套接字</h2><blockquote>
<p>套接字Socket = IP地址 + 端口号</p>
</blockquote>
<h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><blockquote>
<p>传输控制协议，是TCP/IP协议栈中算法最大，功能最复杂的协议</p>
<p>面向连接的可靠交付的提供<strong>全双工通信</strong>的运输层协议</p>
<p>以TCP报文<strong>段</strong>为运输层协议数据单元</p>
<p>面向字节流而非完整报文</p>
<p>被套接字唯一确定的点对点通信</p>
</blockquote>
<h3 id="TCP报文段首部"><a href="#TCP报文段首部" class="headerlink" title="TCP报文段首部"></a>TCP报文段首部</h3><blockquote>
<p><img src="/images/Network/image-20210619082431169.png" alt="image-20210619082431169"></p>
<ul>
<li><p>源目端口</p>
</li>
<li><p>序号</p>
</li>
</ul>
<blockquote>
<p>对TCP传送的每个字节都按序编号</p>
<p>序号字段标识本报文段发送的数据的第一个字节的序号</p>
</blockquote>
<ul>
<li><p>确认号</p>
<blockquote>
<p>期望收到对方下一个报文段的第一个数据字节的序号</p>
<p>收到确认号为N，则N之前的所有数据均以正确收到</p>
</blockquote>
</li>
<li><p>数据偏移 (以4byte为计量单位)</p>
<blockquote>
<p>数据起始对于报文段起始的偏移指明<strong>TCP报文段首部长度</strong></p>
</blockquote>
</li>
<li><p>保留</p>
<blockquote>
<p>保留供以后使用</p>
</blockquote>
</li>
</ul>
<p>6个控制位</p>
<ul>
<li><p>紧急URG</p>
<blockquote>
<p>表示具有高传送优先级</p>
</blockquote>
</li>
<li><p>确认ACK</p>
<blockquote>
<p>连接建立以后所有传送的报文必须将ACK置为1</p>
</blockquote>
</li>
<li><p>推送PSH</p>
<blockquote>
<p>考虑到缓存，发送方希望缓存即使未满接收方也能立即回复</p>
</blockquote>
</li>
<li><p>复位RST</p>
<blockquote>
<p>重置位，重新建立连接</p>
</blockquote>
</li>
<li><p>同步SYN</p>
<blockquote>
<p>连接建立时同步序号</p>
</blockquote>
</li>
<li><p>终止FIN</p>
<blockquote>
<p>释放连接</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>窗口</p>
<blockquote>
<p>指明现在允许对方发送的数据量</p>
<p>告知接收方自己的接受窗口大小以便其设置其发送窗口大小</p>
</blockquote>
</li>
<li><p>校验和</p>
<blockquote>
<p>校验首部与数据的完整性</p>
</blockquote>
</li>
<li><p>紧急指针</p>
<blockquote>
<p>指明紧急数据的字节数</p>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="停止等待协议-自动重传请求ARQ"><a href="#停止等待协议-自动重传请求ARQ" class="headerlink" title="停止等待协议  / 自动重传请求ARQ"></a>停止等待协议  / 自动重传请求ARQ</h3><blockquote>
<p><strong>每</strong>发送一个分组就停止发送，等待确认</p>
<p>收到确认后再发送下一个分组。</p>
<p>分组和确认需要进行编号</p>
</blockquote>
<p>发送方</p>
<blockquote>
<p>发送方<strong>每</strong>发送完一个分组就保留该分组的副本并设置一个超时计时器</p>
<p>指定时间内未收到确认，则重传副本</p>
<p>对于已收到确认信息的分组再次收到确认信息，直接丢弃</p>
</blockquote>
<p>接收方</p>
<ul>
<li><p>分组出现差错</p>
<blockquote>
<p>对出现差错的分组直接丢弃，正确分组回复确认</p>
</blockquote>
</li>
<li><p>确认丢失</p>
<blockquote>
<p>再次收到分组时丢弃分组并再次发送确认</p>
</blockquote>
</li>
<li><p>确认迟到</p>
<blockquote>
<p>再次收到分组时丢弃分组并再次发送确认</p>
</blockquote>
</li>
</ul>
<h3 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h3><blockquote>
<p>ARQ协议信道利用率低，因此采用流水线传输，一次传送多个分组</p>
<p>连续发送 + 累积确认</p>
<p>接收方无需对每一个分组进行确认，而只需对<strong>按序到达</strong>的最后一个分组发送确认</p>
</blockquote>
<h3 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h3><h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><blockquote>
<p>以单工A -&gt; B为例，实际为全双工通信</p>
</blockquote>
<p><strong>发送窗口</strong></p>
<p>组成</p>
<blockquote>
<p><img src="/images/Network/image-20210619101316606.png" alt="image-20210619101316606"></p>
<p>使用三个指针来指明发送窗口的状态</p>
<p>-p1: 已发送已确认的字节，需要从发送缓存中删除</p>
<p>p1: 后沿 </p>
<p>p2 - p1: 已发送未收到确认</p>
<p>p2: 最后发送的字节的位置</p>
<p>p3 - p2: 允许发送但未发送的字节  (可用窗口)</p>
<p>p3: 前沿</p>
<p>p2-: 不允许发送的数据</p>
</blockquote>
<p>原理</p>
<blockquote>
<ol>
<li>有序发送发送窗口内的字节，窗口外的不允许发送</li>
<li>根据接收到的确认将发送窗口后沿前移至确认字节(接收方期望收到的字节)处，并根据返回的窗口值设置发送窗口的大小</li>
<li>若收到的窗口值变小，则前沿后移</li>
<li>若在超时计时器时间内仍未收到确认信息，则重传对应字节</li>
<li>若发送窗口中的字节均已发送,即可用窗口为0，则停止发送，等待确认信息调整发送窗口后继续发发送</li>
</ol>
</blockquote>
<p><strong>接收窗口</strong></p>
<blockquote>
<p><img src="/images/Network/image-20210619102036666.png" alt="image-20210619102036666"></p>
<p>已发送且交付给主机的字节将从接受缓存中删除</p>
</blockquote>
<p>原理</p>
<blockquote>
<ol>
<li>接受窗口对于接受到的允许接受的数据先暂存到接受窗口中</li>
<li>若有序则将有序字节交付目的主机，接收窗口向后移动对应字节，将接受缓存中的对应字节删除，并向发送方发送下一字节位置的确认</li>
<li>若无序且在接收窗口之内则先将收到的数据暂存于接受窗口中，不发送确认，直到接收到缺漏的字节才发送有序字节对最后一个字节的确认</li>
<li>重复步骤1</li>
</ol>
</blockquote>
<p>SACK 选择确认机制</p>
<blockquote>
<p>对于收到的无序且在接收窗口之内字节块，可以将这些字节块的边界信息告知发送方使其不用再重传这些字节块，而只需重传中间缺失的字节块</p>
<p>· but</p>
<p>双方的TCP报文段需要增设SACK选项，用于指明边界</p>
</blockquote>
<p><code>注意:</code></p>
<ol>
<li>A与B的发送接受窗口大小不总是一样大，因为时间滞后性且发送窗口受拥塞情况的限制</li>
<li>TCP要求接收方必须具有累积确认(发送数据时捎带确认信息)或者捎带确认的机制</li>
</ol>
<p>经典重传机制</p>
<blockquote>
<p>正常</p>
<p>ACK(n+1) = Seq(n) + Len(n)</p>
<p>丢包</p>
<p>ACK(n+1) &lt; Seq(n) + Len(n)</p>
<p>​                ↓    ACK(n+1)为第一次丢包处的序号，从此丢包处起即使已传递的后续包仍需重传</p>
<p>Seq(n+1) = ACK(n+1)</p>
</blockquote>
<p>选择重传机制</p>
<p>超时重传机制</p>
<h4 id="重传时间的RTO的选择"><a href="#重传时间的RTO的选择" class="headerlink" title="重传时间的RTO的选择"></a>重传时间的RTO的选择</h4><blockquote>
<p>RTO过大，将导致网络空闲时间过大，使网络传输效率降低</p>
<p>RTO过小，将导致很多没有必要的重传，加重网络负荷</p>
<p>RTO需要略大于往返时间RTT</p>
</blockquote>
<p><strong>RTO的计算</strong></p>
<p>RFC6298标准</p>
<p>未发生重传时RTO计算</p>
<blockquote>
<p>RTO = RTTS + 4*RTTD</p>
</blockquote>
<p>RTTS</p>
<blockquote>
<p>加权平均往返时间</p>
<p>RTT因网络影响并不固定，因此RTO无法使用某一次的RTT来作定量计算</p>
<p>RTTS(初始) = RTT</p>
<p>RTTS = (1-a) * 旧RTTS + a * 本次RTT</p>
<p>a = 1 / 8</p>
</blockquote>
<p>RTTD</p>
<blockquote>
<p>RTT偏差的加权平均</p>
<p>RTTD(初始) = RTT / 2</p>
<p>RTTD = (1-b) * 旧RTTD + b * | 本次RTTS - 本次RTT |</p>
<p>b = 1 / 4</p>
</blockquote>
<p><strong>发生重传时的RTO计算</strong></p>
<blockquote>
<p>发生重传时若仍采用上述方法计算RTO，则因为发送方可能对收到的确认识别出现差错，导致无法识别该确认为重传的确认信息还是正常传输的延时确认信息，导致RTT的测量出现差错，进而导致RTO不准确导致新的问题</p>
<p>Karn算法</p>
<p>只要报文段重传，不采用RTT样本计算，此次重传不更新RTO</p>
<p>由于超时重传时间无法更新，滞后性导致新的问题，比如往后得传送RTT均大于RTO，此不是一直重传</p>
<p>Karn算法修正</p>
<p>RTTO = 旧RTTO * 2</p>
</blockquote>
<h3 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h3><blockquote>
<p>控制发送方的发送速率，使接收方能够稳定接受，否则发送方发送过快，接收方来不及接受，从而造成数据丢失</p>
</blockquote>
<p><strong>通过滑动窗口实现流量控制</strong></p>
<blockquote>
<p>接收方通过发送TCP报文段的首部窗口位告知发送方可接受的发送窗口大小从而使发送方调整自己的发送窗口</p>
</blockquote>
<p><strong>零窗口通知</strong></p>
<blockquote>
<p>当接收方无缓存接受数据时，发送的确定报文段rwnd=0时，发送方调整发送窗口为0不再发送数据</p>
<p>此时若没有机制处理，则双方持续等待(发送方等待rwnd!=0的确认调整发送窗口，接收方有缓存时等待发送方的数据)，导致死锁</p>
<p>-</p>
<ol>
<li><p>当发送方收到rwnd=0的确认信息后，启动<strong>持续计时器</strong>，该时间内未收到确认则发送<strong>大小为1字节</strong>的零窗口通知，并为该通知创建副本和超时重传计时器</p>
</li>
<li><p>接收方无论是否有缓存可接受都必须接受，若返回rwnd=0的确认报文段则持续1，否则打破死锁</p>
</li>
</ol>
</blockquote>
<h3 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h3><blockquote>
<p>对某一资源的需求大于其所能提供的，则会使得网络出现拥塞，导致网络吞吐量随传输轮次的增大而减小，最终导致网络吞吐量为0</p>
<p>发送方会维护一个cwnd拥塞窗口，该窗口随网络拥塞情况动态变化</p>
<p>ssthresh慢开始门限，当cwnd&lt;ssthresh时采用慢开始算法，cwnd&gt;ssthresh时采用拥塞避免算法，cwnd=ssthresh均可采用</p>
</blockquote>
<p><strong>拥塞控制算法</strong></p>
<ul>
<li><p>慢开始</p>
<blockquote>
<p>cwnd初始值设置为1</p>
<p>cwnd随传输轮次的增加一次而加倍增加，一般增加2倍</p>
<p>当cwnd值到达ssthresh慢开始门限时，开始执行拥塞避免算法</p>
<p>当发送超时重传时，认为网络出现拥塞，将ssthresh值为当前cwnd的一半，cwnd值重新设置为1</p>
</blockquote>
</li>
<li><p>拥塞避免</p>
<blockquote>
<p>cwnd随传输轮次的增大呈每次加一线性增长</p>
</blockquote>
</li>
<li><p>快重传</p>
<blockquote>
<p>为了避免部分报文段丢失使发送方认为出现拥塞实际没有出现从而导致网络传输效率下降</p>
<ul>
<li>接收方不再捎带确认，而是每次收到报文段都对已有序收到的报文段立即发送确认</li>
</ul>
<p>发送方连续收到3次对相同报文段的确认，则进行快恢复算法</p>
</blockquote>
</li>
<li><p>快恢复</p>
<blockquote>
<ul>
<li><p>当发送发连续收到3次对相同报文段的确认时，将ssthresh和cwnd均置为当前cwnd的一半并开始执行拥塞避免算法</p>
</li>
<li><p>当发送发连续收到3次对相同报文段的确认时，将ssthresh置为当前cwnd的一半，cwnd置为新 ssthresh + 3 并开始执行拥塞避免算法</p>
</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="TCP运输管理"><a href="#TCP运输管理" class="headerlink" title="TCP运输管理"></a>TCP运输管理</h3><p><strong>TCP连接建立</strong></p>
<blockquote>
<p><strong>三次握手</strong></p>
<p><img src="/images/Network/image-20210620073437492.png" alt="image-20210620073437492"></p>
<p><strong>三握手连接而非二次握手</strong></p>
<blockquote>
<p>当TCP连接请求报文因时间延误，发生超时重传并且连接请求延误报文于第一次连接释放时到达TCP服务器，导致TCP进入了连接建立状态，而TCP客户对此次TCP服务器发送的连接确认不予理睬，导致TCP服务器资源浪费</p>
</blockquote>
</blockquote>
<p><strong>数据传输</strong></p>
<p><strong>TCP释放连接</strong></p>
<blockquote>
<p><strong>四次挥手</strong></p>
<p><img src="/images/Network/image-20210620082437457.png" alt="image-20210620082437457"></p>
<p><strong>Time wait的必要性</strong></p>
<blockquote>
<p>若服务器最终确认报文发生超时重传，若无TCP客户无时间等待态，则提前关闭连接可能造成不对TCP服务器的最终确认报文响应，导致TCP服务器无法关闭连接</p>
</blockquote>
<p><strong>TCP客户故障处理</strong></p>
<blockquote>
<p>若建立连接以后TCP客户发生故障，则无法对TCP服务器作出响应</p>
<p>TCP服务器将设置一个<strong>保活计时器</strong>，每次收到TCP客户发送的数据时便更新并重启保活计时器</p>
<p>若规定时间内未收到响应，则<strong>每75s</strong>发送一个<strong>探测报文</strong>，<strong>连续10次</strong>未收到响应则认为TCP客户发生故障，断开连接</p>
</blockquote>
</blockquote>
<h3 id="基于TCP的协议"><a href="#基于TCP的协议" class="headerlink" title="基于TCP的协议"></a>基于TCP的协议</h3><blockquote>
<p>http 80</p>
<p>https 443</p>
<p>ftp 20/21</p>
<p>ssh 22</p>
<p>telnet 23</p>
<p>smtp/pop 25/100</p>
</blockquote>
<h2 id="Telnet协议"><a href="#Telnet协议" class="headerlink" title="Telnet协议"></a>Telnet协议</h2><blockquote>
<p>远程登录协议，用于对设备进行远程管理，基于明文，建议更安全的SSH</p>
<p>telnet 12.0.1.28</p>
<p>telnet route-server.ip.att.net</p>
</blockquote>
<p>多路复用</p>
<blockquote>
<p>发送方不同的应用进程可以使用同一个运输层协议传送数据</p>
<p>TCP通过端口号port / 套接字Socket 实现多路复用</p>
<p>源目IP + 源目Port + 协议号 = 五元组</p>
</blockquote>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 面向对象初级</title>
    <url>/2021/07/07/C++Primer/C++standard/</url>
    <content><![CDATA[<h1 id="C-面向对象上"><a href="#C-面向对象上" class="headerlink" title="C++ 面向对象上"></a>C++ 面向对象上</h1><p> 语言+标准库</p>
<h2 id="头文件与类的声明"><a href="#头文件与类的声明" class="headerlink" title="头文件与类的声明"></a>头文件与类的声明</h2><p>类的经典分类</p>
<ul>
<li>带指针成员的类</li>
<li>不带指针成员的类</li>
</ul>
<h3 id="头文件的防范式声明"><a href="#头文件的防范式声明" class="headerlink" title="头文件的防范式声明"></a>头文件的防范式声明</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __xxx__</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> __xxx__ abc</span></span><br><span class="line"><span class="comment">//执行</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">//执行</span></span><br></pre></td></tr></table></figure>

<h3 id="类要作提前引用声明"><a href="#类要作提前引用声明" class="headerlink" title="类要作提前引用声明"></a>类要作提前引用声明</h3><h3 id="使用参数初始化列表来规范化类的构造函数"><a href="#使用参数初始化列表来规范化类的构造函数" class="headerlink" title="使用参数初始化列表来规范化类的构造函数"></a>使用参数初始化列表来规范化类的构造函数</h3><h3 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h3><p>创建类对象时无需给定参数的构造函数</p>
<ul>
<li>无参构造函数</li>
<li>全部参数带默认值的构造函数<blockquote>
<p>不可以有两个默认构造函数</p>
</blockquote>
</li>
</ul>
<h3 id="私有构造函数"><a href="#私有构造函数" class="headerlink" title="私有构造函数"></a>私有构造函数</h3><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><h3 id="函数传参尽量采用址传递"><a href="#函数传参尽量采用址传递" class="headerlink" title="函数传参尽量采用址传递"></a>函数传参尽量采用址传递</h3><p>常量引用代替值传递</p>
<h3 id="函数返回值的传递也尽量址传递"><a href="#函数返回值的传递也尽量址传递" class="headerlink" title="函数返回值的传递也尽量址传递"></a>函数返回值的传递也尽量址传递</h3><p><code>注意:</code>若返回对象是在函数中创建的，不可将其引用传回，因为函数调用结束后，其生命周四结束，内存被释放，传回的引用指向的为垃圾数据</p>
<h3 id="Return-by-reference-语法"><a href="#Return-by-reference-语法" class="headerlink" title="Return by reference 语法"></a>Return by reference 语法</h3><blockquote>
<p>传递着无需无需知道接收者是以reference形式接受的，即接收者以对应引用接收时，传递者可使用相应类型传递值</p>
</blockquote>
<h2 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h2><h3 id="相同class的各个对象互为friends"><a href="#相同class的各个对象互为friends" class="headerlink" title="相同class的各个对象互为friends"></a>相同class的各个对象互为friends</h3><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><ul>
<li><p>作成员函数</p>
<blockquote>
<p>任何成员函数会有一个隐藏参数this指针指向(函数调用者)即该运算符的左操作数，不能在参数处显示声明，但是可以在函数体中使用</p>
</blockquote>
</li>
<li><p>非成员函数</p>
</li>
<li><p><code>思考:</code>重载运算符函数已经将运算结果保存到了对应参数中，为什么还要有返回值呢？？？</p>
<blockquote>
<p>因为运算符有连续操作，void完全ok，但是如果出现连=,+,-等操作呢？？所以，还需要有返回值存储当前运算结果</p>
</blockquote>
</li>
</ul>
<h2 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Typename</span>()</span><br></pre></td></tr></table></figure>

<h2 id="带指针成员的类"><a href="#带指针成员的类" class="headerlink" title="带指针成员的类"></a>带指针成员的类</h2><h3 id="Big-Three"><a href="#Big-Three" class="headerlink" title="Big Three"></a>Big Three</h3><p>带指针成员的类不得不写Big Three，默认的函数无法满足需求且会引发问题</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">String</span>(<span class="keyword">const</span> <span class="keyword">char</span>* el=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(el) &#123;</span><br><span class="line">            elem = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(el)+<span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(elem,el);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            elem = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">            *elem = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">String</span>(<span class="keyword">const</span> String&amp; s) &#123; </span><br><span class="line">        <span class="comment">//深拷贝</span></span><br><span class="line">        elem = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(s.elem)+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(<span class="keyword">this</span>.elem,s.elem);</span><br><span class="line">    &#125;</span><br><span class="line">    String&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> String&amp; s) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;s) &#123;</span><br><span class="line">            <span class="comment">//判断是否为同一对象</span></span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> []elem;</span><br><span class="line">        elem = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(s.elem)+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(<span class="keyword">this</span>.elem,s.elem);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">String</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] elem;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* elem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>拷贝构造函数</li>
</ul>
<blockquote>
<p>从零开始创建一个与给定对象相同的对象</p>
<p>浅拷贝</p>
<ul>
<li>仅仅为成员指针的拷贝，这样导致被创建的对象的指针成员指向的内存泄漏，且一个内存被两个指针指向，操作相互受影响</li>
</ul>
<p>深拷贝</p>
<ul>
<li>为指针指向内存的内容的拷贝</li>
</ul>
<p>以字符串为例</p>
</blockquote>
<ul>
<li><p>拷贝赋值函数 对=赋值运算符的重载</p>
<blockquote>
<p>将已存在的对象赋值为另一个对象</p>
<p>以A=B的赋值过程为例：</p>
<ol>
<li><p>将A指针指向的内存清除</p>
</li>
<li><p>A中重新创建一个与B中待拷贝内存大小相同的内存</p>
</li>
<li><p>逐个将B中内存内容拷贝至A中</p>
</li>
</ol>
<p>一般拷贝赋值函数考虑自我赋值，不作任何操作，返回本身即可</p>
</blockquote>
</li>
<li><p>析构函数</p>
</li>
</ul>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><ul>
<li><p>生命周期</p>
<blockquote>
<ul>
<li>stack对象</li>
</ul>
<p>离开栈的作用域，对象的生命周期就结束，系统自动清理对象内存</p>
<ul>
<li>static对象</li>
</ul>
<p>static对象生命在作用域结束之后仍然存在，直到程序结束</p>
<ul>
<li>全局对象</li>
</ul>
<p>直到程序结束</p>
</blockquote>
</li>
</ul>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><ul>
<li><p>生命周期</p>
<blockquote>
<ul>
<li>heap堆对象 指针指向的内存对象</li>
</ul>
<p>当delete语句删除内存对象时，该内存对象生命期结束</p>
</blockquote>
</li>
<li><p>内存泄漏</p>
<blockquote>
<p>当动态创建对象后不存在delete语句释放动态创建的内存时，一旦超出指针作用域，指针失效后，内存空间便无法使用，却没有删除，造成内存泄漏</p>
</blockquote>
</li>
</ul>
<h2 id="堆与栈的区别"><a href="#堆与栈的区别" class="headerlink" title="堆与栈的区别"></a>堆与栈的区别</h2><ul>
<li><blockquote>
<p>栈内存由系统以函数为单位自动分配与释放，局部变量，函数参数均存于栈中</p>
<p>堆由人为动态创建与释放，c语言使用malloc/free函数,c++使用new/delete运算符</p>
<p>由于堆空间需要人为管理，容易造成内存泄漏</p>
</blockquote>
</li>
<li><blockquote>
<p>栈内存的分配释放速度快，效率高，内存连续</p>
<p>堆内存的分配释放速度效率较低，内存不一定连续</p>
</blockquote>
</li>
</ul>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><ul>
<li><p>new运算符</p>
<blockquote>
<p>先分配内存后调用构造函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">obj *p=<span class="keyword">new</span> <span class="built_in">obj</span>(); <span class="comment">//实现过程</span></span><br><span class="line"><span class="keyword">void</span>* mem=<span class="keyword">operator</span> <span class="built_in"><span class="keyword">new</span></span>(<span class="built_in"><span class="keyword">sizeof</span></span>(obj)) <span class="comment">//内部调用malloc(n)分配内存</span></span><br><span class="line">p=<span class="keyword">static_cast</span>&lt;obj*&gt;(mem) <span class="comment">//指针类型的转型</span></span><br><span class="line">p-&gt;obj::<span class="built_in">obj</span>(); <span class="comment">//调用obj对象的构造函数初始化</span></span><br></pre></td></tr></table></figure>

</blockquote>
</li>
<li><p>delete运算符</p>
<blockquote>
<p>先调用析构函数再释放内存</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> p; <span class="comment">//实现过程</span></span><br><span class="line">obj::~<span class="built_in">obj</span>(p) <span class="comment">//先调用obj对象的析构函数</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(p)</span> <span class="comment">//内部调用free(n)释放内存</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>先调用析构函数原因</li>
</ul>
<p>delete删除动态创建的带有指针的类对象时，只会删除为该对象分配的内存空间，即为指针分配的4字节内存空间，但是指针指向的内存空间并没有被删除，但是指针已被删除，这样再次导致内存泄漏问题</p>
</blockquote>
</li>
</ul>
<h3 id="内存分配状态-vc为例"><a href="#内存分配状态-vc为例" class="headerlink" title="内存分配状态  vc为例"></a>内存分配状态  vc为例</h3><ul>
<li><p>new Object </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">obj *p=<span class="keyword">new</span> <span class="built_in">obj</span>();</span><br><span class="line"><span class="keyword">delete</span> p;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>debug模式内存分配</p>
<blockquote>
<p>cookie头    记录分配的内存空间长度 4+4</p>
<p>debug头部    32+4</p>
<p>对象</p>
<p>填充字节部分    -vc的内存需要为16的倍数，不满足取与实际内存最接近的适合大小</p>
</blockquote>
<p>-</p>
<p>非debug模式的内存分配</p>
<blockquote>
<p> cookie头    记录分配的内存空间长度 4+4</p>
<p>对象</p>
<p>填充字节部分    -vc的内存需要为16的倍数，不满足取与实际内存最接近的适合大小</p>
</blockquote>
</blockquote>
</li>
<li><p>new Arrays</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">obj *p=<span class="keyword">new</span> obj[size];</span><br><span class="line"><span class="keyword">delete</span>[] p;	<span class="comment">//[]用于指明为arrays内存模式，不会仅调用一次析构函数</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>debug模式内存分配</p>
<blockquote>
<p>相较于object下的内存，多分配了4byte的数组长度位</p>
</blockquote>
<p>-</p>
<p>非debug模式的内存分配</p>
<blockquote>
<p>相较于object下的内存，多分配了4byte的数组长度位</p>
</blockquote>
</blockquote>
</li>
</ul>
<p><code>注意:</code>Arrays内存分配下，delete时务必添加[]</p>
<p><code>原因:</code>要将Arrays下的内存全部清理，需要执行size次类对象的析构函数清理各个对象元素的内存，而缺省[]的情况下，编译器将只执行一次首元素的析构函数，虽然arrays的内存空间被清理，但是其余对象元素的空间未被清理，导致内存泄漏</p>
<h2 id="Static"><a href="#Static" class="headerlink" title="Static"></a>Static</h2><ul>
<li><p>普通成员变量</p>
<blockquote>
<p>内存的分配跟随对象的创建，从属于某一特定对象，相互独立</p>
</blockquote>
</li>
<li><p>普通成员函数</p>
<blockquote>
<p>成员函数的内存单独占一份，有隐藏this指针，不同对象调用时可识别并操作特定对象的数据成员</p>
</blockquote>
</li>
<li><p>静态成员变量</p>
<blockquote>
<p>该成员变量的内存单独占一份，且被所有对象所共享，且类被声明即已存在</p>
</blockquote>
</li>
<li><p>静态成员函数</p>
<blockquote>
<p>该成员函数仍单独占一份内存，但是特殊在于无隐藏this指针参数，只能对静态数据成员进行操作</p>
</blockquote>
</li>
<li><p>静态局部变量</p>
<blockquote>
<p>该局部变量即使跳出局部作用域，其内存生命仍存在，但是局部作用域外无法访问</p>
</blockquote>
</li>
</ul>
<p>设计模式的应用</p>
<ul>
<li><p>单例模式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//暂略</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="名称空间"><a href="#名称空间" class="headerlink" title="名称空间"></a>名称空间</h2><p>防止名称冲突</p>
<ul>
<li><p>using namespace name</p>
<blockquote>
<p>“将封装的命名空间全部打开，<strong>直接</strong>使用该命名空间中的成员”</p>
</blockquote>
</li>
<li><p> using name::member</p>
</li>
</ul>
<blockquote>
<p>“将封装的命名空间部分打开，可直接使用已打开的命名空间中的成员”</p>
</blockquote>
<ul>
<li> 直接使用命名空间全名加::引用命名空间中的成员</li>
</ul>
<h2 id="OOP-AND-OOD"><a href="#OOP-AND-OOD" class="headerlink" title="OOP AND OOD"></a>OOP AND OOD</h2><h3 id="Composition-复合"><a href="#Composition-复合" class="headerlink" title="Composition 复合"></a>Composition 复合</h3><blockquote>
<p>has-a 一个对象成员直接包含另一类型的对象</p>
</blockquote>
<ul>
<li><p>黑盒复用角度解释</p>
<blockquote>
<p>外部对象可以调用内部对象的方法来实现某些功能</p>
<p>Adaptor 适配器设计模式</p>
</blockquote>
</li>
<li><p>内存角度解释</p>
<blockquote>
<p>外部对象的内存为外部对象额外成员与内部对象成员之和</p>
</blockquote>
</li>
</ul>
<h3 id="符号表示"><a href="#符号表示" class="headerlink" title="符号表示"></a>符号表示</h3><p>实心菱形+箭头 箭头所指的为被组合的对象</p>
<h3 id="组合中的构造与析构"><a href="#组合中的构造与析构" class="headerlink" title="组合中的构造与析构"></a>组合中的构造与析构</h3><ul>
<li><p>构造函数</p>
<blockquote>
<p>由内向外逐步构造，先调用内部对象的默认构造函数</p>
</blockquote>
</li>
<li><p>析构函数</p>
<blockquote>
<p>由外向内逐步析构，先调用外部对象的析构函数</p>
</blockquote>
</li>
</ul>
<h2 id="Delegation-委托"><a href="#Delegation-委托" class="headerlink" title="Delegation 委托"></a>Delegation 委托</h2><p>Composition by reference</p>
<blockquote>
<p>一个对象含有一个指向另一类型对象的指针成员</p>
<p>Handle/Body(pImpl)</p>
</blockquote>
<h3 id="符号表示-1"><a href="#符号表示-1" class="headerlink" title="符号表示"></a>符号表示</h3><p>空心菱形+箭头 箭头所指的为被组合的对象</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>在使用时动态创建复用对象，无需定义外层对象时便创建</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><blockquote>
<p>is-a 继承父类的部分数据成员与成员函数的调用权</p>
</blockquote>
<h3 id="符号表示-2"><a href="#符号表示-2" class="headerlink" title="符号表示"></a>符号表示</h3><p>空心三角+直线 空心三角所指的为被继承的对象</p>
<h3 id="继承中的构造与析构"><a href="#继承中的构造与析构" class="headerlink" title="继承中的构造与析构"></a>继承中的构造与析构</h3><ul>
<li><p>构造函数</p>
<blockquote>
<p>由内向外逐步构造，先调用父类的默认构造函数</p>
</blockquote>
</li>
<li><p>析构函数</p>
<blockquote>
<p>由外向内逐步析构，先调用子类的析构函数</p>
</blockquote>
</li>
</ul>
<h3 id="继承与虚函数"><a href="#继承与虚函数" class="headerlink" title="继承与虚函数"></a>继承与虚函数</h3><ul>
<li><p>纯虚函数</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>无函数体，函数必须被子类override重写</p>
</blockquote>
</li>
<li><p>虚函数</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span> </span>&#123;&#125;```</span><br></pre></td></tr></table></figure>

<p>有函数体可为空，即存在默认函数体，子类可重写也可不重写</p>
</blockquote>
<p>Template method 模板方法设计模式</p>
<blockquote>
<p>父类方法中延时调用子类重写的虚函数</p>
</blockquote>
<h3 id="继承-复用"><a href="#继承-复用" class="headerlink" title="继承+复用"></a>继承+复用</h3><h3 id="继承-委托"><a href="#继承-委托" class="headerlink" title="继承+委托"></a>继承+委托</h3><p>Observer观察者设计模式</p>
</li>
</ul>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><blockquote>
<ol>
<li>应用场景</li>
<li>继承，组合，委托</li>
<li>类图</li>
</ol>
</blockquote>
<p>单例</p>
<p>adaptor适配器</p>
<p>Handle/Body(pImpl)</p>
<p>observer</p>
<p>Composite</p>
<blockquote>
<p>文件系统</p>
</blockquote>
<p>Prptotype</p>
<blockquote>
<p>暂略</p>
</blockquote>
]]></content>
      <categories>
        <category>C++Primer</category>
      </categories>
      <tags>
        <tag>C++Primer</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 面向对象进阶</title>
    <url>/2021/07/07/C++Primer/Object/</url>
    <content><![CDATA[<h1 id="C-面向对象兼对象模型"><a href="#C-面向对象兼对象模型" class="headerlink" title="C++ 面向对象兼对象模型"></a>C++ 面向对象兼对象模型</h1><h2 id="conversion-function-转换函数"><a href="#conversion-function-转换函数" class="headerlink" title="conversion function 转换函数"></a>conversion function 转换函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Type one；</span><br><span class="line"><span class="keyword">double</span> two；</span><br><span class="line">Type Three = one + two; <span class="comment">//先检测对+运算符的重载,然后检测能否类型转换,注意二义性</span></span><br><span class="line"><span class="keyword">double</span> four = one + two; <span class="comment">//先检测对+运算符的重载,然后检测能否类型转换,注意二义性</span></span><br></pre></td></tr></table></figure>

<ul>
<li>类类型转换为其他类型</li>
</ul>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">conType</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> value-conversion&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>只要认为合适，一个类中可以有多个转换函数sad</p>
<p>执行运算时，编译器会首先查找是否有运算符重载函数，没有之后再去调用转换函数</p>
<p>有返回值但是<strong>不需要显式</strong>写出返回值类型</p>
</blockquote>
<ul>
<li><p>其他类型转换为类类型</p>
<blockquote>
<p>no-explict-one-argument</p>
<p>设置只需一个实参的带默认参数的构造函数</p>
</blockquote>
</li>
<li><p>二义性</p>
<blockquote>
<p>导致原因</p>
<blockquote>
<ol>
<li>存在对类类型对运算符的重载</li>
<li>存在类类型对其他类型的转换函数</li>
<li>存在其他类型转换为类类型的one-argument构造函数</li>
</ol>
</blockquote>
<p>解决</p>
<p>explict-one-argument</p>
<blockquote>
<p>将构造函数前加explict关键字，指明该构造函数不可用于类型转换，只可用于实例化对象</p>
</blockquote>
</blockquote>
</li>
</ul>
<h2 id="point-like-classes"><a href="#point-like-classes" class="headerlink" title="point-like classes"></a>point-like classes</h2><blockquote>
<p>包含指针成员</p>
<p>作用在指针上的运算符的重载</p>
</blockquote>
<h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><blockquote>
<p>shared_ptr</p>
<p>封装一个普通指针并添加额外操作</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.h</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shared_ptr</span> &#123;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>(T* px):<span class="built_in">p</span>(px)&#123;&#125;</span><br><span class="line">    <span class="function">T&amp; <span class="keyword">operator</span>* <span class="title">const</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *p;</span><br><span class="line">    &#125; </span><br><span class="line">    T* <span class="keyword">operator</span>-&gt; <span class="built_in"><span class="keyword">const</span></span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* p;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//.cpp</span></span><br><span class="line"> <span class="comment">//X结构体的定义省略</span></span><br><span class="line">...X</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function">shared_ptr&lt;X&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> X)</span></span>;</span><br><span class="line">    <span class="comment">// *sp 相当于*p  p为指向动态创建的指向X类型的指针</span></span><br><span class="line">    <span class="comment">// sp-&gt;function_fromX()  sp-&gt;相当于p-&gt; ---由于-&gt;的特性 sp-&gt;得到p的运算结果后仍保留</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><blockquote>
<p>需要指向容器中的某个元素</p>
</blockquote>
<h4 id="指向链表的迭代器"><a href="#指向链表的迭代器" class="headerlink" title="指向链表的迭代器"></a>指向链表的迭代器</h4><blockquote>
<p>用户角度需要以迭代器获得指定数据</p>
<p>存储角度该链表迭代器类中存的为指向结点的指针</p>
<p>因此需要作各种运算符重载来通过封装好的迭代器指针来直接获取指定数据</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">//以两个运算符重载为例</span></span><br><span class="line"><span class="function">T&amp; <span class="keyword">operator</span>* <span class="title">const</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (*node).data; <span class="comment">//node为指向链表结点的指针</span></span><br><span class="line">&#125;</span><br><span class="line">T* <span class="keyword">operator</span>-&gt; <span class="built_in"><span class="keyword">const</span></span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); <span class="comment">//取所需数据的地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="function-like-classes"><a href="#function-like-classes" class="headerlink" title="function-like classes"></a>function-like classes</h2><blockquote>
<p>Functor,仿函数</p>
<p>一种特殊的类</p>
<ul>
<li>含有对()运算符的重载</li>
<li>继承特殊的标准库中的模板类</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//仿函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">pair</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">First</span> :</span> <span class="keyword">public</span> unary_function&lt;Pair,<span class="keyword">typename</span> Pair::first&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">typename</span> Pair::first&amp; <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> Pair&amp; x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Pair::first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    Pair x;</span><br><span class="line">    <span class="function">First <span class="title">first</span><span class="params">(x)</span><span class="params">()</span></span>;	<span class="comment">//第一个()为创建first类型的函数对象,第二个为调用成员函数(执行函数调用操作符)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h2><h2 id="泛型模板"><a href="#泛型模板" class="headerlink" title="泛型模板"></a>泛型模板</h2><ul>
<li><p>class template类模板</p>
<blockquote>
<p>创建时需要指定类型参数的类型</p>
</blockquote>
</li>
<li><p>function template函数模板</p>
<blockquote>
<p>编译时系统自动根据实参推断参数类型，常用于算法但是注意对应类型应该定义对运算符的重载函数     -实参推导</p>
</blockquote>
</li>
<li><p>member template成员模板</p>
<blockquote>
<p>一个函数模板作另一个类模板的成员</p>
<ul>
<li>多用于类模板构造函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pair</span> &#123;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Pair</span>():<span class="built_in">first</span>(<span class="built_in">T1</span>()),<span class="built_in">second</span>(<span class="built_in">T2</span>())&#123;&#125;	<span class="comment">//使用临时对象初始化</span></span><br><span class="line">    <span class="built_in">Pair</span>(<span class="keyword">const</span> T1&amp; a,<span class="keyword">const</span> T2&amp; b):<span class="built_in">first</span>(a),<span class="built_in">second</span>(b)&#123;&#125;	</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">U1</span>,<span class="keyword">class</span> <span class="title">U2</span>&gt;</span></span><br><span class="line">    <span class="built_in">Pair</span>(<span class="keyword">const</span> Pair&lt;U1,U2&gt;&amp; p):<span class="built_in">first</span>(p.first),<span class="built_in">second</span>(p.second)&#123;&#125;	<span class="comment">//上转型,U1类继承自T1类</span></span><br><span class="line">    </span><br><span class="line">    T1 first;</span><br><span class="line">    T2 second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ... <span class="comment">//fish,bird为鱼类，鸟类对象  lfish，lbird为草鱼，麻雀对象  省略类模板的定义</span></span><br><span class="line">    Pair&lt;lfish,lbird&gt; p1();</span><br><span class="line">    Pair&lt;fish,bird&gt; p(p1);</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 智能指针的应用</span><br><span class="line"></span><br><span class="line">  为实现多态性，即一般指针的上转型，智能指针也需要具有该性质</span><br><span class="line"></span><br><span class="line">### 模板特化</span><br><span class="line"></span><br><span class="line">在模板泛化的基础上对某一种类型进行具体处理</span><br><span class="line"></span><br><span class="line">- full specialization 全局特化</span><br><span class="line"></span><br><span class="line">  ``` c++</span><br><span class="line">  ...  忽略了泛型模板的声明，但是必须存在不能缺少，模板特化需要与泛型模板一同出现</span><br><span class="line">  <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;</span><span class="keyword">char</span>&gt; &#123;</span><br><span class="line">      <span class="function"><span class="keyword">char</span>&amp; <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">char</span> x)</span> <span class="keyword">const</span></span>&#123; <span class="keyword">return</span> x; &#125; </span><br><span class="line">  &#125;</span><br><span class="line">                                                                                      </span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      cout&lt;&lt;hash&lt;<span class="keyword">char</span>&gt;()(<span class="string">&#x27;a&#x27;</span>)&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<ul>
<li><p>partial specialization 偏(局部)特化</p>
<p>个数偏特化</p>
<blockquote>
<p>有多个模板参数，但是需要绑定某个或者某几个连续参数来作特殊处理</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="keyword">class</span> <span class="title">T2</span>,<span class="keyword">class</span> <span class="title">T3</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&#123;</span>&#125;</span><br><span class="line">                                                                                    </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T2</span>,<span class="keyword">class</span> <span class="title">T3</span>&gt;</span>   <span class="comment">//对哪个类型进行特化处理，就缺哪个模板类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;</span><span class="keyword">char</span>,T2,T3&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>范围偏特化</p>
<blockquote>
<p>对某种具有范围的类型如指针进行特写</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&#123;</span>&#125;</span><br><span class="line">                                                                               </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">U</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;</span>U*&gt; &#123;&#125; <span class="comment">//这样当类型为指针类型时，创建的对象为该类模板对应的类型  U可替换为T  这里的T与泛型的T没有关系</span></span><br><span class="line">                                                                                  </span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="模板模板参数"><a href="#模板模板参数" class="headerlink" title="模板模板参数"></a>模板模板参数</h3><blockquote>
<p>template template parameter</p>
<p>一个类模板做另一个类模板的模板参数</p>
<p>personal：外层类模板用来指定创建内层类模板的模板类型，内层类模板在外层类模板中被创建并使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,</span></span><br><span class="line"><span class="class">	<span class="title">template</span>&lt;</span><span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    A&lt;T&gt; inn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    B&lt;<span class="keyword">int</span>,A&gt; b;	<span class="comment">//A不可以为类模板的实例化对象，否则不叫模板模板参数，b对象中含有A&lt;int&gt;类型的成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++ 标准库"></a>C++ 标准库</h1><ul>
<li>迭代器 Iterators</li>
<li>容器 Containers</li>
<li>仿函数 Functors</li>
<li>算法 Algorithms</li>
</ul>
<h1 id="C-11"><a href="#C-11" class="headerlink" title="C++11"></a>C++11</h1><h2 id="可变模板参数"><a href="#可变模板参数" class="headerlink" title="可变模板参数"></a>可变模板参数</h2><blockquote>
<p>variadic templates</p>
<p>指定模板中的某个参数的个数可变,即指定包pack,…就是一个包</p>
<ul>
<li><p>模板参数包</p>
<blockquote>
<p>…用于template parameters</p>
<p><code>template &lt;class T,class... U&gt;</code></p>
</blockquote>
</li>
<li><p>函数参数类型包</p>
<blockquote>
<p>…用于function parameter types</p>
<p><code>T function (const T&amp; a,const U&amp;... b)</code></p>
</blockquote>
</li>
<li><p>函数参数包</p>
<blockquote>
<p>…用于function parameters</p>
<p><code>function(U...); </code></p>
</blockquote>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以函数模板中的可变参数为例</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="title">class</span>... <span class="title">U</span>&gt;</span>  <span class="comment">//模板类型声明处需要将可变参数用...指出</span></span><br><span class="line"><span class="function">T <span class="title">function</span> <span class="params">(<span class="keyword">const</span> T&amp; a,<span class="keyword">const</span> U&amp;... b)</span></span>&#123;  <span class="comment">//函数原型处需要在变量声明与变量名之间用...指出</span></span><br><span class="line">cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line"><span class="built_in">function</span>(b...);  <span class="comment">//使用参数时也需要在变量名之后用...指出  </span></span><br><span class="line"><span class="comment">//这里可变函数模板的使用方法为一个参数加包,第一个参数来逐个递归引用包中的各个参数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">()</span> </span>&#123;&#125;  <span class="comment">//此处无参function的重载为了上述递归无参数的情况</span></span><br></pre></td></tr></table></figure>

<p>可边参数大小</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>...(b);</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h2><blockquote>
<p>类型推断，根据变量值来推断变量的类型</p>
<p><code>注意:</code>必须在定义时初始化</p>
</blockquote>
<h2 id="ranged-base-for"><a href="#ranged-base-for" class="headerlink" title="ranged-base for"></a>ranged-base for</h2><blockquote>
<p>范围遍历</p>
<ul>
<li><p>用decl逐个只读遍历coll容器</p>
<blockquote>
<p>编译会将coll中的元素逐个copy到decl参加运算</p>
</blockquote>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//decl为基本类型</span></span><br><span class="line"><span class="keyword">for</span>(decl : coll) &#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>用decl逐个可读可写遍历coll容器</p>
<blockquote>
<p>编译会将coll中的元素的地址逐个copy到decl参加运算</p>
</blockquote>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//decl为引用类型</span></span><br><span class="line"><span class="keyword">for</span>(decl : coll) &#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="Reference-假象"><a href="#Reference-假象" class="headerlink" title="Reference 假象"></a>Reference 假象</h1><blockquote>
<p>Reference</p>
<ul>
<li><p>底部为一个常量指针，真正所占内存只有4byte</p>
</li>
<li><p>逻辑上为别名,且一旦指定object就不可更改，什么使用的时候什么都跟object一样</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span>&amp; r=a;</span><br><span class="line"><span class="comment">//sizeof(r)==sizeof(a) true</span></span><br><span class="line"><span class="comment">//&amp;r==&amp;a true</span></span><br><span class="line"><span class="comment">//假象！！！! 所有代码呈现的r均与a具有相同性质</span></span><br><span class="line"><span class="comment">//实际内部为常量指针 额外占内存空间且占4byte字节的内存</span></span><br></pre></td></tr></table></figure>
<p>常见用途</p>
<ul>
<li>作函数参数与返回类型</li>
</ul>
<p>指针与引用的区别</p>
<ol>
<li><p>指针是一个实体，而引用仅是个别名</p>
</li>
<li><p>引用使用时无需解引用(*)，指针需要解引用</p>
</li>
<li><p>引用只能在定义时被初始化一次，之后不可变；指针可变</p>
</li>
<li><p>引用没有 const，指针有 const，const 的指针不可变</p>
</li>
<li><p>引用不能为空，指针可以为空，所以引用更安全</p>
</li>
<li><p>“sizeof 引用”得到的是所指向的object的大小，而“sizeof 指针”得到的是指针本身（所指向的变量或对象的地址）的大小</p>
</li>
<li><p>指针和引用的自增（++）运算意义不一样</p>
<blockquote>
<p>指针的++操作，会使指针指向下一个对象</p>
<p>引用的++操作，会是object的值++</p>
</blockquote>
</li>
</ol>
<p>signature</p>
<blockquote>
<p>签名可作是否可进行函数重载的判断</p>
<p>函数类型 |函数名(函数参数) const| {}  ||括起部分为signature签名</p>
<ul>
<li>const</li>
</ul>
<blockquote>
<p>常成员函数可以被const对象或非const对象调用,const对象只会调用const函数而不去调用非const函数,</p>
<p>非const对象会优先调用非const成员函数</p>
</blockquote>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">image</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; im)</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">//1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">image</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> im)</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">//2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">image</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; im)</span><span class="params">()</span><span class="keyword">const</span></span>&#123;&#125; <span class="comment">//3</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">image</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> im)</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">//4</span></span><br><span class="line"><span class="comment">//12会导致2义性</span></span><br><span class="line"><span class="comment">//13作成员函数不会导致2义性</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="对象模型-Object-Model"><a href="#对象模型-Object-Model" class="headerlink" title="对象模型(Object Model)"></a>对象模型(Object Model)</h1><h1 id="虚函数与多态"><a href="#虚函数与多态" class="headerlink" title="虚函数与多态"></a>虚函数与多态</h1><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ul>
<li><p>静态多态</p>
<blockquote>
<p>通过函数重载在编译时指定同名函数执行的函数体，编译时的多态</p>
</blockquote>
</li>
<li><p>动态多态</p>
<blockquote>
<p>通过虚函数实现运行时的多态</p>
</blockquote>
</li>
</ul>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><blockquote>
<p>继承体系中，允许派生类重写与父类同名的函数，并在调用时通过指针或者引用来调用父类或者子类的同名函数</p>
</blockquote>
<p>继承体系中父类与子类重名</p>
<ul>
<li><p>父类声明为虚函数</p>
<blockquote>
<p>子类将override重写父类同名虚函数，子类仅含重写后的虚函数，而不包含父类的同名虚函数</p>
</blockquote>
</li>
<li><p>父类未声明为虚函数</p>
<blockquote>
<p>子类将override重写父类同名虚函数，且子类中将仍包含父类的同名函数，若要调用父类的被隐藏的同名函数可通过::调用</p>
</blockquote>
<p><code>注意:</code> 两者区别在于指针调用时，指向派生类对象的指针上转型为指向父类对象的指针，第二种情况将仍调用父类的同名函数</p>
<h2 id="虚机制"><a href="#虚机制" class="headerlink" title="虚机制"></a>虚机制</h2></li>
</ul>
<h2 id="vptr虚指针"><a href="#vptr虚指针" class="headerlink" title="vptr虚指针"></a>vptr虚指针</h2><blockquote>
<p>只要具有虚函数的类对象都会额外分配一个且仅一个4byte的内存给虚指针来关联各虚函数</p>
</blockquote>
<h2 id="vtbl虚表"><a href="#vtbl虚表" class="headerlink" title="vtbl虚表"></a>vtbl虚表</h2><blockquote>
<p>在编译时会为每一个具有至少一个虚函数的类绑定一个虚表</p>
<p>存放绑定类的包含的所有虚函数的函数指针</p>
</blockquote>
<h3 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h3><p>条件</p>
<ol>
<li><p>通过指针或者引用调用</p>
</li>
<li><p>上转型</p>
</li>
</ol>
<blockquote>
<p>引用绑定</p>
<p>指针指向</p>
</blockquote>
<ol start="3">
<li>调用虚函数</li>
</ol>
<p>处理</p>
<blockquote>
<p>触发虚机制</p>
<p>内部实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">father</span>&#123;</span></span><br><span class="line">    <span class="built_in">father</span>()&#123;</span><br><span class="line">        <span class="comment">//这里将隐含对vptr的赋值，使vptr指向vtbl</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">son</span>&#123;</span></span><br><span class="line">    <span class="built_in">son</span>()&#123;</span><br><span class="line">        <span class="comment">//这里将隐含对vptr的赋值，使vptr指向vtbl</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123; cout&lt;&lt;a&lt;&lt;endl; &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    son sn;</span><br><span class="line">    father* p = &amp;sn; <span class="comment">//上转型</span></span><br><span class="line">    father&amp; a= sn; <span class="comment">//上转型</span></span><br><span class="line">    p-&gt;<span class="built_in">function</span>(); <span class="comment">//属于多态</span></span><br><span class="line">    a.<span class="built_in">function</span>(); <span class="comment">//属于多态</span></span><br><span class="line">    sn.<span class="built_in">function</span>(); <span class="comment">//不属于多态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指针虚机制原理</span></span><br><span class="line">p-&gt;<span class="built_in">function</span>();</span><br><span class="line"><span class="comment">//(*(p-&gt;vptr)[n])(p)</span></span><br><span class="line"><span class="comment">//或(* p-&gt;vtbl[n])(p)```</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="静态绑定"><a href="#静态绑定" class="headerlink" title="静态绑定"></a>静态绑定</h3><ul>
<li>通过非引用对象调用对应类的方法</li>
<li>内部实现为call+函数地址</li>
</ul>
<h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><p>template method 设计模式</p>
<h1 id="Const"><a href="#Const" class="headerlink" title="Const"></a>Const</h1><ul>
<li>const常成员函数 添加const声明，不会对本类数据进行更改，且不能包含对非常成员函数的调用</li>
<li>non-const非常成员函数 无const声明，可能对本类数据进行更改，且可包含对常成员函数的调用</li>
<li>常对象 仅能调用本类的const常成员函数</li>
<li>非常对象 均可调用</li>
</ul>
<p>函数重载</p>
<blockquote>
<p>若一个类同名常成员函数与非常成员函数同时存在</p>
</blockquote>
<ul>
<li>const常对象仅能调用该类对应同名的const版本</li>
<li>非常对象仅能调用该类同名的非const版本</li>
</ul>
<h1 id="new，delete运算符"><a href="#new，delete运算符" class="headerlink" title="new，delete运算符"></a>new，delete运算符</h1><ul>
<li><p>new</p>
<blockquote>
<p>动态创建分三步 1.创建指定大小的内存空间 2.指针类型转型 3.调用对象构造函数</p>
</blockquote>
</li>
<li><p>delete</p>
<blockquote>
<p>删除分两步 1.调用对象的析构函数 2.删除指针指向的内存空间</p>
</blockquote>
</li>
</ul>
<h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><blockquote>
<p>将new的第一步操作与delete的第二步操作做特殊处理</p>
</blockquote>
<ul>
<li><p>对全局new，delete运算符的重载</p>
<blockquote>
<p>::operator new ::operator new[] ::operator delete ::operator delete[]</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size1)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">malloc</span>(size1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span> size2) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">malloc</span>(size2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>*p,<span class="keyword">size_t</span> size)</span> </span>&#123;	<span class="comment">//可以省略第二个参数</span></span><br><span class="line"> <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span>*p,<span class="keyword">size_t</span> size2) &#123;	<span class="comment">//可以省略第二个参数</span></span><br><span class="line"> <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>size1/size2详解</p>
<blockquote>
<p>size1大小对象的内存大小</p>
<p>size2 vc编译环境下</p>
<p>size2=arrays.length*sizeof(obj)+4</p>
<ul>
<li>需要添加4字节的cookie头，值为实际元素个数，指明构造函数与析构函数的执行次数，从上而下逐个构造，析构相反</li>
</ul>
</blockquote>
<p><code>注意:</code>对全局new，delete运算符重载需要慎重</p>
</blockquote>
</li>
<li><p>对类成员new，delete运算符的重载</p>
<blockquote>
<p>new,delete运算符重载函数，该重载范围仅影响对应类类型的对象</p>
</blockquote>
</li>
<li><p>对类成员new[],delete[]运算符的重载</p>
<blockquote>
<p>new[],delete[]运算符重载函数，该重载范围仅影响对应类类型的对象</p>
</blockquote>
</li>
<li><p>placement argument 对new,delete重载时有多个函数参数     多参重载</p>
<blockquote>
<p>对operator new的重载</p>
<p>第一个参数必须是size_t类型</p>
<p>其余位置参数的初始值指定方式为</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>*p = <span class="built_in"><span class="keyword">new</span></span>(argument)<span class="keyword">int</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">对<span class="keyword">operator</span> <span class="keyword">delete</span>的重载</span><br><span class="line"></span><br><span class="line">来清除创建失败的内存，仅在<span class="keyword">new</span>运算符执行抛出异常时才会执行这些operetor <span class="built_in"><span class="keyword">delete</span></span>(不同编译环境情况不同)</span><br><span class="line"></span><br><span class="line">一般<span class="keyword">delete</span>语句并不会调用placement <span class="keyword">delete</span>重载函数,而只会调用一般重载函数</span><br><span class="line"></span><br><span class="line">用来处理异常的，即使没有也编译通过，不再处理异常</span><br><span class="line"> </span><br><span class="line"> ```c++</span><br><span class="line"> <span class="keyword">inline</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="built_in"><span class="keyword">new</span></span>(<span class="keyword">size_t</span> size1,<span class="keyword">int</span> x) &#123;</span><br><span class="line"> <span class="comment">//...x</span></span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">malloc</span>(size1);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* p,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"> <span class="comment">//...x</span></span><br><span class="line"> <span class="built_in">free</span>(p);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> x;</span><br><span class="line">     obj* p=<span class="built_in"><span class="keyword">new</span></span> (x) obj;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<h2 id="new与malloc的区别"><a href="#new与malloc的区别" class="headerlink" title="new与malloc的区别"></a>new与malloc的区别</h2><ol>
<li>new是操作符，而malloc是函数</li>
<li>malloc开辟内存时需要指定大小并返回void*,需要将指针进行类型转换才能操作对象，new运算符开辟内存时需要指定类型并直接返回对应类型的指针</li>
<li>malloc和new都是在堆上开辟内存的，new在调用的时分配内存后，还会调用构造函数初始化，而malloc仅分配内存</li>
<li>new开辟内存失败抛出异常，malloc返回null</li>
<li>new运算符可以被重载</li>
<li>malloc可以分配任意字节，new 只能分配实例所占内存的整数倍数大小</li>
</ol>
]]></content>
      <categories>
        <category>C++Primer</category>
      </categories>
      <tags>
        <tag>C++Primer</tag>
      </tags>
  </entry>
  <entry>
    <title>Algorithm and DataStruture -Primary</title>
    <url>/2021/07/07/Algorithm_Structure/A_plus_D/</url>
    <content><![CDATA[<h1 id="Algorithm-and-DataStruture"><a href="#Algorithm-and-DataStruture" class="headerlink" title="Algorithm and DataStruture"></a>Algorithm and DataStruture</h1><hr>
<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><h2 id="Vector-and-ArrayList"><a href="#Vector-and-ArrayList" class="headerlink" title="Vector and ArrayList"></a>Vector and ArrayList</h2><h2 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h2><p>以定长数组来实现单链表</p>
<p>静态链表每个结点存放的”指针域”为游标即数组下标，以数组下标来指明下一结点地址</p>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>备用链表与数据链表的组合构成一个静态链表</p>
<p>备用链表:</p>
<ul>
<li>头结点:<br>a[0] </li>
<li>其余链表结点:<br>均只存放指向下一可利用空间的游标</li>
<li>尾元结点<br>置为0</li>
</ul>
<p>数据链表:</p>
<ul>
<li>头结点:<br>仅研究无头结点的 a[1]为第一个结点且存放数据</li>
<li>其余链表结点:<br>均只存放指向下一数据结点的游标</li>
<li>尾元结点<br>置为1</li>
</ul>
<p>尾元结点<br>非数组的最后一个元素，而是最后一个有实际值的结点，游标值为-1</p>
<p>结点结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct StaticLinkList &#123;</span><br><span class="line">	int data;</span><br><span class="line">	int next;</span><br><span class="line">&#125;StaticList[MAXSIZE];</span><br><span class="line">&#x2F;&#x2F; 使用StaticList定义等价为  struct StaticLinkList xx[MAXSIZE];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>用途<br>对于不支持指针的高级程序设计语言和数据元素长度固定不变</p>
<p>静态链表的优缺点：<br>优点：再插入和删除时候，只需要修改游标，不需要移动元素，从而改进了顺序存储结构中插入和删除操作需要移动大量元素的缺点。</p>
<p>缺点：没有解决连续存储分配带来的表长难以确定的问题；失去了顺序存储结构随机存取的特性。</p>
<p>有无可利用空间表实现方式有区别</p>
<h2 id="有序表的合并"><a href="#有序表的合并" class="headerlink" title="有序表的合并"></a>有序表的合并</h2><h2 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h2><h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><h2 id="拓展空间"><a href="#拓展空间" class="headerlink" title="拓展空间"></a>拓展空间</h2><h2 id="单链表逆置"><a href="#单链表逆置" class="headerlink" title="单链表逆置"></a>单链表逆置</h2><h2 id="判断单链表是否有环，如果有，求长度与入环点"><a href="#判断单链表是否有环，如果有，求长度与入环点" class="headerlink" title="判断单链表是否有环，如果有，求长度与入环点"></a>判断单链表是否有环，如果有，求长度与入环点</h2><hr>
<h1 id="散列表-哈希表"><a href="#散列表-哈希表" class="headerlink" title="散列表-哈希表"></a>散列表-哈希表</h1><p>引例1: 取N个0-100之间的数后，给定一个数n判断n是否在取得N个数中</p>
<p>采用<strong>数组下标</strong>0-100 来代表0-100的数 下标对应的元素值代表是否为所取的N个数之一 是为1否为0    利用数组下标来映射要查找的值</p>
<p>若n=5  则只需判断a[5]是否等于1即可判断5是否为所取的N个数之一<br>哈希函数构造方法:直接定址法</p>
<p>引入散列表的概念</p>
<p>引例2: 若N的取值范围过大，内存消耗太大上述方法不可取，采用函数取模运算，由N%size的余数值来指明存储位置，此时数组下标标明的元素处不能再存01而是存实际的N值，在搜索N值时通过余数下标找到对应值所在位置 若使用01无法判断该余数对应哪一个N值(冲突)</p>
<p>引入哈希函数的概念Hash(key)<br>哈希函数构造方法:除模取余法</p>
<p>引例3: 不同N值余数却相同，发生冲突</p>
<p>冲突解决方法</p>
<ol>
<li>开放定址(探测)<br>若出现冲突，重新探测一个空闲位置插入<br>优点:<br>随机访问 访问速度快<br>缺点:<br>不利于删除 删除某结点后 存在查询不到已存结点的情况  此时可设置delete标志来解决<br>扩容问题</li>
<li>链地址 hashmap<br> 头结点为相同余数结点 其余结点为余数相同的冲突结点<br> 优点:<br> 利于插入删除<br> 缺点:<br> 冲突数量过多导致查询效率下降</li>
<li>优化的链地址法 hashmap<br> 二叉查找树(退化为链表搜索效率低)-&gt;二叉平衡树(过严苛)-&gt;红黑树<br> 优点:<br> 利于插入删除且查找效率高<br> 缺点:<br> 无法存储大数据且线程不安全</li>
</ol>
<p>JDK1.8 在”一定情况”下采用红黑树代替链表</p>
<p>条件: 节点个数大于8且节点个数达到阈值</p>
<h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>作用: 计算key-value组成的Node对象在数组索引下标中的位置<br>考虑: 容易计算得到 方便查找 冲突要少</p>
<ul>
<li><p>通过hashcode()函数计算key值对应的整型哈希值hash</p>
<blockquote>
<p>hashcode()函数计算可以得到32bit的二进制数，但是返回值会转换为int类型10进制</p>
</blockquote>
</li>
<li><p>将该哈希值hash映射到对应数组索引下标位置</p>
<blockquote>
<p>一般会采用取模%运算，但是仅仅%运算冲突的概率大，在hashmap下利用率不高且链表过长，<br>因此在length为2的整数次幂的条件下，采用&amp;(length-1)来计算，此时可以仍然可得到0-length-1之间的数与%运算等效，但是仍有冲突问题，所以又将该hash值的高16位与低16位作异或运算，再作&amp;运算求下标映射，可以很大程度上使各hash最后几位不同进而减少冲突 —作异或运算因为低位相同但是高位不同也会导致哈希冲突</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;核心部分</span><br><span class="line">int hash(Object key) &#123;</span><br><span class="line">	int h&#x3D;key.hashCode();</span><br><span class="line">	return (h^(h&gt;&gt;&gt;16))&amp;(capicity-1); &#x2F;&#x2F;capicity表示散列表大小</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>采用&amp;运算原因:</p>
<ol>
<li>提高计算性能，二进制数进行运算</li>
<li>可对32bit的hash值进行处理，高16bit与低16bit进行异或运算，进而减少冲突</li>
</ol>
<p>&amp;(length-1)后可得到0-length-1之间的一个数值</p>
<p>一般哈希函数构造方法:</p>
<ol>
<li>直接定址法</li>
<li>除模取余法</li>
<li>随机数法</li>
<li>数字分析法</li>
<li>平方取中法</li>
<li>折叠法</li>
</ol>
<h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><h3 id="开放寻址"><a href="#开放寻址" class="headerlink" title="开放寻址"></a>开放寻址</h3><h3 id="链地址"><a href="#链地址" class="headerlink" title="链地址"></a>链地址</h3><h2 id="Hashmap"><a href="#Hashmap" class="headerlink" title="Hashmap"></a>Hashmap</h2><p>什么是hashmap:</p>
<ol>
<li>整体是一个数组</li>
<li>每个数组元素是一个链表or树</li>
<li>链表中的结点中的value存储值</li>
</ol>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始大小: </p>
<p>默认16<br>预估数据量大小 减少动态扩容次数 提高Hashmap性能<br><code>注意:</code>初始大小必须为2的整数次幂，若不是则系统自动转换为临近的满足条件的大小<br>原因： </p>
<ol>
<li>这样length-1的值才能高一位为0，其余低位均为1，使得&amp;运算是结果取决于hash值的低位</li>
</ol>
<p>负载因子: </p>
<p>默认0.75 </p>
<p>阈值: </p>
<p>初始大小×负载因子<br>默认12 </p>
<p>元素个数超过阈值(0.75*散列表初始大小) 启用动态扩容 扩大为原来的2倍<br>注意 这里元素个数不是散列表大小 而是已有的元素个数</p>
<h3 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h3><ol>
<li>通过hashcode方法计算key对象的hash值</li>
<li>使用该hash再通过哈希函数计算对应映射位置</li>
<li>判断当前元素个数是否大于等于阈值，若没有则继续，否则进行扩容</li>
<li>创建hash对应的key-value-next结点，判断映射位置处是否有其他结点插入，无则插入</li>
<li>已有其他结点插入</li>
</ol>
<ul>
<li>若是链表 按链表方式进行存储(遍历链表 判断是否key相同 相同将value替代 不同则继续遍历到尾结点插入)</li>
<li>若是红黑树 按红黑树的方式进行存储(则按照红黑树的规则遍历 key值相同替代 不同尾结点处插入)</li>
</ul>
<h3 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h3><p>hashmap采用懒扩容机制，仅在调用put方法时才会触发</p>
<ol>
<li>扩容后容量变为原来的2倍</li>
<li>实际上是创建一个新的容量为原来2倍的数组并且需要将原数组元素进行迁移</li>
<li>重新计算各元素的哈希值，因为哈希函数计算映射内存时候用到了size</li>
</ol>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ol>
<li>红黑树引入</li>
</ol>
<ul>
<li>链表长度到8,且数组长度到64</li>
</ul>
<ol start="2">
<li>初始化时候注意初始大小与负载因子的设置 减少动态扩容次数</li>
</ol>
<h3 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h3><p>synchronized </p>
<p>线程安全 对每一个操作上锁，同步约束，但是性能三者最差</p>
<p>与hashmap的区别；</p>
<ol>
<li>初始容量为11</li>
<li>key值与value值不能为null 因为其hash函数没有对null情况作处理</li>
<li>扩容后为2倍原容量+1<h3 id="ConcurrentHashmap"><a href="#ConcurrentHashmap" class="headerlink" title="ConcurrentHashmap"></a>ConcurrentHashmap</h3>分段锁</li>
</ol>
<h2 id="一致性哈希算法"><a href="#一致性哈希算法" class="headerlink" title="一致性哈希算法"></a>一致性哈希算法</h2><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="树的非递归遍历"><a href="#树的非递归遍历" class="headerlink" title="树的非递归遍历"></a>树的非递归遍历</h2><h2 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h2><h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><p>在某种遍历次序下可以找寻某结点在该遍历次序下的前驱后继结点</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现:"></a>实现:</h3><p>n个结点的二叉树有n+1空指针域，若某结点左指针域为空，则使该指针域指向其某种遍历次序下的直接前驱，右-&gt;直接后继 </p>
<h3 id="结点结构"><a href="#结点结构" class="headerlink" title="结点结构:"></a>结点结构:</h3><p>增设两个int型的标志域，ltag，rtag 若为0，指向孩子结点，若为1指向线索</p>
<h3 id="优化："><a href="#优化：" class="headerlink" title="优化："></a>优化：</h3><p>增设一头结点，该头结点左指针域指向原头结点，右指针域指向遍历次序的最后一个结点<br>解决遍历序列两端结点指针域悬浮问题，悬浮的指针域指向该头结点即可</p>
<h3 id="线索化："><a href="#线索化：" class="headerlink" title="线索化："></a>线索化：</h3><p>写出对应遍历序列，遍历所有结点，结点孩子为空指针则将该指针域线索化</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><p>略</p>
<h2 id="赫夫曼树"><a href="#赫夫曼树" class="headerlink" title="赫夫曼树"></a>赫夫曼树</h2><h2 id="B-树–B-树"><a href="#B-树–B-树" class="headerlink" title="B-树–B+树"></a>B-树–B+树</h2><p>数据库的底层结构为B+树</p>
<h3 id="引例"><a href="#引例" class="headerlink" title="引例:"></a>引例:</h3><ol>
<li>select user from User where id=100</li>
<li>select user from User where id&lt;100</li>
<li>select user from User where id&lt;100 and name=’李勇’</li>
</ol>
<h3 id="选择底层结构考虑因素"><a href="#选择底层结构考虑因素" class="headerlink" title="选择底层结构考虑因素"></a>选择底层结构考虑因素</h3><blockquote>
<p>数据量庞大，无法存储与内存中，只能存储于磁盘中，因此涉及磁盘读取问题，一次读取一页(磁盘1页可存16K数据)<br>既存在精确查找还存在范围查找，部分查找<br>每个结点需要能存放足够多的数据</p>
</blockquote>
<h3 id="数据库不使用红黑树做底层结构的原因"><a href="#数据库不使用红黑树做底层结构的原因" class="headerlink" title="数据库不使用红黑树做底层结构的原因"></a>数据库不使用红黑树做底层结构的原因</h3><blockquote>
<p>红黑树一个结点只能存放一个数据，然后读取磁盘一次读取一页16k的数据，磁盘IO时间消耗太大(读取次数多且一次读取浪费的空间也多)，且树过长</p>
</blockquote>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><blockquote>
<p>一个结点存多个数据<br>多叉树</p>
</blockquote>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h3><h4 id="M阶B-树的重要特性"><a href="#M阶B-树的重要特性" class="headerlink" title="M阶B-树的重要特性"></a>M阶B-树的重要特性</h4><blockquote>
<p>结点最多有m颗子树，m-1个关键字，m&gt;=2<br>除了根节点和叶子结点外，其余各结点至少有ceil(m/2)个结点，ceil为上取整<br>非叶子结点的根结点至少有两颗子树</p>
</blockquote>
<h4 id="M阶B-树的构建过程"><a href="#M阶B-树的构建过程" class="headerlink" title="M阶B-树的构建过程"></a>M阶B-树的构建过程</h4><ul>
<li><p>有序添加 </p>
<blockquote>
<p>添加关键字时保证树满足排序树性质</p>
<p>结点添加数据后结点中关键字有序</p>
<p>找叶子结点添加</p>
</blockquote>
</li>
<li><p>中间分裂 若M为偶数，取中间考前考后均可</p>
<blockquote>
<p>当根结点的关键字个数等于阶数时，从m/2关键字处分裂，该关键字单独构成一个结点，其两颗子树分别为其原始左边所有关键字组成的新结点与其原始右边所有关键字组成的新结点</p>
<p>当非根节点的关键字个数等于阶数时，中间分裂，分裂出的关键字有序添加在该结点的父节点中，该结点以该关键字为中心再次分裂为两个结点作分裂关键字的”左右子树”</p>
</blockquote>
</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><blockquote>
<p>结点存放索引+数据地址，数据地址占用大量空间<br>范围查找时，仍需遍历每个结点以获取数据，使得索引失效<br>操作复杂，查找每个结点均需要 磁盘中去取索引 -&gt;数据地址 -&gt;提取记录  稳定性不强</p>
</blockquote>
<h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h3><h4 id="M阶B-树的重要特性-1"><a href="#M阶B-树的重要特性-1" class="headerlink" title="M阶B+树的重要特性"></a>M阶B+树的重要特性</h4><blockquote>
<p>结点最多有m颗子树，m个索引，m&gt;=2<br>除了根节点和叶子结点外，其余各结点至少有ceil(m/2)个索引，ceil为上取整<br>非叶子结点的根结点至少有两颗子树<br>叶子结点的高度一致</p>
</blockquote>
<p><code>注意: 条件上与B-树的区别</code> </p>
<ol>
<li>B+树仅有叶子结点存储数据，其余结点均仅存索引</li>
<li>B+树叶子结点互连成一个双向链表</li>
<li>B+树的各结点最大索引数限制为m阶数</li>
</ol>
<h4 id="M阶B-树的构建过程-1"><a href="#M阶B-树的构建过程-1" class="headerlink" title="M阶B+树的构建过程"></a>M阶B+树的构建过程</h4><ul>
<li><p>有序添加</p>
<blockquote>
<p>添加关键字时保证树满足排序树性质</p>
<p>结点添加数据后结点中关键字有序</p>
<p>找叶子结点添加</p>
</blockquote>
</li>
<li><p>最值分裂</p>
<blockquote>
<p>区别在于结点中索引数满阶时不再是从中间开始分裂，而是从最值(最大，最小索引)处分裂</p>
</blockquote>
</li>
<li><p>删除关键字   不完善哈</p>
<blockquote>
<p>关键字在终端结点</p>
<ol>
<li>若该关键字所在结点的关键字数目比最小临界大，则直接删</li>
<li>否则无法直接删除，看其兄弟结点的关键字数是否大于最小临界，大于则借</li>
<li>否则需要与兄弟结点合并</li>
</ol>
</blockquote>
</li>
</ul>
<blockquote>
<p>关键字不在终端结点</p>
<ol>
<li>关键字所在结点中关键字数大于最小临界，用其相邻关键字替代(左子树中最大或右子树中最小)</li>
<li>关键字所在结点中关键字数不大于最小临界，先合并后再删除</li>
</ol>
</blockquote>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li>仅叶子结点存储数据，大大提高了页空间利用率</li>
<li>叶子结点互连为双向链表，范围查找时，仅需找到边界处，根据此双向链表遍历查找即可，无需再依次访问磁盘提取</li>
<li>分裂时从最值处分裂，这样对应索引引向的子树结点均为大于or小于该索引值的索引，结点的最大索引数变为阶数，也使得叶子双向链表有序，方便遍历</li>
</ol>
<h4 id="阶数M"><a href="#阶数M" class="headerlink" title="阶数M"></a>阶数M</h4><p>由磁盘页的大小与字段大小决定</p>
<h4 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h4><ul>
<li>最左原则</li>
<li>叶子结点不存数据记录，而是存组合索引以及对应记录的记录地址</li>
</ul>
<h2 id="平衡二叉树-AVL"><a href="#平衡二叉树-AVL" class="headerlink" title="平衡二叉树-AVL"></a>平衡二叉树-AVL</h2><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2>]]></content>
      <categories>
        <category>Algorithm and DataStruture</category>
      </categories>
      <tags>
        <tag>Algorithm and DataStruture</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ STL</title>
    <url>/2021/07/16/C++Primer/STL/</url>
    <content><![CDATA[<h1 id="STL体系结构"><a href="#STL体系结构" class="headerlink" title="STL体系结构"></a>STL体系结构</h1><h2 id="六大组件"><a href="#六大组件" class="headerlink" title="六大组件"></a>六大组件</h2><p>容器 container</p>
<p>分配器 allocator</p>
<p>适配器 adaptor</p>
<p>算法 algorithm</p>
<p>迭代器 itrator</p>
<blockquote>
<p>泛化指针</p>
<p>[)前闭后开区间</p>
<p>o.begin()指向首元素，o.end()指向尾元素的下一个位置</p>
</blockquote>
<p>仿函数 functor</p>
<h2 id="OOP-and-GP"><a href="#OOP-and-GP" class="headerlink" title="OOP and GP"></a>OOP and GP</h2><p>Object-Oriented Programming 面向对象编程</p>
<blockquote>
<p>datas 和 methods 封装在一个类中</p>
</blockquote>
<p>Generic Programming 泛型编程</p>
<blockquote>
<p>datas 和 methods 分开</p>
<p>algorithms 通过 Iterators 操作 containers 中的数据 并可使用functors</p>
</blockquote>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="容器分类"><a href="#容器分类" class="headerlink" title="容器分类"></a>容器分类</h3><p>Sequence Containers 序列容器</p>
<blockquote>
<p>Arrays 数组</p>
<p>Vector 动态数组</p>
<p>deque 双向队列</p>
<p>List 双向链表</p>
<p>Forward-List 单链表</p>
</blockquote>
<ul>
<li><p>Associative Containers 关联容器</p>
<blockquote>
<p>set 无重复元素的集合</p>
<p>multiset 可有重复元素</p>
<p>map 无重复元素的键值对集合</p>
<p>multimap 可有重复元素</p>
<p>底层结构为红黑树</p>
</blockquote>
</li>
<li><p>Unordered Containers 无序容器</p>
<blockquote>
<p>unordered set/unordered multiset</p>
<p>unordered map/unordered multimap</p>
<p>底层结构为hashTable-Separate Chaining</p>
</blockquote>
</li>
</ul>
<h3 id="容器测试"><a href="#容器测试" class="headerlink" title="容器测试"></a>容器测试</h3><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试常用库</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span>  <span class="comment">//引入qsort,search等等算法</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">clock_t</span> nowtime = <span class="built_in">clock</span>(); <span class="comment">//clock()函数返回从开启这个程序进程到调用clock()函数的CPU时钟计时单元数，返回单位是毫秒，类型为clock_t</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="Sequence-Containers-序列容器"><a href="#Sequence-Containers-序列容器" class="headerlink" title="Sequence Containers 序列容器"></a>Sequence Containers 序列容器</h4><blockquote>
<p>不便于查找</p>
</blockquote>
<h5 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h5><blockquote>
<p>数组</p>
<h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line">array&lt;type,size&gt; name; <span class="comment">//需要指定定长array的初始大小,size为常量</span></span><br></pre></td></tr></table></figure>
<h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>通过下标来放置元素</p>
<h5 id="接口测试"><a href="#接口测试" class="headerlink" title="接口测试"></a>接口测试</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">array.<span class="built_in">size</span>(); <span class="comment">//容器元素个数</span></span><br><span class="line">array.<span class="built_in">front</span>(); <span class="comment">//取首元素</span></span><br><span class="line">array.<span class="built_in">back</span>(); <span class="comment">//取尾部元素</span></span><br><span class="line">array.<span class="built_in">data</span>(); <span class="comment">//返回容器的首元素地址</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h5><blockquote>
<p>动态数组</p>
<h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line">vector&lt;type&gt; name; <span class="comment">//等等</span></span><br></pre></td></tr></table></figure>

<p>动态扩容一般为扩容为原来的2倍</p>
<p>先创建2倍的内存空间，再逐个元素copy过去</p>
<h5 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h5><p>push_back()</p>
<h5 id="接口测试-1"><a href="#接口测试-1" class="headerlink" title="接口测试"></a>接口测试</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector.<span class="built_in">size</span>(); <span class="comment">//容器元素个数</span></span><br><span class="line">vector.<span class="built_in">front</span>(); <span class="comment">//取首元素</span></span><br><span class="line">vector.<span class="built_in">back</span>(); <span class="comment">//取尾部元素</span></span><br><span class="line">vector.<span class="built_in">data</span>(); <span class="comment">//返回容器的首元素地址</span></span><br><span class="line">vector.<span class="built_in">capacity</span>(); <span class="comment">//查看容器可容纳的空间大小</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h5><blockquote>
<p>双向队列</p>
<h5 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h5><p>双向扩容,一次扩充一个buffer，并由deque中的指针指向</p>
<p>分段buffer连续,段中存放着连续数据 </p>
<p>涵盖了容器适配器stack与queue的功能</p>
<blockquote>
<p>stack与queue均操作受限，因此无法使用iterator迭代器，无法调用find方法</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line">deque&lt;type&gt; name;</span><br></pre></td></tr></table></figure>

<h5 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h5><p>push_back() //将数据放置在deque中段buffer的结构中</p>
<h5 id="接口测试-2"><a href="#接口测试-2" class="headerlink" title="接口测试"></a>接口测试</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">deque.<span class="built_in">size</span>(); <span class="comment">//容器元素个数</span></span><br><span class="line">deque.<span class="built_in">max_size</span>(); <span class="comment">//容器所能容纳的最大元素个数</span></span><br><span class="line">deque.<span class="built_in">front</span>(); <span class="comment">//取首元素</span></span><br><span class="line">deque.<span class="built_in">back</span>(); <span class="comment">//取尾部元素</span></span><br></pre></td></tr></table></figure>


</blockquote>
<h5 id="List"><a href="#List" class="headerlink" title="List"></a>List</h5><blockquote>
<p>双向链表</p>
<h5 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line">list&lt;type&gt; name;</span><br></pre></td></tr></table></figure>

<h5 id="初始化-3"><a href="#初始化-3" class="headerlink" title="初始化"></a>初始化</h5><p>push_back()</p>
<h5 id="接口测试-3"><a href="#接口测试-3" class="headerlink" title="接口测试"></a>接口测试</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">list.<span class="built_in">size</span>(); <span class="comment">//容器元素个数</span></span><br><span class="line">list.<span class="built_in">max_size</span>(); <span class="comment">//容器所能容纳的最大元素个数</span></span><br><span class="line">list.<span class="built_in">front</span>(); <span class="comment">//取首元素</span></span><br><span class="line">list.<span class="built_in">back</span>(); <span class="comment">//取尾部元素</span></span><br></pre></td></tr></table></figure>

<p><code>注意:</code>list不提供randomaccessiterator 所以无法调用全局sort方法,需要内部重载</p>
</blockquote>
<h5 id="Forward-list"><a href="#Forward-list" class="headerlink" title="Forward_list"></a>Forward_list</h5><blockquote>
<p>单链表</p>
<h5 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line">forward_list&lt;type&gt; name;</span><br></pre></td></tr></table></figure>

<h5 id="初始化-4"><a href="#初始化-4" class="headerlink" title="初始化"></a>初始化</h5><p>push_front() 头插</p>
<h5 id="接口测试-4"><a href="#接口测试-4" class="headerlink" title="接口测试"></a>接口测试</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">forward_list.<span class="built_in">max_size</span>(); <span class="comment">//容器所能容纳的最大元素个数</span></span><br><span class="line">forward_list.<span class="built_in">front</span>(); <span class="comment">//取首元素</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="Associative-Containers-关联容器"><a href="#Associative-Containers-关联容器" class="headerlink" title="Associative Containers 关联容器"></a>Associative Containers 关联容器</h4><blockquote>
<p>查找效率高</p>
</blockquote>
<h5 id="Multiset"><a href="#Multiset" class="headerlink" title="Multiset"></a>Multiset</h5><blockquote>
<h5 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line">multiset&lt;type&gt;  name;</span><br></pre></td></tr></table></figure>

<h5 id="初始化-5"><a href="#初始化-5" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Multiset.<span class="built_in">insert</span>(value)  <span class="comment">//安插到该安插的位置而非固定头尾</span></span><br></pre></td></tr></table></figure>

<p>相较于::find(),multiset.find()查找更快,通过(*item)取得值</p>
<h5 id="接口测试-5"><a href="#接口测试-5" class="headerlink" title="接口测试"></a>接口测试</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">multiset.<span class="built_in">size</span>(); <span class="comment">//</span></span><br><span class="line">multiset.<span class="built_in">max_size</span>(); <span class="comment">//</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h5><blockquote>
<blockquote>
<p>底层为红黑树</p>
</blockquote>
<h5 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line">set&lt;type&gt;  name;</span><br></pre></td></tr></table></figure>

<h5 id="初始化-6"><a href="#初始化-6" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Set.<span class="built_in">insert</span>(value)  <span class="comment">//安插到该安插的位置而非固定头尾</span></span><br></pre></td></tr></table></figure>

<h5 id="接口测试-6"><a href="#接口测试-6" class="headerlink" title="接口测试"></a>接口测试</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">set.<span class="built_in">size</span>(); <span class="comment">//</span></span><br><span class="line">set.<span class="built_in">max_size</span>(); <span class="comment">//</span></span><br></pre></td></tr></table></figure>

<p><code>注意:</code> 不允许重复</p>
</blockquote>
<h5 id="Multimap"><a href="#Multimap" class="headerlink" title="Multimap"></a>Multimap</h5><blockquote>
<h5 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line">multimap&lt;key_type,value_type&gt; name</span><br></pre></td></tr></table></figure>

<h5 id="初始化-7"><a href="#初始化-7" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Multimap.<span class="built_in">insert</span>(pair&lt;key_type,value_type&gt;(key,value)) <span class="comment">//使用pair模板对象来封装key-value</span></span><br><span class="line"><span class="comment">//pair.second为value pair.first为key</span></span><br><span class="line"><span class="comment">//不可以用[]做insertion</span></span><br></pre></td></tr></table></figure>

<p>相较于::find(),obj.find()查找更快，通过(*item).second取得值</p>
<h5 id="接口测试-7"><a href="#接口测试-7" class="headerlink" title="接口测试"></a>接口测试</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">multimap.<span class="built_in">size</span>(); <span class="comment">//</span></span><br><span class="line">multimap.<span class="built_in">max_size</span>(); <span class="comment">//</span></span><br></pre></td></tr></table></figure>


</blockquote>
<h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h5><blockquote>
<blockquote>
<p>底层为红黑树</p>
</blockquote>
<h5 id="定义-8"><a href="#定义-8" class="headerlink" title="定义"></a>定义</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line">map&lt;key_type,value_type&gt; name</span><br></pre></td></tr></table></figure>

<h5 id="初始化-8"><a href="#初始化-8" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">map[i] = valve; <span class="comment">// map自动执行封装key-value</span></span><br><span class="line"><span class="comment">//Map.insert(pair&lt;key_type,key_value&gt;(key,value));</span></span><br></pre></td></tr></table></figure>

<h5 id="接口测试-8"><a href="#接口测试-8" class="headerlink" title="接口测试"></a>接口测试</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">map.<span class="built_in">size</span>(); <span class="comment">//</span></span><br><span class="line">map.<span class="built_in">max_size</span>(); <span class="comment">//</span></span><br></pre></td></tr></table></figure>

<p><code>注意:</code> 不允许重复，但是该重复指的是key-value重复，仅一个不同另一个相同不算重复</p>
</blockquote>
<h4 id="Unordered-Containers-无序容器"><a href="#Unordered-Containers-无序容器" class="headerlink" title="Unordered Containers 无序容器"></a>Unordered Containers 无序容器</h4><blockquote>
<p>hash Containers 以hashtable为底层结构</p>
</blockquote>
<h5 id="Unordered-multiset"><a href="#Unordered-multiset" class="headerlink" title="Unordered_multiset"></a>Unordered_multiset</h5><blockquote>
<h5 id="定义-9"><a href="#定义-9" class="headerlink" title="定义"></a>定义</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">unordered_multiset&lt;type&gt; name</span><br></pre></td></tr></table></figure>

<h5 id="初始化-9"><a href="#初始化-9" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Unordered_multiset.<span class="built_in">insert</span>(value);</span><br></pre></td></tr></table></figure>

<h5 id="接口测试-9"><a href="#接口测试-9" class="headerlink" title="接口测试"></a>接口测试</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">u_mset.<span class="built_in">size</span>(); <span class="comment">//</span></span><br><span class="line">u_mset.<span class="built_in">max_size</span>(); <span class="comment">//</span></span><br><span class="line">u_mset.<span class="built_in">bucket_count</span>(); <span class="comment">//篮子数，存放hash值的数组长度</span></span><br><span class="line">u_mset.<span class="built_in">bucket_size</span>(i); <span class="comment">//第i个篮子的连接的结点数</span></span><br><span class="line">u_mset.<span class="built_in">load_factor</span>(); <span class="comment">//负载因子</span></span><br><span class="line">u_mset.<span class="built_in">max_bucket_count</span>(); <span class="comment">//最大篮子数，存放hash值的数组长度</span></span><br><span class="line">u_mset.<span class="built_in">max_load_factor</span>(); <span class="comment">//最大负载因子</span></span><br></pre></td></tr></table></figure>


</blockquote>
<h5 id="Unordered-Multimap"><a href="#Unordered-Multimap" class="headerlink" title="Unordered_Multimap"></a>Unordered_Multimap</h5><blockquote>
<h5 id="定义-10"><a href="#定义-10" class="headerlink" title="定义"></a>定义</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">unordered_multimap&lt;key_type,value_type&gt; name;</span><br></pre></td></tr></table></figure>

<h5 id="初始化-10"><a href="#初始化-10" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">unordered_multimap.<span class="built_in">insert</span>(pair&lt;key_type,value_type&gt;(key,value)) <span class="comment">//使用pair模板对象来封装key-value</span></span><br><span class="line"><span class="comment">//pair.second为value pair.first为key</span></span><br></pre></td></tr></table></figure>

<h5 id="接口测试-10"><a href="#接口测试-10" class="headerlink" title="接口测试"></a>接口测试</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">unordered_multimap.<span class="built_in">size</span>(); <span class="comment">//</span></span><br><span class="line">unordered_multimap.<span class="built_in">max_size</span>(); <span class="comment">//</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="Unordered-Set"><a href="#Unordered-Set" class="headerlink" title="Unordered_Set"></a>Unordered_Set</h5><blockquote>
<p>底部为hashtable</p>
</blockquote>
<h5 id="Unordered-Map"><a href="#Unordered-Map" class="headerlink" title="Unordered_Map"></a>Unordered_Map</h5><blockquote>
<p>底部为hashtable</p>
</blockquote>
<h3 id="容器源码剖析"><a href="#容器源码剖析" class="headerlink" title="容器源码剖析"></a>容器源码剖析</h3><h4 id="Sequence-Containers-序列容器-1"><a href="#Sequence-Containers-序列容器-1" class="headerlink" title="Sequence Containers 序列容器"></a>Sequence Containers 序列容器</h4><h5 id="List-1"><a href="#List-1" class="headerlink" title="List"></a>List</h5><blockquote>
<p>环状双向链表</p>
<p>将有一个空结点使该环状双向链表满足前闭后开原则(begin()指向第一个结点,end()指向尾结点的下一个位置)</p>
</blockquote>
<ul>
<li>GCC2.9</li>
</ul>
<blockquote>
<p>组成</p>
<p>结点模板类</p>
<blockquote>
<p>指向前一个结点成员的空指针</p>
<p>指向下一个结点成员的空指针</p>
</blockquote>
<p>list模板类</p>
<blockquote>
<p>指向结点的头指针node </p>
<ul>
<li>一个list类对象的大小为4byte在GCC2.9编译器下</li>
</ul>
<p>iterator迭代器模板类成员</p>
<p>…</p>
</blockquote>
<p>iterator迭代器模板类</p>
<blockquote>
<p>5个不可或缺的typedef类型声明</p>
<ul>
<li>Link_type 元素类型</li>
<li>Reference 引用类型</li>
<li>Pointer 指针类型</li>
</ul>
<p>指向结点的指针node</p>
<p>对各种运算符的重载函数</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//list_gcc29.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __USER__</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> __USER__ myy</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">list_node</span>&#123;</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">void</span>* nptr; <span class="comment">//空指针比较鸡肋需要进行类型转型gcc4.9对此也进行了改善直接使用指针类型</span></span><br><span class="line">	nptr pre;</span><br><span class="line">	nptr next;</span><br><span class="line">	T data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">list</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> __list_node&lt;T&gt; node_type; <span class="comment">//可能其他部分使用到了这个结点类型</span></span><br><span class="line">	<span class="keyword">typedef</span> node_type* nodeptr;</span><br><span class="line">	<span class="keyword">typedef</span> list_iterator&lt;T,T&amp;,T*&gt; iterator; <span class="comment">//gcc2.9需要传递3个参数gcc4.9对此做了改善只需要传递T类型参数即可</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	nodeptr node;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="keyword">class</span> <span class="title">Ref</span>,<span class="keyword">class</span> <span class="title">Ptr</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_iterator</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//typedef类型声明部分</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> list_iterator&lt;T, Ref, Ptr&gt; self;</span><br><span class="line">	<span class="keyword">typedef</span> __list_node&lt;T&gt;* node_type;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//必要的5中类型声明</span></span><br><span class="line">	<span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category; <span class="comment">//迭代器的种类</span></span><br><span class="line">	<span class="keyword">typedef</span> T value_type; <span class="comment">//数据类型</span></span><br><span class="line">	<span class="keyword">typedef</span> Ptr pointer; <span class="comment">//指向node类型的指针</span></span><br><span class="line">	<span class="keyword">typedef</span> Ref reference; <span class="comment">//node类型的引用类型</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type; <span class="comment">//两个迭代器之间距离的类型</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//- - -</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//运算符重载</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//后置++重载</span></span><br><span class="line">	<span class="comment">//注意返回类型为对象而非引用，所以后置自增无法多次++,例如a++++</span></span><br><span class="line">	self <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">		<span class="function">self <span class="title">temp</span><span class="params">(*<span class="keyword">this</span>)</span></span>; <span class="comment">//调用拷贝构造函数进行深拷贝，将当前保存为临时对象</span></span><br><span class="line">		++*<span class="keyword">this</span>; <span class="comment">//当前对象执行已重载的前置自增操作</span></span><br><span class="line">		<span class="keyword">return</span> temp; <span class="comment">//返回临时对象的拷贝-调用拷贝构造函数</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//前置++重载</span></span><br><span class="line">	<span class="comment">//注意返回类型为引用，所以前置自增可多次++,例如++++a</span></span><br><span class="line">	self&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">		node = (node_type)(node-&gt;next);</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;; </span><br><span class="line"></span><br><span class="line">	reference <span class="keyword">operator</span>*() <span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (*node).data;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*())</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	node_type node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !USER</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>GCC4.9</p>
<blockquote>
<p>相较于2.9的改善</p>
<ol>
<li>结点指针类型明确不再是空指针</li>
<li>结点继承自一个父类</li>
<li>iterator模板参数为1个不再是冗杂的3个</li>
</ol>
<p>gcc4.9下一个list对象所占的内存为8byte</p>
<p>vs2017下一个list对象所占的内存为12byte</p>
</blockquote>
</li>
</ul>
<h5 id="Vector-1"><a href="#Vector-1" class="headerlink" title="Vector"></a>Vector</h5><p>GCC2.9</p>
<p>组成</p>
<blockquote>
<p>三个Iteretor迭代器成员</p>
<blockquote>
<p>分别指向首元素,尾元素下一个位置,最后一个内存位置</p>
<p>一个vector对象的内存为12byte</p>
</blockquote>
<p>各种运算符的重载</p>
<p>基本操作函数成员</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//vector_gcc29.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __user__</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> __user__ myy</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vector</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> T value_name;</span><br><span class="line">	<span class="keyword">typedef</span> value_name* iterator;</span><br><span class="line">	<span class="keyword">typedef</span> T&amp; reference;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line"></span><br><span class="line">	<span class="function">iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> start;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> finish;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">size_type</span>(<span class="built_in">end</span>() - <span class="built_in">begin</span>());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> empty <span class="title">const</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">begih</span>() == <span class="built_in">end</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">size_type <span class="title">capacity</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">size_type</span>(end_storage - <span class="built_in">begin</span>());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连续空间支持下标索引所以需要对[]运算符重载</span></span><br><span class="line">	reference <span class="keyword">operator</span>[] <span class="built_in"><span class="keyword">const</span></span>(size_type&amp; s) &#123;</span><br><span class="line">		<span class="keyword">return</span> *(start + s);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">reference <span class="title">front</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> *<span class="built_in">begin</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">reference <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> *(<span class="built_in">end</span>() - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">end</span>() != end_storage) &#123;</span><br><span class="line">			<span class="built_in">construct</span>(finish,x); <span class="comment">//全局函数</span></span><br><span class="line">			finish++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">insert_aux</span>(<span class="built_in">end</span>(), x); <span class="comment">//插入辅助函数</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert_aux</span><span class="params">(iterator position, <span class="keyword">const</span> T&amp; x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	iterator start;</span><br><span class="line">	iterator finish;</span><br><span class="line">	iterator end_stroage;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !__user__</span></span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Iterator</p>
<blockquote>
<p>vector的内存为连续空间因此不再使用泛型指针而是采用native pointor</p>
</blockquote>
</blockquote>
<p>扩容</p>
<p>GCC2.9</p>
<blockquote>
<p>当vector满时(end() == end_storage)进行二倍扩容</p>
<p>任何扩容不会原地扩容，因为其后连续空间可能已被占用，只能预先申请新的内存并将原元素copy过去</p>
<p>在插入操作时可能引发扩容操作</p>
<blockquote>
<ol>
<li>使用alloc分配器申请二倍内存空间</li>
<li>在copy原vector元素时完成插入操作而非copy扩容完成后再重新插入<ul>
<li>将原vector插入位置position之前的元素先copy到新vector中</li>
<li>执行插入操作</li>
<li>将原vector插入位置position之后的元素再copy到新vector中</li>
</ul>
</li>
<li>删除原内存空间</li>
<li>调整迭代器</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> vector&lt;T,Alloc&gt;::<span class="built_in">insert_aux</span>(iterator position, <span class="keyword">const</span> T&amp; x) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">end</span>() != end_storage) &#123;</span><br><span class="line">		<span class="built_in">insert_aux</span>(finish, *(finish - <span class="number">1</span>));<span class="comment">//position位置之后的元素需要后移</span></span><br><span class="line">		finish++;</span><br><span class="line"></span><br><span class="line">		T temp = x;</span><br><span class="line">		<span class="built_in">copy_backward</span>(position, finish - <span class="number">2</span>, finish - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		*(position) = temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">const</span> size_type old_size = <span class="built_in">size</span>();</span><br><span class="line">		<span class="keyword">const</span> size_type len = ole_size != <span class="number">0</span> ? old_size * <span class="number">2</span> : <span class="number">1</span>; <span class="comment">//获取新创建空间的长度</span></span><br><span class="line"></span><br><span class="line">		iterator new_start = data_allocator::<span class="built_in">allocate</span>(len); <span class="comment">//分配长度为len的内存空间</span></span><br><span class="line">		iterator new_finish = new_start; <span class="comment">//初始为空</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			new_finish = <span class="built_in">uninitialized_copy</span>(start, position, new_start); <span class="comment">//将原vector中position之前的元素copy到扩容后的新内存</span></span><br><span class="line"></span><br><span class="line">			<span class="built_in">construct</span>(new_finish, x); <span class="comment">//将待插入的值插入到position位置</span></span><br><span class="line">			new_finish++;</span><br><span class="line"></span><br><span class="line">			new_finish = <span class="built_in">uninitialized_copy</span>(position, finish, new_finish); <span class="comment">//将原vector中position之后的元素copy到扩容后的新内存</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in"><span class="keyword">catch</span></span> (...) &#123;</span><br><span class="line">			<span class="comment">// &quot;roll back or commit&quot;</span></span><br><span class="line">			<span class="comment">//销毁申请失败的新内存</span></span><br><span class="line">			<span class="built_in">destroy</span>(new_start, new_finish);</span><br><span class="line">			data_allocator::<span class="built_in">deallocate</span>(new_start, len);</span><br><span class="line">			<span class="keyword">throw</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//销毁原vector</span></span><br><span class="line">		<span class="built_in">destroy</span>(<span class="built_in">begin</span>(), <span class="built_in">end</span>());</span><br><span class="line">		<span class="built_in">deallocate</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//调整迭代器</span></span><br><span class="line">		start = new_start;</span><br><span class="line">		finish = new_finish;</span><br><span class="line">		end_storage = new_start + len;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="Array-1"><a href="#Array-1" class="headerlink" title="Array"></a>Array</h5><blockquote>
<p>数组</p>
</blockquote>
<p>GCC2.9</p>
<p>组成</p>
<blockquote>
<p>数组成员</p>
<p>迭代器 native pointer</p>
<p>无构造函数析构函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp,std::<span class="keyword">size_t</span> _Nm&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Array</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> _Tp value_type;</span><br><span class="line">	<span class="keyword">typedef</span> _Tp* pointer;</span><br><span class="line">	<span class="keyword">typedef</span> value_type* iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"></span><br><span class="line">	<span class="comment">//Array无构造函数析构函数</span></span><br><span class="line"></span><br><span class="line">	<span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;arr[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;arr[_Nm];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	value_type arr[_Nm ? _Nm : <span class="number">1</span>]; <span class="comment">//若数组长度参数为0默认将长度值为1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="Forward-list-1"><a href="#Forward-list-1" class="headerlink" title="Forward list"></a>Forward list</h5><blockquote>
<p>单向链表  </p>
<p>无法对 – 运算符重载，所以只能单向移动迭代器</p>
<p>push_front头插</p>
</blockquote>
<h5 id="Deque-1"><a href="#Deque-1" class="headerlink" title="Deque"></a>Deque</h5><blockquote>
<p> 双向队列</p>
<p> 分段有序但是存在是连续空间的假象</p>
</blockquote>
<p>结构</p>
<blockquote>
<p>map + buffer  / 中控 + 缓冲</p>
<p>map</p>
<blockquote>
<p>是一个vector，元素类型为指向bufer的指针</p>
</blockquote>
<p>buffer</p>
<blockquote>
<p>实际存放数据的一段内存</p>
<p>创建deque对象时需要指定buffer大小，若未指定，则使用默认值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">size_t</span> __deque_buf_size(<span class="keyword">size_t</span> n,<span class="keyword">size_t</span> sz) &#123;</span><br><span class="line">	<span class="keyword">return</span> n != <span class="number">0</span> ? n : ( sz &lt; <span class="number">512</span> ? (<span class="keyword">size_t</span>)(<span class="number">512</span> / sz): <span class="built_in">size_t</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<p>组成</p>
<blockquote>
<p>数据元素大小为40byte 16+16+4+4</p>
<p>-</p>
<p>start迭代器 16byte</p>
<blockquote>
<p>-</p>
<p>first指针 - 指向所有buffer中的第一个buffer的起始内存位置</p>
<p>last指针 - 指向所有buffer中的第一个buffer内存的末尾 </p>
<blockquote>
<p>last = first + difference_type(buffer_size());</p>
</blockquote>
<p>cur指针 - 指向所有元素的首元素</p>
<p>map-poninter指针 - 指向map中控vector的首元素</p>
<p>-</p>
</blockquote>
<p>finish迭代器 16byte</p>
<blockquote>
<p>-</p>
<p>first指针 - 指向所有buffer中的最后一个buffer的起始内存位置</p>
<p>last指针- 指向所有buffer中的最后一个buffer内存的末尾 </p>
<blockquote>
<p>last = first + difference_type(buffer_size());</p>
</blockquote>
<p>cur指针 - 指向所有元素中最后一个元素的下一个位置</p>
<p>map-poninter指针 - 指向map中控vector的尾元素</p>
<p>-</p>
</blockquote>
<p>指向map中控的指针 4byte</p>
<p>存储map大小的size_t变量 4byte</p>
<p>-</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc ,<span class="keyword">size_t</span> BufSiz=<span class="number">0</span>&gt;</span><br><span class="line">class Deque &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> iterator&lt;T, T&amp;, T*, BufSiz&gt; iterator;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> T** map_pointer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> start;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> finish;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">size_type <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> finish - start;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">insert</span><span class="params">(iterator pos, <span class="keyword">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (pos.cur == start.cur)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">push_front</span>();</span><br><span class="line">			<span class="keyword">return</span> start;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (pos.cur==finsh.cur) &#123;</span><br><span class="line">			<span class="built_in">push_back</span>();</span><br><span class="line">			iterator temp = finsh;</span><br><span class="line">			<span class="keyword">return</span> --temp;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">insert_aux</span>(pos, x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//deque的元素插入函数</span></span><br><span class="line">	<span class="function">iterator <span class="title">insert_aux</span><span class="params">(iterator pos, <span class="keyword">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">		difference_type len = pos - start;</span><br><span class="line">		<span class="keyword">if</span> (len &lt; <span class="built_in">size</span>() / <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="built_in">push_front</span>(<span class="built_in">front</span>()); <span class="comment">//在最前端插入与第一个元素同值的元素</span></span><br><span class="line">			<span class="built_in">copy</span>(...); <span class="comment">//pos位置之前的元素前移</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">push_back</span>(<span class="built_in">back</span>()); <span class="comment">//在最后端插入与最后一个元素同值的元素</span></span><br><span class="line">			<span class="built_in">copyback</span>(...); <span class="comment">//pos位置之后的元素后移</span></span><br><span class="line">		&#125;</span><br><span class="line">		*pos = x;</span><br><span class="line">		<span class="keyword">return</span> pos;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//&quot;连续空间&quot;需要有对[]运算符的重载</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>[] (<span class="keyword">size_t</span> n) &#123;</span><br><span class="line">        <span class="keyword">return</span> start[<span class="built_in">difference_type</span>(n)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	iterator start;</span><br><span class="line">	iterator finsh;</span><br><span class="line">	map_pointer map;</span><br><span class="line">	size_type map_size;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


</blockquote>
<p>迭代器组成</p>
<blockquote>
<p>-</p>
<p>first指针</p>
<p>last指针</p>
<p>cur指针</p>
<p>map-poninter指针</p>
<p>-</p>
<p>对基本运算符的重载</p>
<ul>
<li><p>*解引用运算符</p>
<blockquote>
<p>取迭代器cur对应的元素</p>
</blockquote>
</li>
<li><p>-&gt;箭头运算符</p>
<blockquote>
<p>取迭代器cur对应的元素的地址</p>
</blockquote>
</li>
<li><p>ite1 - ite2</p>
<blockquote>
<p>得两迭代器之间的所有元素</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>分三部分求得 </p>
<ol>
<li>ite2指向的buffer元素</li>
<li>ite1指向的buffer元素</li>
<li>两个迭代器之间的buffer的所有元素</li>
</ol>
</blockquote>
<ul>
<li><p>++运算符</p>
<blockquote>
<p>“连续空间”下++使ite指向后一个元素</p>
<p>根据cur与边界(first/last)的等值关系来判断是超过buffer界限</p>
</blockquote>
</li>
<li><p>–运算符</p>
<blockquote>
<p>“连续空间”下++使ite指向前一个元素</p>
<p>根据cur与边界(first/last)的等值关系来判断是超过buffer界限</p>
</blockquote>
</li>
<li><p>+=运算符 ite += n</p>
<blockquote>
<p>根据偏移量大小正负来判断是否超过buffer界限(前后均有界)</p>
</blockquote>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="keyword">class</span> <span class="title">Ref</span>,<span class="keyword">class</span> <span class="title">Ptr</span>, <span class="title">size_t</span> <span class="title">BufSiz</span>=</span><span class="number">0</span>&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">iterator</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> random_acsess_iterator_tag iterator_category;</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">	<span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">	<span class="keyword">typedef</span> Ref reference;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> iterator self;</span><br><span class="line">	<span class="keyword">typedef</span> T** map_pointer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	reference <span class="keyword">operator</span>*() <span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> *cur;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">inline</span> <span class="keyword">size_t</span> __deque_buf_size(<span class="keyword">size_t</span> n, <span class="keyword">size_t</span> sz) &#123;</span><br><span class="line">		<span class="keyword">return</span> n != <span class="number">0</span> ? n : (sz &lt; <span class="number">512</span> ? (<span class="keyword">size_t</span>)(<span class="number">512</span> / sz) : <span class="built_in">size_t</span>(<span class="number">1</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	difference_type <span class="keyword">operator</span>- (<span class="keyword">const</span> self&amp; x) &#123;</span><br><span class="line">		<span class="keyword">auto</span> bfnums = (node - x.node - <span class="number">1</span>)*(difference_type)(<span class="built_in">buffer_size</span>()); <span class="comment">//作差的两个迭代器之间的(buffer个数)*(buffer大小)得出之间的元素个数</span></span><br><span class="line">		<span class="keyword">auto</span> front = x.last - x.cur; <span class="comment">// 被减的迭代器指向的buffer中的元素个数</span></span><br><span class="line">		<span class="keyword">auto</span> back = cur - first; <span class="comment">//减数迭代器指向的buffer中的元素个数</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> bfnums + front + back; <span class="comment">//三者作和得两作差迭代器之间的元素个数</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	self&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line"></span><br><span class="line">		cur++; <span class="comment">//当做连续空间，需要将cur指向下一个元素</span></span><br><span class="line">		<span class="comment">// 若cur++后超过当前buffer范围，则该迭代器需要指向下一个buffer</span></span><br><span class="line">		<span class="keyword">if</span> (cur == last) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">set_node</span>(node + <span class="number">1</span>); <span class="comment">//更新迭代器中first,last，node与buffer相关的特定属性</span></span><br><span class="line">			cur = first; <span class="comment">//重新更新cur指向使得cur指向&quot;连续空间&quot;的下一个元素</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	self <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line"></span><br><span class="line">		self temp = *<span class="keyword">this</span>;</span><br><span class="line">		++*<span class="keyword">this</span>;</span><br><span class="line">		<span class="keyword">return</span> *temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	self&amp; <span class="keyword">operator</span>--() &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 判断当前cur是否位于边界处，则该迭代器需要指向下一个buffer</span></span><br><span class="line">		<span class="keyword">if</span> (cur == first) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">set_node</span>(node - <span class="number">1</span>); <span class="comment">//更新迭代器中first,last，node与buffer相关的特定属性</span></span><br><span class="line">			cur = last; <span class="comment">//重新更新cur指向使得cur指向&quot;连续空间&quot;的下一个元素</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cur--; <span class="comment">//因为buffer的左边界就是首元素所以需要先作判断,并且last指向尾元素的下一个位置,需要--指向尾元素</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	self <span class="keyword">operator</span>--(<span class="keyword">int</span>) &#123;</span><br><span class="line"></span><br><span class="line">		self temp = *<span class="keyword">this</span>;</span><br><span class="line">		--*<span class="keyword">this</span>;</span><br><span class="line">		<span class="keyword">return</span> *temp;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">set_node</span><span class="params">(<span class="keyword">const</span> map_pointer&amp; new_node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		node = new_node;</span><br><span class="line">		first = *(new_node);</span><br><span class="line">		last = first + <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	self&amp; <span class="keyword">operator</span>+=(difference_type n) &#123;</span><br><span class="line">		difference_type offset = n + (cur - first); <span class="comment">//通过原cur位置前的元素与偏移量之和得出的新偏移量判断是否超出单buffer范围</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (offset &gt;= <span class="number">0</span> &amp;&amp; offset &lt; <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>())) &#123;</span><br><span class="line"></span><br><span class="line">			cur += n; <span class="comment">//未超过且执行的为+=操作则直接移动cur指针</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">			difference_type node_offset = offset &gt; <span class="number">0</span> ? offset / <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>()) : -<span class="built_in">difference_type</span>((-offset - <span class="number">1</span>) / (<span class="built_in">buffer_size</span>()); <span class="comment">//否则计算跨的buffer个数--node偏移量</span></span><br><span class="line">			<span class="built_in">set_node</span>(node + node_offset); <span class="comment">//更新迭代器</span></span><br><span class="line">			cur = first + offset - node_offset * <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>()); <span class="comment">//更新cur使其指向&quot;连续&quot;空间后移n位的元素，通过first+本buffer偏移量指定</span></span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">                                                                                                                  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	self <span class="keyword">operator</span>+(difference_type n) &#123;</span><br><span class="line">		self temp = *<span class="keyword">this</span>;</span><br><span class="line">		<span class="keyword">return</span> temp += n;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	self&amp; <span class="keyword">operator</span>-=(difference_type n) &#123;</span><br><span class="line">		*<span class="keyword">this</span> += -n;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	self&amp; <span class="keyword">operator</span>-(difference_type n) &#123;</span><br><span class="line">		self temp = *<span class="keyword">this</span>;</span><br><span class="line">		<span class="keyword">return</span> temp -= n;</span><br><span class="line">	&#125;</span><br><span class="line">	                                                                                                            reference <span class="keyword">operator</span>[] (difference_type n) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> *(*<span class="keyword">this</span> + n);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	map_pointer map;</span><br><span class="line">	pointer start;</span><br><span class="line">	pointer last;</span><br><span class="line">	pointer cur;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</blockquote>
<p>常用方法</p>
<blockquote>
<p><code>insert(iterator,const Type&amp;);</code></p>
<p>插入时候需要判断插入的位置距离头部与尾部的位置来决定头插还是尾插</p>
<p>距离谁近，从哪里插入！</p>
</blockquote>
<p>扩容机制</p>
<blockquote>
<p>vector扩容后各元素copy到中段，方便buffer的双向扩充而非从新内存的起始开始</p>
</blockquote>
<h5 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h5><blockquote>
<p>adapter适配器</p>
<p>不提供iterator迭代器以此来防止遍历操作</p>
<p>内含(复用)底层容器(默认deque)，直接使用底层容器的方法来实现queue的方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//queue</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="keyword">class</span> <span class="title">Sequence</span>=</span>deque&lt;T&gt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">queue</span>&#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="keyword">typedef</span> Sequence::value_type value_type</span><br><span class="line"> <span class="keyword">typedef</span> Sequence::size_type size_type</span><br><span class="line"> <span class="keyword">typedef</span> Sequence::reference reference</span><br><span class="line"> <span class="keyword">typedef</span> Sequence::const_reference const_reference</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"> Sequence c;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">empty</span>();&#125;</span><br><span class="line"> <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="keyword">return</span> c.<span class="built_in">size</span>();&#125;</span><br><span class="line"> <span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">front</span>();&#125;</span><br><span class="line"> <span class="function">const_reference <span class="title">front</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">front</span>();&#125;</span><br><span class="line"> <span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">back</span>();&#125;</span><br><span class="line"> <span class="function">const_reference <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">back</span>();&#125;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> value_type&amp; x)</span> </span>&#123;c.<span class="built_in">push_back</span>(x);&#125;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;c.<span class="built_in">pop_front</span>();&#125;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h5><blockquote>
<p>adapter适配器</p>
<p>不提供iterator迭代器以此来防止遍历操作</p>
<p>内含(复用)底层容器(默认deque)，直接使用底层容器的方法来实现stack的方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//stack</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="keyword">class</span> <span class="title">Sequence</span>=</span>deque&lt;T&gt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">stack</span>&#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="keyword">typedef</span> Sequence::value_type value_type</span><br><span class="line"> <span class="keyword">typedef</span> Sequence::size_type size_type</span><br><span class="line"> <span class="keyword">typedef</span> Sequence::reference reference</span><br><span class="line"> <span class="keyword">typedef</span> Sequence::const_reference const_reference</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"> Sequence c;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">empty</span>();&#125;</span><br><span class="line"> <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="keyword">return</span> c.<span class="built_in">size</span>();&#125;</span><br><span class="line"> <span class="function">reference <span class="title">top</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">back</span>();&#125;</span><br><span class="line"> <span class="function">const_reference <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">back</span>();&#125;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> value_type&amp; x)</span> </span>&#123;c.<span class="built_in">push_back</span>(x);&#125;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;c.<span class="built_in">pop_back</span>();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>底层容器的选择</p>
<blockquote>
<p>理论上说含有对应queue/stack所有方法的转调函数的容器均可以作底层容器如list</p>
<p>但是vector无法作queue的底层容器因为vector不提供queue.pop()的转调函数</p>
<p>set/map均无法作底层容器</p>
</blockquote>
<h4 id="Associative-Containers-关联容器-1"><a href="#Associative-Containers-关联容器-1" class="headerlink" title="Associative Containers 关联容器"></a>Associative Containers 关联容器</h4><h5 id="Rb-tree-红黑树初识"><a href="#Rb-tree-红黑树初识" class="headerlink" title="Rb_tree 红黑树初识"></a>Rb_tree 红黑树初识</h5><blockquote>
<p>高度平衡的二叉搜索树</p>
<p>提供iterator迭代器遍历整个红黑树</p>
<p>但是不应使用iterator迭代器去改变元素值，但是map可以因为map容器应提供可更改元素data的迭代器，只是元素的key不可被改变</p>
</blockquote>
<p>rb_tree</p>
<p>GCC2.9</p>
<blockquote>
<p>部分组成</p>
<p>数据成员大小 4+4+1=9 -&gt; 12 byte  函数对象为仿函数，类中仅有对()操作符的重载，因此大小为0，编译器作1处理，但是应为4的倍数，最近的为12</p>
<p>-</p>
<p>红黑树结点个数</p>
<p>头结点</p>
<p>Compare仿函数</p>
<blockquote>
<p>封装通过value值得到key值函数的类</p>
</blockquote>
<p>-</p>
<p>GCC4.9</p>
<p>增加了color enum类型的颜色成员</p>
<p>数据成员大小为24byte</p>
<p>-</p>
<p>需要有5个模板参数</p>
<p>key 键的类型</p>
<p>value value对象 = key对象 + data对象</p>
<p>Alloc 分配器</p>
<p>keyofvalue </p>
<blockquote>
<p>用于从value取出key值的仿函数</p>
<p>若key = value ，则gcc2.9提供了identity<T>仿函数来返回key值</T></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Arg</span>,<span class="keyword">class</span> <span class="title">Result</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">unary_function</span> &#123;</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">typedef</span> Arg argument_type;</span><br><span class="line"> <span class="keyword">typedef</span> Result result_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">identity</span>:</span><span class="keyword">public</span> unary_function&lt;T,T&gt; &#123;</span><br><span class="line"> <span class="comment">// 1.需要公用继承unary_function</span></span><br><span class="line"> <span class="comment">// 2.identity为GCC2.9提供的其他编译环境需要将定义内置于对应容器类中</span></span><br><span class="line"> <span class="comment">// 3.返回值为const类型标明key值不允许被改变</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> T&amp; <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> T&amp; x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</blockquote>
<p>compare 封装key对象比较大小的仿函数</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Arg1</span>,<span class="keyword">class</span> <span class="title">Arg2</span>,<span class="keyword">class</span> <span class="title">Result</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binary_function</span> &#123;</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">typedef</span> Arg1 first_argument_type;</span><br><span class="line"> <span class="keyword">typedef</span> Arg2 second_argument_type;</span><br><span class="line"> <span class="keyword">typedef</span> Result result_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">less</span>:</span><span class="keyword">public</span> binary_function&lt;T,T,T&gt; &#123;</span><br><span class="line"> <span class="comment">// 需要公用继承binary_function</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> T&amp; x,<span class="keyword">const</span> T&amp; y)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt; y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</blockquote>
<p>-</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>,</span></span><br><span class="line"><span class="class">	<span class="keyword">class</span> <span class="title">Value</span>,</span></span><br><span class="line"><span class="class">	<span class="keyword">class</span> <span class="title">Keyofvalue</span>,</span></span><br><span class="line"><span class="class">	<span class="keyword">class</span> <span class="title">Compare</span>,</span></span><br><span class="line"><span class="class">	<span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc</span><br><span class="line">&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">rb_tree</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> __rb_tree_node&lt;Value&gt;* rb_tree_node;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> rb_tree_node* link_type;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">	size_type node_count; <span class="comment">//红黑树结点个数</span></span><br><span class="line">	link_type header; <span class="comment">//头结点</span></span><br><span class="line">	Compare key_compare; <span class="comment">//函数对象 functor</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接口函数</p>
<blockquote>
<p>insert_unique() 插入元素不可重复，若重复不会插入元素</p>
<p>insert_equal() 插入元素可重复</p>
</blockquote>
</blockquote>
<h5 id="Set-Multiset"><a href="#Set-Multiset" class="headerlink" title="Set/Multiset"></a>Set/Multiset</h5><blockquote>
<p>以rb_tree为底层结构</p>
<p>key = value</p>
<p>set调用的insert接口为insert_unique()</p>
<p>Multiset调用的insert接口为insert_equal()</p>
<p>以set为例</p>
</blockquote>
<p>重要组成</p>
<blockquote>
<p>-</p>
<p>底层容器红黑树</p>
<p>const迭代器 不允许更改元素的key与data</p>
<p>-</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>,<span class="keyword">class</span> <span class="title">Compare</span> =</span> less&lt;Key&gt;,<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>=</span>alloc&gt;</span><br><span class="line">&gt;<span class="class"><span class="keyword">class</span> <span class="title">set</span> &#123;</span></span><br><span class="line">&gt;<span class="comment">//...</span></span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> Key Value_Type;</span><br><span class="line"><span class="keyword">typedef</span> Key Key_Type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Compare Key_Compare;</span><br><span class="line"><span class="keyword">typedef</span> Compare Value_Compare;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">identity</span> :</span><span class="keyword">public</span> unary_function&lt;T, T&gt; &#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">const</span> T&amp; <span class="title">operator</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x; <span class="comment">//其实x这里传入的是value，再由value取key</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">typedef</span> rb_tree&lt;Key_Type, Value_Type, identity, Key_Compare,Alloc&gt; rbt;</span><br><span class="line">rbt r;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> rbt::const_iterator iterator; <span class="comment">//使用const_iterator保证无法通过iterator改变元素值</span></span><br><span class="line"></span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="Map-Multimap"><a href="#Map-Multimap" class="headerlink" title="Map/Multimap"></a>Map/Multimap</h5><blockquote>
<p>以rb_tree为底层结构</p>
<p>均将key与data封装为一个pair对象作为value</p>
<p>Map调用的insert接口为insert_unique()</p>
<blockquote>
<p>map还提供了对[key]运算符的重载,存在key指定的元素则返回data值，不存在则insert插入元素</p>
</blockquote>
<p>Multimap调用的insert接口为insert_equal()</p>
<p>以map为例</p>
</blockquote>
<p>重要组成</p>
<blockquote>
<p>-</p>
<p>底层容器红黑树</p>
<p>迭代器 不允许更改元素的key但可以更改元素的data</p>
<p>-</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Compare</span> =</span> less&lt;Key&gt;, <span class="class"><span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">map</span> &#123;</span></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> Key Key_Type;</span><br><span class="line">	<span class="keyword">typedef</span> T Data_Type;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> pair&lt;<span class="keyword">const</span> Key_Type, Data_Type&gt; Value_Type; <span class="comment">//保证key无法被更改但是data可以</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> Compare Key_Compare;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">selectlst</span> :</span> unary_function&lt;value_type, Key_Type&gt; &#123;</span><br><span class="line">     <span class="function"><span class="keyword">const</span> Key_Type&amp; <span class="title">operator</span><span class="params">(<span class="keyword">const</span> value_type&amp; x)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">         <span class="keyword">return</span> x.first;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> rbt::iterator iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">typedef</span> rb_tree&lt;Key_Type, Value_Type, selectlst, Key_Compare, Alloc&gt; rbt;</span><br><span class="line">	rbt r;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="Unordered-Containers-无序容器-1"><a href="#Unordered-Containers-无序容器-1" class="headerlink" title="Unordered Containers 无序容器"></a>Unordered Containers 无序容器</h4><h5 id="hashtable"><a href="#hashtable" class="headerlink" title="hashtable"></a>hashtable</h5><blockquote>
<p>buckets vector + node   buckets数为质数 </p>
<p>hashtable hashmap详解本文略</p>
</blockquote>
<p>类结构基本组成</p>
<blockquote>
<p>五个模板参数</p>
<blockquote>
<p>相较于rb_tree多了一个hashfuc，用于计算obj对应的hash值</p>
</blockquote>
<p>-</p>
<p>…数据成员大小为 1+1+1+12+4 = 19 -&gt; 20 byte</p>
<p>内部维护一个vector容器，存放指向链结点的指针</p>
<p>-</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// buckets vector + node</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">hash_node</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//GCC2.9中node为单向链表</span></span><br><span class="line">	__hash_node* next;</span><br><span class="line">	T data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>,</span></span><br><span class="line"><span class="class">	<span class="keyword">class</span> <span class="title">Key</span>,</span></span><br><span class="line"><span class="class">	<span class="keyword">class</span> <span class="title">Hashfun</span>,</span></span><br><span class="line"><span class="class">	<span class="keyword">class</span> <span class="title">ExtractKey</span>,</span></span><br><span class="line"><span class="class">	<span class="keyword">class</span> <span class="title">EqualKey</span>,</span></span><br><span class="line"><span class="class">	<span class="keyword">class</span> <span class="title">Alloc</span>=</span>alloc</span><br><span class="line">&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hashtable</span> &#123;</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> Hashfun hasher;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> EqualKey key_equal;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">	hasher hash;</span><br><span class="line">	ExtractKey get_key;</span><br><span class="line">	key_equal equals;</span><br><span class="line"></span><br><span class="line">	size_type node_sums; <span class="comment">//存放所有结点元素数的寄存器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> __hash_node&lt;Data&gt; node;    </span><br><span class="line">    vector&lt;node*, alloc&gt; buckets;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>迭代器</p>
<blockquote>
<p>迭代器需要支持加减操作因此不仅需要有指向结点的指针还需要有返回中控vector的指针</p>
<p>hashtable的迭代器相较于rb_tree其允许通过迭代器改变结点的data但是不允许改变key，因为key是hash计算的依据</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>,</span></span><br><span class="line"><span class="class">	<span class="keyword">class</span> <span class="title">Key</span>,</span></span><br><span class="line"><span class="class">	<span class="keyword">class</span> <span class="title">Hashfun</span>,</span></span><br><span class="line"><span class="class">	<span class="keyword">class</span> <span class="title">ExtractKey</span>,</span></span><br><span class="line"><span class="class">	<span class="keyword">class</span> <span class="title">EqualKey</span>,</span></span><br><span class="line"><span class="class">	<span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc</span><br><span class="line">&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">hashtable_iterator</span> &#123;</span></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	__hash_node* next; <span class="comment">//指向结点的指针</span></span><br><span class="line">	hashtable* bk; <span class="comment">//指回vector的指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>扩容</p>
<blockquote>
<p>当node_sums结点个数大于buckets边界值时会进行2倍扩容并重新进行hash计算</p>
<p><code>注意:</code>buckets.size()扩容大小在GCC2.9中并不是一定为2的整数倍，而是2的整数倍附近的质数，初始53</p>
</blockquote>
<p>hashfunc and hashcode</p>
<blockquote>
<p>模板特化完成个类型对象-&gt;size_t类型的转换</p>
<p><code>注意:</code>Gcc2.9中 std模板库并没有提供对<code>hash&lt;std::string&gt;</code>的定义 目前已经有了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>&gt;</span> hash &#123;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Allocators-分配器"><a href="#Allocators-分配器" class="headerlink" title="Allocators 分配器"></a>Allocators 分配器</h2><h3 id="Allocator测试"><a href="#Allocator测试" class="headerlink" title="Allocator测试"></a>Allocator测试</h3><blockquote>
<p>为容器分配内存，不同分配器有不同的分配方式</p>
<p>内部包含一个allocate函数来分配内存，一个deallocate来删除内存并且需要知道起初分配的内存大小</p>
</blockquote>
<h3 id="operator-new-delete-与malloc-free"><a href="#operator-new-delete-与malloc-free" class="headerlink" title="operator new/delete 与malloc/free"></a>operator new/delete 与malloc/free</h3><blockquote>
<p>malloc分配的内存模型</p>
<ul>
<li>一对cookie</li>
<li>一对debug头</li>
<li>struct -size对应的部分</li>
<li>填充字节</li>
</ul>
<p>operator new/delete 的底层实现就是malloc/free</p>
</blockquote>
<h3 id="allocator"><a href="#allocator" class="headerlink" title="allocator"></a>allocator</h3><p>一个类模板,重要的两个函数</p>
<blockquote>
<p>pointer allocator(size_t)</p>
<p>void deallocator(pointer,size_t)</p>
<p>原型并不规范但是值得注意的是一般分配器的deallocator需要知道回收的内存大小才能进行回收，脱离容器直接使用很不方便</p>
</blockquote>
<h3 id="不同编译器对allocator的处理"><a href="#不同编译器对allocator的处理" class="headerlink" title="不同编译器对allocator的处理"></a>不同编译器对allocator的处理</h3><ul>
<li><p>VC6 STL 对allocator的使用与实现</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Visual c++ Builder Compiler</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;xmemory&gt;</span> <span class="comment">// 需要引入对应头文件</span></span></span><br><span class="line"><span class="comment">// VC6+的allocator只是以::operator new和::operator delete完成allocate()和deallocate()，没有任何特殊设计</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">int</span>*p=allocator&lt;<span class="keyword">int</span>&gt;().<span class="built_in">allocator</span>(size,(<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">allocator&lt;<span class="keyword">int</span>&gt;().<span class="built_in">deallocator</span>(p,size);</span><br><span class="line"><span class="comment">// 脱离容器直接使用分配器进行内存分配</span></span><br></pre></td></tr></table></figure>

<p>VC6+的allocator只是以::operator new和::operator delete完成allocate()和deallocate()，没有任何特殊设计</p>
</blockquote>
</li>
<li><p>BC5 STL 对allocator的使用与实现  </p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Borland C++ Builder Compiler</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory.stl&gt;</span> <span class="comment">// 需要引入对应头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">int</span>*p=allocator&lt;<span class="keyword">int</span>&gt;().<span class="built_in">allocator</span>(size); <span class="comment">// 第二个指针参数这里为默认参数省略</span></span><br><span class="line">allocator&lt;<span class="keyword">int</span>&gt;().<span class="built_in">deallocator</span>(p,size);</span><br><span class="line"><span class="comment">// 脱离容器直接使用分配器进行内存分配</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>BC++ 的allocator只是以::operator new和::operator delete完成allocate()和deallocate()，没有任何特殊设计</p>
</blockquote>
</li>
<li><p>GCC2.9</p>
<blockquote>
<p>GCC2.9 的allocator仍只是以::operator new和::operator delete完成allocate()和deallocate()，没有任何特殊设计</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GNU Compiler C++ Builder Compiler</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;defalloc.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>但是GCC2.9库中虽然有allocator但是实际并不使用该类模板做分配器，实际采用的是效率更高的alloc</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stl_alloc.h&gt;</span></span></span><br><span class="line"><span class="comment">// 脱离容器直接使用分配器进行内存分配</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">int</span>*p=alloc::<span class="built_in">allocate</span>(size);</span><br><span class="line">alloc::<span class="built_in">deallocate</span>(p,size);</span><br></pre></td></tr></table></figure>

<p>alloc内存管理</p>
<blockquote>
<p>尽量减少malloc的次数</p>
<p>尽量使得为容器元素分配的内存不带cookie</p>
</blockquote>
<p>具体先略，理解模糊</p>
</blockquote>
</li>
<li><p>GCC4.9</p>
<blockquote>
<p>GCC4.9实际使用的仍是以::operator new和::operator delete完成allocate()和deallocate()</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/allocator.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/new_allocator.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>但是仍然可选择使用GCC2.9的alloc分配器</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span> <span class="comment">// 内含std::allocator</span></span></span><br><span class="line"><span class="comment">// 欲使用std::allocator以外的分配器需要自行#include&lt;ext\...&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// extension allocators 中的__pool_alloc就是GCC2.9的alloc分配器</span></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ext\pool_allocator.h&gt;</span></span></span><br><span class="line">vector&lt;<span class="keyword">int</span>,__gnu_cxx::__pool_alloc&lt;string&gt;&gt; vec;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<h2 id="Iterator-迭代器"><a href="#Iterator-迭代器" class="headerlink" title="Iterator 迭代器"></a>Iterator 迭代器</h2><h3 id="迭代器的设计原则"><a href="#迭代器的设计原则" class="headerlink" title="迭代器的设计原则"></a>迭代器的设计原则</h3><p>至少需要具备5个associated关联类型</p>
<blockquote>
<p>需要回答算法的提问，某些算法中会使用到其中的类型</p>
</blockquote>
<h3 id="Class-iterator"><a href="#Class-iterator" class="headerlink" title="Class iterator"></a>Class iterator</h3><blockquote>
<p>以类封装的iterator可以自己定义associated type</p>
<p>cl_iterator</p>
<blockquote>
<p>模板类内部对关联类型作定义</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cl_iterator</span> &#123;</span></span><br><span class="line">	<span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category; <span class="comment">//迭代器的种类</span></span><br><span class="line">	<span class="comment">//bidirectional为双向链表iterator类型</span></span><br><span class="line">	<span class="keyword">typedef</span> T value_type; <span class="comment">//数据类型</span></span><br><span class="line">	<span class="keyword">typedef</span> Ptr pointer; <span class="comment">//指向node类型的指针</span></span><br><span class="line">	<span class="keyword">typedef</span> Ref reference; <span class="comment">//node类型的引用类型</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type; <span class="comment">//两个迭代器之间距离的类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>algorithm</p>
<blockquote>
<p>直接通过迭代器本身来获取关联类型</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">algorithm</span><span class="params">(I first,I last)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> I::category v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Native-pointer"><a href="#Native-pointer" class="headerlink" title="Native pointer"></a>Native pointer</h3><blockquote>
<p>native pointer是一种退化的iterator，没有能力自己定义associated type</p>
<p>所以algorithm无法直接通过迭代器本身获取关联类型</p>
</blockquote>
<h3 id="Iterator-Triats"><a href="#Iterator-Triats" class="headerlink" title="Iterator Triats"></a>Iterator Triats</h3><blockquote>
<p>”萃取机“以<strong>偏特化</strong>使得以上两种iterator类型均满足设计原则</p>
<p>for cl_iterator</p>
<blockquote>
<p>在已定义cl_cl_iterator迭代器的情况下可直接使用已定义的</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span> &#123;</span></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> T::category iterator_category;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> T::value_type value_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> T::pointer pointer;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> T::reference reference;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> T::difference_type difference_type;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>for native pointer</p>
<blockquote>
<p>区分const pointer与no_const pointer</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//no_const pointer </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span>&lt;</span>T*&gt; &#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="keyword">typedef</span> random_access_iterator_tag iterator_category; <span class="comment">//迭代器的种类</span></span><br><span class="line">	<span class="comment">//bidirectional为双向链表特有iterator类型</span></span><br><span class="line">	<span class="keyword">typedef</span> T value_type; <span class="comment">//数据类型</span></span><br><span class="line">	<span class="keyword">typedef</span> T* pointer; <span class="comment">//指向node类型的指针</span></span><br><span class="line">	<span class="keyword">typedef</span> T&amp; reference; <span class="comment">//node类型的引用类型</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type; <span class="comment">//两个迭代器之间距离的类型</span></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//const pointer特殊在取得的value_type不希望为const T</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span>&lt;</span><span class="keyword">const</span> T*&gt; &#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="keyword">typedef</span> random_access_iterator_tag iterator_category; <span class="comment">//迭代器的种类</span></span><br><span class="line">	<span class="comment">//bidirectional为双向链表特有iterator类型</span></span><br><span class="line">	<span class="keyword">typedef</span> T value_type; <span class="comment">//数据类型</span></span><br><span class="line">	<span class="keyword">typedef</span> T* pointer; <span class="comment">//指向node类型的指针</span></span><br><span class="line">	<span class="keyword">typedef</span> T&amp; reference; <span class="comment">//node类型的引用类型</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type; <span class="comment">//两个迭代器之间距离的类型</span></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>algorithm</p>
<blockquote>
<p>通过”萃取机”来间接获取迭代器的关联类型</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>,...&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">algorithm</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">typedef</span> iterator_traits&lt;I&gt;::category v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight plain"><figcaption><span>typename 后面声明的字符串作类型处理</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## Algorithm - STL中的算法</span><br><span class="line"></span><br><span class="line">&gt; function template</span><br><span class="line">&gt;</span><br><span class="line">&gt; Algogithms 对 Containers进行操作，必须由Iterators提供容器的一些性质信息，而Iterators也必须能够回答算法的这些提问</span><br><span class="line"></span><br><span class="line">### Iterator_category</span><br><span class="line"></span><br><span class="line">#### 五大迭代器种类以及继承关系</span><br><span class="line"></span><br><span class="line">&gt; struct input_iterator_tag</span><br><span class="line">&gt;</span><br><span class="line">&gt; -</span><br><span class="line">&gt;</span><br><span class="line">&gt; struct forward_iterator_tag : input_iterator_tag</span><br><span class="line">&gt;</span><br><span class="line">&gt; struct bidirectional_iterator_tag :  forward_iterator_tag</span><br><span class="line">&gt;</span><br><span class="line">&gt; struct random_acess_iterator_tag : bidirectional_iterator_tag</span><br><span class="line">&gt;</span><br><span class="line">&gt; -</span><br><span class="line">&gt;</span><br><span class="line">&gt; struct output_iterator_tag</span><br><span class="line">&gt;</span><br><span class="line">&gt; &gt; write-only 不允许使用该迭代器读取数据</span><br><span class="line"></span><br><span class="line">#### 类型名称</span><br><span class="line"></span><br><span class="line">&gt; &#96;&#96;&#96;c++ </span><br><span class="line">&gt; #include&lt;typeinfo&gt;</span><br><span class="line">&gt; typeid(iterator).name()  &#x2F;&#x2F;获得对应迭代器的类型名称</span><br><span class="line">&gt; &#x2F;&#x2F;不同编译环境下有不同的类型名称，不过核心部分相同，一些编号不同</span><br></pre></td></tr></table></figure>

<h4 id="容器的迭代器种类"><a href="#容器的迭代器种类" class="headerlink" title="容器的迭代器种类"></a>容器的迭代器种类</h4><blockquote>
<p>input_iterator_tag</p>
<blockquote>
<p>iostream</p>
</blockquote>
<p>-</p>
<p>forward_iterator_tag</p>
<blockquote>
<p>hashtable</p>
<p>单向链表forward_list</p>
</blockquote>
<p>bidirectional_iterator_tag</p>
<blockquote>
<p>rb_tree</p>
<p>双向链表list</p>
</blockquote>
<p>random_acess_iterator_tag</p>
<blockquote>
<p>array</p>
<p>vector</p>
<p>deque</p>
</blockquote>
<p>-</p>
<p>output_iterator_tag</p>
<blockquote>
<p>ostream</p>
</blockquote>
</blockquote>
<h4 id="Iterator-category对Algorithm的影响"><a href="#Iterator-category对Algorithm的影响" class="headerlink" title="Iterator_category对Algorithm的影响"></a>Iterator_category对Algorithm的影响</h4><blockquote>
<p><strong>distance</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//distance 计算两个迭代器之间的距离</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">iterator</span>&gt;</span></span><br><span class="line">iterator_traits&lt;iterator&gt;::<span class="function">difference_type <span class="title">distance</span><span class="params">(iterator ite1,iterator ite2)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;iterator&gt;::iterator_category category; <span class="comment">//获取category类型</span></span><br><span class="line"> <span class="comment">//通过__distance完成对类型不同迭代器的distance操作，需要传入临时类型对象</span></span><br><span class="line"> <span class="keyword">return</span> __distance(ite1,ite2,<span class="built_in">category</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">iterator</span>&gt;</span></span><br><span class="line">iterator_traits&lt;iterator&gt;::difference_type __distance(iterator ite1,iterator ite2,random_access_iterator_tag) &#123;</span><br><span class="line"> <span class="keyword">return</span> ite2 - ite1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">iterator</span>&gt;</span></span><br><span class="line">iterator_traits&lt;iterator&gt;::difference_type __distance(iterator ite1,input_iterator) &#123;</span><br><span class="line"> <span class="keyword">typename</span> iterator_traits&lt;iterator&gt;::difference_type n = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">while</span>(ite1 != ite2) &#123;</span><br><span class="line">     ite++;</span><br><span class="line">     n++;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>advance</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//advance 移动指针</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">iterator</span>,<span class="keyword">class</span> <span class="title">distance</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">advance</span><span class="params">(iterator&amp; ite,distance dis)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;iterator&gt;::iterator_category category; <span class="comment">//获取category类型</span></span><br><span class="line"> <span class="comment">//通过__advance完成对类型不同迭代器的advance操作，需要传入临时类型对象</span></span><br><span class="line"> <span class="keyword">return</span> __advance(ite,dis,<span class="built_in">category</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">iterator</span>,<span class="keyword">class</span> <span class="title">distance</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">advance</span><span class="params">(iterator&amp; ite,distance dis,input_iterator)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(--n) &#123;</span><br><span class="line">     ite++;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">iterator</span>,<span class="keyword">class</span> <span class="title">distance</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">advance</span><span class="params">(iterator&amp; ite,distance dis,bidirectional_iterator_tag)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n&gt;<span class="number">0</span>) &#123;</span><br><span class="line">     <span class="keyword">while</span>(--n) &#123;</span><br><span class="line">     ite++;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">while</span>(++n) &#123;</span><br><span class="line">     ite--;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">iterator</span>,<span class="keyword">class</span> <span class="title">distance</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">advance</span><span class="params">(iterator ite,distance dis,random_access_iterator_tag)</span> </span>&#123;</span><br><span class="line">	ite += dis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>注意:</code>算法只能够<strong>暗示</strong>该算法需要接收的模板迭代器类型，无法控制或者说限制调用时传入的模板类型</p>
</blockquote>
<h3 id="算法部分源码剖析"><a href="#算法部分源码剖析" class="headerlink" title="算法部分源码剖析"></a>算法部分源码剖析</h3><p><strong>accumulate</strong> </p>
<blockquote>
<p>累积运算 将指定范围的数据进行累积运算并将结果返回</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span> <span class="comment">//std::accumulate</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span>&lt;</span><span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>,<span class="keyword">class</span> <span class="title">T</span>,<span class="keyword">class</span> <span class="title">BinaryOperator</span>&gt;</span></span><br><span class="line"><span class="function">T <span class="title">accumulate</span><span class="params">(InputIterator first,InputIterator last,T init,BinaryOperator binary_op)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;first!=last;first++) &#123;</span><br><span class="line">        init = <span class="built_in">binary_op</span>(init,*first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> init;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="keyword">int</span> init = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> num[] = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;;</span><br><span class="line"><span class="built_in">accumulate</span>(num,num+<span class="number">3</span>,init);</span><br><span class="line"></span><br><span class="line"><span class="comment">//binary_op可以传入函数入口地址，或者仿函数对象，或者不传入使用默认的二元操作函数plus&lt;&gt;();</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>for_each</strong></p>
<blockquote>
<p>遍历操作 将指定指定范围的每个数据进行相同操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span> <span class="comment">//std::for_each</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>,<span class="keyword">class</span> <span class="title">Function</span>&gt;</span></span><br><span class="line"><span class="function">Function <span class="title">for_each</span><span class="params">(InputIterator first,InputIterator last,Function f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;first!=last;++first) &#123;</span><br><span class="line">        <span class="built_in">f</span>(*first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>replace,replace_if,replace_copy</strong></p>
<blockquote>
<p>对指定指定范围内的数据进行<strong>替代与拷贝</strong></p>
<p>replace 指定范围的数据使用新值替代指定的旧值</p>
<p>replace_if 指定范围的数据满足条件的替换 需要传入一个可返回true/false的函数对象</p>
<p>replace_copy 对指定范围的数据进行拷贝，等于指定值时使用新值替代否则原样拷贝</p>
</blockquote>
<p><strong>count,count_if</strong></p>
<blockquote>
<p>对指定指定范围内的数据进行<strong>计数</strong></p>
<p>count 计数等于指定值的元素个数</p>
<p>count_if 计数满足指定条件的元素个数</p>
<p>序列容器没有内置的count,count_if函数重载</p>
<p>关联式容器内置有对count,count_if函数的重载</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//count</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>,<span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::<span class="function">difference_type <span class="title">count</span><span class="params">(InputIterator first,InputIterator last,<span class="keyword">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::difference_type n = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span>(;first!=last;++first) &#123;</span><br><span class="line">     <span class="keyword">if</span>(*first==value) &#123;</span><br><span class="line">         n++;</span><br><span class="line">     &#125;</span><br><span class="line"> <span class="keyword">return</span> n;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//count_if</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>,<span class="keyword">class</span> <span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::<span class="function">difference_type <span class="title">count_if</span><span class="params">(InputIterator first,InputIterator last,Predicate pre)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::difference_type n = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span>(;first!=last;++first) &#123;</span><br><span class="line">     <span class="keyword">if</span>(<span class="built_in">pre</span>(*<span class="keyword">this</span>)) &#123;</span><br><span class="line">         n++;</span><br><span class="line"> 	&#125;</span><br><span class="line"> <span class="keyword">return</span> n;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</blockquote>
<p><strong>find,find_if</strong></p>
<blockquote>
<p>对指定指定范围内的数据进行<strong>循序式查找</strong></p>
<p>find 查找等于指定值的元素</p>
<p>find_if 查找满足指定条件的元素 </p>
<p>序列容器没有内置的find,find_if函数重载</p>
<p>关联式容器内置有对find,find_if函数的重载</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//find</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>,<span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function">InputIterator <span class="title">find</span><span class="params">(InputIterator first,InputIterator last,<span class="keyword">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">for</span>(;first!=last;++first) &#123;</span><br><span class="line">     <span class="keyword">if</span>(*first==value) &#123;</span><br><span class="line">         <span class="keyword">return</span> first;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//find_if</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>,<span class="keyword">class</span> <span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="function">InputIterator <span class="title">find_if</span><span class="params">(InputIterator first,InputIterator last,Predicate pre)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"> <span class="keyword">for</span>(;first!=last;++first) &#123;</span><br><span class="line">     <span class="keyword">if</span>(<span class="built_in">pre</span>(*<span class="keyword">this</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span> first;</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>sort</strong></p>
<blockquote>
<p>对指定指定范围内的数据进行<strong>排序</strong></p>
<blockquote>
<p>暗示要求的迭代器类型为random_acess_iterator_tag，所以其他容器无法调用该方法</p>
</blockquote>
<p>list,forward_list内置有对sort函数的重载</p>
<p>其余容器没有内置的sort函数重载</p>
<blockquote>
<p>关联容器内的元素已经是”有序”的不要再去调用sort排序了</p>
</blockquote>
</blockquote>
<p><strong>binary_search</strong></p>
<blockquote>
<p>对指定指定范围内的<strong>有序</strong>数据进行<strong>二分查找</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//内部实际为调用lower_bound/upper_bound</span></span><br><span class="line"><span class="comment">//lower_bound(first,last,val); 返回不违反当前排序状态的情况下val能插入的最低点</span></span><br><span class="line"><span class="comment">//upper_bound(first,last,val); 返回不违反当前排序状态的情况下val能插入的最高点</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>,<span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">binary_search</span><span class="params">(ForwardIterator first,ForwardIterator last,<span class="keyword">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">	first = <span class="built_in">lower_bound</span>(first,last,value);</span><br><span class="line">    <span class="keyword">return</span> (first!=last &amp;&amp; !(val&lt;*first))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Functors-仿函数"><a href="#Functors-仿函数" class="headerlink" title="Functors 仿函数"></a>Functors 仿函数</h2><blockquote>
<p>只为算法服务，提供规范标准</p>
</blockquote>
<h4 id="STL标准库中Functors的基本种类"><a href="#STL标准库中Functors的基本种类" class="headerlink" title="STL标准库中Functors的基本种类"></a>STL标准库中Functors的基本种类</h4><blockquote>
<p><strong>算数类</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//+</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">plus</span>:</span><span class="keyword">public</span> binary_function&lt;T,T,T&gt; &#123;</span><br><span class="line">    <span class="function">T <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>逻辑运算类</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//&amp;&amp;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">logic_and</span>:</span><span class="keyword">public</span> binary_function&lt;T,T,T&gt; &#123;</span><br><span class="line">    <span class="function">T <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp;&amp; y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>相对关系类</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//==</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">equal_to</span>:</span><span class="keyword">public</span> binary_function&lt;T,T,<span class="keyword">bool</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x == y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="GNU-C-独有的Functors的种类"><a href="#GNU-C-独有的Functors的种类" class="headerlink" title="GNU C++独有的Functors的种类"></a>GNU C++独有的Functors的种类</h4><blockquote>
<p><strong>keyofvalue</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// identity</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">identity</span> :</span><span class="keyword">public</span> unary_function&lt;T, T&gt; &#123;</span><br><span class="line">	<span class="function"><span class="keyword">const</span> T&amp; <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> T&amp; x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x; <span class="comment">//其实x这里传入的是value，再由value取key</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//selectlst</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="function">struct <span class="title">pair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">pair</span>():<span class="built_in">first</span>(<span class="built_in">T1</span>()),<span class="built_in">second</span>(<span class="built_in">T2</span>())&#123;&#125;</span><br><span class="line">    <span class="built_in">pair</span>(<span class="keyword">const</span> T1&amp; a,<span class="keyword">const</span> T2&amp; b):<span class="built_in">first</span>(a),<span class="built_in">second</span>(b)&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">typedef</span> T1 first_type;</span><br><span class="line">    <span class="keyword">typedef</span> T2 second_type;</span><br><span class="line">    </span><br><span class="line">    T1 first;</span><br><span class="line">    T2 second;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">selectlst</span> :</span> unary_function&lt;Pair, <span class="keyword">typename</span> Pair::first_type&gt; &#123;</span><br><span class="line">	<span class="function"><span class="keyword">const</span> <span class="keyword">typename</span> Pair::first_type&amp; <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> Pair&amp; x)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> x.first;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="Functors的可适配-adaptable-条件"><a href="#Functors的可适配-adaptable-条件" class="headerlink" title="Functors的可适配(adaptable)条件"></a>Functors的可适配(adaptable)条件</h4><blockquote>
<p>Functors必须继承unary_function或者binary_function中的一个</p>
<p>因为父类中typedef的类型会被适配器提问到</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//运算只有一个操作数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Arg</span>,<span class="keyword">class</span> <span class="title">Result</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">unary_function</span> &#123;</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">typedef</span> Arg argument_type;</span><br><span class="line"> <span class="keyword">typedef</span> Result result_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运算具有两个操作数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Arg1</span>,<span class="keyword">class</span> <span class="title">Arg2</span>,<span class="keyword">class</span> <span class="title">Result</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binary_function</span> &#123;</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">typedef</span> Arg1 first_argument_type;</span><br><span class="line"> <span class="keyword">typedef</span> Arg2 second_argument_type;</span><br><span class="line"> <span class="keyword">typedef</span> Result result_type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Adapter-适配器"><a href="#Adapter-适配器" class="headerlink" title="Adapter 适配器"></a>Adapter 适配器</h2><blockquote>
<p>复合 + “改造”</p>
</blockquote>
<h4 id="Container-Adapters"><a href="#Container-Adapters" class="headerlink" title="Container Adapters"></a>Container Adapters</h4><blockquote>
<p>复合了底层容器的”容器”</p>
</blockquote>
<p><strong>Stack,Queue</strong></p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//stack</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="keyword">class</span> <span class="title">Sequence</span>=</span>deque&lt;T&gt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">stack</span>&#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> Sequence::value_type value_type</span><br><span class="line">    <span class="keyword">typedef</span> Sequence::size_type size_type</span><br><span class="line">    <span class="keyword">typedef</span> Sequence::reference reference</span><br><span class="line">    <span class="keyword">typedef</span> Sequence::const_reference const_reference</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Sequence c;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">empty</span>();&#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="keyword">return</span> c.<span class="built_in">size</span>();&#125;</span><br><span class="line">    <span class="function">reference <span class="title">top</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">back</span>();&#125;</span><br><span class="line">    <span class="function">const_reference <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">back</span>();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> value_type&amp; x)</span> </span>&#123;c.<span class="built_in">push_back</span>(x);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;c.<span class="built_in">pop_back</span>();&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//queue</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="keyword">class</span> <span class="title">Sequence</span>=</span>deque&lt;T&gt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">queue</span>&#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> Sequence::value_type value_type</span><br><span class="line">    <span class="keyword">typedef</span> Sequence::size_type size_type</span><br><span class="line">    <span class="keyword">typedef</span> Sequence::reference reference</span><br><span class="line">    <span class="keyword">typedef</span> Sequence::const_reference const_reference</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Sequence c;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">empty</span>();&#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="keyword">return</span> c.<span class="built_in">size</span>();&#125;</span><br><span class="line">    <span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">front</span>();&#125;</span><br><span class="line">    <span class="function">const_reference <span class="title">front</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">front</span>();&#125;</span><br><span class="line">    <span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">back</span>();&#125;</span><br><span class="line">    <span class="function">const_reference <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">back</span>();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> value_type&amp; x)</span> </span>&#123;c.<span class="built_in">push_back</span>(x);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;c.<span class="built_in">pop_front</span>();&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="Functor-Adapters"><a href="#Functor-Adapters" class="headerlink" title="Functor Adapters"></a>Functor Adapters</h4><blockquote>
<p>复合了底层Functor的”Functor”,本身也具有原Functor的性质，只不过叫成了Functor Adapters</p>
</blockquote>
<p><strong>binder2nd</strong></p>
<blockquote>
<p>绑定二元操作functor的第二个参数为指定值</p>
<p>实际为一个一元操作符的Functor</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//count_if</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>,<span class="keyword">class</span> <span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::<span class="function">difference_type <span class="title">count_if</span><span class="params">(InputIterator first,InputIterator last,Predicate pre)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::difference_type n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;first!=last;++first) &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">pre</span>(*<span class="keyword">this</span>)) &#123;</span><br><span class="line">n++;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="keyword">int</span> n = <span class="built_in">count_if</span>(v1.first,v1.last,<span class="built_in">bind2nd</span>(less&lt;<span class="keyword">int</span>&gt;(),<span class="number">40</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//bind2nd&lt;&gt;</span></span><br><span class="line"><span class="comment">//辅助函数 用于使用更为简易的参数创建并返回binder2nd&lt;Operation&gt;适配器对象</span></span><br><span class="line"><span class="comment">//创建binder2nd&lt;&gt;对象的类型参数为functor类型，但是普通用户很难知道摸个functor的类型是什么</span></span><br><span class="line"><span class="comment">//对于函数模板,编译器会根据实参传入的对象推断其类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>&lt;</span><span class="class"><span class="keyword">class</span> <span class="title">Operation</span>,<span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">typename</span> binder2nd&lt;Operation&gt; <span class="title">bind2nd</span><span class="params">(<span class="keyword">const</span> Operation&amp; op,<span class="keyword">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">tydef <span class="keyword">typename</span> Operation::second_type arg2_type;</span><br><span class="line"><span class="keyword">return</span> binder2nd&lt;Operation&gt;(op,<span class="built_in">arg2_type</span>(x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//binder2nd&lt;&gt;</span></span><br><span class="line"><span class="comment">//为了使该适配器也是adaptable的可是配的，因此该适配器也要继承对应父类模板，来回答问题</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>&lt;</span><span class="class"><span class="keyword">class</span> <span class="title">Operation</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder2nd</span>:</span><span class="keyword">public</span> unary_function&lt;<span class="keyword">typename</span> Operation::first_argument_type,<span class="keyword">typename</span> Operation::result_type&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">binder2nd</span>(<span class="keyword">const</span> Operation&amp; x,<span class="keyword">typename</span> Operation::second_argument_type y):<span class="built_in">op</span>(x),<span class="built_in">value</span>(y)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typename</span> Operation::result_type <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">typename</span> Operation::first_argument_type&amp; x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">op</span>(x,value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">Operation op;</span><br><span class="line"><span class="comment">//使用value记录用于原functor的需要绑定的参数</span></span><br><span class="line"><span class="keyword">typename</span> Operation::second_argument_type value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>not1</strong></p>
<blockquote>
<p>取否</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//count_if</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>,<span class="keyword">class</span> <span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::<span class="function">difference_type <span class="title">count_if</span><span class="params">(InputIterator first,InputIterator last,Predicate pre)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::difference_type n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;first!=last;++first) &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">pre</span>(*<span class="keyword">this</span>)) &#123;</span><br><span class="line">n++;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="keyword">int</span> n = <span class="built_in">count_if</span>(c1.first,c1.last,<span class="built_in">not1</span>(<span class="built_in">bind2nd</span>(less&lt;<span class="keyword">int</span>&gt;(),<span class="number">40</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">//not1</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="function">unary_negate&lt;Predicate&gt; <span class="title">count_if</span><span class="params">(<span class="keyword">const</span> Predicate&amp; pre)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unary_negate&lt;Predicate&gt;(pre);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">unary_negate</span>:</span><span class="keyword">public</span> unary_function&lt;<span class="keyword">typename</span> Predicate::first_argument_type,<span class="keyword">bool</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//单个参数的为了禁止隐式转换而是用explicit修饰符</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">unary_negate</span><span class="params">(<span class="keyword">const</span> Predicate&amp; pre)</span>:op(pre)&#123;</span>&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Predicate op;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">typename</span> Predicate::first_argument_type&amp; x)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> !<span class="built_in">op</span>(x);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>bind</strong></p>
<blockquote>
<p>c++11提供的新型适配器</p>
<p>std::bind可以绑定</p>
<ul>
<li>functions</li>
<li>function objects</li>
<li>member functions _1必须是某个object地址</li>
<li>data members _1必须是某个object地址</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholder; <span class="comment">//adds visibility of _1,_2 占位符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n = <span class="built_in">count_if</span>(v1.first,v1.last,<span class="built_in">bind2nd</span>(less&lt;<span class="keyword">int</span>&gt;(),<span class="number">40</span>));</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">auto</span> fn_ = <span class="built_in">bind</span>(less&lt;<span class="keyword">int</span>&gt;(),_1,<span class="number">40</span>);</span><br><span class="line"><span class="keyword">int</span> n = <span class="built_in">count_if</span>(v1.first,v1.last,fn_);</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="Iterator-Adapters"><a href="#Iterator-Adapters" class="headerlink" title="Iterator Adapters"></a>Iterator Adapters</h4><p><strong>Reverse_iterator</strong></p>
<blockquote>
<p>逆向”迭代器”</p>
<p>rbegin(); 返回指向正向容器尾元素的迭代器</p>
<p>rend(); 返回指向正向容器首元素上一个位置的迭代器</p>
<p>++实现从rbegin() -&gt; rend()的遍历</p>
<p><img src="/images/C++/image-20210711194134888.png" alt="image-20210711194134888"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//reverse_iterator为适配器</span></span><br><span class="line"><span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">reverse_iterator</span>(<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">reverse_iterator</span>(<span class="built_in">begin</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">reverse_iterator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="comment">//为了使该适配器仍可适配-改造 仍需要具备迭代器基本的5个关联类型</span></span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::iterator_category category;</span><br><span class="line">   	<span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::value_type value_type; <span class="comment">//数据类型</span></span><br><span class="line">   	<span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::pointer pointer; <span class="comment">//指向node类型的指针</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::reference reference; <span class="comment">//node类型的引用类型</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::difference_type difference_type; <span class="comment">//两个迭代器之间距离的类型</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">typedef</span> Iterator iterator_type;</span><br><span class="line">     <span class="keyword">typedef</span> reverse_iterator&lt;Iterator&gt; self;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//可使用正向迭代器初始化逆向迭代器也可使用逆向迭代器初始化</span></span><br><span class="line"> <span class="built_in">reverse_iterator</span>(<span class="keyword">const</span> Iterator&amp; x):<span class="built_in">current</span>(x)&#123;&#125;</span><br><span class="line">    <span class="built_in">reverse_iterator</span>(<span class="keyword">const</span> self&amp; x):<span class="built_in">current</span>(x.current)&#123;&#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//取出相应的正向迭代器</span></span><br><span class="line">     <span class="function">iterator_type <span class="title">base</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> current;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//逆向迭代器返回对应正向迭代器的前一位的值</span></span><br><span class="line">     reference <span class="keyword">operator</span>*() <span class="keyword">const</span>&#123;</span><br><span class="line">        self temp = current;</span><br><span class="line">        <span class="keyword">return</span> *--temp;</span><br><span class="line">    &#125;</span><br><span class="line">    pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*())</span><br><span class="line">    &#125;</span><br><span class="line">    self&amp; <span class="keyword">operator</span>++()&#123;</span><br><span class="line">        --current;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    self&amp; <span class="keyword">operator</span>--() &#123;</span><br><span class="line">        ++current;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    self <span class="keyword">operator</span>+(<span class="keyword">const</span> value_type&amp; x) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">self</span>(current - x);</span><br><span class="line">    &#125;</span><br><span class="line">    self <span class="keyword">operator</span>-(<span class="keyword">const</span> value_type&amp; x) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">self</span>(current + x);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">    Iterator current;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>inserter</strong></p>
<p>copy</p>
<blockquote>
<p>a copy to b<br><code>copy(a.begin(),a.end(),b.begin());</code></p>
<p>参数12指定a中copy的范围 </p>
<p>参数3指定指向目的内存的起始迭代器</p>
<p>但是参数3为默认迭代器时必须保证b有充足的内存空间因为copy底层为逐个元素的赋值操作</p>
</blockquote>
<p>inserter适配器</p>
<blockquote>
<p>inserter适配器对迭代器的赋值操作进行了重载，使赋值操作包含insert方法</p>
<p>看似赋值实则插入</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//inserter</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Container</span>,<span class="keyword">class</span> <span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="function">insert_iterator&lt;Container&gt; <span class="title">inserter</span><span class="params">(<span class="keyword">const</span> Container&amp; x,<span class="keyword">const</span> Iterator&amp; y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Container::iterator iter;</span><br><span class="line">    <span class="comment">//需要对传入的迭代器类型进行校验，进行类型转型，失败则提早停止预防运行出错</span></span><br><span class="line">    <span class="keyword">return</span> insert_iterator&lt;Container&gt;(x,<span class="built_in">iter</span>(y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Container</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">insert_iterator</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">insert_iterator</span>(Container&amp; x,<span class="keyword">const</span> <span class="keyword">typename</span> Container::iterator i):<span class="built_in">container</span>(&amp;x),<span class="built_in">ite</span>(i)&#123;&#125;</span><br><span class="line">    <span class="keyword">typedef</span> output_iterator_tag iterator_type;</span><br><span class="line">    </span><br><span class="line">    insert_iterator&lt;Container&gt;&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> Container::value_type&amp; x) &#123;</span><br><span class="line">        ite = container -&gt; <span class="built_in">insert</span>(ite,x);</span><br><span class="line">        ++ite;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Container* container;</span><br><span class="line">    <span class="keyword">typename</span> Container::iterator ite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="X适配器"><a href="#X适配器" class="headerlink" title="X适配器"></a>X适配器</h4><p><strong>ostream_iterator</strong></p>
<p>绑定cout输出流对象,在执行copy操作时可以将被copy的元素输出</p>
<blockquote>
<p>啥也不是，就一个有赋值运算符重载的一个玩意儿</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="keyword">class</span> <span class="title">charT</span>=</span><span class="keyword">char</span>,<span class="class"><span class="keyword">class</span> <span class="title">traits</span>=</span>char_traits&lt;charT&gt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ostream_iterator</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">	<span class="keyword">typedef</span> basic_ostream&lt;charT, traits&gt; ostream_type;</span><br><span class="line">	<span class="keyword">typedef</span> charT char_type;</span><br><span class="line">	<span class="keyword">typedef</span> traits traits_type;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">ostream_iterator</span>(ostream_type&amp; s) :<span class="built_in">out_stream</span>(&amp;s), <span class="built_in">delim</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">	<span class="built_in">ostream_iterator</span>(ostream_type&amp; s,<span class="keyword">const</span> charT* delimm) :<span class="built_in">out_stream</span>(&amp;s), <span class="built_in">delim</span>(delimm) &#123;&#125;</span><br><span class="line">	<span class="built_in">ostream_iterator</span>(<span class="keyword">const</span> ostream_iterator&lt;T&gt;&amp; x):<span class="built_in">out_stream</span>(x.out_stream), <span class="built_in">delim</span>(x.delim) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">ostream_iterator</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">	ostream_iterator&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> T&amp; value) &#123;</span><br><span class="line">		*out_stream &lt;&lt; value;</span><br><span class="line">		<span class="keyword">if</span> (delim != <span class="number">0</span>) &#123;</span><br><span class="line">			*out_stream &lt;&lt; delim;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ostream_iterator&lt;T&gt;&amp; <span class="keyword">operator</span>*() &#123;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ostream_iterator&lt;T&gt;&amp; <span class="keyword">operator</span>++ () &#123;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ostream_iterator&lt;T&gt;&amp; <span class="keyword">operator</span>++ (<span class="keyword">int</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">//内含指向标准输出流对象的指针和分隔符的记录</span></span><br><span class="line">	basic_ostream&lt;charT, traits&gt;* out_stream;</span><br><span class="line">	<span class="keyword">const</span> charT* delim;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="function">ostream_iterator&lt;<span class="keyword">int</span>&gt; <span class="title">out</span><span class="params">(cout, <span class="string">&quot;,&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">copy</span>(v.begin, v.end, out);</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>istream_iterator</strong></p>
<p>绑定cin输入流对象</p>
<blockquote>
<p>当创建istream_iterator&lt;&gt;对象时已经在读取数据了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; c&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">istream_iterator&lt;int&gt; iit(cin),eos; //读取用户输入的数据</span><br><span class="line"><span class="comment">//eos 未绑定输入流对象输入做结束标志用</span></span><br><span class="line"><span class="built_in">copy</span>(iit,eos,<span class="built_in">inserter</span>(c,c.<span class="built_in">begin</span>())); <span class="comment">//将用户输入的数据插入到指定容器中去</span></span><br><span class="line"><span class="comment">//同样也需要对=,++,*做重载操作</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="STL-Surround"><a href="#STL-Surround" class="headerlink" title="STL Surround"></a>STL Surround</h1><h2 id="hash-function"><a href="#hash-function" class="headerlink" title="hash function"></a>hash function</h2><h3 id="两大型式"><a href="#两大型式" class="headerlink" title="两大型式"></a>两大型式</h3><p>functor</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomerHash</span> &#123;</span></span><br><span class="line">    <span class="function">size_type <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Customer&amp; Customer)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ...;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">unorderedset&lt;Customer,CustomerHash&gt; cus;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>function</p>
<blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="function">size_type <span class="title">CustomerHash</span><span class="params">(<span class="keyword">const</span> Customer&amp; Customer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ...;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">unorderedset&lt;Customer,size_type(*)(const Customer&amp;)&gt; cus(20,CustomerHash);  </span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="An-universal-hash-function"><a href="#An-universal-hash-function" class="headerlink" title="An universal hash function"></a>An universal hash function</h3><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::hash&lt;datatype&gt;()(data) </span><br></pre></td></tr></table></figure>

<p>目前标准库中已经有了用于每种基本类型的hashcode计算functor</p>
<p>而对于自定义对象的hashcode计算不能仅仅为各数据成员的hashcode计算值之和</p>
<p>通过<strong>可变类型参数</strong>实现hash_val的参数类型与参数数量的任意</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span> <span class="comment">//引入相应的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomerHash</span> &#123;</span></span><br><span class="line">	<span class="function">std::<span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Customer&amp; c)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">hash_val</span>(c.first, c.second, c.third);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算hashcode的函数模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hash_combine</span><span class="params">(std::<span class="keyword">size_t</span>&amp; seed, <span class="keyword">const</span> T&amp; val)</span> </span>&#123;</span><br><span class="line">	seed ^= std::hash&lt;T&gt;()(val) + <span class="number">0x9e3779b9</span> + (seed &lt;&lt; <span class="number">6</span>) + (seed &gt;&gt; <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//辅助接口函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;class... Types&gt;</span><br><span class="line"><span class="function">std::<span class="keyword">size_t</span> <span class="title">hash_val</span><span class="params">(<span class="keyword">const</span> Types&amp;... args)</span> </span>&#123;</span><br><span class="line">	std::<span class="keyword">size_t</span> seed = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">hash_val</span>(seed, args...);</span><br><span class="line">	<span class="keyword">return</span> seed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span>... <span class="title">Types</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hash_val</span><span class="params">(std::<span class="keyword">size_t</span>&amp; seed, <span class="keyword">const</span> T&amp; val, <span class="keyword">const</span> Types&amp;... args)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">hash_combine</span>(seed, val);</span><br><span class="line">	<span class="built_in">hash_val</span>(seed, args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hash_val</span><span class="params">(std::<span class="keyword">size_t</span>&amp; seed, <span class="keyword">const</span> T&amp; val)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">hash_combine</span>(seed, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h2><blockquote>
<p>元组 不同数据类型数据的组合</p>
</blockquote>
<h3 id="Interface-testing"><a href="#Interface-testing" class="headerlink" title="Interface testing"></a>Interface testing</h3><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//tuple对象的创建</span></span><br><span class="line">tuple&lt;string, int, int&gt; t(&quot;123&quot;,10,11);</span><br><span class="line"><span class="keyword">auto</span> t2 = <span class="built_in">make_tuple</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象成员的获取</span></span><br><span class="line"><span class="comment">//get&lt;num&gt;(tuple_obj) num为从0开始的序号索引 </span></span><br><span class="line"><span class="keyword">int</span> i = get&lt;<span class="number">1</span>&gt;(t);</span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line">string c;</span><br><span class="line"></span><br><span class="line"><span class="comment">//tie(args...) = tuple_obj 元素绑定</span></span><br><span class="line"><span class="comment">//实现用args参数&quot;绑定&quot;tuple中的元素 赋值性的绑定 即绑定后值变化互不影响</span></span><br><span class="line"><span class="built_in">tie</span>(c, a, b) = t;</span><br><span class="line"><span class="comment">//eg:</span></span><br><span class="line">get&lt;<span class="number">0</span>&gt;(t) = <span class="string">&quot;5&quot;</span>;</span><br><span class="line">cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"><span class="comment">//结果仍为123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//stl中tuple对运算符的重载</span></span><br><span class="line"><span class="comment">//t &lt; t2</span></span><br><span class="line"><span class="comment">//t = t2;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取tuple中元素个数</span></span><br><span class="line"><span class="keyword">typedef</span> tuple&lt;string, <span class="keyword">int</span>, <span class="keyword">int</span> TupleType</span><br><span class="line">cout &lt;&lt; tuple_size&lt;TupleType&gt;::value &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取某个元素的类型</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取tuple的head元素</span></span><br><span class="line">string s = t.<span class="built_in">head</span>(); <span class="comment">// s=&quot;123&quot;</span></span><br><span class="line"><span class="comment">//获取tuple的tail部分tuple对象</span></span><br><span class="line"><span class="keyword">auto</span> tail = t.<span class="built_in">tail</span>(); <span class="comment">// tail = tuple&lt;int, int&gt; t(10,11)</span></span><br><span class="line"><span class="comment">//获取tail的head元素</span></span><br><span class="line"><span class="keyword">int</span> se = tail.<span class="built_in">head</span>();</span><br><span class="line"><span class="comment">//值得注意的是head(),tail()在c++17中不再使用该名称</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Internal-structure-G4-8"><a href="#Internal-structure-G4-8" class="headerlink" title="Internal structure - G4.8"></a>Internal structure - G4.8</h3><blockquote>
<p>通过可变类型参数<strong>可动态拆分</strong>特性而构建的一个继承体系结构</p>
<p>即每一个数据类型的数据单独封装为一个类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//tuple对象的创建</span></span><br><span class="line">tuple&lt;int, float, string&gt; t(41,6.3,&quot;nico&quot;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//tuple</span></span><br><span class="line"><span class="comment">//通过可变参数的可动态拆分特性递归实现继承体系</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Head</span>,<span class="title">class</span>... <span class="title">Tail</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tuple</span>&lt;</span>Head,Tail...&gt; : <span class="keyword">private</span> tuple&lt;Tail...&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> tuple&lt;Tail...&gt; inherited;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">tuple</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">tuple</span>(<span class="keyword">const</span> Head&amp; a,<span class="keyword">const</span> Tail&amp;... args):<span class="built_in">m_head</span>(a),<span class="built_in">inherited</span>(args...)&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回tuple对象的head元素</span></span><br><span class="line">    <span class="function">Head <span class="title">head</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过上转型为父类类型截断本类数据</span></span><br><span class="line">    <span class="comment">//返回不含m_head的含tail部分的tuple对象</span></span><br><span class="line">    <span class="function">inherited&amp; <span class="title">tail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Head m_head;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当递归至父类为tuple&lt;&gt;时作停止递归的处理</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tuple</span>&lt;</span>&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>继承图示</p>
<p><img src="/.com//Users\YunDid\AppData\Roaming\Typora\typora-user-images\image-20210712164552782.png" alt="image-20210712164552782"></p>
</blockquote>
<h2 id="Type-triats"><a href="#Type-triats" class="headerlink" title="Type triats"></a>Type triats</h2><blockquote>
<p>它所提供的判断功能，在<strong>编译期间</strong>可以检查出是否是正确的类型，以便能编写更为安全的代码。</p>
</blockquote>
<h3 id="Interface-testing-1"><a href="#Interface-testing-1" class="headerlink" title="Interface testing"></a>Interface testing</h3><p><strong>G2.9</strong></p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//询问</span></span><br><span class="line">__type_traits&lt;<span class="keyword">int</span>&gt;::has_trivial_copy_constructor <span class="comment">//return 0/1</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>C++11</strong></p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//询问</span></span><br><span class="line">is_copy_constructible&lt;T&gt;::value <span class="comment">//return 0/1</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Structure-G2-9"><a href="#Structure-G2-9" class="headerlink" title="Structure G2.9"></a>Structure G2.9</h3><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可以询问萃取机对应类型的某些性质类型从而做出判断</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">type_traits</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> __true_type this_dummy_member_must-be_first;</span><br><span class="line">    <span class="keyword">typedef</span> __false_type has_trivial_default_constructor;</span><br><span class="line">    <span class="keyword">typedef</span> __false_type has_trivial_copy_constructor;</span><br><span class="line">    <span class="keyword">typedef</span> __false_type has_trivial_assignment_constructor;</span><br><span class="line">    <span class="keyword">typedef</span> __false_type has_trivial_destructor;</span><br><span class="line">    <span class="keyword">typedef</span> __false_type is_POD_type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//POD - plain old data</span></span><br><span class="line"><span class="comment">//trivial 不重要的/平凡的</span></span><br><span class="line"><span class="comment">//特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">type_traits</span>&lt;</span><span class="keyword">int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">typedef</span> __true_type has_trivial_default_constructor;</span><br><span class="line">    <span class="keyword">typedef</span> __true_type has_trivial_copy_constructor;</span><br><span class="line">    <span class="keyword">typedef</span> __true_type has_trivial_assignment_constructor;</span><br><span class="line">    <span class="keyword">typedef</span> __true_type has_trivial_destructor;</span><br><span class="line">    <span class="keyword">typedef</span> __true_type is_POD_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//询问</span></span><br><span class="line">__type_traits&lt;<span class="keyword">int</span>&gt;::has_trivial_copy_constructor</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Structure-C-11"><a href="#Structure-C-11" class="headerlink" title="Structure C++11"></a>Structure C++11</h3><h4 id="type-traits-categories"><a href="#type-traits-categories" class="headerlink" title="type traits categories"></a>type traits categories</h4><ul>
<li><p>Primary type categories</p>
<blockquote>
<p>is_array</p>
<p>is_class</p>
</blockquote>
</li>
<li><p>Type properties</p>
<blockquote>
<p>is_abstract</p>
<p>is_const</p>
</blockquote>
</li>
<li><p>Type features</p>
<blockquote>
<p>is_copy_constructible</p>
<p>is_move_constructible</p>
</blockquote>
</li>
<li><p>Composite type categories </p>
<blockquote>
<p>is_compound</p>
<p>is_object</p>
</blockquote>
</li>
</ul>
<h4 id="is-void"><a href="#is-void" class="headerlink" title="is_void"></a>is_void</h4><blockquote>
<p>将类型丢给is_void萃取机可判断是否为void类型</p>
<p>is_void -&gt; __is_void_helper&lt;…&gt;::type -&gt; false_type/true_type   -&gt;表示继承关系</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//remove_cv去除const与volatile类型的影响,remove_cv本身也是萃取机</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_void</span> :</span> <span class="keyword">public</span> __is_void_helper&lt; <span class="keyword">typename</span> remove_cv&lt;T&gt;::type &gt;::type</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//泛化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">is_void_helper</span> :</span> <span class="keyword">public</span> false_type&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_cv</span> &#123;</span></span><br><span class="line">   	<span class="keyword">typedef</span> <span class="keyword">typename</span> remove_const&lt; <span class="keyword">typename</span> remove_volatile&lt;T&gt;::type &gt;::type type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">is_void_helper</span>&lt;</span><span class="keyword">void</span>&gt; : <span class="keyword">public</span> true_type&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_const</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_const</span>&lt;</span>T <span class="keyword">const</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">typedef</span> remove_const&lt; <span class="keyword">typename</span> remove_volatile&lt;T&gt;::type &gt;::type type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_volatile</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_volatile</span>&lt;</span>T <span class="keyword">volatile</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Moveable-elements"><a href="#Moveable-elements" class="headerlink" title="Moveable elements"></a>Moveable elements</h2><blockquote>
<p>移动构造函数</p>
<blockquote>
<p>浅拷贝，仅拷贝指针且拷贝后切断原对象的指向即将原对象的指针设为NULL</p>
<p>确保movecopy后原对象不再使用，所以一般用临时对象做movecopy</p>
</blockquote>
<p>拷贝构造函数</p>
<blockquote>
<p>深拷贝</p>
</blockquote>
</blockquote>
<h4 id="vector中的movecopy"><a href="#vector中的movecopy" class="headerlink" title="vector中的movecopy"></a>vector中的movecopy</h4><p><strong>深拷贝</strong></p>
<blockquote>
<p>调用std::__uninitialized_copy_a(…) 即copy函数来进行逐个元素的赋值</p>
</blockquote>
<p><strong>浅拷贝</strong></p>
<blockquote>
<p>vector中的三个指针进行简单的swap()交换 ·</p>
</blockquote>
<h1 id="勿在浮沙筑高台"><a href="#勿在浮沙筑高台" class="headerlink" title="勿在浮沙筑高台"></a>勿在浮沙筑高台</h1>]]></content>
      <categories>
        <category>C++Primer</category>
      </categories>
      <tags>
        <tag>C++Primer</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 2.0新特性</title>
    <url>/2021/07/16/C++Primer/C++11/</url>
    <content><![CDATA[<h1 id="C-2-0-新特性"><a href="#C-2-0-新特性" class="headerlink" title="C++2.0 新特性"></a>C++2.0 新特性</h1><p><strong>语言</strong></p>
<blockquote>
<p>Variadic Templates</p>
<p>move Semantics</p>
<p>auto</p>
<p>Range-base for loop</p>
<p>Initiallizer list</p>
<p>Lambdas</p>
<p>…</p>
</blockquote>
<p><strong>标准库</strong></p>
<blockquote>
<p>type_traits</p>
<p>Unordered容器</p>
<p>forward_list</p>
<p>array</p>
<p>tuple</p>
<p>Con-currency</p>
<p>RegEx</p>
<p>…</p>
</blockquote>
<h1 id="C-Standard演化"><a href="#C-Standard演化" class="headerlink" title="C++ Standard演化"></a>C++ Standard演化</h1><ul>
<li>c++ 98 (1.0)</li>
<li>c++ 03 (TR1,Technical Report 1)</li>
<li>c++ 11 (2.0)</li>
<li>c++ 14</li>
</ul>
<h1 id="—-Part-for-Language—"><a href="#—-Part-for-Language—" class="headerlink" title="—-Part for Language—-"></a>—-Part for Language—-</h1><hr>
<h1 id="Spaces-in-Template-Expressions"><a href="#Spaces-in-Template-Expressions" class="headerlink" title="Spaces in Template Expressions"></a>Spaces in Template Expressions</h1><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;list&lt;<span class="keyword">int</span>&gt; &gt; <span class="comment">// OK in each C++ Version</span></span><br><span class="line">vector&lt;list&lt;<span class="keyword">int</span>&gt;&gt; <span class="comment">// OK since C++11 可以省略空格，编译器不会误以为为&gt;&gt;运算符</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="nullptr-and-std-nullptr-t"><a href="#nullptr-and-std-nullptr-t" class="headerlink" title="nullptr and std::nullptr_t"></a>nullptr and std::nullptr_t</h1><p><strong>nullptr关键字</strong></p>
<blockquote>
<p>nullptr可以自动转换为每一个指针类型，但不会转换为任何整数类型，其基本类型为std::nullptr_t</p>
<p>c++11使用nullptr来指定指针不指向任何值(void*)</p>
<p>而不是0或者NULL,NULL本质就是0</p>
</blockquote>
<p><strong>std::nullptr_t类型</strong></p>
<blockquote>
<p>一个基本的数据类型</p>
<p>在<cstddef>中定义</cstddef></p>
</blockquote>
<h1 id="auto-keyword"><a href="#auto-keyword" class="headerlink" title="auto keyword"></a>auto keyword</h1><blockquote>
<p>可用于类型推断</p>
<p>用于复杂的/太长的类型</p>
</blockquote>
<h1 id="Uniform-Initialization"><a href="#Uniform-Initialization" class="headerlink" title="Uniform Initialization"></a>Uniform Initialization</h1><blockquote>
<p>一致性初始化 - {}</p>
</blockquote>
<h2 id="Simple-Test"><a href="#Simple-Test" class="headerlink" title="Simple Test"></a>Simple Test</h2><blockquote>
<p>底层编译遇到{}会形成一个initializer_list<T></T></p>
<p>该容器内部关联一个array&lt;T,n&gt;，<strong>根据</strong>欲创建对象的<strong>构造函数</strong>的参数选择1 or 2进行初始化</p>
<ol>
<li><p>直接传递initializer_list<T></T></p>
</li>
<li><p>逐个拆解array&lt;T,n&gt;中的元素调用相应的构造函数</p>
<blockquote>
<p>若创建对象内部<strong>无initializer_list做参数的构造函数</strong>,则<strong>必须</strong>要求{}与其已有构造函数的<strong>参数一致</strong></p>
</blockquote>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//变量名后直接加&#123;&#125;进行初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数调用次数?</span></span><br><span class="line"><span class="keyword">int</span> values[] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">//使用方式1</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="comment">//使用方式2</span></span><br><span class="line">complex&lt;<span class="keyword">double</span>&gt; a &#123;<span class="number">4.0</span>,<span class="number">5.0</span>&#125;</span><br></pre></td></tr></table></figure>

<p><code>注意:</code></p>
<ul>
<li>如果使用{空}初始化,即使是局部变量也会强制具有初始值 0 or nullptr or …</li>
<li>使用一致性初始化时候不允许隐式<strong>收缩转换</strong>(高精度-&gt;低精度),反过来允许</li>
<li>若有意进行收缩转换,则应使用静态强制转换static_cast<low_type>(high_type_data)</low_type></li>
</ul>
</blockquote>
<h2 id="initializer-list"><a href="#initializer-list" class="headerlink" title="initializer_list"></a>initializer_list</h2><h3 id="Inner-Construct"><a href="#Inner-Construct" class="headerlink" title="Inner Construct"></a>Inner Construct</h3><blockquote>
<p>内部并不是复合(has)一个array容器，而是存放一个指向array元素的迭代器</p>
<p>浅拷贝</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">initializer_list</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="comment">//指向常量的指针说明initializer_list不具备对赋予数据的写的功能</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">const</span> value_type* iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">const</span> value_type* const_iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">initializer_list</span><span class="params">()</span>:array(<span class="number">0</span>),len(<span class="number">0</span>)&#123;</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> const_iterator <span class="title">begin</span><span class="params">()</span><span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> const_iterator <span class="title">end</span><span class="params">()</span><span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array + len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> size_type <span class="title">size</span><span class="params">()</span><span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//这里私有的构造函数编译器可调用且一定会调用</span></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">initializer_list</span><span class="params">(const_iterator a,size_type l)</span>:array(a),len(l)&#123;</span>&#125;</span><br><span class="line">    iterator array;</span><br><span class="line">    size_type len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


</blockquote>
<h3 id="In-Container"><a href="#In-Container" class="headerlink" title="In Container"></a>In Container</h3><blockquote>
<p>c++11下每个容器都提供了使用initializer_list类型参数的函数重载</p>
<ul>
<li>构造函数</li>
<li>operator=(initializer_list<value_type> _l)</value_type></li>
<li>insert(iterator _p,initializer_list<value_type> _l)</value_type></li>
<li>assign(initializer_list<value_type> _l)</value_type></li>
</ul>
</blockquote>
<h3 id="In-Algorithm"><a href="#In-Algorithm" class="headerlink" title="In Algorithm"></a>In Algorithm</h3><blockquote>
<p>可以使算法可接受<strong>不定参数</strong>但是<strong>类型相同</strong>的参数，使用Initializer List对象({})传入参数</p>
</blockquote>
<p><strong>print</strong></p>
<blockquote>
<p>实现输出多个相同类型参数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//c++11提供initializer_list&lt;&gt;类模板，供用户自定义对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(initializer_list&lt;<span class="keyword">int</span>&gt; a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> p = a.<span class="built_in">begin</span>(); p != a.<span class="built_in">end</span>(); p++) &#123;</span><br><span class="line">		cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//必须用&#123;&#125;或者initializer_list&lt;&gt;类对象初始化</span></span><br><span class="line"><span class="built_in">print</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>max</strong></p>
<blockquote>
<p>实现求多个相同类型参数的最大值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compare</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">iterator</span>&gt;</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(iterator t1, iterator t2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> *t1 &lt; *t2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//辅助接口函数，用于生成临时functor对象</span></span><br><span class="line"><span class="function">Compare <span class="title">compare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Compare</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//逐个取initializer_list容器关联array容器中个元素采用擂台比较，返回指向最大元素的迭代器</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">iterator</span>, <span class="keyword">class</span> <span class="title">Comparee</span>&gt;</span></span><br><span class="line">iterator ___maxx(iterator first, iterator last, Comparee cmp) &#123;</span><br><span class="line">	<span class="keyword">if</span> (first == last) &#123;</span><br><span class="line">		<span class="keyword">return</span> first;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	iterator result = first;</span><br><span class="line">	<span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">cmp</span>(result, first)) &#123;</span><br><span class="line">			result = first;</span><br><span class="line">		&#125;</span><br><span class="line">		first++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为___maxx提供functor比较规则</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">iterator</span>&gt;</span></span><br><span class="line">iterator _maxx(iterator first, iterator last) &#123;</span><br><span class="line">	<span class="keyword">return</span> ___maxx(first, last, <span class="built_in">compare</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function">T <span class="title">maxx</span><span class="params">(initializer_list&lt;T&gt; list)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> *_maxx(list.<span class="built_in">begin</span>(), list.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">maxx</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;); <span class="comment">//return 5</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="explict"><a href="#explict" class="headerlink" title="explict"></a>explict</h1><h2 id="For-ctors-taking-one-augument"><a href="#For-ctors-taking-one-augument" class="headerlink" title="For ctors taking one augument"></a>For ctors taking one augument</h2><p>explict不允许该类构造函数用于隐式类型转换</p>
<blockquote>
<p>只需要提供单一实参的构造函数</p>
<p>eg:带默认参数的构造函数</p>
</blockquote>
<h2 id="For-ctors-taking-more-than-one-augument"><a href="#For-ctors-taking-more-than-one-augument" class="headerlink" title="For ctors taking more than one augument"></a>For ctors taking more than one augument</h2><p>c++11中也不允许本类构造函数用于隐式类型转换</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//P类中无带initializer_list参数类型的构造函数</span></span><br><span class="line">P p5 = &#123;<span class="number">77</span>,<span class="number">5</span>,<span class="number">6</span>&#125;; <span class="comment">//error:不允许调用explict构造函数用于隐式类型转换</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="Range-based-for-statement"><a href="#Range-based-for-statement" class="headerlink" title="Range-based for statement"></a>Range-based for statement</h1><p>只读遍历</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//只读</span></span><br><span class="line"><span class="keyword">for</span> ( decl : coll) &#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> p = coll.<span class="built_in">begin</span>();p!=coll.<span class="built_in">end</span>();p++) &#123;</span><br><span class="line">    <span class="comment">//coll.begin() 等价于 begin(coll)</span></span><br><span class="line">    decl = *p;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//eg:</span></span><br><span class="line"><span class="comment">//const auto&amp; 只读且更快</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp;elem : coll) &#123;</span><br><span class="line">    cout &lt;&lt; elem &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; p = coll.<span class="built_in">begin</span>();p!=coll.<span class="built_in">end</span>();p++) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; elem = *p;</span><br><span class="line">    cout &lt;&lt; elem &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>读写遍历</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可读可写</span></span><br><span class="line"><span class="keyword">for</span> ( decl&amp; : coll) &#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> p = coll.<span class="built_in">begin</span>();p!=coll.<span class="built_in">end</span>();p++) &#123;</span><br><span class="line">    <span class="comment">//coll.begin() 等价于 begin(coll)</span></span><br><span class="line">    decl&amp; = *p;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//eg:</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; elem : coll) &#123;</span><br><span class="line">    elem += <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; p = coll.<span class="built_in">begin</span>();p!=coll.<span class="built_in">end</span>();p++) &#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; elem = *p;</span><br><span class="line">    elem += <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="default-delete"><a href="#default-delete" class="headerlink" title="=default,=delete"></a>=default,=delete</h1><blockquote>
<p>一般作用于Big-Three</p>
<ul>
<li>构造函数</li>
<li>拷贝构造</li>
<li>移动构造</li>
<li>拷贝赋值</li>
<li>移动赋值</li>
<li>析构函数</li>
</ul>
</blockquote>
<h2 id="default"><a href="#default" class="headerlink" title="= default"></a>= default</h2><blockquote>
<p>若用户自定义了任何一个构造函数，则不再使用默认构造函数，若仍需要使用则需要使用= default指出</p>
<p>用与默认构造函数和默认析构函数，表明仍使用该默认版本</p>
<p>用于Big-five之外无意义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span></span><br><span class="line">    <span class="built_in">Foo</span>(<span class="keyword">int</span> a):<span class="built_in">x</span>(a)&#123;&#125;</span><br><span class="line">    <span class="built_in">Foo</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="delete"><a href="#delete" class="headerlink" title="= delete"></a>= delete</h2><blockquote>
<p>可用于任何函数，表明该函数不能再被调用</p>
</blockquote>
<h2 id="No-Copy-and-Private-Copy"><a href="#No-Copy-and-Private-Copy" class="headerlink" title="No-Copy and Private-Copy"></a>No-Copy and Private-Copy</h2><blockquote>
<p>通过= default与= delete与访问权限修饰符构造具有特殊性质的类</p>
</blockquote>
<p><strong>No-Copy</strong></p>
<blockquote>
<p>不允许被copy</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NoCopy</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NoCopy</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">NoCopy</span>(<span class="keyword">const</span> NoCopy&amp;) = <span class="keyword">delete</span>; <span class="comment">// no-copy</span></span><br><span class="line">    NoCopy&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> NoCopy&amp;) = <span class="keyword">delete</span>; <span class="comment">// no-assignment</span></span><br><span class="line">    ~<span class="built_in">NoCopy</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>NoDtor</strong></p>
<blockquote>
<p>不允许被删除</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NoDtor</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NoDtor</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">NoDtor</span>() = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="comment">//后果自负,该内存无法被清除</span></span><br><span class="line">&#125;;</span><br><span class="line">NoDtor p; <span class="comment">//error</span></span><br><span class="line"><span class="keyword">auto</span> p* = <span class="keyword">new</span> <span class="built_in">NoDtor</span>();</span><br><span class="line"><span class="keyword">delete</span> p; <span class="comment">//error</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>Private-Copy</strong></p>
<blockquote>
<p>不语允许普通对象copy，只允许inner member or friends 调用copy</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PrivateCopy</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">PrivateCopy</span>(<span class="keyword">const</span> PrivateCopy&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    PrivateCopy&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> PrivateCopy&amp;) = <span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PrivateCopy</span>() = <span class="keyword">default</span>;   </span><br><span class="line">    ~<span class="built_in">PrivateCopy</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="Alias-Template"><a href="#Alias-Template" class="headerlink" title="Alias Template"></a>Alias Template</h1><blockquote>
<p>using</p>
<p>创建类模板的别名Alias，此时Alias也是一个类模板</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="comment">//声明使用模板</span></span><br><span class="line"><span class="keyword">using</span> Vec = std::vector&lt;T,MyAlloc&lt;T&gt;&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用别名时无模板</span></span><br><span class="line"><span class="comment">// Vec&lt;int&gt; coll == std::vecor&lt;int,MyAlloc&lt;T&gt;&gt; coll</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Single-case"><a href="#Single-case" class="headerlink" title="Single case"></a>Single case</h2><blockquote>
<p>要求实现一个test接口，要求只传入容器模板和数据类型来测试该容器的一些特性</p>
<p>测试:<code>test(list,string)</code>通过</p>
<p>难点: 接口如何获得容器的类型和其数据类型</p>
</blockquote>
<p><strong>Simple function</strong></p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">const</span> Container&amp; c,<span class="keyword">const</span> Type&amp; a)</span> </span>&#123;</span><br><span class="line">    Container&lt;Type&gt; c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i++) &#123;</span><br><span class="line">        c.<span class="built_in">insert</span>(c.<span class="built_in">end</span>(),<span class="built_in">Type</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用方式</span></span><br><span class="line"><span class="built_in">test</span>(<span class="built_in">list</span>(),<span class="built_in">string</span>());</span><br><span class="line">    </span><br><span class="line"><span class="comment">//此方式无法通过参数对象获得对象类型</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>Template function</strong></p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Container</span>,<span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">const</span> Container&amp; c,<span class="keyword">const</span> Type&amp; a)</span> </span>&#123;</span><br><span class="line">    Container&lt;Type&gt; c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i++) &#123;</span><br><span class="line">        c.<span class="built_in">insert</span>(c.<span class="built_in">end</span>(),<span class="built_in">Type</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用方式</span></span><br><span class="line"><span class="built_in">test</span>(<span class="built_in">list</span>(),<span class="built_in">string</span>());</span><br><span class="line">    </span><br><span class="line"><span class="comment">//编译器无法判断Container是类模板</span></span><br><span class="line"><span class="comment">//typename Container&lt;Type&gt; c; ?</span></span><br><span class="line"><span class="comment">//typename用于判断后面子句含有::的类型，该语法不通过</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>iterator_traits + Template function</strong></p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Container</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">const</span> Container&amp; c)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;<span class="keyword">typename</span> Container::iterator&gt;::value_type Type;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i++) &#123;</span><br><span class="line">     c.<span class="built_in">insert</span>(c.<span class="built_in">end</span>(),<span class="built_in">Type</span>());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用方式</span></span><br><span class="line"><span class="built_in">test</span>(<span class="built_in">list</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以，但是接口弹性小，使用不方便</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>Template template parameter + class</strong></p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,</span></span><br><span class="line"><span class="class">	<span class="title">template</span>&lt;</span><span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">     Container</span><br><span class="line">&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="keyword">typedef</span> T Type;</span><br><span class="line"> <span class="comment">//创建对象时通过构造函数去测试容器的相关特性</span></span><br><span class="line"> <span class="built_in">test</span>()&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i++) &#123;</span><br><span class="line">     c.<span class="built_in">insert</span>(c.<span class="built_in">end</span>(),<span class="built_in">Type</span>());</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> Container&lt;T&gt; c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用方式</span></span><br><span class="line">test&lt;string,vector&gt;;</span><br><span class="line"><span class="comment">//报错原因是vector的第二个alloc模板参数在用作模板模板参数时不会自动使用默认值，需要调用时自行指定第二个模板参数</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>Template template parameter + class + alias Template</strong></p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//using</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">using</span> Vector = std::vector&lt;T,MyAlloc&lt;T&gt;&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;class T,</span><br><span class="line">	<span class="keyword">template</span>&lt;class T&gt;</span><br><span class="line">     Container</span><br><span class="line">&gt;</span><br><span class="line">class test &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="keyword">typedef</span> T Type;</span><br><span class="line"> <span class="comment">//创建对象时通过构造函数去测试容器的相关特性</span></span><br><span class="line"> <span class="built_in">test</span>()&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i++) &#123;</span><br><span class="line">     c.<span class="built_in">insert</span>(c.<span class="built_in">end</span>(),<span class="built_in">Type</span>());</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> Container&lt;T&gt; c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用方式</span></span><br><span class="line">test&lt;string,Vector&gt;;</span><br><span class="line"><span class="comment">//此时Vector模板虽然只接受一个类型参数，但是却可以同时使用该参数指定第二个alloc模板参数</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="Template-template-parameter"><a href="#Template-template-parameter" class="headerlink" title="Template template parameter"></a>Template template parameter</h1><blockquote>
<p>模板做另一个模板的参数，一般用于上述情况</p>
</blockquote>
<h1 id="Type-Alias"><a href="#Type-Alias" class="headerlink" title="Type Alias"></a>Type Alias</h1><blockquote>
<p>using</p>
<p>等同于typedef</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> T value_type;</span><br><span class="line"><span class="keyword">using</span> value_type = T;</span><br><span class="line"><span class="comment">//无区别，新语法</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="noexcept"><a href="#noexcept" class="headerlink" title="noexcept"></a>noexcept</h1><blockquote>
<p>指明某函数不会丢出异常</p>
<p>特别是vector的移动构造函数若不指明noexcept则在grow时不会调用移动构造</p>
</blockquote>
<p><strong>growable containers</strong></p>
<ul>
<li>vector</li>
<li>deque</li>
</ul>
<p><strong>Testing</strong></p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="literal">true</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//甚至可以指定不会丢出异常的条件</span></span><br><span class="line">    <span class="comment">//若在swqp出现了异常却未被处理,会将该异常不断往调用点回抛，最终抛向std::terminate(),调用std::abort()终止程序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="override"><a href="#override" class="headerlink" title="override"></a>override</h1><blockquote>
<p>用于重写父类的虚函数时向编译器指明重写虚函数的意图</p>
<p>若出现错误导致操作不再是重写操作则报错</p>
</blockquote>
<h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><blockquote>
<p>用于类表明该类不允许被继承</p>
<p>用于虚函数表明该虚函数不允许被重写</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">a</span> <span class="keyword">final</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> <span class="keyword">final</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//注意final的位置</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h1><blockquote>
<p>获取一个表达式的类型</p>
</blockquote>
<h2 id="Used-to-declare-return-types"><a href="#Used-to-declare-return-types" class="headerlink" title="Used to declare return types"></a>Used to declare return types</h2><blockquote>
<p>用于返回类型复杂未知时</p>
<p><code>注意:</code>-&gt; decltype(…) 必须绑定 auto 类型说明符</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="keyword">decltype</span>(x+y) <span class="built_in">add</span>(T1 x,T2 y) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此时decltype()使用了作用域之外的对象，报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line">auto add(T1 x,T2 y) -&gt; decltype(x+y) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="In-metaprogramming"><a href="#In-metaprogramming" class="headerlink" title="In metaprogramming"></a>In metaprogramming</h2><blockquote>
<p>用于模板</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">a</span><span class="params">(<span class="keyword">const</span> T&amp; obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> T type;</span><br><span class="line">    <span class="comment">//等价于</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(obj)</span> type</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Used-to-pass-the-type-of-a-lambda"><a href="#Used-to-pass-the-type-of-a-lambda" class="headerlink" title="Used to pass the type of a lambda"></a>Used to pass the type of a lambda</h2><blockquote>
<p>获取lambda对象的类型</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> compare = [](...)&#123;...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//&lt;&gt;中传递类型后还必须将lambdas对象传给构造函数才能创建好set对象</span></span><br><span class="line">std::set&lt;Obj,decltype(compare)&gt; coll(compare);</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="Lambdas"><a href="#Lambdas" class="headerlink" title="Lambdas"></a>Lambdas</h1><blockquote>
<p>可理解为-匿名函数<strong>对象</strong>/匿名functor<strong>对象</strong></p>
<p>functor的创建会<strong>先有</strong>模板类functor<strong>类型的声明</strong>再去创建functor对象</p>
<p>而Lambdas自定义起便是一个匿名的functor对象，虽然具有functor对象的一些性质，但是</p>
</blockquote>
<h2 id="Defination"><a href="#Defination" class="headerlink" title="Defination"></a>Defination</h2><blockquote>
<ol>
<li><p>捕获外部作用域中访问lambdas的对象</p>
<blockquote>
<p>[=] : 按值传递方式捕获外部作用域中的所有对象</p>
<p>[&amp;] : 按按引用传递方式捕获外部作用域中的所有对象</p>
<p>[x,&amp;y] : 捕获指定对象，x按值传递捕获，y按引用传递捕获</p>
</blockquote>
</li>
<li><p>函数参数</p>
<blockquote>
<p>若无参可省略()，<strong>若含可选参数项必须含有()</strong></p>
</blockquote>
</li>
<li><p>可选参数项</p>
<ul>
<li><p>mutable</p>
<blockquote>
<p>若1处的对象按值传递，则若想更改值传递对象的值，必须使用mutable修饰，否则不允许更改</p>
<p>若1处的对象按引用传递，则可省略，且对对象的更改会影响到外部对象</p>
</blockquote>
</li>
<li><p>noexcept</p>
</li>
<li><p>decltype</p>
<blockquote>
<p>若函数有返回值，则需要通过decltype指定返回值类型，可省略</p>
</blockquote>
</li>
</ul>
</li>
<li><p>statement</p>
<blockquote>
<p>可有返回值</p>
</blockquote>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>](function_arguments) <span class="keyword">mutable</span> <span class="keyword">noexcept</span> -&gt; <span class="keyword">decltype</span>(function_return_statement) &#123;</span><br><span class="line">    <span class="comment">//statement</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用1</span></span><br><span class="line">[<span class="number">1</span>](function_arguments) <span class="keyword">mutable</span> <span class="keyword">noexcept</span> -&gt; <span class="keyword">decltype</span>(function_return_statement) &#123;</span><br><span class="line">    <span class="comment">//statement</span></span><br><span class="line">&#125;(function_arguments);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用2</span></span><br><span class="line"><span class="keyword">auto</span> x = [<span class="number">1</span>](function_arguments) <span class="keyword">mutable</span> <span class="keyword">noexcept</span> -&gt; <span class="keyword">decltype</span>(function_return_statement) &#123;</span><br><span class="line">    <span class="comment">//statement</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">x</span>(function_arguments);</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="What-compiler-generates-for-lambdas"><a href="#What-compiler-generates-for-lambdas" class="headerlink" title="What compiler generates for lambdas ?"></a>What compiler generates for lambdas ?</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> tobefound = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">auto</span> lambdas1 = [tobefound](<span class="keyword">int</span> val) &#123;</span><br><span class="line">    <span class="keyword">return</span> tobefound == val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译器处理为</span></span><br><span class="line"><span class="keyword">int</span> tobefound = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnNamedFunctor</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UnNamedFunctor</span>(<span class="keyword">int</span> x):<span class="built_in">tobefound</span>(x)&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    auto operator()(int val) -&gt; decltype(tobefound == val) &#123;</span><br><span class="line">        <span class="keyword">return</span> tobefound == val;</span><br><span class="line">    &#125; </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> tobefound;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">UnNamedFunctor <span class="title">lambdas2</span><span class="params">(tobefound)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>注意:</code></p>
<ol>
<li><p>虽然编译器会将lambdas当做匿名functor处理，但是由于其特殊语法，所以lambdas并无默认构造函数与对=运算符的重载</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. 使用到lambdas传参时(如创建关联式容器)不仅需要在&lt;&gt;传递lambdas对象类型，还需要将lambdas对象传递给容器构造函数进而创建容器</span><br><span class="line"></span><br><span class="line">因为容器存在通过传入类型的默认构造函数创建对应类型对象的默认构造函数，而lambdas无默认构造函数，报错</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Variadic Templates</span><br><span class="line"></span><br><span class="line">可变模板参数</span><br><span class="line"></span><br><span class="line">可随**使用方式**而动态的**拆分**可变参数包</span><br><span class="line"></span><br><span class="line">可用于递归,但Variadic Templates**不会产生递归**，而是Variadic Templates可动态拆分的特性**可用于递归**</span><br><span class="line"></span><br><span class="line">## In function template</span><br><span class="line"></span><br><span class="line">递归调用</span><br><span class="line"></span><br><span class="line">处理参数</span><br><span class="line"></span><br><span class="line">### Print</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;c++ </span><br><span class="line">template&lt;class T,class... Types&gt;</span><br><span class="line">&#x2F;&#x2F;指定拆分方式为n &#x3D; 1 + (n - 1) &#x2F; n &#x3D; a + args...</span><br><span class="line">void print(const T&amp; a, const Types&amp;... args) &#123;</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"> &#x2F;&#x2F;sizeof...(args) 可返回可变参数的个数</span><br><span class="line"> 	cout &lt;&lt; &quot;剩余可变参数个数: &quot; &lt;&lt; sizeof...(args) &lt;&lt; endl;</span><br><span class="line"> &#x2F;&#x2F;使用可变参数性质进行递归调用</span><br><span class="line">	print(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;若本函数模板与上面的函数模板并存，则只会调用上面更特化的版本</span><br><span class="line">template&lt;class... Types&gt;</span><br><span class="line">void print(const Types&amp;... args) &#123;</span><br><span class="line">	&#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置递归终止时的处理方式</span><br><span class="line">&#x2F;&#x2F;按照指定方式(1,n-1)一直进行拆分，处理base_case(n-1&#x3D;0)递归结束的情况</span><br><span class="line">void print() &#123;&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	print(&quot;abc&quot;, 123, 465);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ol>
</blockquote>
<h3 id="Hash-Function"><a href="#Hash-Function" class="headerlink" title="Hash Function"></a>Hash Function</h3><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span> <span class="comment">//引入相应的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomerHash</span> &#123;</span></span><br><span class="line">	<span class="function">std::<span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Customer&amp; c)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">hash_val</span>(c.first, c.second, c.third);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算hashcode的函数模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hash_combine</span><span class="params">(std::<span class="keyword">size_t</span>&amp; seed, <span class="keyword">const</span> T&amp; val)</span> </span>&#123;</span><br><span class="line">	seed ^= std::hash&lt;T&gt;()(val) + <span class="number">0x9e3779b9</span> + (seed &lt;&lt; <span class="number">6</span>) + (seed &gt;&gt; <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//辅助接口函数，虽然接受可变参数，但是未指定拆分方式，不进行拆分，不用于递归，用于返回hash值</span></span><br><span class="line"><span class="keyword">template</span>&lt;class... Types&gt;</span><br><span class="line"><span class="function">std::<span class="keyword">size_t</span> <span class="title">hash_val</span><span class="params">(<span class="keyword">const</span> Types&amp;... args)</span> </span>&#123;</span><br><span class="line">	std::<span class="keyword">size_t</span> seed = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">hash_val</span>(seed, args...);</span><br><span class="line">	<span class="keyword">return</span> seed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定拆分方式为n = 1 + (n - 1)，进行递归调用逐个取可变参数中的首元素更新seed</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span>... <span class="title">Types</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hash_val</span><span class="params">(std::<span class="keyword">size_t</span>&amp; seed, <span class="keyword">const</span> T&amp; val, <span class="keyword">const</span> Types&amp;... args)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">hash_combine</span>(seed, val);</span><br><span class="line">	<span class="built_in">hash_val</span>(seed, args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理递归结束的情况</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hash_val</span><span class="params">(std::<span class="keyword">size_t</span>&amp; seed, <span class="keyword">const</span> T&amp; val)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">hash_combine</span>(seed, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h3><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (*a) &#123;</span><br><span class="line">		<span class="keyword">if</span> (*a == <span class="string">&#x27;%&#x27;</span> &amp;&amp; *(++a) != <span class="string">&#x27;%&#x27;</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;invalid format string:missing arguments&quot;</span>);</span><br><span class="line">			cout &lt;&lt; *a++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span>...<span class="title">Types</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* a,<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> Types&amp;... args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (*a) &#123;</span><br><span class="line">		<span class="keyword">if</span> (*a == <span class="string">&#x27;%&#x27;</span> &amp;&amp; *(++a) != <span class="string">&#x27;%&#x27;</span>) &#123;</span><br><span class="line">			cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">			<span class="built_in">printf</span>(++a,args...);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		std::cout &lt;&lt; *a++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;extra argument!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d%s\n&quot;</span>, <span class="number">5</span>, <span class="string">&quot;hello variadic templates&quot;</span>);</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="max"><a href="#max" class="headerlink" title="max"></a>max</h3><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maximum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;class... Types&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maximum</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">const</span> Types&amp;... x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用标准库的max函数动态拆解可变参数并作递归比较得到最大值</span></span><br><span class="line">	<span class="keyword">return</span> std::<span class="built_in">max</span>(n, <span class="built_in">maximum</span>(x...));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="In-class-template"><a href="#In-class-template" class="headerlink" title="In class template"></a>In class template</h2><blockquote>
<p>递归继承，复合</p>
<p>处理类型</p>
</blockquote>
<h3 id="Recursive-inheritance"><a href="#Recursive-inheritance" class="headerlink" title="Recursive inheritance"></a>Recursive inheritance</h3><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//tuple</span></span><br><span class="line"><span class="comment">//通过可变参数的可动态拆分特性递归实现继承体系</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Head</span>,<span class="title">class</span>... <span class="title">Tail</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tuple</span>&lt;</span>Head,Tail...&gt; : <span class="keyword">private</span> tuple&lt;Tail...&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="keyword">typedef</span> tuple&lt;Tail...&gt; inherited;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">tuple</span>() &#123;&#125;</span><br><span class="line"> <span class="built_in">tuple</span>(<span class="keyword">const</span> Head&amp; a,<span class="keyword">const</span> Tail&amp;... args):<span class="built_in">m_head</span>(a),<span class="built_in">inherited</span>(args...)&#123;&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//返回tuple对象的head元素</span></span><br><span class="line"> <span class="function">Head <span class="title">head</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> m_head;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//通过上转型为父类类型截断本类数据</span></span><br><span class="line"> <span class="comment">//返回不含m_head的含tail部分的tuple对象</span></span><br><span class="line"> <span class="function">inherited&amp; <span class="title">tail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"> Head m_head;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当递归至父类为tuple&lt;&gt;时作停止递归的处理</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tuple</span>&lt;</span>&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Recursive-Composition"><a href="#Recursive-Composition" class="headerlink" title="Recursive Composition"></a>Recursive Composition</h3><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//tup</span></span><br><span class="line"><span class="comment">//通过可变参数的可动态拆分特性递归实现复合体系</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Head</span>,<span class="title">class</span>... <span class="title">Tail</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tup</span>&lt;</span>Head,Tail...&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="keyword">typedef</span> tup&lt;Tail...&gt; composited;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">tup</span>() &#123;&#125;</span><br><span class="line"> <span class="built_in">tup</span>(<span class="keyword">const</span> Head&amp; a,<span class="keyword">const</span> Tail&amp;... args):<span class="built_in">m_head</span>(a),<span class="built_in">m_tail</span>(args...)&#123;&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//返回tup对象的head元素</span></span><br><span class="line"> <span class="function">Head <span class="title">head</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> m_head;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//返回复合的</span></span><br><span class="line"> <span class="function">composited&amp; <span class="title">tail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> m_tail;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"> Head m_head;</span><br><span class="line"> composited m_tail;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归终止处理</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tup</span>&lt;</span>&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="—-Part-for-STL—"><a href="#—-Part-for-STL—" class="headerlink" title="—-Part for STL—-"></a>—-Part for STL—-</h1><hr>
<h1 id="Move-Semantics"><a href="#Move-Semantics" class="headerlink" title="Move Semantics"></a>Move Semantics</h1><h2 id="Rvalue-References"><a href="#Rvalue-References" class="headerlink" title="Rvalue References"></a>Rvalue References</h2><blockquote>
<p>一种引用类型，该引用类型可以避免不必要的copy操作</p>
<p>当 = 的右侧为Rvalue References类型时，左值对象可以<strong>偷取</strong>右值对象的内容而不必额外分配内存，执行copy操作，而是执行movecopy操作</p>
</blockquote>
<h3 id="Rvalue-and-Lvalue"><a href="#Rvalue-and-Lvalue" class="headerlink" title="Rvalue and Lvalue"></a>Rvalue and Lvalue</h3><p><strong>Rvalue</strong></p>
<blockquote>
<p>只能出现在 = 右侧的对象</p>
<p>临时对象为右值对象</p>
</blockquote>
<p><strong>Lvalue</strong></p>
<blockquote>
<p>可以出现在 = 左侧的对象</p>
</blockquote>
<p><code>注意:</code>c++标准库中很多类的运算符重载导致该规范被打破，但是大部分情况仍是该规范主导</p>
<p><strong>Transition</strong></p>
<blockquote>
<p>可以通过标准库中的std::move(Lvalue_obj)将Lvalue_obj转换为右值对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(_Tp&amp;&amp; t)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</blockquote>
<h2 id="Perfect-Forwarding"><a href="#Perfect-Forwarding" class="headerlink" title="Perfect Forwarding"></a>Perfect Forwarding</h2><h3 id="Unperfect-Forwarding"><a href="#Unperfect-Forwarding" class="headerlink" title="Unperfect Forwarding"></a>Unperfect Forwarding</h3><blockquote>
<p>对象在传递过程中<strong>无类型保证措施</strong>，无法确保对象的<strong>透明转发</strong></p>
<p>右值引用对象会由于某些原因(如被重新封装为named object)而转换为左值引用对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>&amp; i)</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>&amp;&amp; i)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forward</span><span class="params">(<span class="keyword">int</span>&amp;&amp; i)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="built_in">process</span>(<span class="number">1</span>); <span class="comment">//调用1</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">process</span>(a); <span class="comment">//调用2</span></span><br><span class="line"></span><br><span class="line">forward(<span class="number">1</span>); <span class="comment">//发现转发过程调用了2而非1，因为forward内部将1封装成了named object，从而转换为了一个左值对象</span></span><br><span class="line">forward(std::<span class="built_in">move</span>(a)); <span class="comment">//发现转发过程调用了2而非1</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Perfect-Forwarding-1"><a href="#Perfect-Forwarding-1" class="headerlink" title="Perfect Forwarding"></a>Perfect Forwarding</h3><blockquote>
<p>通过一个<strong>forward函数模板</strong>来保证任意参数的<strong>透明转发</strong>，即各<strong>参数性质</strong>不会发生改变</p>
<p>静态强制转换</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">//std::forward&lt;Lvalue_type&gt;()</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//forward lvalue</span></span><br><span class="line">&gt;<span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">constexpr</span> _Tp&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp; t)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;_Tp&amp;&amp;&gt;(t);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//forward rvalue</span></span><br><span class="line">&gt;<span class="comment">//就算被封装成了obj也要萃取出obj中的右值引用类型</span></span><br><span class="line">&gt;<span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">constexpr</span> _Tp&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp;&amp; t)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">   <span class="built_in"><span class="keyword">static_assert</span></span>(!std::is_lvalue_reference&lt;_Tp&gt;::value,<span class="string">&quot;_Tp is an lvalue reference type&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;_Tp&amp;&amp;&gt;(t);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Lvalue_type</span>,<span class="keyword">class</span> <span class="title">Rvalue_type</span>&gt;</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">void</span> <span class="title">funA</span><span class="params">(<span class="keyword">const</span> Lvalue_type&amp; a,Rvalue_type&amp;&amp; b)</span> </span>&#123;</span><br><span class="line">   _forward( std::forward&lt;Lvalue_type&gt;(a),std::forward&lt;Rvalue_type&gt;(b) ) &#123;&#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Move-avare-class"><a href="#Move-avare-class" class="headerlink" title="Move-avare class"></a>Move-avare class</h2><blockquote>
<p>针对于<strong>Pointer Like Class</strong>而言</p>
<p>因为movecopy一定经过一次浅拷贝，即一字节一字节的赋值，若类中无指针成员，则movecopy效率几乎等同于copy</p>
</blockquote>
<h3 id="Container-of-elements-is-move-able"><a href="#Container-of-elements-is-move-able" class="headerlink" title="Container of elements is move-able"></a>Container of elements is move-able</h3><blockquote>
<p> 容器在执行元素copy操作时,仍触发容器的copyconstruct-cctor,但是触发了元素的movecopy-MAsgn</p>
<blockquote>
<p>元素类型内部对move进行了实现</p>
</blockquote>
<p>move-able elements 对vector的操作效率，deque非首尾插入元素时影响最大，对其结点构成的容器影响不大</p>
<blockquote>
<p>也就是说move-able elements 优化了容器的cctor</p>
</blockquote>
</blockquote>
<p><strong>Defination</strong></p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//静态成员用于计数各类型函数的执行次数</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">size_t</span> CCtor;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">size_t</span> MCtor;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">size_t</span> CAsgn;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">size_t</span> MAsgn;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">size_t</span> Ctor;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">size_t</span> Mtor;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">size_t</span> Dtor;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">MyString</span>() :<span class="built_in">data</span>(<span class="literal">nullptr</span>), <span class="built_in">len</span>(<span class="number">0</span>) &#123;</span><br><span class="line">		++Dtor;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">MyString</span>(<span class="keyword">const</span> <span class="keyword">char</span>* x) :<span class="built_in">len</span>(<span class="built_in">strlen</span>(x)) &#123;</span><br><span class="line">		++Ctor;</span><br><span class="line">		_copy(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">MyString</span>(<span class="keyword">const</span> MyString&amp; x) &#123;</span><br><span class="line">		++CCtor;</span><br><span class="line">		_copy(x.data);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//moveable的函数必须有noexcept关键字修饰否则不会调用，注意位置</span></span><br><span class="line">	<span class="built_in">MyString</span>(MyString&amp;&amp; x) <span class="keyword">noexcept</span> :<span class="built_in">data</span>(x.data), <span class="built_in">len</span>(x.len)&#123;</span><br><span class="line">		++MCtor;</span><br><span class="line">		<span class="comment">//偷取后需要切断原对象对该内存的连接</span></span><br><span class="line">		<span class="comment">//重要性:</span></span><br><span class="line">		<span class="comment">//若没及时切断连接，两个指针同时指向一个内存，若传入右值引用对象(匿名对象)生命周期提早结束，会将该共享内存清除，导致本对象无法使用</span></span><br><span class="line">		x.data = <span class="literal">NULL</span>;</span><br><span class="line">		x.len = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	MyString&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> MyString&amp;x) &#123;</span><br><span class="line">		++CAsgn;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> == &amp;x) &#123;&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (data) <span class="keyword">delete</span> data;</span><br><span class="line">			len = x.len;</span><br><span class="line">			_copy(x.data);	</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//返回值仍为引用，因为仅根据右值引用产生不同的赋值操作但是返回类型都是一样的</span></span><br><span class="line">	MyString&amp; <span class="keyword">operator</span>= (MyString&amp;&amp; x) &#123;</span><br><span class="line">		++MAsgn;</span><br><span class="line">		<span class="comment">//先进行判断是否为self赋值</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> == &amp;x) &#123;&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//所有赋值必须先清理原内存后再进行赋值</span></span><br><span class="line">			<span class="keyword">if</span> (data) <span class="keyword">delete</span> data;</span><br><span class="line">			<span class="comment">//偷取内容</span></span><br><span class="line">			len = x.len;</span><br><span class="line">			data = x.data;</span><br><span class="line">			<span class="comment">//切断连接</span></span><br><span class="line">			x.data = <span class="literal">NULL</span>;</span><br><span class="line">			x.len = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">MyString</span>() &#123;</span><br><span class="line">		++Dtor;</span><br><span class="line">		<span class="keyword">if</span> (data) &#123;</span><br><span class="line">			<span class="keyword">delete</span> data;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">char</span> *data;</span><br><span class="line">	<span class="keyword">int</span> len;</span><br><span class="line">	<span class="comment">//封装内部工具函数用于copy即开辟空间逐个赋值</span></span><br><span class="line">	<span class="keyword">void</span> _copy(<span class="keyword">const</span> <span class="keyword">char</span>* x) &#123;</span><br><span class="line">		data = <span class="keyword">new</span> <span class="keyword">char</span>[len + <span class="number">1</span>];</span><br><span class="line">		<span class="built_in">memcpy</span>(data, x, len);</span><br><span class="line">		data[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> MyString::CCtor = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> MyString::MCtor = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> MyString::CAsgn = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> MyString::MAsgn = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> MyString::Ctor = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> MyString::Mtor = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> MyString::Dtor = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>Interface</strong></p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试部分</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output_static_data</span><span class="params">(<span class="keyword">const</span> T&amp; mystr)</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(mystr).<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot;--&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;CCtor = &quot;</span> &lt;&lt; T::CCtor</span><br><span class="line">		&lt;&lt; <span class="string">&quot;MCtor = &quot;</span> &lt;&lt; T::MCtor</span><br><span class="line">		&lt;&lt; <span class="string">&quot;CAsgn = &quot;</span> &lt;&lt; T::CAsgn</span><br><span class="line">		&lt;&lt; <span class="string">&quot;MAsgn = &quot;</span> &lt;&lt; T::MAsgn</span><br><span class="line">		&lt;&lt; <span class="string">&quot;Ctor = &quot;</span> &lt;&lt; T::Ctor</span><br><span class="line">		&lt;&lt; <span class="string">&quot;Mtor = &quot;</span> &lt;&lt; T::Mtor</span><br><span class="line">		&lt;&lt; <span class="string">&quot;Dtor = &quot;</span> &lt;&lt; T::Dtor</span><br><span class="line">		&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">M</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_moveable</span><span class="params">(M c, <span class="keyword">long</span>&amp; value)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt; <span class="keyword">typename</span> M::iterator &gt;::value_type Type;</span><br><span class="line">	<span class="keyword">char</span> random[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">clock_t</span> timeStart = <span class="built_in">clock</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; value; i++) &#123;</span><br><span class="line">		<span class="built_in">snprintf</span>(random, <span class="number">10</span>, <span class="string">&quot;%d&quot;</span>, <span class="built_in">random</span>());</span><br><span class="line">		<span class="keyword">auto</span> ite = c.<span class="built_in">end</span>();</span><br><span class="line">		<span class="comment">//测试move_able elements对容器插入效率的影响</span></span><br><span class="line">		<span class="comment">//Type()为临时对象，所以传递的为右值引用对象</span></span><br><span class="line">		c.<span class="built_in">insert</span>(ite, <span class="built_in">Type</span>(random));</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;milli_seconds : &quot;</span> &lt;&lt; <span class="built_in">clock</span>() - timeStart &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;size() = &quot;</span> &lt;&lt; c.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">output_static_data</span>(*(c.<span class="built_in">begin</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Container-is-move-able"><a href="#Container-is-move-able" class="headerlink" title="Container is move-able"></a>Container is move-able</h3><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//G4.9 vector</span></span><br><span class="line"><span class="comment">//拷贝构造</span></span><br><span class="line"><span class="built_in">vector</span>(<span class="keyword">const</span> vector&amp; __x):_Base(__x.<span class="built_in">size</span>(),_Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator())) &#123;</span><br><span class="line"> <span class="keyword">this</span>-&gt;_M_impl.M_finish = std::__uninitialized_copy_a(__x.begin,__x.<span class="built_in">end</span>(),<span class="keyword">this</span>-&gt;_M_impl._M_start,</span><br><span class="line">	_M_get_Tp_allocator())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//右值拷贝构造</span></span><br></pre></td></tr></table></figure>



<p><img src="/images/C++/image-20210716075445489.png"></p>
</blockquote>
<h1 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h1><blockquote>
<p>数组</p>
</blockquote>
<p><strong>组成</strong></p>
<blockquote>
<p>内含一个数组成员</p>
<p>迭代器 native pointer</p>
<p><strong>无构造函数析构函数</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//TR1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp,std::<span class="keyword">size_t</span> _Nm&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Array</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> _Tp value_type;</span><br><span class="line">	<span class="keyword">typedef</span> _Tp* pointer;</span><br><span class="line">	<span class="keyword">typedef</span> value_type* iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"></span><br><span class="line">	<span class="comment">//Array无构造函数析构函数</span></span><br><span class="line"></span><br><span class="line">	<span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;arr[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;arr[_Nm];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	value_type arr[_Nm ? _Nm : <span class="number">1</span>]; <span class="comment">//若数组长度参数为0默认将长度值为1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h1><blockquote>
<p>G4.9</p>
<p>vector + 链表</p>
</blockquote>
<h2 id="hash-function"><a href="#hash-function" class="headerlink" title="hash-function"></a>hash-function</h2><blockquote>
<p>通过对hash类模板 functor 的特化完成不同基本数据类型的hash_code的计算</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//eg:</span></span><br><span class="line"><span class="comment">//__hash_base&lt;size_t,size_t&gt;相当于unary_function 为了使特化版本adaptable</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;</span><span class="keyword">int</span>&gt; : __hash_base&lt;<span class="keyword">size_t</span>,<span class="keyword">size_t</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">hash&lt;<span class="keyword">int</span>&gt;()(<span class="number">1</span>); <span class="comment">//return 1</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h1><blockquote>
<p>元组 不同数据类型数据的组合</p>
</blockquote>
<h3 id="Interface-testing"><a href="#Interface-testing" class="headerlink" title="Interface testing"></a>Interface testing</h3><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//tuple对象的创建</span></span><br><span class="line">tuple&lt;string, int, int&gt; t(&quot;123&quot;,10,11);</span><br><span class="line"><span class="keyword">auto</span> t2 = <span class="built_in">make_tuple</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象成员的获取</span></span><br><span class="line"><span class="comment">//get&lt;num&gt;(tuple_obj) num为从0开始的序号索引 </span></span><br><span class="line"><span class="keyword">int</span> i = get&lt;<span class="number">1</span>&gt;(t);</span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line">string c;</span><br><span class="line"></span><br><span class="line"><span class="comment">//tie(args...) = tuple_obj 元素绑定</span></span><br><span class="line"><span class="comment">//实现用args参数&quot;绑定&quot;tuple中的元素 赋值性的绑定 即绑定后值变化互不影响</span></span><br><span class="line"><span class="built_in">tie</span>(c, a, b) = t;</span><br><span class="line"><span class="comment">//eg:</span></span><br><span class="line">get&lt;<span class="number">0</span>&gt;(t) = <span class="string">&quot;5&quot;</span>;</span><br><span class="line">cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"><span class="comment">//结果仍为123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//stl中tuple对运算符的重载</span></span><br><span class="line"><span class="comment">//t &lt; t2</span></span><br><span class="line"><span class="comment">//t = t2;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取tuple中元素个数</span></span><br><span class="line"><span class="keyword">typedef</span> tuple&lt;string, <span class="keyword">int</span>, <span class="keyword">int</span> TupleType</span><br><span class="line">cout &lt;&lt; tuple_size&lt;TupleType&gt;::value &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取某个元素的类型</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取tuple的head元素</span></span><br><span class="line">string s = t.<span class="built_in">head</span>(); <span class="comment">// s=&quot;123&quot;</span></span><br><span class="line"><span class="comment">//获取tuple的tail部分tuple对象</span></span><br><span class="line"><span class="keyword">auto</span> tail = t.<span class="built_in">tail</span>(); <span class="comment">// tail = tuple&lt;int, int&gt; t(10,11)</span></span><br><span class="line"><span class="comment">//获取tail的head元素</span></span><br><span class="line"><span class="keyword">int</span> se = tail.<span class="built_in">head</span>();</span><br><span class="line"><span class="comment">//值得注意的是head(),tail()在c++17中不再使用该名称</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Internal-structure-G4-8"><a href="#Internal-structure-G4-8" class="headerlink" title="Internal structure - G4.8"></a>Internal structure - G4.8</h3><blockquote>
<p>通过可变类型参数<strong>可动态拆分</strong>特性而构建的一个继承体系结构</p>
<p>即每一个数据类型的数据单独封装为一个类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//tuple对象的创建</span></span><br><span class="line">tuple&lt;int, float, string&gt; t(41,6.3,&quot;nico&quot;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//tuple</span></span><br><span class="line"><span class="comment">//通过可变参数的可动态拆分特性递归实现继承体系</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Head</span>,<span class="title">class</span>... <span class="title">Tail</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tuple</span>&lt;</span>Head,Tail...&gt; : <span class="keyword">private</span> tuple&lt;Tail...&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="keyword">typedef</span> tuple&lt;Tail...&gt; inherited;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">tuple</span>() &#123;&#125;</span><br><span class="line"> <span class="built_in">tuple</span>(<span class="keyword">const</span> Head&amp; a,<span class="keyword">const</span> Tail&amp;... args):<span class="built_in">m_head</span>(a),<span class="built_in">inherited</span>(args...)&#123;&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//返回tuple对象的head元素</span></span><br><span class="line"> <span class="function">Head <span class="title">head</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> m_head;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//通过上转型为父类类型截断本类数据</span></span><br><span class="line"> <span class="comment">//返回不含m_head的含tail部分的tuple对象</span></span><br><span class="line"> <span class="function">inherited&amp; <span class="title">tail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"> Head m_head;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当递归至父类为tuple&lt;&gt;时作停止递归的处理</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tuple</span>&lt;</span>&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>继承图示</p>
<p><img src="/.com//Users\YunDid\AppData\Roaming\Typora\typora-user-images\image-20210712164552782.png" alt="image-20210712164552782"></p>
</blockquote>
<h2 id><a href="#" class="headerlink" title></a></h2>]]></content>
      <categories>
        <category>C++Primer</category>
      </categories>
      <tags>
        <tag>C++Primer</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP 粘包</title>
    <url>/2021/08/11/Network/Tcp%E7%B2%98%E5%8C%85/</url>
    <content><![CDATA[<h1 id="TCP-粘包"><a href="#TCP-粘包" class="headerlink" title="TCP 粘包"></a>TCP 粘包</h1><blockquote>
<p>由于TCP本身是一种基于流的，安全可靠的传输协议，所以发送方与接受方每次处理数据的量以及数据的处理频率可以不同</p>
<p>这就导致接收方可能无法完整解析一个数据包，存在数据包粘连问题</p>
</blockquote>
<h2 id="Problems"><a href="#Problems" class="headerlink" title="Problems"></a>Problems</h2><ol>
<li>理想状态下接受到了发送方发送的完整数据包</li>
<li>接受到了发送方发来的N个不等长数据包，导致接收方无法拆分</li>
<li>接受到了发送发来的一个N个完整数据包+一个不完整数据包，无法拆分</li>
</ol>
<h2 id="Reason"><a href="#Reason" class="headerlink" title="Reason"></a>Reason</h2><ol>
<li>发送方与接收方对数据的发送与接受速率，每次处理的量不对等</li>
<li>接收方不知道每个数据包的起始位置与数据包的大小，无法对当前接收到的数据进行拆分</li>
</ol>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><ol>
<li>使用标准的应用层协议(http,https)封装不定长的数据包</li>
<li>将传输的数据包添加包头(包头大小自定，一般为4byte)，包头存有数据包的总字节数(不包括包头大小)，形成一个完整的数据块</li>
</ol>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><blockquote>
<p>发送方逐行读取txt文件中的内容进行发送，接收方由于不知道完整数据包大小导致无法设置接收缓存的大小来接收并处理完整数据包</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">发送方:</span><br><span class="line">Welcome</span><br><span class="line">to</span><br><span class="line">China!</span><br><span class="line">理想接收方:</span><br><span class="line">Welcome</span><br><span class="line">to</span><br><span class="line">China!</span><br><span class="line">实际接收方:</span><br><span class="line">we</span><br><span class="line">lc</span><br><span class="line">om.</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Sending-end"><a href="#Sending-end" class="headerlink" title="Sending end"></a>Sending end</h3><ol>
<li><p>动态分配一段 N+4 的内存，一般为字符数组</p>
<blockquote>
<p> 前4个字节存放包头，注意包头需要进行网络字节序(4byte完整解析)的转换</p>
<p> 后N个字节存放完整的数据包</p>
</blockquote>
</li>
<li><p>发送该数据块，并每次检测是否还有包头指定的剩余字节未发送</p>
<blockquote>
<p>若未完成，此次发送未结束，继续发送剩余字节数</p>
<p>若完成，即完成一个数据块发送</p>
</blockquote>
</li>
<li><p>释放申请的 N+4 内存</p>
</li>
</ol>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//buf 待发送字符数组 size 待发送数据包长度(由于发送的时候包头一块发 所以这里一般是包头+数据包长度)</span></span><br><span class="line"><span class="keyword">int</span> _send(SOCKET fd,<span class="keyword">const</span> <span class="keyword">char</span>* buf,<span class="keyword">int</span> size) &#123;</span><br><span class="line"> <span class="comment">//位置记录指针，记录下次发送的位置</span></span><br><span class="line"> <span class="keyword">const</span> <span class="keyword">char</span>* p = buf;</span><br><span class="line"> <span class="comment">//count记录剩余需要发送的字节数</span></span><br><span class="line"> <span class="keyword">int</span> count = size;</span><br><span class="line"> <span class="comment">//发送完整数据包</span></span><br><span class="line"> <span class="keyword">while</span>(count&gt;<span class="number">0</span>) &#123;</span><br><span class="line">     <span class="keyword">int</span> len = <span class="built_in">send</span>(fd,p,count,<span class="number">0</span>);</span><br><span class="line">     <span class="keyword">if</span>(len&lt;<span class="number">0</span>) &#123;</span><br><span class="line">         <span class="built_in">closesocket</span>(fd);</span><br><span class="line">         <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">     &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len==<span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">continue</span>;</span><br><span class="line">     &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">//count记录剩余需要发送的字节数</span></span><br><span class="line">         count-=len;</span><br><span class="line">         <span class="comment">//p指针记录下次发送字节的位置</span></span><br><span class="line">         p+=len;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据发送部分</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">		string buff;</span><br><span class="line">		<span class="keyword">int</span> sign;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (<span class="built_in">getline</span>(in, buff)) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//包头设置</span></span><br><span class="line">			<span class="keyword">int</span> len = buff.<span class="built_in">length</span>();</span><br><span class="line">			<span class="keyword">int</span> biglen = <span class="built_in">htonl</span>(len);</span><br><span class="line"></span><br><span class="line">			<span class="comment">//数据块设置 数据包+包头</span></span><br><span class="line">			<span class="keyword">char</span>* buf = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">4</span> + len);	</span><br><span class="line">			<span class="built_in">memcpy</span>(buf, (<span class="keyword">char</span>*)&amp;biglen, <span class="number">4</span>);</span><br><span class="line">			<span class="built_in">memcpy</span>(buf+<span class="number">4</span>, &amp;buff, len);</span><br><span class="line"></span><br><span class="line">			sign = _send(c_socket, buf, len + <span class="number">4</span>);</span><br><span class="line">			<span class="keyword">if</span> (sign &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;数据已发送&quot;</span> &lt;&lt; endl;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (sign == <span class="number">0</span>) &#123;</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;服务端断开连接!&quot;</span> &lt;&lt; endl;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;数据发送失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Receiving-end"><a href="#Receiving-end" class="headerlink" title="Receiving end"></a>Receiving end</h3><ol>
<li><p>先检测收到字节流的首4个字节，提取出包头存放的数据包长度len，注意主机字节序的转换</p>
</li>
<li><p>动态申请对应大小的内存，完成对len长度完整数据包的接受，并每次检测是否还有包头指定的剩余字节未接受</p>
<blockquote>
<p>若未完成，此次接受未结束，继续接受剩余字节数</p>
<p>若完成，即完成一个数据块接受</p>
</blockquote>
</li>
<li><p>处理完整数据包</p>
</li>
<li><p>释放申请的堆内存</p>
</li>
</ol>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//buf 用于接收的数据包字符数组 size 待接收数据包长度</span></span><br><span class="line"><span class="keyword">int</span> _recv(SOCKET fd,<span class="keyword">char</span>* buf,<span class="keyword">int</span> size) &#123;</span><br><span class="line"> <span class="comment">//位置记录指针，记录下次存放的位置</span></span><br><span class="line"> <span class="keyword">char</span>* p = buf;</span><br><span class="line"> <span class="comment">//count记录剩余需要接收的字节数</span></span><br><span class="line"> <span class="keyword">int</span> count = size;</span><br><span class="line"> <span class="comment">//接收完整数据包</span></span><br><span class="line"> <span class="keyword">while</span>(count&gt;<span class="number">0</span>) &#123;</span><br><span class="line">     <span class="keyword">int</span> len = <span class="built_in">recv</span>(fd,p,count,<span class="number">0</span>);</span><br><span class="line">     <span class="keyword">if</span>(len&lt;<span class="number">0</span>) &#123;</span><br><span class="line">         <span class="built_in">closesocket</span>(fd);</span><br><span class="line">         <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">     &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len==<span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">//返回已经接收的字节数</span></span><br><span class="line">         <span class="keyword">return</span> size-count;</span><br><span class="line">     &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">//count记录剩余需要接收的字节数</span></span><br><span class="line">         count-=len;</span><br><span class="line">         <span class="comment">//p指针记录下次接收字节的位置</span></span><br><span class="line">         p+=len;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据接收</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"> 	<span class="comment">//先接收包头并提取出数据包大小</span></span><br><span class="line">		<span class="keyword">int</span> biglen;</span><br><span class="line">		<span class="keyword">int</span> len;</span><br><span class="line">		_recv(p-&gt;fd, (<span class="keyword">char</span>*)&amp;biglen, <span class="number">4</span>);</span><br><span class="line"> 	<span class="comment">//字节序转换</span></span><br><span class="line">		len = <span class="built_in">ntohl</span>(biglen);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//动态分配完整数据包大小的内存</span></span><br><span class="line">		<span class="keyword">char</span>* buff = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(len);</span><br><span class="line">		<span class="comment">//接收数据包</span></span><br><span class="line">		<span class="keyword">int</span> sign = _recv(p-&gt;fd, buff, len);</span><br><span class="line">		<span class="keyword">if</span> (sign &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">//对接收数据的处理</span></span><br><span class="line">			cout &lt;&lt; buff &lt;&lt; endl;;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (sign == <span class="number">0</span>) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;客户端&quot;</span> &lt;&lt; <span class="built_in">inet_ntoa</span>(p-&gt;addr.sin_addr) &lt;&lt; <span class="string">&quot;断开连接!&quot;</span> &lt;&lt; endl;</span><br><span class="line">			p-&gt;fd = <span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;读取客户端&quot;</span> &lt;&lt; <span class="built_in">inet_ntoa</span>(p-&gt;addr.sin_addr) &lt;&lt; <span class="string">&quot;数据失败!&quot;</span> &lt;&lt; endl;</span><br><span class="line">			p-&gt;fd = <span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></blockquote>
]]></content>
      <categories>
        <category>Socket</category>
      </categories>
      <tags>
        <tag>Socket</tag>
      </tags>
  </entry>
  <entry>
    <title>Socket</title>
    <url>/2021/08/11/Network/Socket/</url>
    <content><![CDATA[<h1 id="Socket-初识"><a href="#Socket-初识" class="headerlink" title="Socket 初识"></a>Socket 初识</h1><h1 id="Necessary-foundation"><a href="#Necessary-foundation" class="headerlink" title="Necessary foundation"></a>Necessary foundation</h1><h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><blockquote>
<p><strong>在全球互联网范围</strong>内<strong>唯一标识主机</strong>的<strong>地址</strong></p>
</blockquote>
<h3 id="IPV4"><a href="#IPV4" class="headerlink" title="IPV4"></a>IPV4</h3><blockquote>
<p>32bit，4byte的地址，使用点分十进制法表示</p>
<p>可以使用的IP地址为2^32个</p>
</blockquote>
<h3 id="IPV6"><a href="#IPV6" class="headerlink" title="IPV6"></a>IPV6</h3><blockquote>
<p>128bit，16byte的地址，使用:分16进制法表示</p>
<p>可以使用的地址为2^128个</p>
</blockquote>
<h2 id="Port-端口"><a href="#Port-端口" class="headerlink" title="Port 端口"></a>Port 端口</h2><blockquote>
<p>唯一标识主机中的某进程</p>
<p>16bit的 unsigned short (无符号短整型)数</p>
<p>可以使用的端口数目为2^16，有效端口范围为0~65535(2^16-1)</p>
</blockquote>
<h2 id="存储模式"><a href="#存储模式" class="headerlink" title="存储模式"></a>存储模式</h2><blockquote>
<p><strong>大于一字节</strong>的数据在内存中的存储方式</p>
</blockquote>
<h3 id="大端存储"><a href="#大端存储" class="headerlink" title="大端存储"></a>大端存储</h3><blockquote>
<p>低内存地址 -&gt; 高内存地址 存放 高字节数据 -&gt; 低字节数据</p>
</blockquote>
<h3 id="小端存储"><a href="#小端存储" class="headerlink" title="小端存储"></a>小端存储</h3><blockquote>
<p>低内存地址 -&gt; 高内存地址 存放 低字节数据 -&gt; 高字节数据</p>
</blockquote>
<h3 id="如何判断主机的存储模式"><a href="#如何判断主机的存储模式" class="headerlink" title="如何判断主机的存储模式"></a>如何判断主机的存储模式</h3><p><strong>基本思路</strong></p>
<blockquote>
<p>将一4byte无符号整形数据<strong>截取首字节</strong>的内容判断该首字节存放是高字节数据还是低字节数据</p>
</blockquote>
<blockquote>
<p><code>注意:</code>整数数据从左往右依次为 高字节 -&gt; 低字节</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span>*p = &amp;a;</span><br><span class="line"> <span class="comment">//通过类型转型截取数据首字节的部分</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span>*p1 = (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)p;</span><br><span class="line"></span><br><span class="line"> <span class="built_in"><span class="keyword">switch</span></span>(*p1) &#123;</span><br><span class="line">     <span class="keyword">case</span> <span class="number">1</span> :</span><br><span class="line">         cout&lt;&lt;<span class="string">&quot;小端&quot;</span>&lt;&lt;endl;<span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">case</span> <span class="number">0</span> :</span><br><span class="line">         cout&lt;&lt;<span class="string">&quot;大端&quot;</span>&lt;&lt;endl;<span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">default</span> :</span><br><span class="line">         cout&lt;&lt;<span class="string">&quot;无法判断&quot;</span>&lt;&lt;endl;<span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h2><blockquote>
<p><strong>大于一个字节</strong>类型的数据在内存中的<strong>存放顺序</strong></p>
<p>char类型没有字节序问题，因为基本单位大小为1byte</p>
</blockquote>
<p><strong>Little-Endian</strong></p>
<blockquote>
<p>低内存地址 -&gt; 高内存地址 存放 高字节数据 -&gt; 低字节数据</p>
</blockquote>
<p><strong>Big-Endian</strong></p>
<blockquote>
<p>低内存地址 -&gt; 高内存地址 存放 低字节数据 -&gt; 高字节数据</p>
</blockquote>
<h3 id="主机字节序"><a href="#主机字节序" class="headerlink" title="主机字节序"></a>主机字节序</h3><blockquote>
<p><strong>多字节</strong>整数在内存中的存放顺序</p>
<p>不同CPU，操作系统有不同的字节序类型</p>
</blockquote>
<h3 id="网络字节序"><a href="#网络字节序" class="headerlink" title="网络字节序"></a>网络字节序</h3><blockquote>
<p>TCP/IP协议规定好的数据的表示格式</p>
<p>它与具体的操作系统，CPU类型等无关，保证了数据在不同主机之间传输时的正确性</p>
<p><strong>采用大端存储</strong></p>
</blockquote>
<h3 id="跨平台通信"><a href="#跨平台通信" class="headerlink" title="跨平台通信"></a>跨平台通信</h3><blockquote>
<p>发送方与接收方都是从低内存地址开始发送/接受数据</p>
<p>而采用Big-Endian的接收方会按高字节-&gt;低字节的方式去存取传来的数据(认为传来的首字节为数据的高字节部分)</p>
<p>若通信双方采用不同字节序，则会导致发送方发送的数据被接收方错误解析，导致传送的数据出错!</p>
</blockquote>
<h4 id="字节序的转换"><a href="#字节序的转换" class="headerlink" title="字节序的转换"></a>字节序的转换</h4><blockquote>
<p>IP , Port端口等在通信时需要进行大小端转换</p>
</blockquote>
<h4 id="Port端口的转换"><a href="#Port端口的转换" class="headerlink" title="Port端口的转换"></a>Port端口的转换</h4><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">// htonl -&gt; host to network long  将 32位长整数 由主机字节序 -&gt; 网络字节序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//32bit长整型在不同字节序之间的转换</span></span><br><span class="line"><span class="comment">//不适用于IP地址，因为IP地址是字符串类型</span></span><br><span class="line"><span class="function"><span class="keyword">unit32_t</span> <span class="title">htonl</span><span class="params">(<span class="keyword">uint32_t</span> hostlong)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unit32_t</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">unit32_t</span> netlong)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//16bit短整型在不同字节序之间的转换</span></span><br><span class="line"><span class="comment">//适用于端口的转换</span></span><br><span class="line"><span class="function"><span class="keyword">unit16_t</span> <span class="title">htons</span><span class="params">(<span class="keyword">unit16_t</span> hostshort)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unit16_t</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">unit16_t</span> netshort)</span></span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="IP地址的转换"><a href="#IP地址的转换" class="headerlink" title="IP地址的转换"></a>IP地址的转换</h4><blockquote>
<p>32bit长整型在不同字节序之间的转换接口函数并不适用于IP地址</p>
<p>因为IP地址虽然本质是一个整形数，但是使用过程中都是字符串类型</p>
<p><strong>字符串类型的主机字节序 &lt;-&gt; 整型类型的网络字节序</strong></p>
<p><strong>IPV4 - 仅适用于IPV4</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//windows 与 linux 均含该接口函数</span></span><br><span class="line"><span class="comment">//字符串类型的主机字节序 -&gt; 整型类型的网络字节序</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">inet_addr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//整型类型的网络字节序 -&gt; 字符串类型的主机字节序</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">inet_ntoa</span><span class="params">(struct in_addr in)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>sockaddr结构  –vs2017源码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sockaddr结构  --vs2017源码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//sockaddr</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span>&#123;</span></span><br><span class="line"> <span class="keyword">sa_family_t</span> sa_family; <span class="comment">//地址族协议 只能指定为IPV4</span></span><br><span class="line"> <span class="keyword">char</span> sa_data[<span class="number">14</span>]; <span class="comment">//端口(2byte) + IP(4byte) + 填充(8byte)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sockaddr_in</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span>(_WIN32_WINNT &lt; 0x0600)</span></span><br><span class="line"><span class="keyword">short</span>   sin_family;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">//(_WIN32_WINNT &lt; 0x0600)</span></span></span><br><span class="line">ADDRESS_FAMILY sin_family;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//(_WIN32_WINNT &lt; 0x0600)</span></span></span><br><span class="line"></span><br><span class="line">USHORT sin_port;   <span class="comment">//大端字节序的 Port端口</span></span><br><span class="line"><span class="comment">//-----------------------------------------------</span></span><br><span class="line">IN_ADDR sin_addr;  <span class="comment">//IN_ADDR 含大端字节序的 IP地址</span></span><br><span class="line"><span class="comment">//-----------------------------------------------</span></span><br><span class="line">CHAR sin_zero[<span class="number">8</span>];  <span class="comment">//8字节填充</span></span><br><span class="line">&#125; SOCKADDR_IN, *PSOCKADDR_IN;</span><br><span class="line"></span><br><span class="line"><span class="comment">//IN_ADDR</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> &#123;</span> UCHAR s_b1,s_b2,s_b3,s_b4; &#125; S_un_b;</span><br><span class="line">       <span class="class"><span class="keyword">struct</span> &#123;</span> USHORT s_w1,s_w2; &#125; S_un_w;</span><br><span class="line"><span class="comment">//-----------------------------------------------           </span></span><br><span class="line">       ULONG S_addr;  <span class="comment">//S_addr 大端字节序的 IP地址</span></span><br><span class="line"><span class="comment">//-----------------------------------------------</span></span><br><span class="line">&#125; S_un;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> s_addr  S_un.S_addr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> s_host  S_un.S_un_b.s_b2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> s_net   S_un.S_un_b.s_b1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> s_imp   S_un.S_un_w.s_w2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> s_impno S_un.S_un_b.s_b4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> s_lh    S_un.S_un_b.s_b3</span></span><br><span class="line">&#125; IN_ADDR, *PIN_ADDR, FAR *LPIN_ADDR;</span><br></pre></td></tr></table></figure>

<p><strong>Linux IPV4-IPV6通用</strong> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//仅Linux下含该接口函数，windows下无</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串类型的主机字节序 -&gt; 整型类型的网络字节序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> af,<span class="keyword">const</span> <span class="keyword">char</span>* src,<span class="keyword">void</span>* dst)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//af: 协议族(IPV4-AF_INET IPV6-AF_INET6) 指定src的地址类型 点分10进制 or 冒号分16进制</span></span><br><span class="line"><span class="comment">//src: 待转换的字符串类型的IP地址</span></span><br><span class="line"><span class="comment">//dst: 转换成功后的整型大端字节序的IP地址并不以返回值返回，而是通过参数dst返回</span></span><br><span class="line"><span class="comment">//return: </span></span><br><span class="line"><span class="comment">//1: 成功转换 0: 无效的src IP地址 -1: 协议族类型与src IP地址不匹配</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//整型类型的网络字节序 -&gt; 字符串类型的主机字节序</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> af,<span class="keyword">const</span> <span class="keyword">void</span>*src,<span class="keyword">char</span>* dst,<span class="keyword">socklen_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//af: 协议族(IPV4-AF_INET IPV6-AF_INET6) 指定src的地址类型 点分10进制 or 冒号分16进制</span></span><br><span class="line"><span class="comment">//src: 指向 待转换的整型类型的IP地址 内存的指针</span></span><br><span class="line"><span class="comment">//dst: 转换成功后的整型大端字节序的IP地址不仅以返回值返回，而是通过参数dst返回</span></span><br><span class="line"><span class="comment">//size: 标记 dst指向的内存 可存储的最大字节数</span></span><br><span class="line"><span class="comment">//return: 转换成功后的IP字符串 or 失败NULL</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="Socket-本地局域网"><a href="#Socket-本地局域网" class="headerlink" title="Socket - 本地局域网"></a>Socket - 本地局域网</h1><blockquote>
<p><strong>应用层</strong>与<strong>TCP/IP协议族</strong>之间的<strong>抽象层</strong></p>
<p>Facade门面模式的思想，用户只需操作该<strong>Socket接口</strong>来完成<strong>网络之间进程的通信</strong>而无需了解协议族细节</p>
<p><strong>四元组</strong>(ClientIP , ClientPort , ServerIP , ServerPort)</p>
<p><img src="/images/Socket/image-20210726185800869.png" alt="image-20210726185800869"></p>
</blockquote>
<h2 id="Defination"><a href="#Defination" class="headerlink" title="Defination"></a>Defination</h2><blockquote>
<p><strong>一个</strong>套接字接口<strong>构成</strong>连接的<strong>一端</strong>，<strong>一对</strong>套接字接口<strong>确定</strong>一个<strong>连接</strong></p>
</blockquote>
<h4 id="Socket-类型"><a href="#Socket-类型" class="headerlink" title="Socket 类型"></a>Socket 类型</h4><h5 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h5><blockquote>
<p>一个文件描述符对应两块内存 <strong>读缓冲区</strong> 与 <strong>写缓冲区</strong></p>
<p><strong>文件描述符的作用</strong></p>
<blockquote>
<p> 从读缓冲区中读数据，将数据写入到写缓冲区中</p>
</blockquote>
</blockquote>
<h5 id="用于监听的-socket对象-文件描述符"><a href="#用于监听的-socket对象-文件描述符" class="headerlink" title="用于监听的 socket对象 / 文件描述符"></a>用于监听的 socket对象 / 文件描述符</h5><blockquote>
<p>只有一个</p>
<p>只负责监听客户端进程连接请求，不负责双方通信</p>
<p>当client 发送连接请求时，内核会将该请求存放于监听socket对象的读缓冲区中</p>
<p>在调用accept()时，再由内核检测该读缓冲区中是否有数据，若检测到该读缓冲区有数据不阻塞，建立连接，否则阻塞</p>
</blockquote>
<h5 id="用于通信的-socket对象-文件描述符"><a href="#用于通信的-socket对象-文件描述符" class="headerlink" title="用于通信的 socket对象 / 文件描述符"></a>用于通信的 socket对象 / 文件描述符</h5><blockquote>
<p>可以有多个，通信双方都有各自的通信socket描述符</p>
<p>负责相应的客户端进程与该服务端进程的通信，若有N个客户端进程与该服务端进程通信，则有N个相对应的socket描述符</p>
<p>进行数据通信时，发送方的先将通信数据写入到 通信socket对象 的写缓冲区中</p>
<p>再由内核检测对应写缓冲区中是否有数据，有则发送到网络中</p>
<p>接收方内核将接受到的数据存到相应的读缓冲区，再通过IO操作读取数据</p>
</blockquote>
<h2 id="基于TCP的套接字通信流程"><a href="#基于TCP的套接字通信流程" class="headerlink" title="基于TCP的套接字通信流程"></a>基于TCP的套接字通信流程</h2><h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><ol>
<li><p>创建用于监听的socketA对象，该对象为一个文件描述符</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> socketA = <span class="keyword">new</span> <span class="built_in">socket</span>(...);</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>将该socketA对象与server进程的 IP+Port 进行绑定</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bind</span>(...);</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>监听该socketA的连接情况</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">listen</span>(...);</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>若有 client端进程 发起连接请求，进行回应并返回一个用于通信的socketB对象</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//TCP三次握手，开辟用于通信的资源</span></span><br><span class="line"><span class="keyword">int</span> socketB = <span class="built_in">accept</span>(...);</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>对该socketB对象进行IO操作，完成与client端进程的通信</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接受数据</span></span><br><span class="line"><span class="built_in">read</span>(); / <span class="built_in">recv</span>();</span><br><span class="line"><span class="comment">//发送数据</span></span><br><span class="line"><span class="built_in">write</span>(); / <span class="built_in">send</span>();</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>若client进程断开连接，则server也将用于通信的socketB对象关闭</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//socketB</span></span><br><span class="line"><span class="comment">//四次挥手的后两次挥手</span></span><br><span class="line"><span class="built_in">close</span>();</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>若服务器不再启用，则关闭用于监听的socketA对象</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//socketA</span></span><br><span class="line"><span class="built_in">close</span>();</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ol>
<h3 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h3><ol>
<li><p>创建用于通信的socket对象</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> socket = <span class="keyword">new</span> <span class="built_in">socket</span>(...);</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>向指定 IP+Port 的server端进程 发起连接请求</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//三次握手建立连接，开辟通信资源</span></span><br><span class="line"><span class="built_in">connect</span>();</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>对该socket对象进行IO操作，完成与server端进程的通信</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接受数据</span></span><br><span class="line"><span class="built_in">read</span>(); / <span class="built_in">recv</span>();</span><br><span class="line"><span class="comment">//发送数据</span></span><br><span class="line"><span class="built_in">write</span>(); / <span class="built_in">send</span>();</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>关闭该用于通信的socket对象</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//四次挥手的前两次挥手</span></span><br><span class="line"><span class="built_in">close</span>();</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ol>
<h2 id="Interface-Linux"><a href="#Interface-Linux" class="headerlink" title="Interface - Linux"></a>Interface - Linux</h2><ul>
<li><p><code>int socket(int domain,int type,int protocol);</code></p>
<blockquote>
<p><strong>创建socket对象</strong>，并返回<strong>唯一标识</strong>该socket对象的<strong>socket描述符</strong></p>
<p><strong>domain:</strong> 协议族(family)，决定了socket的<strong>地址类型</strong></p>
<blockquote>
<p>AF_INET ipv4(32bit) + 端口号(16bit) 的组合</p>
</blockquote>
<p><strong>type:</strong> 传输层协议类型</p>
<blockquote>
<p>SOCK_STREAM(TCP),SOCK_DGRAM(UDP) </p>
</blockquote>
<p><strong>protocol:</strong> 协议</p>
<blockquote>
<p>IPPROTO_TCP…</p>
<p>若为0，则自动选择type类型的协议</p>
</blockquote>
<p><code>注意:</code>type 与 protocol 需要对应，一般直接将protocol置为0</p>
<p><strong>rerurn:</strong> a file descirptor for the new socket  / 成功则返回该socket文件描述符 / 失败则返回-1</p>
</blockquote>
</li>
<li><p><code>int bind(int server_sockfd,const struct sockaddr* server_addr,socklen_t addrlen);</code></p>
<blockquote>
<p>将 socket对象 与指定 ( ip+port ) 建立绑定</p>
<p><strong>server_sockfd:</strong> 将被绑定的 server端 socket对象</p>
<p><strong>server_addr:</strong> 与 server_sockfd 进行绑定的协议地址( port+IP)</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sockaddr结构  --vs2017源码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//sockaddr</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span>&#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sa_family; <span class="comment">//地址族协议 只能指定为IPV4</span></span><br><span class="line">    <span class="keyword">char</span> sa_data[<span class="number">14</span>]; <span class="comment">//端口(2byte) + IP(4byte) + 填充(8byte)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sockaddr_in</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span>(_WIN32_WINNT &lt; 0x0600)</span></span><br><span class="line"><span class="keyword">short</span>   sin_family;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">//(_WIN32_WINNT &lt; 0x0600)</span></span></span><br><span class="line">ADDRESS_FAMILY sin_family;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//(_WIN32_WINNT &lt; 0x0600)</span></span></span><br><span class="line"></span><br><span class="line">USHORT sin_port;   <span class="comment">//大端字节序的 Port端口</span></span><br><span class="line"><span class="comment">//-----------------------------------------------</span></span><br><span class="line">IN_ADDR sin_addr;  <span class="comment">//IN_ADDR 含大端字节序的 IP地址</span></span><br><span class="line"><span class="comment">//-----------------------------------------------</span></span><br><span class="line">CHAR sin_zero[<span class="number">8</span>];  <span class="comment">//8字节填充</span></span><br><span class="line">&#125; SOCKADDR_IN, *PSOCKADDR_IN;</span><br><span class="line"></span><br><span class="line"><span class="comment">//IN_ADDR</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">          <span class="class"><span class="keyword">struct</span> &#123;</span> UCHAR s_b1,s_b2,s_b3,s_b4; &#125; S_un_b;</span><br><span class="line">          <span class="class"><span class="keyword">struct</span> &#123;</span> USHORT s_w1,s_w2; &#125; S_un_w;</span><br><span class="line"><span class="comment">//-----------------------------------------------           </span></span><br><span class="line">          ULONG S_addr;  <span class="comment">//S_addr 大端字节序的 IP地址</span></span><br><span class="line"><span class="comment">//-----------------------------------------------</span></span><br><span class="line">  &#125; S_un;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> s_addr  S_un.S_addr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> s_host  S_un.S_un_b.s_b2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> s_net   S_un.S_un_b.s_b1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> s_imp   S_un.S_un_w.s_w2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> s_impno S_un.S_un_b.s_b4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> s_lh    S_un.S_un_b.s_b3</span></span><br><span class="line">&#125; IN_ADDR, *PIN_ADDR, FAR *LPIN_ADDR;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>addrlen:</strong> 协议地址的长度，大小</p>
<p><strong>return:</strong> 成功 0 / 失败 -1</p>
<p><code>注意:</code></p>
<ol>
<li><p>server端需要在listen之前bind绑定<strong>固定地址</strong>，client无需手动绑定，而是在<strong>connect时</strong>由系统生成<strong>随机端口</strong> + 自身IP的组合</p>
</li>
<li><p>client 与 server 的通信需要借助该addr来建立连接</p>
</li>
<li><p>在将地址绑定到 socket对象 的时候，注意一定要进行主机字节序 -&gt; 网络字节序的转换 Port 与 IP 均需要进行大端转换</p>
<blockquote>
<p>即使均采用big-endian，也需要显示写出转换函数，此时该函数不会进行转换，而是原样返回传入的参数</p>
</blockquote>
</li>
</ol>
</blockquote>
</li>
<li><p><code>int listen(int server_sockfd,int backlog);</code></p>
<blockquote>
<p>对绑定地址后的socket进行监听，等待客户的connect连接请求</p>
<p><strong>server_sockfd:</strong> 被监听的 server端 socket对象</p>
<p><strong>backlog:</strong> 该socket对象<strong>一次可检测到的最大客户端请求数</strong>，内核默认最大为128</p>
<p><strong>return:</strong> 成功 0 / 失败 -1</p>
</blockquote>
</li>
<li><p><code>int connect(int client_sockid,const struct sockaddr* addr,socklen_t addrlen);</code></p>
<blockquote>
<p>client 向 server 发送连接请求</p>
<p><strong>client_sockid:</strong> 发送请求的 client_socket对象</p>
<p><strong>addr:</strong> 请求的目的地址，应该与被请求的 server端 server_addr相同</p>
<p><strong>addrlen:</strong> 协议地址的长度</p>
<p><strong>return:</strong> 成功 0 / 失败 -1</p>
</blockquote>
</li>
<li><p><code>int accept(int server_sockfd, struct sockaddr* addr,socklen_t *addrlen);</code></p>
<blockquote>
<p>server 接受<strong>一个客户端</strong>请求，与<strong>一个客户端</strong>建立连接</p>
<p>与多个客户端建立连接需要调用多次</p>
<p><strong>server_sockfd:</strong> server端 socket对象</p>
<p><strong>addr:</strong> 协议地址，传出参数，用于根据需求选择传出 client 协议地址(IP+Port)信息</p>
<p><strong>addrlen:</strong> 指针 指向存放addr内存大小的那块内存的地址，既是传入参数(需要初始化)又是传出参数(可通过该参数返回值)</p>
<blockquote>
<p>若addr为空，则addrlen也相应置空，若不为空，则将 存放addr内存大小的内存地址 传给addrlen指针</p>
</blockquote>
<p><strong>return:</strong> 成功 用于通信的socket描述符 / 失败 -1</p>
</blockquote>
</li>
<li><p><code>read(),write()</code></p>
<blockquote>
<p>IO接口</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发送数据</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;   <span class="comment">//--A</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sockfd: 用于通信的socket描述符</span></span><br><span class="line"><span class="comment">buf: 传入要发送的数据</span></span><br><span class="line"><span class="comment">size: buf的最大容量，防止内存溢出</span></span><br><span class="line"><span class="comment">return: &gt;0 实际发送的字节数 = len</span></span><br><span class="line"><span class="comment">-1 发送失败</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;   <span class="comment">//--B</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sockfd: 用于通信的socket描述符</span></span><br><span class="line"><span class="comment">buf: 传入要发送的数据</span></span><br><span class="line"><span class="comment">size: buf的最大容量，防止内存溢出</span></span><br><span class="line"><span class="comment">flags: 特殊属性，一般设置为0</span></span><br><span class="line"><span class="comment">return: &gt;0 实际发送的字节数 = len</span></span><br><span class="line"><span class="comment">-1 发送失败</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//接受数据</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> size)</span></span>;   <span class="comment">//--A</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sockfd: 用于通信的socket描述符</span></span><br><span class="line"><span class="comment">buf: 暂存接受到的数据</span></span><br><span class="line"><span class="comment">size: buf的最大容量，防止内存溢出</span></span><br><span class="line"><span class="comment">return: &gt;0 实际接受的字节数</span></span><br><span class="line"><span class="comment">=0 对方断开连接,不再阻塞直接返回0</span></span><br><span class="line"><span class="comment">-1 接受数据失败,阻塞等待数据到达,重新接受</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> size, <span class="keyword">int</span> flags)</span></span>;   <span class="comment">//--B</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sockfd: 用于通信的socket描述符</span></span><br><span class="line"><span class="comment">buf: 暂存接受到的数据</span></span><br><span class="line"><span class="comment">size: buf的最大容量，防止内存溢出</span></span><br><span class="line"><span class="comment">flags: 特殊属性，一般设置为0</span></span><br><span class="line"><span class="comment">return: &gt;0 实际接受的字节数</span></span><br><span class="line"><span class="comment">=0 对方断开连接,不再阻塞直接返回0</span></span><br><span class="line"><span class="comment">-1 接受数据失败,阻塞等待数据到达,重新接受</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p><code>close(int sockfd);</code></p>
<blockquote>
<p>关闭socket对象</p>
<p><strong>return:</strong> 成功 0 / 失败 -1</p>
<p><code>注意:</code></p>
<ol>
<li>close操作只是使相应socket描述字的引用计数-1，只有当引用计数为0的时候，才会触发TCP客户端向服务器发送终止连接请求。</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Soncket-in-Windows"><a href="#Soncket-in-Windows" class="headerlink" title="Soncket in Windows"></a>Soncket in Windows</h2><ul>
<li><p>初始化套接字环境</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//--------------加载套接字库---------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//包含对应头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="comment">//加载相应的动态链接库 ws2_32.lib</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------初始化套接字环境---------------</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">WSAStartup</span>(WORD wVersionRequested,LPWSADATA lpWSAData);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">wVersionRequested: 指定Windows Socket版本，一般使用的版本为2.2-MAKEWORD(2,2)</span></span><br><span class="line"><span class="comment">lpWSAData: WSAData 结构的指针</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------注销Winsock相关库-----------</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line">WSADATA wsaData;</span><br><span class="line">WORD libversion = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">WSAStartup</span>(libversion, &amp;wsaData) != <span class="number">0</span>) &#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Init Operaing error.&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">LOBYTE</span>(wsaData.wVersion) != <span class="number">2</span> || <span class="built_in">HIBYTE</span>(wsaData.wVersion) != <span class="number">2</span>) &#123;</span><br><span class="line">	<span class="built_in">WSACleanup</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Can&#x27;find valid lib.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>其余基本与Linux下的流程相同</p>
<blockquote>
<p><strong>字节序转换</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//window上没有这两个函数</span></span><br><span class="line"><span class="built_in">inet_ntop</span>(); </span><br><span class="line"><span class="built_in">inet_pton</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//// 字符串IP -&gt; 大端整形</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">inet_addr</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> FAR * cp)</span></span>;	<span class="comment">// windows</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">inet_addr</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cp)</span></span>;			<span class="comment">// linux</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 大端整形 -&gt; 字符串IP</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">inet_ntoa</span><span class="params">(struct in_addr in)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>socket描述符</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//windows下为SOCKET类型 本质与Linux下的int相同</span></span><br></pre></td></tr></table></figure>

<p><strong>Interface</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回值: 成功返回套接字, 失败返回INVALID_SOCKET</span></span><br><span class="line"><span class="function">SOCKET <span class="title">socket</span><span class="params">(<span class="keyword">int</span> af,<span class="keyword">int</span> type,<span class="keyword">int</span> protocal)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">af: 地址族协议</span></span><br><span class="line"><span class="comment">	ipv4: AF_INET (windows/linux)</span></span><br><span class="line"><span class="comment">	PF_INET (windows)</span></span><br><span class="line"><span class="comment">	AF_INET == PF_INET  -----------------windows下的异同</span></span><br><span class="line"><span class="comment">type:</span></span><br><span class="line"><span class="comment">	SOCK_STREAM</span></span><br><span class="line"><span class="comment">	SOCK_DGRAM</span></span><br><span class="line"><span class="comment">protocal: 一般写0 即可</span></span><br><span class="line"><span class="comment">	在windows上的另一种写法  -----------------windows下的异同</span></span><br><span class="line"><span class="comment">	IPPROTO_TCP, 使用指定的流式协议中的tcp协议</span></span><br><span class="line"><span class="comment">	IPPROTO_UDP, 使用指定的报式协议中的udp协议</span></span><br><span class="line"><span class="comment">return: </span></span><br><span class="line"><span class="comment">	成功 返回套接字 / 失败 返回INVALID_SOCKET  -----------------windows下的异同</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 关键字: FAR NEAR, 这两个关键字在32/64位机上是没有意义的, 指定的 内存的寻址方式   -----------------windows下的异同</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(SOCKET s,<span class="keyword">const</span> struct sockaddr FAR* name, <span class="keyword">int</span> namelen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">return: </span></span><br><span class="line"><span class="comment">	成功 返回0 / 失败 返回SOCKET_ERROR -----------------windows下的异同</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(SOCKET s,<span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">return: </span></span><br><span class="line"><span class="comment">	成功返回0 / 失败返回SOCKET_ERROR -----------------windows下的异同</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">SOCKET <span class="title">accept</span> <span class="params">( SOCKET s, struct sockaddr FAR* addr, <span class="keyword">int</span> FAR* addrlen )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">return: </span></span><br><span class="line"><span class="comment">	成功 返回用于通信的套接字 / 失败返回INVALID_SOCKET</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span> <span class="params">(SOCKET s,<span class="keyword">const</span> struct sockaddr FAR* name,<span class="keyword">int</span> namelen )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">return: </span></span><br><span class="line"><span class="comment">	成功 返回0 / 失败返回SOCKET_ERROR</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//如果要使用windows api 中的 connect 需要在函数名前加::</span></span><br><span class="line">::<span class="built_in">connect</span>(sock, (struct sockaddr*)&amp;addr, <span class="built_in"><span class="keyword">sizeof</span></span>(addr));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收数据</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recv</span> <span class="params">(SOCKET s,<span class="keyword">char</span> FAR* buf,<span class="keyword">int</span> len,<span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="comment">// 发送数据</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">send</span> <span class="params">(SOCKET s,<span class="keyword">const</span> <span class="keyword">char</span> FAR * buf, <span class="keyword">int</span> len,<span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭套接字</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">closesocket</span> <span class="params">(SOCKET s)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">return:</span></span><br><span class="line"><span class="comment">	成功 返回0 / 失败 返回SOCKET_ERROR</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//----------------------- udp 通信函数 -------------------------</span></span><br><span class="line"><span class="comment">// 接收数据</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recvfrom</span><span class="params">(SOCKET s,<span class="keyword">char</span> FAR *buf,<span class="keyword">int</span> len,<span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">         struct sockaddr FAR *from,<span class="keyword">int</span> FAR *fromlen)</span></span>;</span><br><span class="line"><span class="comment">// 发送数据</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sendto</span><span class="params">(SOCKET s,<span class="keyword">const</span> <span class="keyword">char</span> FAR *buf,<span class="keyword">int</span> len,<span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">const</span> struct sockaddr FAR *to,<span class="keyword">int</span> tolen)</span></span>;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<h2 id="Socket-Programing-单线程"><a href="#Socket-Programing-单线程" class="headerlink" title="Socket Programing - 单线程"></a>Socket Programing - 单线程</h2><h3 id="Server-1"><a href="#Server-1" class="headerlink" title="Server"></a>Server</h3><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(disable : 4996) </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化套接字环境</span></span><br><span class="line">	WORD libversion = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">	WSADATA wsadata;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">WSAStartup</span>(libversion, &amp;wsadata) != <span class="number">0</span>) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;init winsock error.&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">LOBYTE</span>(wsadata.wVersion) != <span class="number">2</span> &amp;&amp; <span class="built_in">HIBYTE</span>(wsadata.wVersion) != <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">WSACleanup</span>();</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;version error.&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建server 监听socket描述字</span></span><br><span class="line">	SOCKET lis_socket = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (lis_socket == INVALID_SOCKET) &#123;</span><br><span class="line">		<span class="built_in">closesocket</span>(lis_socket);</span><br><span class="line">		<span class="built_in">WSACleanup</span>();</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;socket creat error.&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//绑定到指定协议地址 (IP+Port)</span></span><br><span class="line">	sockaddr_in addr_s;</span><br><span class="line">	addr_s.sin_family = AF_INET;</span><br><span class="line">	addr_s.sin_port = <span class="built_in">htons</span>(<span class="number">1234</span>);</span><br><span class="line">	addr_s.sin_addr.S_un.S_addr = ADDR_ANY;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">bind</span>(lis_socket, (sockaddr*)&amp;addr_s, <span class="built_in"><span class="keyword">sizeof</span></span>(addr_s)) == SOCKET_ERROR) &#123;</span><br><span class="line">		<span class="built_in">closesocket</span>(lis_socket);</span><br><span class="line">		<span class="built_in">WSACleanup</span>();</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;socket bind error.&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//监听 socket描述字 的读缓冲的连接情况</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">listen</span>(lis_socket, <span class="number">128</span>) == SOCKET_ERROR) &#123;</span><br><span class="line">		<span class="built_in">closesocket</span>(lis_socket);</span><br><span class="line">		<span class="built_in">WSACleanup</span>();</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;socket listen error.&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//阻塞 等待客户端发起请求 建立连接</span></span><br><span class="line">	SOCKET tx_socket;</span><br><span class="line">	sockaddr_in addr_c;</span><br><span class="line">	<span class="keyword">int</span> len = <span class="built_in"><span class="keyword">sizeof</span></span>(addr_c);</span><br><span class="line">	tx_socket = <span class="built_in">accept</span>(lis_socket, (sockaddr*)&amp;addr_c, &amp;len);</span><br><span class="line">	<span class="keyword">if</span> (tx_socket == INVALID_SOCKET) &#123;</span><br><span class="line">		<span class="built_in">closesocket</span>(lis_socket);</span><br><span class="line">		<span class="built_in">closesocket</span>(tx_socket);</span><br><span class="line">		<span class="built_in">WSACleanup</span>();</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;socket accept error.&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;已与一客户端建立连接!&quot;</span> &lt;&lt; endl &lt;&lt; <span class="string">&quot;客户端IP: &quot;</span> &lt;&lt; <span class="built_in">inet_ntoa</span>(addr_c.sin_addr) &lt;&lt; endl &lt;&lt; <span class="string">&quot;客户端Port: &quot;</span> &lt;&lt; <span class="built_in">ntohs</span>(addr_c.sin_port) &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">//读取数据</span></span><br><span class="line">		<span class="keyword">char</span> buff[<span class="number">1024</span>];</span><br><span class="line">		<span class="built_in">memset</span>(buff, <span class="number">0</span>, <span class="number">1024</span>); <span class="comment">//清空buff缓冲区</span></span><br><span class="line">		<span class="keyword">int</span> sign = <span class="built_in">recv</span>(tx_socket, buff, <span class="number">1024</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (sign &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;客户端 say: &quot;</span> &lt;&lt; buff &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (sign == <span class="number">0</span>) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;客户端断开连接!&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;数据读取失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//发送数据</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请输入希望发送的内容 :&quot;</span> &lt;&lt; endl;</span><br><span class="line">		string content;</span><br><span class="line">		<span class="built_in">getline</span>(cin, content);</span><br><span class="line">		sign = <span class="built_in">send</span>(tx_socket, content.<span class="built_in">c_str</span>(), <span class="built_in">strlen</span>(content.<span class="built_in">c_str</span>()), <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (sign &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (sign == <span class="number">0</span>) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;客户端断开连接!&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;数据发送失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭套接字</span></span><br><span class="line">	<span class="built_in">closesocket</span>(lis_socket);</span><br><span class="line">	<span class="built_in">closesocket</span>(tx_socket);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Client-1"><a href="#Client-1" class="headerlink" title="Client"></a>Client</h3><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(disable : 4996) </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 初始化套接字环境</span></span><br><span class="line">	WORD libversion = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">	WSADATA wsadata;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">WSAStartup</span>(libversion, &amp;wsadata) != <span class="number">0</span>) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;init winsock error.&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">LOBYTE</span>(wsadata.wVersion) != <span class="number">2</span> &amp;&amp; <span class="built_in">HIBYTE</span>(wsadata.wVersion) != <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">WSACleanup</span>();</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;version error.&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建server 通信socket描述字</span></span><br><span class="line">	SOCKET c_socket = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (c_socket == INVALID_SOCKET) &#123;</span><br><span class="line">		<span class="built_in">closesocket</span>(c_socket);</span><br><span class="line">		<span class="built_in">WSACleanup</span>();</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;socket creat error.&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//发起连接请求</span></span><br><span class="line">	sockaddr_in addr_s;</span><br><span class="line">	addr_s.sin_family = AF_INET;</span><br><span class="line">	addr_s.sin_port = <span class="built_in">htons</span>(<span class="number">1234</span>);</span><br><span class="line">	addr_s.sin_addr.S_un.S_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">connect</span>(c_socket, (sockaddr*)&amp;addr_s, <span class="built_in"><span class="keyword">sizeof</span></span>(addr_s)) == SOCKET_ERROR) &#123;</span><br><span class="line">		<span class="built_in">closesocket</span>(c_socket);</span><br><span class="line">		<span class="built_in">WSACleanup</span>();</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;socket connect error.&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//发送数据</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请输入希望发送的内容 :&quot;</span> &lt;&lt; endl;</span><br><span class="line">		string content;</span><br><span class="line">		<span class="built_in">getline</span>(cin, content);</span><br><span class="line">		<span class="keyword">int</span> sign = <span class="built_in">send</span>(c_socket, content.<span class="built_in">c_str</span>(), <span class="built_in">strlen</span>(content.<span class="built_in">c_str</span>()), <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (sign &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (sign == <span class="number">0</span>) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;服务端断开连接!&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;数据发送失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//读取数据</span></span><br><span class="line">		<span class="keyword">char</span> buff[<span class="number">1024</span>];</span><br><span class="line">		<span class="built_in">memset</span>(buff, <span class="number">0</span>, <span class="number">1024</span>); <span class="comment">//清空buff缓冲区</span></span><br><span class="line">		sign = <span class="built_in">recv</span>(c_socket, buff, <span class="number">1024</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (sign &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;服务端 say: &quot;</span> &lt;&lt; buff &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (sign == <span class="number">0</span>) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;服务端断开连接!&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;数据读取失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><blockquote>
<p>只能处理一对连接，无法处理server与多对client的连接</p>
</blockquote>
<h3 id="Reasons"><a href="#Reasons" class="headerlink" title="Reasons"></a>Reasons</h3><blockquote>
<p>存在引起进程阻塞的函数</p>
</blockquote>
<ul>
<li><p>accept()</p>
<blockquote>
<p> 当监听socket描述字的读缓冲区内存无连接对象时，accept()函数将导致进程进入阻塞态</p>
</blockquote>
</li>
<li><p>send()</p>
<blockquote>
<p>当通信socket描述字的读缓冲区内存中无数据可读时，send()函数将导致进程进入阻塞态</p>
</blockquote>
</li>
<li><p>write()</p>
<blockquote>
<p>当通信socket描述字的写缓冲区内存满时，write()函数将导致进程进入阻塞态</p>
</blockquote>
</li>
</ul>
<h2 id="Socket-Programing-多线程"><a href="#Socket-Programing-多线程" class="headerlink" title="Socket Programing - 多线程"></a>Socket Programing - 多线程</h2><h3 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h3><blockquote>
<p>主要负责监听</p>
<ul>
<li>**循环accept()**接受连接</li>
<li>每接受一个连接，<strong>创建</strong>一个<strong>子线程</strong>进行相应的通信</li>
<li><strong>回收子线程资源</strong>，由于join()会造成accept()阻塞，因此直接使用detach()作<strong>线程分离</strong></li>
</ul>
</blockquote>
<h3 id="子线程"><a href="#子线程" class="headerlink" title="子线程"></a>子线程</h3><blockquote>
<p>主要负责通信</p>
<ul>
<li>基于主线程传来的<strong>文件描述符与client地址</strong>，进行数据的发送与接受</li>
</ul>
</blockquote>
<h3 id="线程同步分析"><a href="#线程同步分析" class="headerlink" title="线程同步分析"></a>线程同步分析</h3><blockquote>
<p>主线程单独处理共有媒介数组</p>
<p>子线程也仅仅对收到的数据进行回复</p>
<p>因此不涉及多个线程对共享资源的争夺，不必做线程同步</p>
</blockquote>
<h3 id="Server-2"><a href="#Server-2" class="headerlink" title="Server"></a>Server</h3><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//若使用c++11中的多线程，必须引入的两个库</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(disable : 4996) </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Socket_addr</span> &#123;</span></span><br><span class="line">	sockaddr_in addr;</span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Socket_addr</span> <span class="title">pp</span>[512];</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">connect_thread</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化套接字环境</span></span><br><span class="line">	WORD libversion = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">	WSADATA wsadata;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">WSAStartup</span>(libversion, &amp;wsadata) != <span class="number">0</span>) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;init winsock error.&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">LOBYTE</span>(wsadata.wVersion) != <span class="number">2</span> &amp;&amp; <span class="built_in">HIBYTE</span>(wsadata.wVersion) != <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">WSACleanup</span>();</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;version error.&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建server 监听socket描述字</span></span><br><span class="line">	SOCKET lis_socket = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (lis_socket == INVALID_SOCKET) &#123;</span><br><span class="line">		<span class="built_in">closesocket</span>(lis_socket);</span><br><span class="line">		<span class="built_in">WSACleanup</span>();</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;socket creat error.&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//绑定到指定协议地址 (IP+Port)</span></span><br><span class="line">	sockaddr_in addr_s;</span><br><span class="line">	addr_s.sin_family = AF_INET;</span><br><span class="line">	addr_s.sin_port = <span class="built_in">htons</span>(<span class="number">1234</span>);</span><br><span class="line">	addr_s.sin_addr.S_un.S_addr = ADDR_ANY;</span><br><span class="line">	<span class="comment">//ADDR_ANY 宏定义，可以代表本机任意一个IP地址</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (::<span class="built_in">bind</span>(lis_socket, (sockaddr*)&amp;addr_s, <span class="built_in"><span class="keyword">sizeof</span></span>(addr_s)) == SOCKET_ERROR) &#123;</span><br><span class="line">	<span class="built_in">closesocket</span>(lis_socket);</span><br><span class="line">	<span class="built_in">WSACleanup</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;socket bind error.&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="comment">//监听 socket描述字 的读缓冲的连接情况</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">listen</span>(lis_socket, <span class="number">128</span>) == SOCKET_ERROR) &#123;</span><br><span class="line">		<span class="built_in">closesocket</span>(lis_socket);</span><br><span class="line">		<span class="built_in">WSACleanup</span>();</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;socket listen error.&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//阻塞 等待客户端发起请求 建立连接</span></span><br><span class="line">	SOCKET tx_socket;</span><br><span class="line">	sockaddr_in addr_c;</span><br><span class="line">	<span class="keyword">int</span> len = <span class="built_in"><span class="keyword">sizeof</span></span>(addr_c);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//主线程</span></span><br><span class="line">	<span class="comment">//1. 循环接受服务端发起的连接</span></span><br><span class="line">	<span class="comment">//2. 对应每个连接创建相应的子线程处理通信</span></span><br><span class="line">	<span class="comment">//3. 与子线程分离，使其他线程承担子线程的资源回收工作，防止主线程受阻塞</span></span><br><span class="line">	<span class="comment">//4. 关闭监听套接字描述符，通信套接字描述符不能由主线程关闭，而应由通信子线程关闭</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化参数数组</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++) &#123;</span><br><span class="line">		<span class="comment">//-1表示无效套接字描述符，可通过判断该描述符是否有效来判断是否还可以接受新的连接，并将新的连接存入该数组</span></span><br><span class="line">		pp[i].fd = <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Socket_addr</span>* <span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		tx_socket = <span class="built_in">accept</span>(lis_socket, (sockaddr*)&amp;addr_c, &amp;len);</span><br><span class="line">		<span class="keyword">if</span> (tx_socket == INVALID_SOCKET) &#123;</span><br><span class="line">			<span class="built_in">closesocket</span>(lis_socket);</span><br><span class="line">			<span class="built_in">closesocket</span>(tx_socket);</span><br><span class="line">			<span class="built_in">WSACleanup</span>();</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;socket&quot;</span> &lt;&lt; endl;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;socket accept error.&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//设置初始化参数</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (pp[i].fd == <span class="number">-1</span>) &#123;</span><br><span class="line"></span><br><span class="line">					<span class="comment">//设置参数对应的地址与通信套接字描述符信息</span></span><br><span class="line">					pp[i].addr = addr_c;</span><br><span class="line">					pp[i].fd = tx_socket;</span><br><span class="line"></span><br><span class="line">					<span class="comment">//获取线程创建参数的内存，如果无为-1的，说明无法在创建更多线程了</span></span><br><span class="line">					p = &amp;pp[i];</span><br><span class="line">                    </span><br><span class="line">                      <span class="comment">//至关重要的break，若忽略，处理第一次连接的线程将占据所有媒介资源</span></span><br><span class="line">                      <span class="comment">//只要第一次连接的客户端不退出，将导致能够检测到其他连接但是却不能够通信，因为数组中所有p-&gt;fd=-1</span></span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (i == <span class="number">512</span> - <span class="number">1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">//sleep(5)</span></span><br><span class="line">					this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">					i--;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//创建子线程</span></span><br><span class="line">			<span class="function">thread <span class="title">con</span><span class="params">(connect_thread, p)</span></span>;</span><br><span class="line">			<span class="comment">//子线程资源分离</span></span><br><span class="line">             <span class="comment">//不使用join回收的原因是join是阻塞函数，将导致accept所在线程的阻塞</span></span><br><span class="line">			con.<span class="built_in">detach</span>();</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭监听套接字描述符</span></span><br><span class="line">	<span class="built_in">closesocket</span>(lis_socket);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">connect_thread</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Socket_addr</span>* <span class="title">p</span> =</span> (struct Socket_addr*)arg;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;已与新客户端建立连接!&quot;</span> &lt;&lt; endl &lt;&lt; <span class="string">&quot;客户端IP: &quot;</span> &lt;&lt; <span class="built_in">inet_ntoa</span>(p-&gt;addr.sin_addr) &lt;&lt; endl &lt;&lt; <span class="string">&quot;客户端Port: &quot;</span> &lt;&lt; <span class="built_in">ntohs</span>(p-&gt;addr.sin_port) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    	<span class="comment">//读取数据</span></span><br><span class="line">    	<span class="keyword">char</span> buff[<span class="number">1024</span>];</span><br><span class="line">    	<span class="built_in">memset</span>(buff, <span class="number">0</span>, <span class="number">1024</span>); <span class="comment">//清空buff缓冲区</span></span><br><span class="line">    	<span class="keyword">int</span> sign = <span class="built_in">recv</span>(p-&gt;fd, buff, <span class="number">1024</span>, <span class="number">0</span>);</span><br><span class="line">    	<span class="keyword">if</span> (sign &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    		cout &lt;&lt; <span class="string">&quot;客户端&quot;</span> &lt;&lt; <span class="built_in">inet_ntoa</span>(p-&gt;addr.sin_addr) &lt;&lt; <span class="string">&quot;say: &quot;</span> &lt;&lt; buff &lt;&lt; endl;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span> (sign == <span class="number">0</span>) &#123;</span><br><span class="line">    		cout &lt;&lt; <span class="string">&quot;客户端&quot;</span>&lt;&lt; <span class="built_in">inet_ntoa</span>(p-&gt;addr.sin_addr) &lt;&lt;<span class="string">&quot;断开连接!&quot;</span> &lt;&lt; endl;</span><br><span class="line">			p-&gt;fd = <span class="number">-1</span>;</span><br><span class="line">    		<span class="keyword">break</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">else</span> &#123;</span><br><span class="line">    		cout &lt;&lt; <span class="string">&quot;读取客户端&quot;</span>&lt;&lt; <span class="built_in">inet_ntoa</span>(p-&gt;addr.sin_addr) &lt;&lt;<span class="string">&quot;数据失败!&quot;</span> &lt;&lt; endl;</span><br><span class="line">			p-&gt;fd = <span class="number">-1</span>;</span><br><span class="line">    		<span class="keyword">break</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//发送数据</span></span><br><span class="line">    	cout &lt;&lt; <span class="string">&quot;请输入希望向客户端&quot;</span> &lt;&lt; <span class="built_in">inet_ntoa</span>(p-&gt;addr.sin_addr) &lt;&lt;<span class="string">&quot;发送的内容 :&quot;</span> &lt;&lt; endl;</span><br><span class="line">    	string content;</span><br><span class="line">    	<span class="built_in">getline</span>(cin, content);</span><br><span class="line">    	sign = <span class="built_in">send</span>(p-&gt;fd, content.<span class="built_in">c_str</span>(), <span class="built_in">strlen</span>(content.<span class="built_in">c_str</span>()), <span class="number">0</span>);</span><br><span class="line">    	<span class="keyword">if</span> (sign &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">if</span> (sign == <span class="number">0</span>) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;客户端&quot;</span> &lt;&lt; <span class="built_in">inet_ntoa</span>(p-&gt;addr.sin_addr) &lt;&lt; <span class="string">&quot;断开连接!&quot;</span> &lt;&lt; endl;</span><br><span class="line">			p-&gt;fd = <span class="number">-1</span>;</span><br><span class="line">    		<span class="keyword">break</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">else</span> &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;向客户端&quot;</span> &lt;&lt; <span class="built_in">inet_ntoa</span>(p-&gt;addr.sin_addr) &lt;&lt; <span class="string">&quot;发送数据失败!&quot;</span> &lt;&lt; endl;</span><br><span class="line">			p-&gt;fd = <span class="number">-1</span>;</span><br><span class="line">    		<span class="keyword">break</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关闭套接字</span></span><br><span class="line">	<span class="built_in">closesocket</span>(p-&gt;fd);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置相应数组位置的fd值为-1，为其他连接释放相应资源</span></span><br><span class="line">	p-&gt;fd = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>注意:</code></p>
<ol>
<li><p>Winsock2.h 与 c++11中 bind()函数冲突 解决方案</p>
<blockquote>
<ul>
<li>不使用std命名空间</li>
<li>使用运算符 :: ,::bind()指明调用Winsock2.h中的bind函数</li>
</ul>
</blockquote>
</li>
</ol>
</blockquote>
<h3 id="Client-2"><a href="#Client-2" class="headerlink" title="Client"></a>Client</h3><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//同单线程</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Socket-Programing-线程池"><a href="#Socket-Programing-线程池" class="headerlink" title="Socket Programing - 线程池"></a>Socket Programing - 线程池</h2><h3 id="Server-3"><a href="#Server-3" class="headerlink" title="Server"></a>Server</h3><ul>
<li><p>创建线程池对象</p>
</li>
<li><p>添加任务</p>
<blockquote>
<ol>
<li>连接任务(需要主线程传递所需要的参数)</li>
<li>通信任务(每一个连接任务对应一个通信任务，参数传递体现关联性)</li>
</ol>
</blockquote>
</li>
</ul>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Thread_pool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Thread_pool.cpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(disable : 4996) </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Socket_addr</span> &#123;</span></span><br><span class="line">	sockaddr_in addr;</span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//主线程向线程池中的执行线程传递执行需要的参数 : 监听套接字，线程池对象</span></span><br><span class="line"><span class="comment">//线程池对象参数的原因是因为执行线程处理函数是个静态方法</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Socket_arg</span> &#123;</span></span><br><span class="line">	Thread_pool&lt;Socket_arg&gt; *p;</span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">accept_task</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">connect_task</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化套接字环境</span></span><br><span class="line">	WORD libversion = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">	WSADATA wsadata;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">WSAStartup</span>(libversion, &amp;wsadata) != <span class="number">0</span>) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;init winsock error.&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">LOBYTE</span>(wsadata.wVersion) != <span class="number">2</span> &amp;&amp; <span class="built_in">HIBYTE</span>(wsadata.wVersion) != <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">WSACleanup</span>();</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;version error.&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建server 监听socket描述字</span></span><br><span class="line">	SOCKET lis_socket = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (lis_socket == INVALID_SOCKET) &#123;</span><br><span class="line">		<span class="built_in">closesocket</span>(lis_socket);</span><br><span class="line">		<span class="built_in">WSACleanup</span>();</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;socket creat error.&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//绑定到指定协议地址 (IP+Port)</span></span><br><span class="line">	sockaddr_in addr_s;</span><br><span class="line">	addr_s.sin_family = AF_INET;</span><br><span class="line">	addr_s.sin_port = <span class="built_in">htons</span>(<span class="number">1234</span>);</span><br><span class="line">	addr_s.sin_addr.S_un.S_addr = ADDR_ANY;</span><br><span class="line">	<span class="comment">//ADDR_ANY 宏定义，可以代表本机任意一个IP地址</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (::<span class="built_in">bind</span>(lis_socket, (sockaddr*)&amp;addr_s, <span class="built_in"><span class="keyword">sizeof</span></span>(addr_s)) == SOCKET_ERROR) &#123;</span><br><span class="line">		<span class="built_in">closesocket</span>(lis_socket);</span><br><span class="line">		<span class="built_in">WSACleanup</span>();</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;socket bind error.&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//监听 socket描述字 的读缓冲的连接情况</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">listen</span>(lis_socket, <span class="number">128</span>) == SOCKET_ERROR) &#123;</span><br><span class="line">		<span class="built_in">closesocket</span>(lis_socket);</span><br><span class="line">		<span class="built_in">WSACleanup</span>();</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;socket listen error.&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------</span></span><br><span class="line">	<span class="comment">//创建线程池</span></span><br><span class="line">	<span class="function">Thread_pool&lt;Socket_arg&gt; <span class="title">pool</span><span class="params">(<span class="number">3</span>, <span class="number">400</span>)</span></span>;</span><br><span class="line">	<span class="comment">//初始化参数</span></span><br><span class="line">    <span class="comment">//必须堆上内存，栈上内存会被共享(传递的是地址)，从而后续线程通信套接字更新旧线程套接字</span></span><br><span class="line">	Socket_arg *arg = <span class="keyword">new</span> <span class="built_in">Socket_arg</span>();</span><br><span class="line">	arg-&gt;fd = lis_socket;</span><br><span class="line">	arg-&gt;p = &amp;pool;</span><br><span class="line">	<span class="comment">//添加任务</span></span><br><span class="line">	pool.<span class="built_in">addTask</span>(accept_task, arg);</span><br><span class="line"></span><br><span class="line">	this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">1000000</span>));</span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">accept_task</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Socket_arg* pool = <span class="keyword">static_cast</span>&lt;Socket_arg*&gt;(arg);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//阻塞 等待客户端发起请求 建立连接</span></span><br><span class="line">	SOCKET tx_socket;</span><br><span class="line">	sockaddr_in addr_c;</span><br><span class="line">	<span class="keyword">int</span> len = <span class="built_in"><span class="keyword">sizeof</span></span>(addr_c);</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		tx_socket = <span class="built_in">accept</span>(pool-&gt;fd, (sockaddr*)&amp;addr_c, &amp;len);</span><br><span class="line">		<span class="keyword">if</span> (tx_socket == INVALID_SOCKET) &#123;</span><br><span class="line">			<span class="built_in">closesocket</span>(pool-&gt;fd);</span><br><span class="line">			<span class="built_in">closesocket</span>(tx_socket);</span><br><span class="line">			<span class="built_in">WSACleanup</span>();</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;socket accept error.&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------</span></span><br><span class="line">			<span class="comment">//初始化参数</span></span><br><span class="line">			Socket_addr *a = <span class="keyword">new</span> <span class="built_in">Socket_addr</span>();</span><br><span class="line">			a-&gt;addr = addr_c;</span><br><span class="line">			a-&gt;fd = tx_socket;</span><br><span class="line">			<span class="comment">//添加连接任务</span></span><br><span class="line">			pool-&gt;p-&gt;<span class="built_in">addTask</span>(connect_task, a);</span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭监听套接字描述符</span></span><br><span class="line">	<span class="built_in">closesocket</span>(pool-&gt;fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">connect_task</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Socket_addr</span>* <span class="title">p</span> =</span> (struct Socket_addr*)arg;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;已与新客户端建立连接!&quot;</span> &lt;&lt; endl &lt;&lt; <span class="string">&quot;客户端IP: &quot;</span> &lt;&lt; <span class="built_in">inet_ntoa</span>(p-&gt;addr.sin_addr) &lt;&lt; endl &lt;&lt; <span class="string">&quot;客户端Port: &quot;</span> &lt;&lt; <span class="built_in">ntohs</span>(p-&gt;addr.sin_port) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">//读取数据</span></span><br><span class="line">		<span class="keyword">char</span> buff[<span class="number">1024</span>];</span><br><span class="line">		<span class="built_in">memset</span>(buff, <span class="number">0</span>, <span class="number">1024</span>); <span class="comment">//清空buff缓冲区</span></span><br><span class="line">		<span class="keyword">int</span> sign = <span class="built_in">recv</span>(p-&gt;fd, buff, <span class="number">1024</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (sign &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;客户端&quot;</span> &lt;&lt; <span class="built_in">ntohs</span>(p-&gt;addr.sin_port) &lt;&lt; <span class="string">&quot;say: &quot;</span> &lt;&lt; buff &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (sign == <span class="number">0</span>) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;客户端&quot;</span> &lt;&lt; <span class="built_in">ntohs</span>(p-&gt;addr.sin_port) &lt;&lt; <span class="string">&quot;断开连接!&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;读取客户端&quot;</span> &lt;&lt; <span class="built_in">ntohs</span>(p-&gt;addr.sin_port) &lt;&lt; <span class="string">&quot;数据失败!&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//发送数据</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请输入希望向客户端&quot;</span> &lt;&lt; <span class="built_in">ntohs</span>(p-&gt;addr.sin_port) &lt;&lt; <span class="string">&quot;发送的内容 :&quot;</span> &lt;&lt; endl;</span><br><span class="line">		string content;</span><br><span class="line">		<span class="built_in">getline</span>(cin, content);</span><br><span class="line">		sign = <span class="built_in">send</span>(p-&gt;fd, content.<span class="built_in">c_str</span>(), <span class="built_in">strlen</span>(content.<span class="built_in">c_str</span>()), <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (sign &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (sign == <span class="number">0</span>) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;客户端&quot;</span> &lt;&lt; <span class="built_in">ntohs</span>(p-&gt;addr.sin_port) &lt;&lt; <span class="string">&quot;断开连接!&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;向客户端&quot;</span> &lt;&lt; <span class="built_in">ntohs</span>(p-&gt;addr.sin_port) &lt;&lt; <span class="string">&quot;发送数据失败!&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭套接字</span></span><br><span class="line">	<span class="built_in">closesocket</span>(p-&gt;fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
]]></content>
      <categories>
        <category>Socket</category>
      </categories>
      <tags>
        <tag>Socket</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Thread</title>
    <url>/2021/08/11/Thread/Thread/</url>
    <content><![CDATA[<h1 id="Process-进程"><a href="#Process-进程" class="headerlink" title="Process 进程"></a>Process 进程</h1><h2 id="进程概述"><a href="#进程概述" class="headerlink" title="进程概述"></a>进程概述</h2><ul>
<li><p>程序</p>
<blockquote>
<p>可执行的二进制文件，占用磁盘资源</p>
</blockquote>
</li>
<li><p>进程</p>
<blockquote>
<p>运行中的程序，占用CPU资源，不占据磁盘资源</p>
<p>是系统资源分配的基本单位</p>
</blockquote>
</li>
</ul>
<h2 id="进程空间"><a href="#进程空间" class="headerlink" title="进程空间"></a>进程空间</h2><h3 id="defination"><a href="#defination" class="headerlink" title="defination"></a>defination</h3><blockquote>
<p>每一个进程都会对应一个进程空间，即虚拟地址空间</p>
<p>其大小与操作系统的位数有关</p>
<p>n位操作系统，虚拟地址空间大小为2^n</p>
</blockquote>
<h4 id="虚拟地址空间"><a href="#虚拟地址空间" class="headerlink" title="虚拟地址空间"></a>虚拟地址空间</h4><ul>
<li>作用</li>
</ul>
<blockquote>
<p>操作系统cpu不具备数据存储能力，仅具备运算能力</p>
<p>cpu通过mmu内存管理单元</p>
<p>实现虚拟地址到物理内存的映射</p>
</blockquote>
<ul>
<li><p>意义</p>
<blockquote>
<ol>
<li>扩大地址空间</li>
<li>保护内存，不同进程运行在不同的虚拟地址空间中，互不影响</li>
<li>控制内存访问，提高了安全性</li>
<li>解决了直接使用物理内存导致的大量<strong>内存碎片</strong>问题</li>
</ol>
</blockquote>
</li>
</ul>
<h3 id="Address-Layout-32bit"><a href="#Address-Layout-32bit" class="headerlink" title="Address Layout -32bit"></a>Address Layout -32bit</h3><h4 id="内核区-1G"><a href="#内核区-1G" class="headerlink" title="内核区 1G"></a>内核区 1G</h4><p>标记: 目前了解并不深入</p>
<blockquote>
<ul>
<li>公用内核代码和数据</li>
</ul>
<p>不允许<strong>用户态应用程序</strong>直接或间接读写该区域</p>
<p>内核区<strong>驻留内存</strong>，是操作系统的一部分</p>
<p>虽然每个进程都有自己独立的虚拟地址空间，但是这些虚拟地址空间的内核区，关联着<strong>同一块物理内存</strong></p>
<ul>
<li>维护进程相关的数据结构</li>
</ul>
<p>pcb进程控制块</p>
<blockquote>
<p>pcb进程控制块中记录了进程运行相关的一些信息，如<strong>进程id，进程状态</strong>等</p>
</blockquote>
<p>…</p>
</blockquote>
<h4 id="用户区-3G"><a href="#用户区-3G" class="headerlink" title="用户区 3G"></a>用户区 3G</h4><blockquote>
<p><img src="/images/Thread/image-20210803104900968.png" alt="image-20210803104900968"></p>
<p>从0开始的连续地址空间:</p>
<p><strong>保留区:</strong> 没有被赋予物理地址，NULL指向的内存</p>
<p><strong>.text段:</strong> 存放程序的执行代码</p>
<p><strong>.data段:</strong> 静态存储区，全局存储区，存放已被初始化且不为0的全局变量和静态变量(局部or全局)</p>
<p><strong>.bss段:</strong> 存放未被初始化或初始化为0的全局变量和静态变量(局部or全局)</p>
<p><strong>heap(堆区):</strong> <strong>动态分配的向上增长的不连续内存</strong></p>
<p><strong>mmap(内存映射区):</strong> 作为内存映射区加载磁盘文件或者动态库</p>
<p><strong>stack(栈区):</strong> 函数内部对的函数参数，返回值，非静态局部变量，<strong>系统自动分配的向下增长的连续内存</strong></p>
<p><strong>argv,argc(命令行参数):</strong> 传递给main()函数的参数</p>
<p><strong>env(环境变量):</strong> 存放工作路径，进程所有者的等信息 </p>
</blockquote>
<h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><ul>
<li>创建态</li>
<li>就绪态</li>
<li>运行态</li>
<li>阻塞态(挂起态)</li>
<li>退出态</li>
</ul>
<h3 id="CPU调度与切换"><a href="#CPU调度与切换" class="headerlink" title="CPU调度与切换"></a>CPU调度与切换</h3><blockquote>
<p>任务从保存到再次加载的这个过程就是一次上下文切换</p>
</blockquote>
<h2 id="Linux下的接口函数"><a href="#Linux下的接口函数" class="headerlink" title="Linux下的接口函数"></a>Linux下的接口函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入相应头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>pid_t fork(void);</code></li>
</ul>
<blockquote>
<p><strong>子进程的创建</strong></p>
<p>pid_t: 通过该返回值判断当前进程是子进程还是父进程</p>
<blockquote>
<p>若 pid &gt; 0 则当前进程为父进程，pid为子进程id</p>
<p>若 pid = 0 则当前进程为子进程</p>
</blockquote>
<p><code>注意:</code></p>
<ol>
<li>创建成功后，子进程得到新的虚拟地址空间，<strong>用户区内容</strong>虽然与父进程<strong>相同</strong>，但是却<strong>互不影响</strong>，变化相互独立</li>
<li><strong>子进程的调用位置</strong>从fork调用点开始，子进程中fork也同样会有返回值，通过fork()返回值标识父子进程</li>
<li>一定要注意区分父子进程，如循环创建子进程，若不作子进程处理，子进程也将创建孙子进程</li>
</ol>
</blockquote>
<ul>
<li><p><code>pid_t getpid(void);</code></p>
<blockquote>
<p><strong>获取当前进程的进程IP - PID</strong></p>
</blockquote>
</li>
<li><p><code>pid_t getppid(void);</code></p>
<blockquote>
<p><strong>获取父进程的进程IP - PID</strong></p>
</blockquote>
</li>
<li><p><code>void exit(int status);</code></p>
<blockquote>
<p>标准C库函数下的<strong>退出进程</strong></p>
<p>status: 退出码，退出之后的状态码</p>
<p>main()中 return 也可退出进程</p>
</blockquote>
</li>
<li><p><code>void _exit(int status);</code></p>
<blockquote>
<p>Linux系统下的<strong>退出进程</strong></p>
<p>status: 退出码，退出之后的状态码</p>
<p>main()中 return 也可退出进程</p>
</blockquote>
</li>
<li><p><code>pid_t wait(int *status);</code></p>
<blockquote>
<p><strong>阻塞函数</strong>，用于<strong>进程资源的回收</strong></p>
<p>status: <strong>传出参数</strong>，用于判断回收进程的退出方式，不需要可指定为NULL，取出status的数据需要使用一些<strong>宏函数</strong></p>
<p>WIFEXITED(status): 返回 1, 进程是正常退出的</p>
<p>WEXITSTATUS(status)：得到进程退出时候的状态码，相当于 return 后边的数值，或者 exit () 函数的参数</p>
<p>WIFSIGNALED(status): 返回 1, 进程是被信号杀死了</p>
<p>WTERMSIG(status): 获得进程是被哪个信号杀死的，会得到信号的编号</p>
<p>return: 成功 回收的子进程PID / 失败 -1</p>
</blockquote>
</li>
<li><p><code>pid_t waitpid(pid_t pid,int *status,int options);</code></p>
<blockquote>
<p>可选阻塞or非阻塞的升级版wait，用于<strong>进程资源的回收</strong></p>
<p>pid: 指定进程回收范围</p>
<blockquote>
<p>-1 等同于wait()，无差别回收</p>
<p>pid 回收指定IP为pid的子进程资源</p>
</blockquote>
<p>status: 传出参数，判断子进程退出方式</p>
<p>options: 是否阻塞</p>
<p>0 阻塞方式 / WNOHANG 非阻塞方式</p>
</blockquote>
</li>
</ul>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><blockquote>
<p>子进程退出，用户区资源已自动释放，但是子进程pcb等内核区资源无法自己释放，而父进程也不释放子进程内核区资源</p>
<p>-</p>
<p>此时即使再次kill子进程也无法释放其内核区资源，必须由父进程回收</p>
</blockquote>
<h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><blockquote>
<p>子进程退出之前，父进程提前退出，导致子进程成为孤儿进程</p>
<p>-</p>
<p>系统将分配一个固定进程领养该子进程，防止其进一步成为僵尸进程</p>
</blockquote>
<h1 id="Thread-线程"><a href="#Thread-线程" class="headerlink" title="Thread 线程"></a>Thread 线程</h1><h2 id="线程概述"><a href="#线程概述" class="headerlink" title="线程概述"></a>线程概述</h2><blockquote>
<p>linux下线程是轻量级的进程，windows下则不是</p>
<p>一个进程可以由多个线程组成且至少由一个线程组成</p>
<p>是系统调度的最小单位</p>
</blockquote>
<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><ul>
<li><p>进程</p>
<blockquote>
<ol>
<li>系统资源分配的最小单位</li>
<li>一个进程对应一个虚拟地址空间，并且相互独立，互不影响</li>
<li>上下文切换较线程更缓慢</li>
</ol>
</blockquote>
</li>
<li><p>线程</p>
<blockquote>
<ol>
<li>系统调度的最小单位</li>
<li>多个线程共享一个虚拟地址空间，独享的是栈区与某些内核</li>
<li>线程更廉价，上下文切换快</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Linux下的接口函数-1"><a href="#Linux下的接口函数-1" class="headerlink" title="Linux下的接口函数"></a>Linux下的接口函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入相应的头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>pthread_t pthread_self(void);</code></p>
<blockquote>
<p>返回当前线程的线程ID</p>
</blockquote>
</li>
<li><p><code>int pthread_create(pthread_t *id,const pthread_attr_t *attr,void*(*start_routine)(void*),void* arg);</code></p>
<blockquote>
<p><strong>线程创建</strong></p>
<p>id: 传出参数，若创建成功，返回指向子线程ID内存的指针</p>
<p>attr: 线程属性，一般为NULL</p>
<p>start_routine: 函数指针，子线程将执行的回调函数</p>
<p>arg: 函数实参(只能有一个，并且形参为void*)</p>
<p>return: 成功 0 / 失败 相应错误号</p>
<p>-</p>
</blockquote>
</li>
<li><p><code>void pthread_exit(void *retval);</code></p>
<blockquote>
<p><strong>线程退出</strong></p>
<p>retval: 指向线程退出时父线程将得到的数据的指针，如果不需要则指定为NULL</p>
<p>-</p>
<p><code>注意:</code></p>
<ol>
<li>主线程一旦退出，子线程的资源也将被一并释放，反之则不会</li>
<li>主进程退出，并不会使子进程资源释放，因为不占同一块内存资源</li>
</ol>
</blockquote>
</li>
<li><p><code>int pthread_join(pthread_t pid,void **retval)</code></p>
<blockquote>
<p><strong>子线程资源回收</strong></p>
<p>阻塞函数</p>
<p>pid: 子线程的线程ID</p>
<p>retval: 二级指针，指向一级指针的地址，是一个传出参数，接受pthread_exit()中的retval指针，可指定为NULL</p>
<p>return: 成功 0 / 失败 错误号</p>
<p>-</p>
<p><strong>子线程资源回收方式</strong></p>
<blockquote>
<p>由于pthread_exit与pthread_join函数通过指针来传递资源的地址</p>
<p>所以应该尽量将即将回收的资源存放到全局数据区(全局变量，静态变量中)或者heap堆区</p>
</blockquote>
<ul>
<li><p>使用子线程栈</p>
<blockquote>
<p>若资源内存位于栈区，则内存将随子线程的退出而释放，父线程将无法回收</p>
</blockquote>
</li>
<li><p>全局变量</p>
</li>
<li><p>主线程栈</p>
<blockquote>
<p>主线程中创建对象，子线程中进行赋值，主线程不仅可以通过两个函数接口返回资源</p>
<p>直接通过对象便可访问资源</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p><code>int pthread_detach(pthread_t thread);</code></p>
<blockquote>
<p><strong>线程分离</strong></p>
<blockquote>
<p>pthread_join函数为阻塞函数，会影响主线程的业务处理</p>
<p>线程分离后，子线程退出时的内核资源将由系统的其他线程接管</p>
</blockquote>
<p>thread: 即将分离的子线程ID</p>
</blockquote>
</li>
</ul>
<h2 id="多线程与线程同步"><a href="#多线程与线程同步" class="headerlink" title="多线程与线程同步"></a>多线程与线程同步</h2><h3 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h3><ul>
<li><p>并发</p>
<blockquote>
<p>针对某一个硬件资源，如<strong>一个cpu核心</strong></p>
<p>cpu在一个时间段只能处理一个任务，但是却给人以多任务<strong>同时处理的假象</strong></p>
<p>其实是通过<strong>cpu时间片的快速切换</strong>来时间的，各个线程是通过抢夺cpu时间片来<strong>轮流进行</strong>的</p>
</blockquote>
</li>
<li><p>并行 </p>
<blockquote>
<p>针对多个硬件资源，如<strong>多个cpu核心</strong></p>
<p>真正意义上的<strong>多任务同时处理</strong></p>
<p>但是每个硬件资源同样存在并发</p>
</blockquote>
</li>
</ul>
<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><blockquote>
<p>多个线程”同时”操作一个共享资源时，相互之间存在冲突，导致数据混乱，需要实现同步，顺序访问</p>
</blockquote>
<h3 id="临界资源与临界区"><a href="#临界资源与临界区" class="headerlink" title="临界资源与临界区"></a>临界资源与临界区</h3><ul>
<li><p>临界资源</p>
<blockquote>
<p>多个线程共同访问的资源称为临界资源</p>
</blockquote>
</li>
<li><p>临界区</p>
<blockquote>
<p>临界资源的上下相关代码称为临界区</p>
</blockquote>
</li>
<li><p>线程同步</p>
<blockquote>
<ol>
<li>在临界区上界加锁</li>
<li>在临界区下界解锁</li>
</ol>
<p>通过这样的方式可以实现临界区只能同时被一个线程访问</p>
</blockquote>
</li>
</ul>
<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><blockquote>
<p><code>pthread_mutex_t mutex;</code></p>
<p>mutex: 互斥锁，含有</p>
<ol>
<li>互斥锁状态信息 锁定 or 打开</li>
<li>若为锁定态，则还存有相关线程的信息，如线程ID</li>
</ol>
</blockquote>
<h4 id="互斥锁函数"><a href="#互斥锁函数" class="headerlink" title="互斥锁函数"></a>互斥锁函数</h4><ul>
<li><code>int pthread_mutex_init(pthread_mutex_t *restrict mutex , const pthread_mutexattr_t *restrict attr);</code></li>
</ul>
<blockquote>
<p><strong>初始化互斥锁</strong></p>
<p>mutex: 指向相应互斥锁的指针</p>
<p>attr: 互斥锁的属性，一般指定为NULL，即采用默认属性</p>
<p>return: 成功 0 / 失败 错误号</p>
</blockquote>
<ul>
<li><p><code>int pthread_mutex_lock(pthread_mutex_t *mutex);</code></p>
<blockquote>
<p><strong>设置互斥锁为锁定态 - 加锁</strong></p>
<blockquote>
<p>阻塞函数，若加锁时该锁已被锁定，则相应线程被阻塞，直到锁被打开，再解除阻塞，争夺锁资源</p>
</blockquote>
<p>mutex: 指向相应互斥锁的指针</p>
<p>return: 成功 0 / 失败 错误号</p>
</blockquote>
</li>
<li><p><code>int pthread_mutex_trylock(pthread_mutex_t *mutex);</code></p>
<blockquote>
<p><strong>设置互斥锁为锁定态 - 加锁</strong></p>
<blockquote>
<p>非阻塞函数，若加锁时该锁已被锁定，返回错误号</p>
</blockquote>
<p>mutex: 指向相应互斥锁的指针</p>
<p>return: 成功 0 / 失败 错误号</p>
</blockquote>
</li>
<li><p><code>int pthread_mutex_unlock(pthread_mutex_t *mutex);</code></p>
<blockquote>
<p><strong>设置互斥锁为打开态 - 解锁</strong></p>
<blockquote>
<p>只有加锁的线程才能够对相应互斥锁解锁</p>
</blockquote>
<p>mutex: 指向相应互斥锁的指针</p>
<p>return: 成功 0 / 失败 错误号</p>
</blockquote>
</li>
<li><p><code>int pthread_mutex_destory(pthread_mutex_t *mutex)</code></p>
<blockquote>
<p><strong>释放互斥锁资源</strong></p>
<p>mutex: 指向相应互斥锁的指针</p>
<p>return: 成功 0 / 失败 错误号</p>
</blockquote>
</li>
</ul>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><blockquote>
<p>根本原因为多线程对有限系统资源的争夺</p>
</blockquote>
<h5 id="常见情况"><a href="#常见情况" class="headerlink" title="常见情况"></a>常见情况</h5><ul>
<li><p>加锁后忘记解锁</p>
<blockquote>
<p>只有加锁线程A能够解锁，其他线程再申请加锁时，如果A线程一直不解锁，将导致其他线程死锁，一直阻塞</p>
</blockquote>
</li>
<li><p>重复加锁</p>
<blockquote>
<p>加锁线程A重复加锁，第二次加锁时必须等待第一次解锁，而第一次解锁又必须等待第二次加锁，进入死锁</p>
</blockquote>
</li>
<li><p>多线程同时访问多个共享资源</p>
<blockquote>
<p>A线程访问共享资源A时加锁，同时B线程访问共享资源B时加锁</p>
<p>A线程访问A资源时申请访问B资源，同时B线程访问B资源访时申请访问A资源</p>
<p>A线程因为B线程未打开B资源的锁而阻塞，同时B线程因为A线程未打开A资源的锁而阻塞</p>
<p>陷入死锁</p>
</blockquote>
</li>
</ul>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><blockquote>
<p>在读操作时允许多个线程同时访问，可以提高程序的执行效率</p>
<p><code>pthread_rwlock_t rwlock;</code></p>
<p>rwlock: 读写锁，含有</p>
<ol>
<li>互斥锁状态信息 锁定 or 打开</li>
<li>若为锁定态，则还存有锁定的操作类型 读 / 写</li>
<li>若为锁定态，则还存有相关线程的信息，如线程ID</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>对临界区添加读锁后可在添加其他读锁</li>
<li>对临界区添加写锁后不允许再添加其他任何锁</li>
<li>在抢夺cpu调度权时，写锁的优先级高于读锁</li>
</ol>
</blockquote>
<h4 id="读写锁函数"><a href="#读写锁函数" class="headerlink" title="读写锁函数"></a>读写锁函数</h4><ul>
<li><code>int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock,const pthread_rwlockattrt *restrict attr);</code></li>
</ul>
<blockquote>
<p><strong>初始化读写锁</strong></p>
<p>rwlock: 指向相应读写锁的指针</p>
<p>attr: 读写锁的属性，一般指定为NULL，即采用默认属性</p>
<p>return: 成功 0 / 失败 错误号</p>
</blockquote>
<ul>
<li><p><code>int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);</code></p>
<blockquote>
<p><strong>锁定读锁</strong></p>
<blockquote>
<p>阻塞函数，若加锁时该锁已被锁定为写锁，则相应线程被阻塞，直到锁被打开，再解除阻塞，争夺锁资源</p>
<p>若加读锁时候该锁已被锁定为读锁，则仍可加读锁</p>
</blockquote>
<p>rwlock: 指向相应读锁的指针</p>
<p>return: 成功 0 / 失败 错误号</p>
</blockquote>
</li>
<li><p><code>int pthread_rwlock_tryrdlock(pthread_rwlock_t *rdlock);</code></p>
<blockquote>
<p><strong>锁定读锁</strong></p>
<blockquote>
<p>非阻塞函数，若加锁时该锁已被锁定为写锁，则返回错误号</p>
<p>若加读锁时候该锁已被锁定为读锁，则仍可加读锁</p>
</blockquote>
<p>rdlock: 指向相应互斥锁的指针</p>
<p>return: 成功 0 / 失败 错误号</p>
</blockquote>
<p><code>int pthread_rwlock_wrlock(pthread_rwlock_t *wrlock);</code></p>
<blockquote>
<p><strong>锁定写锁</strong></p>
<blockquote>
<p>阻塞函数，若加锁时该锁已被锁定，则相应线程被阻塞，直到锁被打开，再解除阻塞，争夺锁资源</p>
</blockquote>
<p>wrlock: 指向相应写锁的指针</p>
<p>return: 成功 0 / 失败 错误号</p>
</blockquote>
<p><code>int pthread_rwlock_trywrlock(pthread_rwlock_t *wrlock);</code></p>
<blockquote>
<p><strong>锁定写锁</strong></p>
<blockquote>
<p>非阻塞函数，若加锁时该锁已被锁定，则返回错误号</p>
</blockquote>
<p>wrlock: 指向相应互斥锁的指针</p>
<p>return: 成功 0 / 失败 错误号</p>
</blockquote>
</li>
<li><p><code>int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);</code></p>
<blockquote>
<p><strong>设置读写锁为打开态 - 解锁</strong></p>
<blockquote>
<p>只有加锁的线程才能够对相应互斥锁解锁</p>
</blockquote>
<p>rwlock: 指向相应互斥锁的指针</p>
<p>return: 成功 0 / 失败 错误号</p>
</blockquote>
</li>
<li><p><code>int pthread_rwlock_destory(pthread_rwlock_t *rwlock)</code></p>
<blockquote>
<p><strong>释放读写锁资源</strong></p>
<p>mutex: 指向相应互斥锁的指针</p>
<p>return: 成功 0 / 失败 错误号</p>
</blockquote>
</li>
</ul>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><blockquote>
<p>用于阻塞线程的，配合互斥锁完成线程同步</p>
<p>使用条件变量可以使线程在申请已锁定锁资源时，在满足某些条件的情况下才会阻塞，否则仍可以同时进入临界区</p>
</blockquote>
<h4 id="Linux下的接口函数-2"><a href="#Linux下的接口函数-2" class="headerlink" title="Linux下的接口函数"></a>Linux下的接口函数</h4><ul>
<li><p><code>pthread_cond_t cond;</code></p>
<blockquote>
<p><strong>创建条件变量</strong></p>
<p>条件变量将存放被其阻塞的线程的相关信息</p>
</blockquote>
</li>
<li><p><code>int pthread_cond_init(pthread_cond_t *restrict cond,const pthread_condattr_t *restrict attr;</code></p>
<blockquote>
<p><strong>初始化条件变量</strong></p>
<p>cond: 条件变量地址</p>
<p>attr: 条件变量属性，一般使用默认属性，指定为NULL</p>
</blockquote>
</li>
<li><p><code>int pthread_cond_wait(pthread_cond_t *restrict cond,pthread_mutex_t *restrict mutex)</code></p>
<blockquote>
<p><strong>阻塞线程</strong></p>
<blockquote>
<p>若调用该函数时，线程已将参数互斥锁锁定，则解除锁定，进入阻塞，唤醒后才重新争夺锁资源</p>
</blockquote>
<p>cond: 条件变量地址</p>
<p>mutex: 互斥锁地址</p>
</blockquote>
</li>
<li><p><code>int pthread_cond_timewait(pthread_cond_t *restrict cond,pthread_mutex_t *restrict mutex,const struct timespec *restrict abstime);</code></p>
<blockquote>
<p><strong>阻塞线程</strong></p>
<blockquote>
<p>可以指定线程阻塞的时长</p>
<ol>
<li>某一时间点解除阻塞</li>
<li>通过某时间段解除阻塞</li>
</ol>
<p>timespec结构体详自查，代表1971.1.1 0:0:0到某个时间点的时间</p>
</blockquote>
<p>cond: 条件变量地址</p>
<p>mutex: 互斥锁地址</p>
<p>abstime: 线程阻塞时长</p>
</blockquote>
</li>
<li><p><code>int pthread_cond_signal(pthread_cond_t *cond);</code></p>
<blockquote>
<p><strong>唤醒阻塞在条件变量上的至少一个线程</strong></p>
<p>cond: 条件变量地址</p>
</blockquote>
</li>
<li><p><code>int pthread_cond_broadcast(pthread_cond_t *cond);</code></p>
<blockquote>
<p><strong>唤醒阻塞在条件变量上的所有线程</strong></p>
<p>cond: 条件变量地址</p>
</blockquote>
</li>
</ul>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><blockquote>
<p>主要用于阻塞线程，无法保证线程安全，若需要保证线程安全，则需要与互斥锁一同使用</p>
</blockquote>
<h4 id="Linux下的接口函数-3"><a href="#Linux下的接口函数-3" class="headerlink" title="Linux下的接口函数"></a>Linux下的接口函数</h4><blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p><code>sem_t sem</code></p>
<blockquote>
<p><strong>创建信号量</strong></p>
</blockquote>
</li>
<li><p><code>int sem_init(sem_t *sem,int pshared,unsigned int value);</code></p>
<blockquote>
<p><strong>初始化信号量</strong></p>
<p>sem: 指向信号量的指针</p>
<p>pshared: 0 线程同步 / 非0 进程同步</p>
<p>value: 初始化信号量拥有的资源数，该值若为0，线程在访问时将被阻塞</p>
</blockquote>
</li>
<li><p><code>int sem_wait(sem_t *sem);</code></p>
<blockquote>
<p><strong>消耗信号量资源</strong></p>
<blockquote>
<p>线程调用后，sem的资源数将-1，若&gt;0，线程将占用该资源，若=0，说明无资源可用，线程阻塞</p>
</blockquote>
<p>sem: 指向信号量的指针</p>
</blockquote>
</li>
<li><p><code>int sem_tyrwait(sem_t *sem);</code></p>
<blockquote>
<p><strong>消耗信号量资源</strong></p>
<blockquote>
<p>非阻塞方式，若资源被耗尽，线程请求时不会阻塞，而是返回错误号</p>
</blockquote>
<p>sem: 指向信号量的指针</p>
</blockquote>
</li>
<li><p><code>int sem_timedwait(sem_t *sem,const struct timespec *restrict abstime);</code></p>
<blockquote>
<p><strong>消耗信号量资源</strong></p>
<blockquote>
<p>可以指定线程阻塞的时长</p>
<ol>
<li>某一时间点解除阻塞</li>
<li>通过某时间段解除阻塞</li>
</ol>
<p>timespec结构体详自查，代表1971.1.1 0:0:0到某个时间点的时间</p>
</blockquote>
<p>sem: 指向信号量的指针</p>
<p>abstime: 线程阻塞时长</p>
</blockquote>
</li>
<li><p><code>int sem_post(sem_t *sem);</code></p>
<blockquote>
<p><strong>生产信号量资源</strong></p>
<blockquote>
<p>线程调用后信号量拥有的资源+1</p>
</blockquote>
<p>sem: 指向信号量的指针</p>
</blockquote>
</li>
<li><p><code>int sem_getvalue(sem_t *sem,int *sval);</code></p>
<blockquote>
<p><strong>获取信号量拥有的资源数</strong></p>
<p>sem: 指向信号量的指针</p>
<p>sval: 传出参数，sem信号量拥有的资源数</p>
</blockquote>
</li>
</ul>
<h1 id="Thread-in-C-11"><a href="#Thread-in-C-11" class="headerlink" title="Thread in C++11"></a>Thread in C++11</h1><blockquote>
<p>C++11中提供了 std::thread 线程类方便的支持了并发编程</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入相应头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;thread&gt;</span></span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Ctor"><a href="#Ctor" class="headerlink" title="Ctor"></a>Ctor</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认构造函数,创建的线程对象不执行任何动作</span></span><br><span class="line"><span class="built_in">thread</span>() <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="comment">//移动构造，将t线程的所有权转移给当前创建的线程，之后t线程无法再执行任何动作</span></span><br><span class="line"><span class="built_in">thread</span>(thread&amp;&amp; t) <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="comment">//一般泛型构造函数，可指定回调函数以及函数参数</span></span><br><span class="line"><span class="comment">//Function可以为任何函数对象(functor，匿名函数，类成员你函数，普通函数)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Function</span>,<span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="built_in">thread</span>(Function&amp;&amp; f,Args&amp;&amp;... args);</span><br><span class="line"><span class="comment">//禁止拷贝构造</span></span><br><span class="line"><span class="built_in">thread</span>(<span class="keyword">const</span> thread&amp; t) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Members-of-the-function"><a href="#Members-of-the-function" class="headerlink" title="Members of the function"></a>Members of the function</h2><h3 id="get-id"><a href="#get-id" class="headerlink" title="get_id"></a>get_id</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::<span class="function">thread::id <span class="title">get_id</span><span class="params">()</span> cosnt <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>获取线程ID</strong></p>
</blockquote>
<h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>回收线程资源</strong></p>
<p>阻塞函数</p>
<p>由父线程回收子线程资源</p>
<p>父线程中字线程对象一旦调用join()，就必须阻塞等待子线程执行完毕后才能释放子线程资源，接触阻塞</p>
</blockquote>
<h3 id="detach"><a href="#detach" class="headerlink" title="detach"></a>detach</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">detach</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>线程分离</strong></p>
<p>非阻塞函数</p>
<p>由系统其他线程回收子线程资源</p>
<p><code>注意:</code></p>
<ol>
<li>若父线程提前退出，子线程资源仍然会随父线程退出而释放</li>
<li>子线程仅在父线程运行期间能够”脱离”父线程，不必由父线程回收其资源</li>
</ol>
</blockquote>
<h3 id="joinable"><a href="#joinable" class="headerlink" title="joinable"></a>joinable</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">joinable</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>判断父子线程的关联关系</strong></p>
<p>若返回true，则主线程与子线程有关联关系</p>
<p>关联条件:</p>
<ol>
<li>子线程不为空，即子线程不是采用默认构造函数创建的线程</li>
<li>子线程资源未被回收</li>
<li>子线程未被分离</li>
</ol>
</blockquote>
<h3 id="hardware-concurrency"><a href="#hardware-concurrency" class="headerlink" title="hardware_concurrency"></a>hardware_concurrency</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="title">hardware_concurrency</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>计算cpu核心数</strong></p>
</blockquote>
<h2 id="Namespace-this-thread"><a href="#Namespace-this-thread" class="headerlink" title="Namespace - this_thread"></a>Namespace - this_thread</h2><blockquote>
<p>std::this_thread 命名空间</p>
</blockquote>
<h3 id="get-id-1"><a href="#get-id-1" class="headerlink" title="get_id"></a>get_id</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::<span class="function">thread::id <span class="title">get_id</span><span class="params">()</span> cosnt <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>获取线程ID</strong></p>
</blockquote>
<h3 id="sleep-for"><a href="#sleep-for" class="headerlink" title="sleep_for"></a>sleep_for</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Rep</span>,<span class="keyword">class</span> <span class="title">Period</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sleep_for</span><span class="params">(<span class="keyword">const</span> chrono::duration&lt;Rep,Period&gt;&amp; rel_time)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用实例</span></span><br><span class="line">this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>休眠一段时间</strong></p>
<p>线程由 运行态 -&gt; 阻塞态</p>
<p>指定线程阻塞一定的时间长度-duration类型，之后解除阻塞</p>
</blockquote>
<h3 id="sleep-until"><a href="#sleep-until" class="headerlink" title="sleep_until"></a>sleep_until</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;chrono&gt;</span> </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Clock</span>,<span class="keyword">class</span> <span class="title">Duration</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sleep_for</span><span class="params">(<span class="keyword">const</span> chrono::time_point&lt;Clock,Duration&gt;&amp; abs_time)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>休眠至某时间点</strong></p>
<p>线程由 运行态 -&gt; 阻塞态</p>
<p>指定线程阻塞到某一个指定的时间点-time_point类型，之后解除阻塞</p>
</blockquote>
<h3 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">yield</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>放弃CPU资源</strong></p>
<p>线程由 运行态 -&gt; 就绪态</p>
<p>区别于sleep，yield后线程不会进入阻塞态，而是直接进入下一轮的cpu资源争夺</p>
<p>避免某个线程长期占用cpu资源，导致多线程处理性能下降</p>
</blockquote>
<h2 id="std-call-once"><a href="#std-call-once" class="headerlink" title="std::call_once"></a>std::call_once</h2><blockquote>
<p>保证某操作只能被执行一次</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mutex&gt;</span></span></span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Callable</span>,<span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_once</span><span class="params">(std::once_flag&amp; flag,Callable&amp;&amp; f,Args&amp;&amp;... args)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>flag: std::once_flag 类型的对象，保证该操作能被多线程执行 / 该操作执行的对象能被多线程访问到</p>
<p>f: 回调函数</p>
<p>args: 函数参数</p>
</blockquote>
<h2 id="Mutex-互斥锁"><a href="#Mutex-互斥锁" class="headerlink" title="Mutex -互斥锁"></a>Mutex -互斥锁</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入相关头文件</span></span><br><span class="line"><span class="meta">#incldue<span class="meta-string">&lt;mutex&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>为了保证互斥锁对象的可用性，在所有有处理函数未执行完毕之前，不允许执行mutex互斥锁对象的析构函数</p>
<p>互斥锁个数与共享资源数有关</p>
</blockquote>
<h3 id="std-mutex"><a href="#std-mutex" class="headerlink" title="std::mutex"></a>std::mutex</h3><blockquote>
<p><strong>独占的互斥锁</strong></p>
<p><code>mutex m_mutex</code></p>
<p>m_mutex 为 mutex类 的实例对象，即互斥锁对象</p>
</blockquote>
<h4 id="mutex-类成员函数"><a href="#mutex-类成员函数" class="headerlink" title="mutex 类成员函数"></a>mutex 类成员函数</h4><ul>
<li><p><code>void lock();</code></p>
<blockquote>
<p>阻塞加锁</p>
</blockquote>
</li>
<li><p><code>bool trylock();</code></p>
<blockquote>
<p>非阻塞加锁</p>
</blockquote>
</li>
<li><p><code>void unlock();</code></p>
<blockquote>
<p>解锁</p>
</blockquote>
</li>
</ul>
<h3 id="std-recursive-mutex"><a href="#std-recursive-mutex" class="headerlink" title="std::recursive_mutex"></a>std::recursive_mutex</h3><blockquote>
<p><strong>递归互斥锁</strong></p>
<p><code>recursive_mutex m_mutex</code></p>
<p>允许一个线程多次获得互斥锁的所有权</p>
</blockquote>
<h4 id="recursive-mutex-实例"><a href="#recursive-mutex-实例" class="headerlink" title="recursive_mutex 实例"></a>recursive_mutex 实例</h4><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> this_thread;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">xthread</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">xthread</span>(<span class="keyword">int</span> n) :<span class="built_in">m</span>(n) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">plus</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="function">lock_guard&lt;recursive_mutex&gt; <span class="title">tt</span><span class="params">(t)</span></span>;</span><br><span class="line">		m += x;</span><br><span class="line">		cout &lt;&lt; m &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">jplus</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="function">lock_guard&lt;recursive_mutex&gt; <span class="title">tt</span><span class="params">(t)</span></span>;</span><br><span class="line">		m -= x;</span><br><span class="line">		cout &lt;&lt; m &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">mut</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">		<span class="function">lock_guard&lt;recursive_mutex&gt; <span class="title">tt</span><span class="params">(t)</span></span>;</span><br><span class="line">		<span class="built_in">plus</span>(x);</span><br><span class="line">		<span class="built_in">jplus</span>(y);</span><br><span class="line">		cout &lt;&lt; m &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m;</span><br><span class="line">    <span class="comment">//若为mutex类型，则会出现异常</span></span><br><span class="line">	recursive_mutex t;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">xthread <span class="title">x</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	x.<span class="built_in">mut</span>(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>注意:</code></p>
<ol>
<li>同一线程获取一个互斥锁所有权的最大次数未具体说明，一旦超过该次数，仍会出现 std::system 错误</li>
<li>递归互斥锁的效率要低一些</li>
<li>不建议使用，逻辑复杂</li>
</ol>
</blockquote>
<h3 id="std-timed-mutex"><a href="#std-timed-mutex" class="headerlink" title="std::timed_mutex"></a>std::timed_mutex</h3><blockquote>
<p><strong>超时独占互斥锁</strong></p>
<p>timed_mutex m_mutex</p>
</blockquote>
<h4 id="timed-mutex-类成员函数"><a href="#timed-mutex-类成员函数" class="headerlink" title="timed_mutex 类成员函数"></a>timed_mutex 类成员函数</h4><ul>
<li><p><code>void lock();</code></p>
<blockquote>
<p>阻塞加锁</p>
</blockquote>
</li>
<li><p><code>bool trylock();</code></p>
<blockquote>
<p>非阻塞加锁</p>
</blockquote>
</li>
<li><p><code>void unlock();</code></p>
<blockquote>
<p>解锁</p>
</blockquote>
</li>
</ul>
<hr>
<ul>
<li><pre><code class="c++">template&lt;class Rep,class Period&gt;
bool try_lock_for(const chrono::duration&lt;Rep,Period&gt;&amp; time);
</code></pre>
<blockquote>
<p>非阻塞加锁</p>
<p>申请锁资源时锁已被锁定，可以弹性阻塞一段时间，若该时间后仍未抢到锁，则返回false</p>
</blockquote>
</li>
<li><p>```c++<br>template&lt;class Clock,class Duration&gt;<br>bool try_lock_until(const chrono::time_point&lt;Clock,Duration&gt;&amp; time);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line">  &gt; 非阻塞加锁</span><br><span class="line">  &gt;</span><br><span class="line">  &gt; 申请锁资源时锁已被锁定，可以弹性阻塞到某一时间点，若该时间后仍未抢到锁，则返回false</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### std::recursive_timed_mutex</span><br><span class="line"></span><br><span class="line">&gt; **超时递归互斥锁**</span><br><span class="line"></span><br><span class="line">### adaptor - std::lock_guard</span><br><span class="line"></span><br><span class="line">&gt; C++11中新增加的模板类，对以上四种类型进行再封装</span><br><span class="line">&gt;</span><br><span class="line">&gt; &#96;&#96;&#96;c++</span><br><span class="line">&gt; &#x2F;&#x2F;模板定义</span><br><span class="line">&gt; &#x2F;&#x2F;Mutex 为泛型锁类型</span><br><span class="line">&gt; template&lt;class Mutex&gt;</span><br><span class="line">&gt; class lock_guard&#123;</span><br><span class="line">&gt; 	explicit lock_guard(const Mutex&amp; t);</span><br><span class="line">&gt; &#125;;</span><br><span class="line">&gt; </span><br><span class="line">&gt; &#x2F;&#x2F;调用</span><br><span class="line">&gt; mutex t;</span><br><span class="line">&gt; lock_guard&lt;mutex&gt; m_mutex(t);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="feature"><a href="#feature" class="headerlink" title="feature"></a>feature</h4><blockquote>
<ol>
<li>lock_guard类在构造函数中完成加锁(创建即加锁)，在析构函数中完成解锁(超出其作用域时候自动解锁)</li>
<li>采用RAII (Resource acquisition is initialization) 机制</li>
<li>不能中途解锁，因为其解锁是针对临界区所在作用域的</li>
<li>不能和条件变量一起使用，wait时仍需要使用泛型锁类型</li>
</ol>
</blockquote>
<h3 id="adaptor-std-unique-lock"><a href="#adaptor-std-unique-lock" class="headerlink" title="adaptor - std::unique_lock"></a>adaptor - std::unique_lock</h3><blockquote>
<p>std::lock_guard 模板类的升级版，进一步封装了完善的功能</p>
</blockquote>
<h4 id="std-unique-lock-类成员函数"><a href="#std-unique-lock-类成员函数" class="headerlink" title="std::unique_lock 类成员函数"></a>std::unique_lock 类成员函数</h4><ul>
<li><p><code>lock()</code></p>
</li>
<li><p><code>try_lock()</code></p>
</li>
<li><p><code>try_lock_for()</code></p>
<blockquote>
<p>非阻塞加锁</p>
<p>申请锁资源时锁已被锁定，可以弹性阻塞一段时间，若该时间后仍未抢到锁，则返回false</p>
</blockquote>
</li>
<li><p><code>try_lock_until()</code></p>
<blockquote>
<p>非阻塞加锁</p>
<p>申请锁资源时锁已被锁定，可以弹性阻塞到某一时间点，若该时间后仍未抢到锁，则返回false</p>
</blockquote>
</li>
<li><p><code>unlock()</code></p>
</li>
</ul>
<h4 id="feature-1"><a href="#feature-1" class="headerlink" title="feature"></a>feature</h4><blockquote>
<ol>
<li>创建时可以不锁定(通过指定第二个参数为std::defer_lock)，需要时锁定</li>
<li>可以随时加锁解锁</li>
<li>析构时候自动释放锁</li>
<li>可以和条件变量一起使用，且wait时必须使用unique_lock类型不能使用泛型锁类型</li>
</ol>
</blockquote>
<h2 id="条件变量-1"><a href="#条件变量-1" class="headerlink" title="条件变量"></a>条件变量</h2><blockquote>
<p>“一种事件通知机制”，可以导致线程阻塞，接收到某通知后解除阻塞，可与互斥锁共同使用完成线程同步</p>
</blockquote>
<h3 id="condition-variable"><a href="#condition-variable" class="headerlink" title="condition_variable"></a>condition_variable</h3><blockquote>
<p>需要配合 std::unique_lock&lt; std::mutex &gt; 进行wait操作</p>
<p><code> condition_variable cond</code></p>
</blockquote>
<h4 id="operator-function"><a href="#operator-function" class="headerlink" title="operator function"></a>operator function</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入相应头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;condition_variable&gt;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>void wait(unique_lock&lt;mutex&gt;&amp; lck);</code></p>
<blockquote>
<p><strong>立即阻塞条件变量下的线程</strong></p>
<p>如果已锁定互斥锁资源，则解开互斥锁</p>
</blockquote>
</li>
<li><p>```c++<br>template<class predicate><br>void wait(unique_lock<mutex>&amp; lck,Predicate pred);</mutex></class></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line">  &gt; **条件阻塞条件变量下的线程**</span><br><span class="line">  &gt;</span><br><span class="line">  &gt; pred: 返回值为bool类型的函数对象</span><br><span class="line">  &gt;</span><br><span class="line">  &gt; 若pred的返回值为true，则不阻塞，向下继续执行</span><br><span class="line">  &gt;</span><br><span class="line">  &gt; 若pred的返回值为false，则阻塞，解锁</span><br><span class="line">  </span><br><span class="line">- &#96;&#96;&#96;c++ </span><br><span class="line">  template &lt;class Rep, class Period&gt;</span><br><span class="line">  cv_status wait_for (unique_lock&lt;mutex&gt;&amp; lck,const chrono::duration&lt;Rep,Period&gt;&amp; rel_time);</span><br><span class="line">  	</span><br><span class="line">  template &lt;class Rep, class Period, class Predicate&gt;</span><br><span class="line">  bool wait_for(unique_lock&lt;mutex&gt;&amp; lck,const chrono::duration&lt;Rep,Period&gt;&amp; rel_time, Predicate pred);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>阻塞线程</strong></p>
<p>若阻塞后未被唤醒，则经过一段时间后自动解除阻塞</p>
</blockquote>
</li>
<li><p>```c++<br>template &lt;class Clock, class Duration&gt;<br>cv_status wait_until (unique_lock<mutex>&amp; lck,const chrono::time_point&lt;Clock,Duration&gt;&amp; abs_time);</mutex></p>
<p>template &lt;class Clock, class Duration, class Predicate&gt;<br>bool wait_until (unique_lock<mutex>&amp; lck,const chrono::time_point&lt;Clock,Duration&gt;&amp; abs_time, Predicate pred);</mutex></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  &gt; **阻塞线程**</span><br><span class="line">  &gt;</span><br><span class="line">  &gt; 若阻塞后未被唤醒，则到某时间点后自动解除阻塞</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;void notify_one() noexcept;&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">  &gt; **通知唤醒被当前条件变量阻塞的一个线程**</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;void notify_all() noexcept;&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">  &gt; **通知唤醒被当前条件变量阻塞的所有线程**</span><br><span class="line"></span><br><span class="line">### condition_variable_any</span><br><span class="line"></span><br><span class="line">&gt; 可以与任意带有lock()，unlock()成员的mutex搭配使用</span><br><span class="line">&gt;</span><br><span class="line">&gt; &#96;&#96;&#96; condition_variable_any cond&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">#### operator function</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;c++ </span><br><span class="line">&#x2F;&#x2F;引入相应头文件</span><br><span class="line">#include&lt;condition_variable&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>```c++<br>template<class lock><br>void wait(Lock&amp; lck);</class></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line">  &gt; **立即阻塞条件变量下的线程**</span><br><span class="line">  &gt;</span><br><span class="line">  &gt; 如果已锁定Lock类型的互斥锁资源，则解开互斥锁</span><br><span class="line">  </span><br><span class="line">- &#96;&#96;&#96;c++ </span><br><span class="line">  template&lt;class Lock,class Predicate&gt;</span><br><span class="line">  void wait(Lock&amp; lck,Predicate pred);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>条件阻塞条件变量下的线程</strong></p>
<p>pred: 返回值为bool类型的函数对象</p>
<p>若pred的返回值为true，则不阻塞，向下继续执行</p>
<p>若pred的返回值为false，则阻塞，解锁</p>
</blockquote>
</li>
<li><p>```c++<br>template &lt;class Lock,class Rep, class Period&gt;<br>cv_status wait_for (Lock&amp; lck,const chrono::duration&lt;Rep,Period&gt;&amp; rel_time);</p>
<p>template &lt;class Lock,class Rep, class Period, class Predicate&gt;<br>bool wait_for(Lock&amp; lck,const chrono::duration&lt;Rep,Period&gt;&amp; rel_time, Predicate pred);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  &gt; **阻塞线程**</span><br><span class="line">  &gt;</span><br><span class="line">  &gt; 若阻塞后未被唤醒，则经过一段时间后自动解除阻塞</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;c++ </span><br><span class="line">  template &lt;class Lock,class Clock, class Duration&gt;</span><br><span class="line">  cv_status wait_until (Lock&amp; lck,const chrono::time_point&lt;Clock,Duration&gt;&amp; abs_time);</span><br><span class="line">  </span><br><span class="line">  template &lt;class Lock,class Clock, class Duration, class Predicate&gt;</span><br><span class="line">  bool wait_until (Lock&amp; lck,const chrono::time_point&lt;Clock,Duration&gt;&amp; abs_time, Predicate pred);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>阻塞线程</strong></p>
<p>若阻塞后未被唤醒，则到某时间点后自动解除阻塞</p>
</blockquote>
</li>
<li><p><code>void notify_one() noexcept;</code></p>
<blockquote>
<p><strong>通知唤醒被当前条件变量阻塞的一个线程</strong></p>
</blockquote>
</li>
<li><p><code>void notify_all() noexcept;</code></p>
<blockquote>
<p><strong>通知唤醒被当前条件变量阻塞的所有线程</strong></p>
</blockquote>
</li>
</ul>
<h3 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h3><h5 id="condition-variable-1"><a href="#condition-variable-1" class="headerlink" title="condition_variable"></a>condition_variable</h5><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> this_thread;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">product_queue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">product_queue</span>(<span class="keyword">int</span> m) :<span class="built_in">max_pro</span>(m) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//生产者线程处理函数</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">product</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//封装独占互斥锁</span></span><br><span class="line">		<span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//通过lambda表达式传递阻塞判断函数对象</span></span><br><span class="line">		pro.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]() &#123;</span><br><span class="line">			<span class="keyword">return</span> max_pro != m_queue.<span class="built_in">size</span>(); <span class="comment">// 为ture时不阻塞</span></span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//生产产品</span></span><br><span class="line">		m_queue.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;生产者线程: &quot;</span> &lt;&lt; <span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;生产了一个产品!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//通知阻塞在con条件变量下的线程解除阻塞</span></span><br><span class="line">		con.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//消费者线程处理函数</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//封装独占互斥锁</span></span><br><span class="line">		<span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//通过lambda表达式传递阻塞判断函数对象</span></span><br><span class="line">		con.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>]() &#123;</span><br><span class="line">			<span class="keyword">return</span> !m_queue.<span class="built_in">empty</span>();</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//消费产品</span></span><br><span class="line">		m_queue.<span class="built_in">pop_front</span>();</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;消费者线程: &quot;</span> &lt;&lt; <span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;消费了一个产品!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//通知阻塞在pro条件变量下的线程解除阻塞</span></span><br><span class="line">		pro.<span class="built_in">notify_all</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//一把互斥锁</span></span><br><span class="line">	mutex m_mutex;</span><br><span class="line">	<span class="comment">//两个条件变量</span></span><br><span class="line">	condition_variable pro;</span><br><span class="line">	condition_variable con;</span><br><span class="line">	<span class="comment">//生产队列</span></span><br><span class="line">	list&lt;<span class="keyword">int</span>&gt; m_queue;</span><br><span class="line">	<span class="comment">//最大产品数</span></span><br><span class="line">	<span class="keyword">int</span> max_pro;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">product_queue <span class="title">queue</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> product = <span class="built_in">bind</span>(&amp;product_queue::product, &amp;queue);</span><br><span class="line">	<span class="keyword">auto</span> consume = <span class="built_in">bind</span>(&amp;product_queue::consume, &amp;queue);</span><br><span class="line"></span><br><span class="line">	thread pro[<span class="number">3</span>], con[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">		pro[i] = <span class="built_in">thread</span>(product);</span><br><span class="line">		con[i] = <span class="built_in">thread</span>(consume);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">		pro[i].<span class="built_in">join</span>();</span><br><span class="line">		con[i].<span class="built_in">join</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>feature</strong></p>
<blockquote>
<ol>
<li><p>需要配合 std::unique_lock&lt; std::mutex &gt; 进行wait操作</p>
<blockquote>
<p>因为 std::unique_lock&lt; std::mutex &gt; 内置了unlock解锁函数</p>
</blockquote>
</li>
<li><p>创建线程对象时，需要传入函数指针，如何获取类对象中的protuct or consume 成员函数的指针?</p>
<blockquote>
<p>使用bind函数适配器生成一个新的可调用对象</p>
</blockquote>
</li>
</ol>
<p><strong>c++11 bind</strong></p>
<ul>
<li><p>绑定普通函数</p>
<blockquote>
<p><code>auto newCallable = bind(callable,arg_list)</code>;</p>
<p>newCallable: 新的可调用对象</p>
<p>callable: 原本的可调用对象</p>
<p>arg_list: 使用placeholder::_1等占位符表示函数参数，若无参省略即可</p>
</blockquote>
</li>
<li><p>绑定类的成员函数</p>
<blockquote>
<p><code>auto newCallable = std::bind(&amp;Plus::plus,&amp;p,arg_list);</code></p>
<p>Plus: 被绑定成员函数所属的类</p>
<p>plus: 需要绑定的成员函数</p>
<p>&amp;p: 创建的类对象的地址</p>
<p>arg_list: 使用placeholder::_1等占位符表示函数参数，若无参省略即可</p>
</blockquote>
</li>
<li><p>绑定类的静态成员函数</p>
<blockquote>
<p><code>auto newCallable = std::bind(&amp;Plus::plus,arg_list);</code></p>
</blockquote>
</li>
</ul>
</blockquote>
<h5 id="condition-variable-any"><a href="#condition-variable-any" class="headerlink" title="condition_variable_any"></a>condition_variable_any</h5><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> this_thread;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">product_queue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">product_queue</span>(<span class="keyword">int</span> m) :<span class="built_in">max_pro</span>(m) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//生产者线程处理函数</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">product</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//封装独占互斥锁</span></span><br><span class="line">		<span class="function">lock_guard&lt;mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//通过lambda表达式传递阻塞判断函数对象</span></span><br><span class="line">		pro.<span class="built_in">wait</span>(m_mutex, [<span class="keyword">this</span>]() &#123;</span><br><span class="line">			<span class="keyword">return</span> max_pro != m_queue.<span class="built_in">size</span>();</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//生产产品</span></span><br><span class="line">		m_queue.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;生产者线程: &quot;</span> &lt;&lt; <span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;生产了一个产品!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//通知阻塞在con条件变量下的线程解除阻塞</span></span><br><span class="line">		con.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//消费者线程处理函数</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//封装独占互斥锁</span></span><br><span class="line">		<span class="function">lock_guard&lt;mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//通过lambda表达式传递阻塞判断函数对象</span></span><br><span class="line">		con.<span class="built_in">wait</span>(m_mutex, [<span class="keyword">this</span>]() &#123;</span><br><span class="line">			<span class="keyword">return</span> !m_queue.<span class="built_in">empty</span>();</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//消费产品</span></span><br><span class="line">		m_queue.<span class="built_in">pop_front</span>();</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;消费者线程: &quot;</span> &lt;&lt; <span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;消费了一个产品!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//通知阻塞在pro条件变量下的线程解除阻塞</span></span><br><span class="line">		pro.<span class="built_in">notify_all</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//一把互斥锁</span></span><br><span class="line">	mutex m_mutex;</span><br><span class="line">	<span class="comment">//两个条件变量</span></span><br><span class="line">	condition_variable_any pro;</span><br><span class="line">	condition_variable_any con;</span><br><span class="line">	<span class="comment">//生产队列</span></span><br><span class="line">	list&lt;<span class="keyword">int</span>&gt; m_queue;</span><br><span class="line">	<span class="comment">//最大产品数</span></span><br><span class="line">	<span class="keyword">int</span> max_pro;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">product_queue <span class="title">queue</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> product = <span class="built_in">bind</span>(&amp;product_queue::product, &amp;queue);</span><br><span class="line">	<span class="keyword">auto</span> consume = <span class="built_in">bind</span>(&amp;product_queue::consume, &amp;queue);</span><br><span class="line"></span><br><span class="line">	thread pro[<span class="number">3</span>], con[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">		pro[i] = <span class="built_in">thread</span>(product);</span><br><span class="line">		con[i] = <span class="built_in">thread</span>(consume);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">		pro[i].<span class="built_in">join</span>();</span><br><span class="line">		con[i].<span class="built_in">join</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>feature</strong></p>
<blockquote>
<ol>
<li><p>不能直接使用 lock_guard&lt; mutex &gt; 锁对象做wait参数</p>
<blockquote>
<p>因为 lock_guard&lt; mutex &gt; 不允许手动解锁即并未内置unlock函数</p>
</blockquote>
</li>
</ol>
<p><strong>c++11 bind</strong></p>
<ul>
<li><p>绑定普通函数</p>
<blockquote>
<p><code>auto newCallable = bind(callable,arg_list)</code>;</p>
<p>newCallable: 新的可调用对象</p>
<p>callable: 原本的可调用对象</p>
<p>arg_list: 使用placeholder::_1等占位符表示函数参数，若无参省略即可</p>
</blockquote>
</li>
<li><p>绑定类的成员函数</p>
<blockquote>
<p><code>auto newCallable = std::bind(&amp;Plus::plus,&amp;p,arg_list);</code></p>
<p>Plus: 被绑定成员函数所属的类</p>
<p>plus: 需要绑定的成员函数</p>
<p>&amp;p: 创建的类对象的地址</p>
<p>arg_list: 使用placeholder::_1等占位符表示函数参数，若无参省略即可</p>
</blockquote>
</li>
<li><p>绑定类的静态成员函数</p>
<blockquote>
<p><code>auto newCallable = std::bind(&amp;Plus::plus,arg_list);</code></p>
</blockquote>
</li>
</ul>
</blockquote>
<h2 id="atomic-原子变量"><a href="#atomic-原子变量" class="headerlink" title="atomic 原子变量"></a>atomic 原子变量</h2><blockquote>
<p>通过 std::atomic&lt; T &gt; 原子类型管理的内部变量成为原子变量</p>
<p>原子变量只能由原子操作进行操作，原子操作执行时不允许被线程调度机制打断，一旦开始，就会一直运行到结束</p>
<p>通过原子变量可以代替互斥锁</p>
</blockquote>
<h3 id="atomic-类"><a href="#atomic-类" class="headerlink" title="atomic 类"></a>atomic 类</h3><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">atomic</span>&#123;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//默认构造函数</span></span><br><span class="line">    <span class="built_in">atomic</span>() <span class="keyword">noexcept</span> = <span class="keyword">default</span>;</span><br><span class="line">    <span class="comment">//带参构造</span></span><br><span class="line">    <span class="built_in">atomic</span>(<span class="keyword">const</span> T&amp; desired) <span class="keyword">noexcept</span>;</span><br><span class="line">    <span class="comment">//拷贝构造</span></span><br><span class="line">    <span class="built_in">atomic</span>(<span class="keyword">const</span> T&amp; atomic)= <span class="keyword">delete</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//赋值运算符重载</span></span><br><span class="line">    <span class="comment">//允许使用原子变量赋值</span></span><br><span class="line">    T <span class="keyword">operator</span>=( T desired ) <span class="keyword">noexcept</span>;</span><br><span class="line">    T <span class="keyword">operator</span>=( T desired ) <span class="keyword">volatile</span> <span class="keyword">noexcept</span>;</span><br><span class="line">    <span class="comment">//不允许使用原子类型的对象赋值</span></span><br><span class="line">    atomic&amp; <span class="keyword">operator</span>=( <span class="keyword">const</span> atomic&amp; ) = <span class="keyword">delete</span>;</span><br><span class="line">    atomic&amp; <span class="keyword">operator</span>=( <span class="keyword">const</span> atomic&amp; ) <span class="keyword">volatile</span> = <span class="keyword">delete</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//c++11中为atomic引入了条件变量机制</span></span><br><span class="line">    ... <span class="built_in">wait</span>(...);</span><br><span class="line">    ... <span class="built_in">notify_one</span>(...);</span><br><span class="line">    ... <span class="built_in">notify_all</span>(...);</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="atomic-类型别名"><a href="#atomic-类型别名" class="headerlink" title="atomic 类型别名"></a>atomic 类型别名</h3><blockquote>
<p>typedef std::atomic&lt; int &gt; atomic_int</p>
<p>直接使用 atomic_int 即可 创建 std::atomic&lt; int &gt; 类型的原子对象</p>
</blockquote>
<h3 id="atomic-应用"><a href="#atomic-应用" class="headerlink" title="atomic 应用"></a>atomic 应用</h3><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入相应头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> this_thread;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">xthread</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">xthread</span>(<span class="keyword">int</span> n) :<span class="built_in">m</span>(n) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">plus</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		m += x;</span><br><span class="line">		cout &lt;&lt; m &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">jplus</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		m -= x;</span><br><span class="line">		cout &lt;&lt; m &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">mut</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">plus</span>(x);</span><br><span class="line">		<span class="built_in">jplus</span>(y);</span><br><span class="line">		cout &lt;&lt; m &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">atomic_int</span> m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">xthread <span class="title">x</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	x.<span class="built_in">mut</span>(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="Thread-pool-线程池"><a href="#Thread-pool-线程池" class="headerlink" title="Thread pool - 线程池"></a>Thread pool - 线程池</h1><h2 id="Struct"><a href="#Struct" class="headerlink" title="Struct"></a>Struct</h2><h3 id="basic-struct"><a href="#basic-struct" class="headerlink" title="basic struct"></a>basic struct</h3><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread_pool</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//共有接口</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化线程池</span></span><br><span class="line">	<span class="built_in">Thread_pool</span>(<span class="keyword">int</span> min, <span class="keyword">int</span> max);</span><br><span class="line">	<span class="comment">//销毁线程池</span></span><br><span class="line">	~<span class="built_in">Thread_pool</span>();</span><br><span class="line">	<span class="comment">//向线程池中添加任务</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addTask</span><span class="params">(<span class="keyword">const</span> callback, <span class="keyword">void</span>*)</span></span>;</span><br><span class="line">	<span class="comment">//获取线程池中工作线程数</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getworkingTNum</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//获取线程池中存活线程数</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getliveTNum</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//私有接口</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">threadid_t</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//类的成员函数作线程处理函数时，必须作为静态函数</span></span><br><span class="line">	<span class="comment">//线程处理函数必须定义时即有入口地址，而实例成员函数只有在创建实例对象后才会分配函数入口地址</span></span><br><span class="line">	<span class="comment">//静态成员需要将this指针显示传入</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//管理者线程处理函数</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">manager</span><span class="params">(Thread_pool&lt;T&gt;*)</span></span>;</span><br><span class="line">	<span class="comment">//消费者线程处理函数</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">consumer</span><span class="params">(Thread_pool&lt;T&gt;*)</span></span>;</span><br><span class="line">	<span class="comment">//线程退出前处理函数</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">threadExit</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//私有数据成员</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//任务队列</span></span><br><span class="line">	Task_queue&lt;T&gt;* q_task;</span><br><span class="line">	<span class="comment">//管理者线程</span></span><br><span class="line">	thread* manage;</span><br><span class="line">	<span class="comment">//消费者线程数组</span></span><br><span class="line">	<span class="keyword">threadid_t</span>* consumes_ID;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//thread::id -&gt; unsigned int 函数</span></span><br><span class="line">	<span class="function"><span class="keyword">threadid_t</span> <span class="title">id_change</span><span class="params">(thread::id)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//线程池状态参数	</span></span><br><span class="line">	<span class="keyword">int</span> minTnum; <span class="comment">//线程池最小线程数</span></span><br><span class="line">	<span class="keyword">int</span> maxTnum; <span class="comment">//线程池最大线程数</span></span><br><span class="line">	<span class="keyword">int</span> workingTnum; <span class="comment">//工作状态线程数</span></span><br><span class="line">	<span class="keyword">int</span> liveTnum; <span class="comment">//存活状态线程数</span></span><br><span class="line">	<span class="keyword">int</span> exitTnum; <span class="comment">//需要退出的线程数</span></span><br><span class="line">	<span class="keyword">bool</span> openT; <span class="comment">//线程池开关状态</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//线程池锁</span></span><br><span class="line">	mutex t_mutex;</span><br><span class="line">	<span class="comment">//消费者条件变量</span></span><br><span class="line">	condition_variable cond;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Thread_pool&lt;T&gt;::<span class="built_in">Thread_pool</span>(<span class="keyword">int</span> min, <span class="keyword">int</span> max)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="comment">//任务队列初始化</span></span><br><span class="line">		q_task = <span class="keyword">new</span> Task_queue&lt;T&gt;();</span><br><span class="line">		<span class="keyword">if</span> (q_task == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			cerr &lt;&lt; <span class="string">&quot;q_task create error.&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//消费者线程ID数组初始化</span></span><br><span class="line"></span><br><span class="line">		consumes_ID = <span class="keyword">new</span> <span class="keyword">threadid_t</span>[max];</span><br><span class="line">		<span class="keyword">if</span> (consumes_ID == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			cerr &lt;&lt; <span class="string">&quot;consumes_ID create error.&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">memset</span>(consumes_ID, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">threadid_t</span>)*max); <span class="comment">//设置ID数组初值均为0</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//线程池状态参数初始化</span></span><br><span class="line">		minTnum = min; <span class="comment">//线程池最小线程数</span></span><br><span class="line">		maxTnum = max; <span class="comment">//线程池最大线程数</span></span><br><span class="line">		workingTnum = <span class="number">0</span>; <span class="comment">//工作状态线程数</span></span><br><span class="line">		liveTnum = min; <span class="comment">//存活状态线程数,因为马上创建min个消费者线程</span></span><br><span class="line">		exitTnum = <span class="number">0</span>; <span class="comment">//退出线程数</span></span><br><span class="line">		openT = <span class="literal">true</span>; <span class="comment">//线程池开关状态</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//管理者线程创建 ----------------------需要指定参数</span></span><br><span class="line">		<span class="keyword">auto</span> manage_f = <span class="built_in">bind</span>(&amp;Thread_pool&lt;T&gt;::manager,<span class="keyword">this</span>);</span><br><span class="line">		manage = <span class="keyword">new</span> <span class="built_in">thread</span>(manage_f,<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;管理者线程创建成功! ID : &quot;</span> &lt;&lt; manage-&gt;<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">		<span class="comment">//消费者线程创建</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; min; i++) &#123;</span><br><span class="line">			<span class="comment">//创建线程 ----------------------需要指定参数</span></span><br><span class="line">			<span class="keyword">auto</span> consume_f = <span class="built_in">bind</span>(&amp;Thread_pool&lt;T&gt;::consumer,<span class="keyword">this</span>);</span><br><span class="line">			thread* con = <span class="keyword">new</span> <span class="built_in">thread</span>(consume_f);</span><br><span class="line">			<span class="comment">//记录创建的消费者线程</span></span><br><span class="line">			<span class="keyword">threadid_t</span> ID = <span class="built_in">id_change</span>(con-&gt;<span class="built_in">get_id</span>());</span><br><span class="line">			consumes_ID[i] = ID;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;消费者线程创建成功! ID : &quot;</span> &lt;&lt; con-&gt;<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;线程池初始化成功!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;------------------------------------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="comment">//停止循环</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//释放初始化失败的资源</span></span><br><span class="line">	<span class="keyword">if</span> (q_task) &#123;</span><br><span class="line">		<span class="keyword">delete</span> q_task;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (consumes_ID) &#123;</span><br><span class="line">		<span class="keyword">delete</span>[] consumes_ID;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;线程池初始化失败!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Thread_pool&lt;T&gt;::~<span class="built_in">Thread_pool</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭线程池</span></span><br><span class="line">	openT = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//回收线程池创建的资源</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//回收管理线程资源</span></span><br><span class="line">	manage-&gt;<span class="built_in">join</span>();</span><br><span class="line">	<span class="keyword">if</span> (manage) &#123;</span><br><span class="line">		<span class="keyword">delete</span> manage;</span><br><span class="line">		manage = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//回收消费者线程资源</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxTnum; i++) &#123;</span><br><span class="line">		<span class="comment">//通过唤醒来使各个消费者线程自动销毁</span></span><br><span class="line">		cond.<span class="built_in">notify_all</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//回收任务队列</span></span><br><span class="line">	<span class="keyword">if</span> (q_task) &#123;</span><br><span class="line">		<span class="keyword">delete</span> q_task;</span><br><span class="line">		q_task = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//回收线程数组</span></span><br><span class="line">	<span class="keyword">if</span> (consumes_ID) &#123;</span><br><span class="line">		<span class="keyword">delete</span>[]consumes_ID;</span><br><span class="line">		consumes_ID = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向线程池中添加任务</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Thread_pool&lt;T&gt;::<span class="built_in">addTask</span>(<span class="keyword">const</span> callback f, <span class="keyword">void</span> *arg)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//判断线程池状态</span></span><br><span class="line">	<span class="keyword">if</span> (!openT) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//添加任务</span></span><br><span class="line">	q_task-&gt;_addTask(f, arg);</span><br><span class="line">	<span class="comment">//唤醒消费者线程</span></span><br><span class="line">	cond.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取线程池中工作线程数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> Thread_pool&lt;T&gt;::<span class="built_in">getworkingTNum</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">unique_lock&lt;mutex&gt; <span class="title">u_mutex</span><span class="params">(t_mutex)</span></span>;</span><br><span class="line">	<span class="keyword">int</span> num = workingTnum;</span><br><span class="line">	u_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">	<span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> Thread_pool&lt;T&gt;::<span class="built_in">getliveTNum</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">unique_lock&lt;mutex&gt; <span class="title">u_mutex</span><span class="params">(t_mutex)</span></span>;</span><br><span class="line">	<span class="keyword">int</span> num = liveTnum;</span><br><span class="line">	u_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">	<span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程退出前处理函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Thread_pool&lt;T&gt;::<span class="built_in">threadExit</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">auto</span> cID = this_thread::<span class="built_in">get_id</span>();</span><br><span class="line">	<span class="keyword">threadid_t</span> ID = <span class="built_in">id_change</span>(cID);</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; maxTnum; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ID == consumes_ID[i]) &#123;</span><br><span class="line"></span><br><span class="line">			consumes_ID[i] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;线程退出 ID : &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//C++11中未提供线程退出函数，仅为退出前的处理</span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//thread::id -&gt; unsigned int 转换函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> Thread_pool&lt;T&gt;::<span class="keyword">threadid_t</span> Thread_pool&lt;T&gt;::<span class="built_in">id_change</span>(thread::id id)</span><br><span class="line">&#123;</span><br><span class="line">	Thread_pool&lt;T&gt;::<span class="keyword">threadid_t</span> ID = hash&lt;thread::id&gt;()(id);</span><br><span class="line">	<span class="keyword">return</span> ID;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Task-queue-任务队列"><a href="#Task-queue-任务队列" class="headerlink" title="Task queue - 任务队列"></a>Task queue - 任务队列</h3><h4 id="basic-interface-for-thread-pool"><a href="#basic-interface-for-thread-pool" class="headerlink" title="basic interface for thread pool"></a>basic interface for thread pool</h4><ul>
<li>添加任务</li>
<li>取出任务</li>
<li>查看任务个数</li>
</ul>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> callback = <span class="built_in"><span class="keyword">void</span></span>(*)(<span class="keyword">void</span>* arg);</span><br><span class="line"></span><br><span class="line"><span class="comment">//任务类型	</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Task</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Task</span>(): <span class="built_in">function</span>(<span class="literal">nullptr</span>),<span class="built_in">arg</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">	<span class="built_in">Task</span>(<span class="keyword">const</span> callback f, <span class="keyword">void</span>* argg) :<span class="built_in">function</span>(f)&#123;</span><br><span class="line">		arg = <span class="keyword">static_cast</span>&lt;T*&gt;(argg);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	callback function; <span class="comment">//回调函数类型</span></span><br><span class="line">	T* arg; <span class="comment">//函数参数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//任务队列</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task_queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Task_queue&lt;T&gt;() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//取出任务</span></span><br><span class="line">	Task&lt;T&gt;&amp; _getTask();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//添加任务</span></span><br><span class="line">	<span class="keyword">void</span> _addTask(<span class="keyword">const</span> Task&lt;T&gt; &amp;task);</span><br><span class="line">	<span class="keyword">void</span> _addTask(<span class="keyword">const</span> callback, <span class="keyword">void</span>*);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//查看任务个数</span></span><br><span class="line">	<span class="keyword">int</span> _getTaskNum();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//共享队列资源</span></span><br><span class="line">	queue&lt;Task&lt;T&gt;&gt; task_q;</span><br><span class="line">	<span class="comment">//队列锁</span></span><br><span class="line">	mutex m_mutex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Task&lt;T&gt;&amp; Task_queue&lt;T&gt;::_getTask()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//栈上内存再考虑考虑</span></span><br><span class="line">	Task&lt;T&gt; q;</span><br><span class="line">	m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">	<span class="keyword">if</span> (!task_q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		q = task_q.<span class="built_in">front</span>();</span><br><span class="line">		task_q.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">	<span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Task_queue&lt;T&gt;::_addTask(<span class="keyword">const</span> Task&lt;T&gt; &amp;task)</span><br><span class="line">&#123;</span><br><span class="line">	m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">	task_q.<span class="built_in">push</span>(task);</span><br><span class="line">	m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Task_queue&lt;T&gt;::_addTask(<span class="keyword">const</span> callback f,<span class="keyword">void</span> *arg)</span><br><span class="line">&#123;</span><br><span class="line">	m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">	task_q.<span class="built_in">push</span>(Task&lt;T&gt;(f, arg));</span><br><span class="line">	m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> Task_queue&lt;T&gt;::_getTaskNum()</span><br><span class="line">&#123;</span><br><span class="line">	m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">	num = task_q.<span class="built_in">size</span>();</span><br><span class="line">	m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">	<span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Consumer-Thread-执行线程组"><a href="#Consumer-Thread-执行线程组" class="headerlink" title="Consumer Thread - 执行线程组"></a>Consumer Thread - 执行线程组</h3><blockquote>
<p>执行线程循环从任务队列取出任务并执行，直到被阻塞，受管理者线程控制</p>
<p>有多个并构成一个执行线程组记录状态</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//消费者线程处理函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Thread_pool&lt;T&gt;::<span class="built_in">consumer</span>(Thread_pool&lt;T&gt;* pool)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">//加锁访问任务队列</span></span><br><span class="line">		<span class="function">unique_lock&lt;mutex&gt; <span class="title">u_mutex</span><span class="params">(pool-&gt;t_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//判断线程池开启状态下是否任务队列为空</span></span><br><span class="line">		pool-&gt;cond.<span class="built_in">wait</span>(u_mutex, [pool]() &#123;</span><br><span class="line">			<span class="keyword">if</span> (pool-&gt;openT == <span class="literal">false</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in"><span class="keyword">return</span></span> (pool-&gt;q_task-&gt;_getTaskNum() != <span class="number">0</span>);</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//判断唤醒方是生产线程还是管理线程</span></span><br><span class="line">		<span class="comment">//生产线程唤醒代表可取任务</span></span><br><span class="line">		<span class="comment">//管理线程唤醒代表需要销毁该线程</span></span><br><span class="line">		<span class="comment">//析构唤醒代表需要销毁</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//判断是否线程池处于开启状态，关闭则为析构唤醒</span></span><br><span class="line">		<span class="keyword">if</span> (pool-&gt;openT == <span class="literal">false</span>) &#123;</span><br><span class="line">			<span class="comment">//若已关闭则解锁，销毁</span></span><br><span class="line">			u_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">			<span class="comment">//线程退出，通过return退出</span></span><br><span class="line">			pool-&gt;<span class="built_in">threadExit</span>();</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//判断是否为管理线程唤醒</span></span><br><span class="line">		<span class="keyword">if</span> (pool-&gt;exitTnum &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//判断该线程能否销毁</span></span><br><span class="line">			<span class="keyword">if</span> (pool-&gt;liveTnum &gt; pool-&gt;minTnum) &#123;</span><br><span class="line"></span><br><span class="line">				<span class="comment">//该线程退出，需要退出的线程数-1</span></span><br><span class="line">				pool-&gt;exitTnum--;</span><br><span class="line">				<span class="comment">//该线程退出，存活线程数-1</span></span><br><span class="line">				pool-&gt;liveTnum--;</span><br><span class="line">				<span class="comment">//解锁</span></span><br><span class="line">				u_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">				<span class="comment">//线程退出，通过return退出</span></span><br><span class="line">				pool-&gt;<span class="built_in">threadExit</span>();</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;小于最小线程数，目前不能再销毁线程啦!&quot;</span> &lt;&lt; endl;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//取出任务</span></span><br><span class="line">		Task&lt;T&gt; t = pool-&gt;q_task-&gt;_getTask();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//变更线程池状态参数</span></span><br><span class="line">		pool-&gt;workingTnum++;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//解锁</span></span><br><span class="line">		u_mutex.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//执行任务</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;消费线程 --- 已取出任务正在执行中... ID : &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">		t.<span class="built_in">function</span>(t.arg);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//变更线程池状态参数</span></span><br><span class="line">		u_mutex.<span class="built_in">lock</span>();</span><br><span class="line">		pool-&gt;workingTnum--;</span><br><span class="line">		u_mutex.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//任务执行完毕</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;消费线程 --- 任务执行完毕... ID : &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Manage-Thread-管理线程"><a href="#Manage-Thread-管理线程" class="headerlink" title="Manage Thread - 管理线程"></a>Manage Thread - 管理线程</h3><blockquote>
<p>检测线程池状态，通过添加或者销毁线程，使线程池既能保证任务执行效率又能保证线程资源使用效率</p>
<p>仅有一个管理者线程</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//管理者线程处理函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Thread_pool&lt;T&gt;::<span class="built_in">manager</span>(Thread_pool&lt;T&gt;* pool)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (pool-&gt;openT) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//每1s检测一次</span></span><br><span class="line">		this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">		<span class="comment">//取出相关状态参数与任务	</span></span><br><span class="line">		<span class="keyword">int</span> task_num = pool-&gt;q_task-&gt;_getTaskNum();</span><br><span class="line">		<span class="keyword">int</span> live = pool-&gt;<span class="built_in">getliveTNum</span>();</span><br><span class="line">		<span class="keyword">int</span> working = pool-&gt;<span class="built_in">getworkingTNum</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//测试用</span></span><br><span class="line">		<span class="comment">/*cout &lt;&lt; task_num &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; live &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; working &lt;&lt; endl;*/</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">int</span> NUMBER = <span class="number">2</span>;</span><br><span class="line">		<span class="comment">//判断是否需要添加线程</span></span><br><span class="line">		<span class="function">unique_lock&lt;mutex&gt; <span class="title">u_mutex</span><span class="params">(pool-&gt;t_mutex)</span></span>;</span><br><span class="line">		<span class="keyword">if</span> (task_num &gt; live &amp;&amp; live &lt; pool-&gt;maxTnum) &#123;</span><br><span class="line">			<span class="keyword">int</span> count;</span><br><span class="line">			<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (i = <span class="number">0</span>, count = <span class="number">0</span>; i &lt; pool-&gt;maxTnum &amp;&amp; count &lt; NUMBER &amp;&amp; live &lt; pool-&gt;maxTnum; i++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (pool-&gt;consumes_ID[i] == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">					<span class="keyword">auto</span> consume_f = <span class="built_in">bind</span>(&amp;Thread_pool&lt;T&gt;::consumer, pool);</span><br><span class="line"></span><br><span class="line">					thread* con = <span class="keyword">new</span> <span class="built_in">thread</span>(consume_f);</span><br><span class="line">					cout &lt;&lt; <span class="string">&quot;消费者线程被添加成功! ID : &quot;</span> &lt;&lt; con-&gt;<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">					<span class="comment">//记录创建的消费者线程</span></span><br><span class="line">					<span class="keyword">threadid_t</span> ID = pool-&gt;<span class="built_in">id_change</span>(con-&gt;<span class="built_in">get_id</span>());</span><br><span class="line">					pool-&gt;consumes_ID[i] = ID;</span><br><span class="line"></span><br><span class="line">					<span class="comment">//更新状态参数</span></span><br><span class="line">					pool-&gt;liveTnum++;</span><br><span class="line"></span><br><span class="line">					<span class="comment">//添加成功后再count++；</span></span><br><span class="line">					count++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125;</span><br><span class="line">		u_mutex.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//判断是否需要销毁线程</span></span><br><span class="line">		<span class="keyword">if</span> (live &gt; pool-&gt;minTnum &amp;&amp; live &gt; <span class="number">2</span> * working) &#123;</span><br><span class="line">			<span class="function">unique_lock&lt;mutex&gt; <span class="title">u_mutex</span><span class="params">(pool-&gt;t_mutex)</span></span>;</span><br><span class="line">			pool-&gt;exitTnum = NUMBER;</span><br><span class="line">			u_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">			<span class="keyword">int</span> i;</span><br><span class="line">			<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NUMBER; i++) &#123;</span><br><span class="line">				pool-&gt;cond.<span class="built_in">notify_one</span>();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h3><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>* n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> * x = (<span class="keyword">int</span>*)(n);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;count = &quot;</span> &lt;&lt; (*x)++ &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	Thread_pool&lt;<span class="keyword">int</span>&gt;* p = <span class="keyword">new</span> Thread_pool&lt;<span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">500</span>);</span><br><span class="line">	<span class="keyword">int</span>* n = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>();</span><br><span class="line">	*n = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">		p-&gt;<span class="built_in">addTask</span>(func, n);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//删除之前保证子线程执行完毕阻塞5s</span></span><br><span class="line">	this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//为了看完整的退出信息阻塞5s</span></span><br><span class="line">	this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Summary-of-problems"><a href="#Summary-of-problems" class="headerlink" title="Summary of problems"></a>Summary of problems</h2><ul>
<li><p>条件变量个数</p>
<blockquote>
<p>添加任务不设置条件变量进行阻塞，因为适配器queue容器底层deque(默认)可自动扩容</p>
<p>但是执行线程需要添加一个条件变量用于在无任务时阻塞</p>
</blockquote>
</li>
<li><p>锁的个数</p>
<blockquote>
<p>访问任务队列一把锁</p>
<p>线程状态参数的更新一把锁</p>
</blockquote>
</li>
<li><p>函数类型固定单一</p>
</li>
<li><p>模板的分离式编译</p>
<blockquote>
<p><strong>问题 :</strong> </p>
<p>模板的分离式编译后，报错未找到定义</p>
<p><strong>改进 :</strong>  </p>
<p>C++ 编译器对模板的分离式编译支持很弱，建议将头文件的声明与定义放一起</p>
<p>因为模板的实现仍是模板，重复定义没啥大问题</p>
<p>若选择分离，则main文件中需要将.h与.cpp同时引入即可</p>
</blockquote>
</li>
<li><p>无符号整型类型 线程ID 的获取</p>
<blockquote>
<p>观察发现 thread::id 是一个类对象，仅提供了一个公共对外接口，unsigned int 类型的数据成员被设置为私有直接拿不到</p>
<p>但是发现该类实现了对 hash 模板的特化，我们可以使用其hash值代替线程ID</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 特化源码</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;</span>thread::id&gt;</span><br><span class="line">	&#123;	<span class="comment">// hash functor for thread::id</span></span><br><span class="line">	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS <span class="keyword">typedef</span> thread::id argument_type;</span><br><span class="line">	_CXX17_DEPRECATE_ADAPTOR_TYPEDEFS <span class="keyword">typedef</span> <span class="keyword">size_t</span> result_type;</span><br><span class="line"></span><br><span class="line">	<span class="function">_NODISCARD <span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> thread::id _Keyval)</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">		</span>&#123;	<span class="comment">// hash _Keyval to size_t value by pseudorandomizing transform</span></span><br><span class="line">		<span class="keyword">return</span> (_Hash_representation(_Keyval._Id));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"><span class="comment">// 转换方法</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> Thread_pool&lt;T&gt;::<span class="keyword">threadid_t</span> Thread_pool&lt;T&gt;::<span class="built_in">id_change</span>(thread::id id)</span><br><span class="line">&#123;</span><br><span class="line">	Thread_pool&lt;T&gt;::<span class="keyword">threadid_t</span> ID = hash&lt;thread::id&gt;()(id);</span><br><span class="line">	<span class="keyword">return</span> ID;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>变量重定义使局部变量覆盖了类成员</p>
<blockquote>
<p>md</p>
<p>wcnmd</p>
<p>我他妈的查了一下午草</p>
</blockquote>
</li>
<li><p>管理者线程无法增加，销毁消费者线程</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">unique_lock&lt;mutex&gt; <span class="title">u_mutex</span><span class="params">(pool-&gt;t_mutex)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (task_num &gt; live &amp;&amp; live &lt; pool-&gt;maxTnum) &#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;需要添加线程!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">int</span> count;</span><br><span class="line">	<span class="keyword">int</span> i</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>, count = <span class="number">0</span>; i &lt; pool-&gt;maxTnum &amp;&amp; count &lt; NUMBER &amp;&amp; live &lt; pool-&gt;maxTnum; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (pool-&gt;consumes_ID[i] == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;爷看看有没有在添加线程!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">auto</span> consume_f = <span class="built_in">bind</span>(&amp;Thread_pool&lt;T&gt;::consumer, pool);</span><br><span class="line"></span><br><span class="line">			thread* con = <span class="keyword">new</span> <span class="built_in">thread</span>(consume_f);</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;消费者线程 : &quot;</span> &lt;&lt; con-&gt;<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;被添加成功!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//记录创建的消费者线程</span></span><br><span class="line">			<span class="keyword">threadid_t</span> ID = pool-&gt;<span class="built_in">id_change</span>(con-&gt;<span class="built_in">get_id</span>());</span><br><span class="line">			pool-&gt;consumes_ID[i] = ID;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//更新状态参数</span></span><br><span class="line">			pool-&gt;liveTnum++;</span><br><span class="line">			<span class="comment">//---------------------------------------------------------</span></span><br><span class="line">			<span class="comment">//添加成功后再count++；</span></span><br><span class="line">			count++;</span><br><span class="line">          <span class="comment">//---------------------------------------------------------</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line">u_mutex.<span class="built_in">unlock</span>();</span><br></pre></td></tr></table></figure>

<p><strong>问题 :</strong> </p>
<p>将count++放置在for的第三个参数处</p>
<p>但是线程池中 consumes_ID 线程ID记录数组的前n个最开始始终是初始化时候的n个线程ID</p>
<p>但实际只循环了两次，两次判断失败直接退出了循环，无法增加线程</p>
<p><strong>改进 :</strong>  </p>
<p>添加成功后再count++</p>
</blockquote>
</li>
<li><p>析构函数无法释放资源</p>
<blockquote>
<p><strong>问题 :</strong> </p>
<p>线程池处于关闭态时，执行线程被阻塞，无法执行后续判断进而销毁线程</p>
<p><strong>改进 :</strong>  </p>
<p>线程池处于关闭态时，为执行线程放行不阻塞，后续作判断</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pool-&gt;cond.<span class="built_in">wait</span>(u_mutex, [pool]() &#123;</span><br><span class="line">			<span class="keyword">if</span> (pool-&gt;openT == <span class="literal">false</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in"><span class="keyword">return</span></span> (pool-&gt;q_task-&gt;_getTaskNum() != <span class="number">0</span>);</span><br><span class="line">		&#125;);</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>任务执行状态输出穿插输出</p>
<blockquote>
<p>cpu调度问题，任务的执行与锁无关，但是语句执行是否连续，在于cpu调度</p>
</blockquote>
</li>
<li><p>野指针问题</p>
<blockquote>
<p>delete后未将指针设置为nullptr</p>
</blockquote>
</li>
<li><p>线程退出</p>
<blockquote>
<p>c++11未提供线程退出函数，这里的线程退出仅是退出前状态参数的更新，退出仍采用return退出</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>Thread</category>
      </categories>
      <tags>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ SBH堆管理机制</title>
    <url>/2021/08/11/C++Primer/SBH/</url>
    <content><![CDATA[<h1 id="Heap堆管理机制-SBH"><a href="#Heap堆管理机制-SBH" class="headerlink" title="Heap堆管理机制 - SBH"></a>Heap堆管理机制 - SBH</h1><h1 id="CRT-Strartup-code"><a href="#CRT-Strartup-code" class="headerlink" title="CRT Strartup code"></a>CRT Strartup code</h1><h2 id="Importance"><a href="#Importance" class="headerlink" title="Importance"></a>Importance</h2><blockquote>
<p>正确初始化C run-time library,即CRT</p>
<p>确保C++中静态对象的构造函数在正确的时机被调用</p>
</blockquote>
<h2 id="Entry-Point-Symbol"><a href="#Entry-Point-Symbol" class="headerlink" title="Entry-Point Symbol"></a>Entry-Point Symbol</h2><blockquote>
<p> 使用一个 function name 作Entry-Point Symbol，指定startup code</p>
<p>The funtion must be defined with the <strong>__stdcall</strong> calling convention(公约)</p>
</blockquote>
<ul>
<li><p>mainCRTStartup</p>
<blockquote>
<p>控制台应用程序 Console</p>
</blockquote>
</li>
<li><p>WinMainCRTStartup</p>
<blockquote>
<p>窗体应用程序 Windows</p>
</blockquote>
</li>
<li><p>_DllMainCRTStartup</p>
<blockquote>
<p>动态链接库 Dll</p>
</blockquote>
</li>
</ul>
<h2 id="Example-mainCRTStartup"><a href="#Example-mainCRTStartup" class="headerlink" title="Example - mainCRTStartup()"></a>Example - mainCRTStartup()</h2><h3 id="Code-Abstract"><a href="#Code-Abstract" class="headerlink" title="Code Abstract"></a>Code Abstract</h3><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mainCRTStartup</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">int</span> mainret;</span><br><span class="line"><span class="keyword">if</span>(!_heap_init(<span class="number">0</span>)) <span class="comment">// 1. heap初始化</span></span><br><span class="line">__try&#123;</span><br><span class="line">  _ioinit(); <span class="comment">//2. IO初始化  </span></span><br><span class="line">  _acmdln = (<span class="keyword">char</span>*)<span class="built_in">GetCommandLineA</span>(); <span class="comment">//3. 获取命令行参数</span></span><br><span class="line">_aenvptr = (cahr*)__crtGetEnvironmentStringsA(); <span class="comment">//4. 获取环境变量</span></span><br><span class="line">_setargv(); <span class="comment">//5. 字符串处理</span></span><br><span class="line">_setenvp(); <span class="comment">//6. 字符串处理</span></span><br><span class="line">_cinit(); <span class="comment">//7. data初始化</span></span><br><span class="line">__initenv = _environ; <span class="comment">//8. Main </span></span><br><span class="line">mainret = <span class="built_in">main</span>(__argc,__argv,_environ); <span class="comment">//8. Main 注意calling convention</span></span><br><span class="line"><span class="built_in">exit</span>(mainret); <span class="comment">//9. Exit</span></span><br><span class="line">  &#125;</span><br><span class="line">__eccept(...) &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="System-heap-management-interface"><a href="#System-heap-management-interface" class="headerlink" title="System heap management interface"></a>System heap management interface</h1><blockquote>
<p>HeapAlloc()</p>
<p>VirtualAlloc()</p>
</blockquote>
<h1 id="Heap堆管理机制-VC6"><a href="#Heap堆管理机制-VC6" class="headerlink" title="Heap堆管理机制  -VC6"></a>Heap堆管理机制  -VC6</h1><h2 id="Small-Block-Heap-SBH"><a href="#Small-Block-Heap-SBH" class="headerlink" title="Small Block Heap - SBH"></a>Small Block Heap - SBH</h2><blockquote>
<p>小块堆管理机制</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//__sbh_threshpld 设置内存门限，所需要的分配的内存小于该值，使用SBH机制为其分配内存</span></span><br><span class="line"><span class="comment">//__sbh_threshpld = 3F8，i.e. 1016</span></span><br><span class="line"><span class="comment">//_ioinit()对内存的分配操作中，自下而上的调用中分配的内存在不断的膨胀,在base()这里还未分配8byte的cookie首尾</span></span><br><span class="line"><span class="comment">//共1024 1K</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">heap_alloc_base</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//SBH堆管理机制</span></span><br><span class="line"><span class="comment">//从VirtualAlloc()取内存</span></span><br><span class="line"><span class="keyword">if</span>(size &lt;= __sbh_threshold) &#123;</span><br><span class="line">  pvReturn = __sbh_alloc_block(size);</span><br><span class="line">  <span class="keyword">if</span>(pvReturn) <span class="keyword">return</span> pvReturn;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//window提供的heap堆管理接口</span></span><br><span class="line"><span class="comment">//即调用HeapAlloc从_crtheap堆中取需要的内存</span></span><br><span class="line"><span class="keyword">if</span>(size==<span class="number">0</span>) size=<span class="number">1</span>;</span><br><span class="line">size=(size+...)&amp;~(...);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">HeapAlloc</span>(_crtheap,<span class="number">0</span>,size);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/SBH/image-20210716152231050.png" alt="image-20210716152231050"></p>
</blockquote>
<h3 id="Memory-Mangement"><a href="#Memory-Mangement" class="headerlink" title="Memory Mangement"></a>Memory Mangement</h3><blockquote>
<p>先向操作系统申请1M的内存，取其中 1/32 = 32K 部分</p>
<p>再将32K分成8块4K的内存段，作为SBH内存管理的<strong>基本单元</strong></p>
</blockquote>
<h4 id="Debug首部"><a href="#Debug首部" class="headerlink" title="Debug首部"></a>Debug首部</h4><blockquote>
<p>用于标识已分配内存的一些状态</p>
<p>其中指针用于链接 <strong>Debug Heap</strong> 双向链表 ，使调试器掌握<strong>分配内存的状态</strong></p>
<p>Debug Heap可以使物理上不连续的内存逻辑上有序</p>
<p>fill 部分为用户可见部分，其余部分用户不可见</p>
<p><img src="/images/SBH/image-20210716175659278.png" alt="image-20210716175659278"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//内存块的标识符</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _NORMAL_BLOCK 1 <span class="comment">//用于应用程序的内存 / 用于APP的内存</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_BLOCK 2 <span class="comment">//用于CRT的内存</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> nNoMansLandSize 4</span></span><br><span class="line">tydef <span class="class"><span class="keyword">struct</span> _<span class="title">CrtMemBlockHeader</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CrtMemBlockHeader</span>* <span class="title">pBlockHeaderNext</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CrtMemBlockHeader</span>* <span class="title">pBlockHeaderPrev</span>;</span></span><br><span class="line"><span class="keyword">char</span>* szFileNAME; <span class="comment">//分配该区块代码所在的文件</span></span><br><span class="line"><span class="keyword">int</span> nLine; <span class="comment">//分配该区块的代码所在文件代码行</span></span><br><span class="line"><span class="keyword">size_t</span> nDataSize;</span><br><span class="line"><span class="keyword">int</span> nBlockUse; <span class="comment">//1 or 0 代表该内存的用途 CRT/APP</span></span><br><span class="line"><span class="keyword">long</span> lRequest;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> gap[nNoMansLandSize];</span><br><span class="line">&#125; _CrtMemBlockHeader;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="Header结构"><a href="#Header结构" class="headerlink" title="Header结构"></a>Header结构</h4><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> BITVEC;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagHeader</span> &#123;</span></span><br><span class="line"> <span class="comment">//32bit hign 与 32bit low 会组合为一组64bit</span></span><br><span class="line"> BITVEC bitvEntryHi;</span><br><span class="line"> BITVEC bitvEntryLo;</span><br><span class="line"> BITVEC bitvCommit;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">void</span>* pHeadData;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">tagRegion</span>* <span class="title">pRegion</span>;</span></span><br><span class="line">&#125;HEADER,*PHEADER;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="heap-init-和-sbh-heap-init"><a href="#heap-init-和-sbh-heap-init" class="headerlink" title="_heap_init() 和 __sbh_heap_init()"></a>_heap_init() 和 __sbh_heap_init()</h4><blockquote>
<p>CRT会先为自己建立一个**_crtheap**,然后从中分配SBH所需要的<strong>HEADERS,REGIONS</strong>作为<strong>管理之用</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __cdecl _heap_init (<span class="keyword">int</span> mtflag) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化 Big-bloc heap</span></span><br><span class="line">    <span class="comment">//建立一个_crtheap堆专门用于SBH堆管理</span></span><br><span class="line">    <span class="keyword">if</span>((_crtheap = <span class="built_in">HeapCreat</span>(...))) &#123;</span><br><span class="line">        <span class="comment">//失败处理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化 Small-block heap</span></span><br><span class="line">    <span class="keyword">if</span>( __sbh_heap_init() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//失败处理</span></span><br><span class="line">        <span class="built_in">HeapDestroy</span>(_crtheap);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> __cdecl __sbh_heap_init(<span class="keyword">void</span>) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从_crtheap中分配16个Header</span></span><br><span class="line">    <span class="keyword">if</span>(!(__sbh_pHeaderList = </span><br><span class="line">        <span class="built_in">HeapAlloc</span>( _crtheap , <span class="number">0</span> , <span class="number">16</span>*<span class="built_in"><span class="keyword">sizeof</span></span>(HEADER) )</span><br><span class="line">        )</span><br><span class="line">      )&#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//状态设置</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> TURE;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="ioinit"><a href="#ioinit" class="headerlink" title="ioinit()"></a>ioinit()</h4><p>任何程序开始之前首次分配的内存大小为256byte，用于IO初始化</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//区分Debug模式的条件编译</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _DEBUG</span></span><br><span class="line"><span class="comment">//非debug模式下，分配的内存快无额外的debug首部</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _malloc_crt malloc</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">//c++编译器提供的macro宏</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _THISFILE __FILE__ <span class="comment">//指明当前代码所在的文件,__LINE__还可指出是第几行</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _malloc_crt(s) _malloc_dbg(s,_CRT_BLOCK,_THISFILE,__LINE__)</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __cdecl _ioinit(<span class="keyword">void</span>) &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line"> <span class="comment">//内存分配</span></span><br><span class="line"> <span class="comment">//IOINFO_ARRAY_ELTS = 32</span></span><br><span class="line">     <span class="comment">//sizeof(ioinfo) = 8</span></span><br><span class="line">    <span class="keyword">if</span>(</span><br><span class="line">        (pio = _malloc_crt(IOINFO_ARRAY_ELTS * <span class="built_in"><span class="keyword">sizeof</span></span>(ioinfo))</span><br><span class="line">      ) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//..</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">   </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="heap-alloc-dbg"><a href="#heap-alloc-dbg" class="headerlink" title="heap_alloc_dbg()"></a>heap_alloc_dbg()</h4><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">blockSize = <span class="built_in"><span class="keyword">sizeof</span></span>(_CrtMemBlockHeader) + nSize + nNoMansLandSize;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">pHead = (_CrtMemBlockHeader*)_heap _alloc_base(blockSize); <span class="comment">//获取内存,并使用pHead指针临时指向</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置Debug Heap</span></span><br><span class="line"><span class="comment">//将各heap内存块串为一个双向链表</span></span><br><span class="line"><span class="comment">//static  _CrtMemBlockHeader* pfirst</span></span><br><span class="line"><span class="comment">//static  _CrtMemBlockHeader* plast</span></span><br><span class="line"><span class="keyword">if</span>(pfirst) &#123;</span><br><span class="line">    pfirst -&gt; pBlockHeaderPrev = pHead;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    plast = pHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pHead -&gt; pBlockHeaderPrev = <span class="literal">NULL</span>;</span><br><span class="line">pHead -&gt; pBlockHeaderNext = pfirst;</span><br><span class="line"><span class="comment">//... Debug首部的其余6个属性的设置</span></span><br><span class="line"></span><br><span class="line">pfirst = pHead;</span><br><span class="line"></span><br><span class="line"><span class="comment">//fill in gap</span></span><br><span class="line"><span class="built_in">memset</span>((<span class="keyword">void</span>*)pHead-&gt;gap,_bNoMansLandFill,nNoMansLandSize);</span><br><span class="line"><span class="built_in">memset</span>((<span class="keyword">void</span>*)( <span class="built_in">pbData</span>(pHead) + nSize ),_bNoMansLandFill,nNoMansLandSize);</span><br><span class="line"><span class="comment">//fill data</span></span><br><span class="line"><span class="built_in">memset</span>((<span class="keyword">void</span>*)<span class="built_in">pbData</span>(pHead),_bCleanLandFill,nNoMansLandSize);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">void</span>*)<span class="built_in">pbData</span>(pHead);</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="sbh-alloc-block"><a href="#sbh-alloc-block" class="headerlink" title="__sbh_alloc_block()"></a>__sbh_alloc_block()</h4><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//BYTES_PER_PARA = 16</span></span><br><span class="line"><span class="comment">//添加cookie以及将内存大小调整到16的边界</span></span><br><span class="line">sizeEntry = (intSize + <span class="number">2</span>*<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) + (BYTES_PER_PARA<span class="number">-1</span>) &amp;~ (BYTES_PER_PARA<span class="number">-1</span>) )</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="sbh-alloc-new-region"><a href="#sbh-alloc-new-region" class="headerlink" title="__sbh_alloc_new_region()"></a>__sbh_alloc_new_region()</h4><h5 id="Logic-memory"><a href="#Logic-memory" class="headerlink" title="Logic memory"></a><strong>Logic memory</strong></h5><blockquote>
<p>REGION -&gt; GROUP -&gt; LISTHEAD -&gt; ENTRY</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> BITVEC;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagRegion</span> &#123;</span></span><br><span class="line"> <span class="comment">//判断链表是否链接了区块，无法从空链表切割分配内存</span></span><br><span class="line"> <span class="keyword">int</span> indGroupUse;</span><br><span class="line"> <span class="keyword">char</span> cntRegionSize[<span class="number">64</span>];</span><br><span class="line"> <span class="comment">//32组64bit的组合，组成一个64bit的变量</span></span><br><span class="line"> BITVEC bitvEntryHi[<span class="number">32</span>];</span><br><span class="line"> BITVEC bitvEntryLo[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">tagGroup</span> <span class="title">grpHeadList</span>[32];</span></span><br><span class="line">&#125;REGION,*PREGION;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagGroup</span> &#123;</span></span><br><span class="line"> <span class="keyword">int</span> cntEntries;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//自上而下第一个双向链表链接(维护)的区块大小范围为0~16B</span></span><br><span class="line"> <span class="comment">//第64个即63号双向链表链接(维护)的区块大小范围为&gt;1KB and &lt; 8KB</span></span><br><span class="line"> <span class="comment">// sign = Esize / 16 - 1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagListHead</span> <span class="title">listHead</span>[64];</span></span><br><span class="line">&#125;GROUP,*PGROUP;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagListHead</span> &#123;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//用于组织管理大小相同的内存块</span></span><br><span class="line"> <span class="comment">//将大小相同的内存块串成双向链表</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">tagEntry</span>* <span class="title">pEntryNext</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tagEntry</span>* <span class="title">pEntryPrev</span>;</span></span><br><span class="line"></span><br><span class="line">&#125;LISTHEAD,*PLISTHEAD;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagEntry</span> &#123;</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span> sizeFont;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">tagEntry</span>* <span class="title">pEntryNext</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tagEntry</span>* <span class="title">pEntryPrev</span>;</span></span><br><span class="line"></span><br><span class="line">&#125;ENTRY,*PENTRY;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><img src="/images/SBH/image-20210717083105261.png" alt="image-20210717083105261"></p>
</blockquote>
<h5 id="Physics-memory"><a href="#Physics-memory" class="headerlink" title="Physics memory"></a><strong>Physics memory</strong></h5><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">p = <span class="built_in">VirtualAlloc</span>(<span class="number">0</span>,<span class="number">1</span>M,MEM_RESERVE,...);</span><br><span class="line"><span class="comment">//向操作系统申请1M的内存</span></span><br><span class="line"><span class="built_in">VirtualAlloc</span>(addr,<span class="number">32</span>K,MEM_RESERVE,...)</span><br><span class="line"><span class="comment">//取其中 1/32 = 32K 部分</span></span><br><span class="line"><span class="comment">//再将32K分成8块小内存，通过 LISTHEADER 管理 4K=4096 的小内存段</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/SBH/image-20210717083750367.png" alt="image-20210717083750367"></p>
<p><strong>强制分隔字段</strong></p>
<p>每段大小虽然为4k = 4096 但是其中8byte为<strong>强制分隔字段</strong></p>
<blockquote>
<p>在所有分配的内存全部回收时候，防止SBH内存管理的<strong>基本单元</strong>被合并</p>
<p>每个基本单元逻辑上由双向链表链接不连续，但是实际物理上是连续的内存</p>
</blockquote>
<p><strong>保留字段</strong></p>
<p>4096 - 8 = 4088 所以需<strong>保留字段</strong>确保内存为<strong>16的整数倍</strong></p>
<p><strong>可分配内存</strong></p>
<p>而只有4080可以用于分配内存因为有8byte的cookie字段指明长度</p>
<p><code>注意:</code></p>
<ol>
<li>只要是<strong>可分配内存/空闲内存</strong>，一定有两个<strong>临时指针</strong>，该指针用于LISTHEAD<strong>登记管理</strong></li>
<li><strong>临时指针</strong>内存段被分配后，会被<strong>覆盖</strong>，不在用于LISTHEAD<strong>登记管理</strong></li>
</ol>
<p><img src="/images/SBH/image-20210717092728471.png" alt="image-20210717092728471"></p>
</blockquote>
<h3 id="Memory-Allocate"><a href="#Memory-Allocate" class="headerlink" title="Memory Allocate"></a>Memory Allocate</h3><blockquote>
<ol>
<li>从由各LISTHEAD管理的所有空闲内存中找出与申请内存<strong>最接近</strong>的空闲内存进行分配</li>
<li>从空闲内存中切割分配用户所需要的的内存，并通过逐级的回溯<strong>最终返回</strong>给用户指向该分配内存的指针<strong>pUser</strong></li>
</ol>
<blockquote>
<p>pUser当前所指位置并不是当前分配后的pUser的实际指向，该指针会最终移动到该位置</p>
</blockquote>
<ol start="3">
<li><p><strong>重新登记</strong>管理剩余内存的LISTHEAD</p>
<blockquote>
<p>ec0 / 10h &gt; 1K 所以仍由63号LISTHEAD管理该剩余内存区块</p>
</blockquote>
</li>
</ol>
<p><img src="/images/SBH/image-20210717103245856.png" alt="image-20210717103245856"></p>
</blockquote>
<h5 id="For-the-first-time-distribution"><a href="#For-the-first-time-distribution" class="headerlink" title="For the first time distribution"></a>For the first time distribution</h5><blockquote>
<p>初始时仅由最后一个LISTHEAD管理8段基本单元，其余LISTHEAD为空</p>
<p>因此首次分配内存时申请的130h内存由最后一个listhead组织管理分配，而不是对应的 130h / 10h = 19 18号链表链接</p>
<p><img src="/images/SBH/image-20210717103332926.png" alt="image-20210717103332926"></p>
</blockquote>
<h3 id="Memory-recycle"><a href="#Memory-recycle" class="headerlink" title="Memory recycle"></a>Memory recycle</h3><blockquote>
<p>free(pCurrnet);</p>
</blockquote>
<h5 id="Merge"><a href="#Merge" class="headerlink" title="Merge"></a>Merge</h5><blockquote>
<p><strong>每一次</strong>回收都将与该回收内存<strong>紧邻的</strong>空闲内存(cookie尾末位为0)进行合并</p>
<p>下一空闲内存的cookie头 = pCurrnet - 4 + 300</p>
<p>上一空闲内存的cookie尾 = pCurrnet - 8</p>
<p>通过判断cookie的首尾末位状态来判断是否进行合并</p>
<blockquote>
<p>若只有cookie头或cookie尾，则只能朝反向单向检测内存块的状态</p>
</blockquote>
<p><img src="/images/SBH/image-20210717175327399.png" alt="image-20210717175327399"></p>
</blockquote>
<h5 id="Re-Register"><a href="#Re-Register" class="headerlink" title="Re-Register"></a>Re-Register</h5><blockquote>
<p><strong>重新登记</strong>管理该回收内存的LISTHEAD,将该内存”插入”到对应LISTHEAD链接的双向链表中</p>
<blockquote>
<p>更新空闲内存的临时指针指向，将空闲内存”挂”到对应LISTHEAD管理的双向链表上</p>
</blockquote>
<p><img src="/images/SBH/image-20210717104533693.png" alt="image-20210717104533693"></p>
</blockquote>
<blockquote>
<p>b0内存分配出去后，该部分剩余190h内存需要重新又相应双向链表管理</p>
<p><img src="/images/SBH/image-20210717105611949.png" alt="image-20210717105611949"></p>
</blockquote>
<h1 id="Verification"><a href="#Verification" class="headerlink" title="Verification"></a>Verification</h1><h2 id="Blocks-allocated-befor-main"><a href="#Blocks-allocated-befor-main" class="headerlink" title="Blocks allocated befor main()"></a>Blocks allocated befor main()</h2><blockquote>
<p>在进入main()之前，CRT已经进行一些内存分配的工作，例如环境变量的内存分配</p>
</blockquote>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mainCRTStartup</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    verification</span><br><span class="line">  _acmdln = (<span class="keyword">char</span>*)<span class="built_in">GetCommandLineA</span>(); <span class="comment">//3. 获取命令行参数</span></span><br><span class="line">  <span class="comment">//_acmdln为argv格式</span></span><br><span class="line">  </span><br><span class="line">  _aenvptr = (cahr*)__crtGetEnvironmentStringsA(); <span class="comment">//4. 获取所有环境变量</span></span><br><span class="line">  </span><br><span class="line">    _setargv(); <span class="comment">//5. 字符串处理</span></span><br><span class="line">  <span class="comment">//为_acmdln分配内存</span></span><br><span class="line">  _setenvp(); <span class="comment">//6. 字符串处理</span></span><br><span class="line">  <span class="comment">//为pointer table分配内存</span></span><br><span class="line">    <span class="comment">//10个字符串与10个指针(连续)，共11次内存分配操作</span></span><br><span class="line">  </span><br><span class="line">  __initenv = _environ;</span><br><span class="line">  <span class="comment">// _environ是指指向环境变量字符串的指针</span></span><br><span class="line">  <span class="comment">//环境变量字符串使用指针指向</span></span><br><span class="line">  <span class="comment">//因此 _environ 为pointer to pointer table</span></span><br><span class="line">  </span><br><span class="line">  mainret = <span class="built_in">main</span>(__argc,__argv,_environ);</span><br><span class="line">  <span class="comment">//calling convention约束下，这里的参数无所谓有无</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>例一VC6操作系统有10个环境变量需要分配内存</p>
<p><img src="/images/SBH/image-20210718090713992.png" alt="image-20210718090713992"></p>
<ol>
<li><p>以argv格式获取命令行参数</p>
<blockquote>
<p>argv格式(假设argc为n)</p>
<ul>
<li><p>连续n个指针,指向n个字符串</p>
</li>
<li><p>连续n个字符串，每个字符串以’/0’结束</p>
</li>
<li><p>\0结尾，4byte</p>
</li>
</ul>
</blockquote>
</li>
<li><p>使用一大段内存获取操作系统中的<strong>所有环境变量</strong></p>
</li>
<li><p>通过10个独立的字符串内存段和1个指针内存段来管理所有环境变量</p>
<blockquote>
<p>每个内存段添加debug首部等便于调试器管理</p>
</blockquote>
</li>
<li><p>设置命令行参数内存</p>
</li>
</ol>
<p><img src="/images/SBH/image-20210718092728650.png" alt="image-20210718092728650"></p>
</blockquote>
<h1 id="Heap堆管理机制-VC10"><a href="#Heap堆管理机制-VC10" class="headerlink" title="Heap堆管理机制 -VC10"></a>Heap堆管理机制 -VC10</h1><blockquote>
<p>VC10下并没有取消SBH堆管理机制，而是内置到了HeapAlloc操作系统下</p>
</blockquote>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">hMyHeap = <span class="built_in">HeapCreate</span>(<span class="number">0</span>,<span class="number">4096</span>,<span class="number">0</span>); <span class="comment">// 例中 hMyHeap=39000</span></span><br></pre></td></tr></table></figure>

<p><strong>LISTHEAD</strong></p>
<p>hMyHeap指向的地址中，在offset = 178 即 39178地址处，有128 对 LISTHEAD指针 4byte为一个指针</p>
<blockquote>
<p>每对LISTHEAD指针分别以<strong>双向链表</strong>登记，管理着不同的状态的内存</p>
<p>free[0]: &gt;1K</p>
<blockquote>
<p>初始登记管理所有基本单元</p>
</blockquote>
<p>free[127]: 0~8 byte</p>
<blockquote>
<p>初始两个指针都指向自己，表示该LISTHEAD连接的链表为空，无法分配内存</p>
</blockquote>
</blockquote>
<p><strong>基本单元</strong></p>
<p>cookie首部</p>
<blockquote>
<p>8byte</p>
<p>不仅记录本区块的内存长度，还记录前一个区块的内存长度</p>
<p>长度单位为8byte</p>
<blockquote>
<p>free[size] 可与 LISTHEAD 直接建立管理对应关系</p>
</blockquote>
<p>首区块 前一区块内存长度字段值为 0303 有特殊意义</p>
</blockquote>
<p>debug 尾部</p>
<blockquote>
<p>16byte</p>
</blockquote>
<p><img src="/images/SBH/image-20210718101857874.png" alt="image-20210718101857874"></p>
</blockquote>
<h2 id="Verification-1"><a href="#Verification-1" class="headerlink" title="Verification"></a>Verification</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">lp = <span class="built_in">HeapAlloc</span>(hMyheap,HEAP_ZERO_MEMORY,<span class="number">1024</span>);</span><br></pre></td></tr></table></figure>



<p><img src="/images/SBH/image-20210718103359627.png" alt="image-20210718103359627"></p>
</blockquote>
]]></content>
      <categories>
        <category>C++Primer</category>
      </categories>
      <tags>
        <tag>C++Primer</tag>
      </tags>
  </entry>
  <entry>
    <title>Design mode / 设计模式</title>
    <url>/2021/08/11/C++Primer/Design_Mode/</url>
    <content><![CDATA[<h1 id="Design-mode-设计模式"><a href="#Design-mode-设计模式" class="headerlink" title="Design mode / 设计模式"></a>Design mode / 设计模式</h1><blockquote>
<p>没有任何稳定点的软件体系结构，设计模式没有意义</p>
<p>任何点都稳定的软件体系结构，设计模式也没有意义</p>
<p>从变化点和稳定点中寻找隔离点，分离后管理变化</p>
<blockquote>
<p>编译时稳定复用</p>
<p>运行时<strong>多态</strong>变化</p>
</blockquote>
</blockquote>
<h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><blockquote>
<p><strong>应对变化 提高复用</strong></p>
<p><strong>二进制单位意义</strong>的复用，而不是<strong>代码片段级</strong>粘贴性质的复用</p>
<p>二进制单位意义的复用无需重新编译部署</p>
</blockquote>
<h2 id="依赖倒置原则-DIP"><a href="#依赖倒置原则-DIP" class="headerlink" title="依赖倒置原则 -DIP"></a>依赖倒置原则 -DIP</h2><blockquote>
<p>变化应该依赖于稳定，稳定不应该依赖于变化</p>
<p>高层模块不应该依赖于低层模块，二者都可以依赖于抽象</p>
<p>抽象不应该依赖于实现，实现细节可以依赖于抽象</p>
</blockquote>
<h2 id="开闭原则-OCP"><a href="#开闭原则-OCP" class="headerlink" title="开闭原则 -OCP"></a>开闭原则 -OCP</h2><blockquote>
<p>对<strong>拓展开放</strong>，对<strong>修改封闭</strong></p>
<p>类模块应该是可拓展的，但是不可修改</p>
<p>类应该以<strong>拓展方式</strong>来应对需求变化，而不是更改类中代码</p>
</blockquote>
<h2 id="单一职责原则-SRP"><a href="#单一职责原则-SRP" class="headerlink" title="单一职责原则 -SRP"></a>单一职责原则 -SRP</h2><blockquote>
<p>一个类应该<strong>仅有一个</strong>引起它变化的原因</p>
<p>桥模式</p>
</blockquote>
<h2 id="接口隔离原则-ISP"><a href="#接口隔离原则-ISP" class="headerlink" title="接口隔离原则 -ISP"></a>接口隔离原则 -ISP</h2><blockquote>
<p>不能让用户依赖于他们不使用的方法</p>
<p>就是一个类实现了多个接口，其中用户用不到的方法使用private等限定隔离</p>
</blockquote>
<h2 id="里氏替换原则-LSP"><a href="#里氏替换原则-LSP" class="headerlink" title="里氏替换原则 -LSP"></a>里氏替换原则 -LSP</h2><blockquote>
<p>子类型必须能替换掉它的父类型 IS-A</p>
<p>能使用父类对象的方法子类也能适用</p>
<p>假设有两个类，一个是Base类，另一个是Child类，并且Child类是Base的子类。那么一个方法如果可以接受一个基类对象b的话:method1(Base b)那么它必然可以接受一个子类的对象method1(Child c)</p>
</blockquote>
<h2 id="组合优先于继承"><a href="#组合优先于继承" class="headerlink" title="组合优先于继承"></a>组合优先于继承</h2><blockquote>
<p>组合为黑盒复用，继承是白盒复用</p>
<p>继承一定程度上破坏了封装性，子类父类耦合度高</p>
</blockquote>
<h2 id="封装变化点"><a href="#封装变化点" class="headerlink" title="封装变化点"></a>封装变化点</h2><blockquote>
<p>一侧变化，一侧稳定</p>
</blockquote>
<h2 id="针对接口编程，而不是针对实现编程"><a href="#针对接口编程，而不是针对实现编程" class="headerlink" title="针对接口编程，而不是针对实现编程"></a>针对接口编程，而不是针对实现编程</h2><blockquote>
<p>不将变量类型声明为某个特定的具体类，而是声明为某个接口</p>
<p>客户程序无需知道对象的具体类型，只需要知道对象所具有的接口</p>
</blockquote>
<h1 id="模式分类"><a href="#模式分类" class="headerlink" title="模式分类"></a>模式分类</h1><h2 id="从目的来看"><a href="#从目的来看" class="headerlink" title="从目的来看"></a>从目的来看</h2><ul>
<li>创建型模式</li>
</ul>
<blockquote>
<p>将对象的部分创建工作<strong>延迟</strong>到子类</p>
<p>应对需求变化为<strong>对象创建具体类型的实现</strong>带来的冲击</p>
</blockquote>
<ul>
<li>结构型模式</li>
</ul>
<blockquote>
<p>通过类继承或者对象组合的<strong>结构</strong></p>
<p>应对需求变化对<strong>对象结构</strong>带来的冲击</p>
</blockquote>
<ul>
<li>行为型模式</li>
</ul>
<blockquote>
<p><strong>划分</strong>对象间的<strong>职责</strong></p>
<p>应对需求变化为<strong>多个交互对象</strong>带来的冲击</p>
</blockquote>
<h2 id="封装变化"><a href="#封装变化" class="headerlink" title="封装变化"></a>封装变化</h2><p>​        ↓</p>
<h1 id="“组件协作”模式"><a href="#“组件协作”模式" class="headerlink" title="“组件协作”模式"></a>“组件协作”模式</h1><blockquote>
<p>通过<strong>晚期绑定</strong></p>
<p>实现<strong>框架</strong>与<strong>应用程序</strong>之间的松耦合</p>
</blockquote>
<h2 id="Template-Method-模式"><a href="#Template-Method-模式" class="headerlink" title="Template Method 模式"></a>Template Method 模式</h2><h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><blockquote>
<p><strong>稳定</strong>操作框架结构，而其中某些子步骤有<strong>变化需求</strong></p>
<p>无法实现任务和整体结构的<strong>同步</strong></p>
</blockquote>
<h3 id="Defination"><a href="#Defination" class="headerlink" title="Defination"></a>Defination</h3><blockquote>
<p>Template Method 操作算法骨架(稳定) -&gt; 骨架中某些步骤<strong>延迟</strong>到子类实现(变化)</p>
<p>从而子类可以<strong>复用</strong>该<strong>算法骨架</strong>或者<strong>重写</strong>算法中<strong>某些特定步骤</strong></p>
<p><strong>延迟</strong></p>
<blockquote>
<p>定义一个虚函数让子类实现or重写，从而支持子类变化</p>
</blockquote>
</blockquote>
<h3 id="Code-and-UML"><a href="#Code-and-UML" class="headerlink" title="Code and UML"></a>Code and UML</h3><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// libiary and Application</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">libiary</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//稳定的函数不能声明为虚函数</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">template_method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">		<span class="built_in">var</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//若不声明为虚函数，无法调用子类的构造函数</span></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">libiary</span>() &#123;&#125;;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">//变化的函数声明为虚函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">var</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Application</span> :</span> <span class="keyword">public</span> libiary &#123;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">var</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//多态调用</span></span><br><span class="line">	libiary* p = <span class="keyword">new</span> <span class="built_in">Application</span>();</span><br><span class="line">	p-&gt;<span class="built_in">template_method</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>-</p>
<p><img src="/images/Design_Mode/image-20210719103524862.png" alt="image-20210719103524862"></p>
</blockquote>
<h2 id="Strategy-模式"><a href="#Strategy-模式" class="headerlink" title="Strategy 模式"></a>Strategy 模式</h2><h3 id="Motivation-1"><a href="#Motivation-1" class="headerlink" title="Motivation"></a>Motivation</h3><blockquote>
<p>一个类中包含多个算法</p>
<p>不再使用的算法成为性能负担</p>
<p>拓展算法时必须于类中添加代码，违反开闭原则</p>
<p>客户程序段存在 **if-else散弹 ** <strong>-</strong>  <strong>bad smell</strong></p>
</blockquote>
<h3 id="Defination-1"><a href="#Defination-1" class="headerlink" title="Defination"></a>Defination</h3><blockquote>
<p><strong>单独封装</strong>算法，算法可相互替换 </p>
<p>算法可独立于客户程序(稳定)而变化(<strong>拓展，子类化</strong>)</p>
<p>用<strong>拓展的方式</strong>面对<strong>算法方面</strong>需求的变化</p>
</blockquote>
<h3 id="Code-and-UML-1"><a href="#Code-and-UML-1" class="headerlink" title="Code and UML"></a>Code and UML</h3><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 税率计算</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/Design_Mode/image-20210721084310497.png" alt="image-20210721084310497"></p>
</blockquote>
<h2 id="Observer-模式"><a href="#Observer-模式" class="headerlink" title="Observer 模式"></a>Observer 模式</h2><h3 id="Motivation-2"><a href="#Motivation-2" class="headerlink" title="Motivation"></a>Motivation</h3><blockquote>
<p>过于紧密的通知依赖关系不能很好地抵御变化</p>
<p>违反依赖倒置原则</p>
</blockquote>
<h3 id="Defination-2"><a href="#Defination-2" class="headerlink" title="Defination"></a>Defination</h3><blockquote>
<p><strong>弱化后的</strong>一对多的依赖中，一个对象发生变化，所有依赖他的对象都可以<strong>得到通知</strong>并<strong>自动更新</strong></p>
</blockquote>
<h3 id="Code-and-UML-2"><a href="#Code-and-UML-2" class="headerlink" title="Code and UML"></a>Code and UML</h3><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//GUI</span></span><br><span class="line"><span class="comment">//通过稳定的Observer基类，接口来弱化耦合关系</span></span><br><span class="line"><span class="comment">//观察者需要通过addListenser注册成为&quot;监听对象&quot;，并实现Observer接口从而具有自动更新的能力</span></span><br><span class="line"><span class="comment">//目标对象中含有某种容器存放各个观察者对象，注册实际上就是push_back</span></span><br><span class="line"><span class="comment">//目标对象发送通知notify方法其实是遍历容器调用接口中update()抽象方法(因此观察者对象必须实现Observer接口)</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/Design_Mode/image-20210721083330460.png" alt="image-20210721083330460"></p>
</blockquote>
<h1 id="“单一职责”模式"><a href="#“单一职责”模式" class="headerlink" title="“单一职责”模式"></a>“单一职责”模式</h1><blockquote>
<p>责任划分不清晰，继承拓展使得子类急剧膨胀</p>
</blockquote>
<h2 id="Decorator-模式"><a href="#Decorator-模式" class="headerlink" title="Decorator 模式"></a>Decorator 模式</h2><h3 id="Motivation-3"><a href="#Motivation-3" class="headerlink" title="Motivation"></a>Motivation</h3><blockquote>
<p>过度使用<strong>继承</strong>来<strong>拓展</strong>对象功能，使得<strong>子类过度膨胀</strong></p>
<blockquote>
<p>继承为继承<strong>静态特质</strong>，拓展不够灵活</p>
<blockquote>
<p>编译时装配</p>
<p>运行时装配</p>
</blockquote>
<p>拓展功能增多</p>
<p>各种组合功能</p>
</blockquote>
<p>eg:</p>
<p><img src="/images/Design_Mode/image-20210721100237043.png" alt="image-20210721100237043"></p>
</blockquote>
<h3 id="Defination-3"><a href="#Defination-3" class="headerlink" title="Defination"></a>Defination</h3><blockquote>
<p><strong>组合代替继承</strong></p>
<p>解决<strong>主体类</strong>在多个方向上的<strong>拓展</strong> </p>
<blockquote>
<p>装饰的含义是在已有功能已有对象的基础上拓展</p>
<p>在<strong>创建拓展对象</strong>的时候需要<strong>绑定</strong> (运行时) <strong>主体类对象</strong></p>
</blockquote>
<p>黑盒复用，因多态存在，可通过复合基类指针来实现<strong>不同方向</strong>拓展功能的<strong>组合</strong>，灵活度高</p>
<p>eg: 如 File 与 Crypto 是两个方向的功能拓展 本就不应该使用继承方式表示关系</p>
<p><img src="/images/Design_Mode/image-20210721100207892.png" alt="image-20210721100207892"></p>
</blockquote>
<h3 id="Code-and-UML-3"><a href="#Code-and-UML-3" class="headerlink" title="Code and UML"></a>Code and UML</h3><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//功能stream</span></span><br><span class="line"><span class="comment">//继承体系中，子类相同的字段应该向上提取，Decorator 中间类即为 Component* 共同字段的上提</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意:</span></span><br><span class="line"><span class="comment">//不把Component*字段上升到stream基类的原因是FileStream等主体类并不需要该字段</span></span><br><span class="line"><span class="comment">//因此把该共有字段上升到Decorator装饰器对象中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Decorator</span></span><br><span class="line"><span class="comment">//接口上is-a Component用于满足 Component 接口规范</span></span><br><span class="line"><span class="comment">//实现上has-a Component用于使用多态基类指针黑盒复用其他功能接口，完成功能组合</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> :</span> <span class="keyword">public</span> Component &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"> Component* component;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="comment">//...省略</span></span><br><span class="line"> <span class="built_in">Decorator</span>(...):...&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Design_Mode/image-20210721094228300.png" alt="image-20210721094228300"></p>
</blockquote>
<h2 id="Bridge-模式"><a href="#Bridge-模式" class="headerlink" title="Bridge 模式"></a>Bridge 模式</h2><h3 id="Motivation-4"><a href="#Motivation-4" class="headerlink" title="Motivation"></a>Motivation</h3><blockquote>
<p>某些类型具有<strong>固有的实现逻辑</strong>，使得他们具有<strong>多个变化维度</strong></p>
</blockquote>
<h3 id="Defination-4"><a href="#Defination-4" class="headerlink" title="Defination"></a>Defination</h3><blockquote>
<p>通过<strong>组合</strong>，将<strong>抽象部分</strong>与<strong>实现部分</strong>分离，使他们可以独立的变化</p>
</blockquote>
<h3 id="Code-and-UML-4"><a href="#Code-and-UML-4" class="headerlink" title="Code and UML"></a>Code and UML</h3><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通信模块</span></span><br><span class="line"><span class="comment">//解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessagerImp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//业务抽象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Messager</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	MessagerImp* messager;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Messager</span>(MessagerImp* m) :<span class="built_in">messager</span>(m) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Login</span><span class="params">(string username, string password)</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(string message)</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendPicture</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Messager</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现抽象</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessagerImp</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PlaySound</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DrawShape</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">WriteText</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Connect</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">MessagerImp</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//平台实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PCMessagerBase</span> :</span> <span class="keyword">public</span> MessagerImp &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PlaySound</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//**********</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DrawShape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//**********</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">WriteText</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//**********</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//**********</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MobileMessagerBase</span> :</span> <span class="keyword">public</span> MessagerImp &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PlaySound</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//==========</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DrawShape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//==========</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">WriteText</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//==========</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//==========</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//业务逻辑</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessagerLite</span>:</span><span class="keyword">public</span> Messager &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">MessagerLite</span>(MessagerImp* m) :<span class="built_in">Messager</span>(m) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Login</span><span class="params">(string username, string password)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		messager-&gt;<span class="built_in">Connect</span>();</span><br><span class="line">		<span class="comment">//........</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(string message)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		messager-&gt;<span class="built_in">WriteText</span>();</span><br><span class="line">		<span class="comment">//........</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendPicture</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		messager-&gt;<span class="built_in">DrawShape</span>();</span><br><span class="line">		<span class="comment">//........</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessagerPerfect</span>:</span><span class="keyword">public</span> Messager &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">MessagerPerfect</span>(MessagerImp* m) :<span class="built_in">Messager</span>(m) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Login</span><span class="params">(string username, string password)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		messager-&gt;<span class="built_in">PlaySound</span>();</span><br><span class="line">		<span class="comment">//********</span></span><br><span class="line">		messager-&gt;<span class="built_in">Connect</span>();</span><br><span class="line">		<span class="comment">//........</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(string message)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		messager-&gt;<span class="built_in">PlaySound</span>();</span><br><span class="line">		<span class="comment">//********</span></span><br><span class="line">		messager-&gt;<span class="built_in">WriteText</span>();</span><br><span class="line">		<span class="comment">//........</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendPicture</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		messager-&gt;<span class="built_in">PlaySound</span>();</span><br><span class="line">		<span class="comment">//********</span></span><br><span class="line">		messager-&gt;<span class="built_in">DrawShape</span>();</span><br><span class="line">		<span class="comment">//........</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//编译时装配</span></span><br><span class="line">	MessagerImp* p = <span class="keyword">new</span> <span class="built_in">PCMessagerBase</span>();</span><br><span class="line">	Messager * messager = <span class="keyword">new</span> <span class="built_in">MessagerLite</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/images/Design_Mode/image-20210725171507191.png" alt="image-20210725171507191"></p>
</blockquote>
<h2 id="Decorator-和-Bridge-的异同"><a href="#Decorator-和-Bridge-的异同" class="headerlink" title="Decorator 和 Bridge 的异同"></a>Decorator 和 Bridge 的异同</h2><ul>
<li><p>异</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">Decorator</th>
<th align="center">Bridge</th>
</tr>
</thead>
<tbody><tr>
<td align="center">单一职责</td>
<td align="center">功能子类的职责交叉划分不清</td>
<td align="center">基类多维度职责划分不清</td>
</tr>
<tr>
<td align="center">共有字段</td>
<td align="center">无法上升至基类，上升至Decorator装饰器接口类中</td>
<td align="center">上升至业务抽象基类中</td>
</tr>
<tr>
<td align="center">应用场景</td>
<td align="center">单维度多方向的功能拓展</td>
<td align="center">多维度的需求变化</td>
</tr>
</tbody></table>
</li>
<li><p>同</p>
<blockquote>
<ol>
<li><p>都是采用<strong>组合代替继承</strong>解决子类膨胀问题</p>
</li>
<li><p>都是<strong>运行时装配</strong>，即功能对象与主类对象的组合，各维度对象与主维度对象的组合</p>
<blockquote>
<p>通过多态在创建对象时进行对象<strong>动态组合</strong>，而非在类中直接绑定<strong>静态组合</strong></p>
</blockquote>
</li>
</ol>
</blockquote>
</li>
</ul>
<h1 id="“对象创建”-模式"><a href="#“对象创建”-模式" class="headerlink" title="“对象创建” 模式"></a>“对象创建” 模式</h1><blockquote>
<p>避免了使用 new 进行对象创建导致的紧耦合(依赖具体类)，使得对象的创建更为稳定</p>
</blockquote>
<h2 id="Factory-Method-模式"><a href="#Factory-Method-模式" class="headerlink" title="Factory Method 模式"></a>Factory Method 模式</h2><h3 id="Motivation-5"><a href="#Motivation-5" class="headerlink" title="Motivation"></a>Motivation</h3><blockquote>
<p>对象的具体类型经常变化，导致<strong>新对象</strong>创建时<strong>紧耦合</strong>现象</p>
</blockquote>
<h3 id="Defination-5"><a href="#Defination-5" class="headerlink" title="Defination"></a>Defination</h3><blockquote>
<p>定义一个创建对象的接口(工厂基类)，让子类决定实例化哪一个类(具体工厂)</p>
<p>通过虚函数使一个类的实例化<strong>延迟</strong>到子类实现</p>
</blockquote>
<h3 id="Code-and-UML-5"><a href="#Code-and-UML-5" class="headerlink" title="Code and UML"></a>Code and UML</h3><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//FactoryMethod基类 将对象创建任务延迟到子类</span></span><br><span class="line"><span class="comment">//通过拓展策略，创建新增类型对象 --添加一个子类实现工厂基类接口</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/Design_Mode/image-20210721110754696.png" alt="image-20210721110754696"></p>
</blockquote>
<h2 id="Abstract-Factory-模式"><a href="#Abstract-Factory-模式" class="headerlink" title="Abstract Factory 模式"></a>Abstract Factory 模式</h2><h3 id="Motivation-6"><a href="#Motivation-6" class="headerlink" title="Motivation"></a>Motivation</h3><blockquote>
<p>一系列<strong>相互依赖对象</strong> <strong>/</strong> <strong>系列对象</strong>的创建工作，通过简单工厂模式创建的各个对象可能<strong>破坏</strong>这种依赖关系</p>
</blockquote>
<h3 id="Defination-6"><a href="#Defination-6" class="headerlink" title="Defination"></a>Defination</h3><blockquote>
<p>提供一个接口，让该接口来负责创建一系列”相互依赖对象”</p>
</blockquote>
<h3 id="Code-and-UML-6"><a href="#Code-and-UML-6" class="headerlink" title="Code and UML"></a>Code and UML</h3><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数据库读取</span></span><br><span class="line"><span class="comment">//不同数据库command与connection对象相互关联且 </span></span><br><span class="line"><span class="comment">//将各个相关联的分工厂基类(commandFactory,connectionFactory)合并为一个总工厂基类(Factory)</span></span><br><span class="line"><span class="comment">//该总工厂接口规范子工厂对象的创建工作</span></span><br></pre></td></tr></table></figure>



<p><img src="/images/Design_Mode/image-20210722081816272.png" alt="image-20210722081816272"></p>
</blockquote>
<h2 id="Prototype-模式"><a href="#Prototype-模式" class="headerlink" title="Prototype 模式"></a>Prototype 模式</h2><h3 id="Motivation-7"><a href="#Motivation-7" class="headerlink" title="Motivation"></a>Motivation</h3><blockquote>
<p>某些<strong>结构复杂</strong>的对象的创建工作</p>
<p><strong>结构复杂</strong>的对象再面临<strong>复杂变化</strong>时，很难拥有<strong>稳定的接口</strong></p>
</blockquote>
<h3 id="Defination-7"><a href="#Defination-7" class="headerlink" title="Defination"></a>Defination</h3><blockquote>
<p>使用<strong>原型实例</strong>指定创建对象的种类，通过<strong>拷贝</strong>这些原型来创建新的对象</p>
<blockquote>
<p>深拷贝</p>
</blockquote>
</blockquote>
<h3 id="Code-and-UML-7"><a href="#Code-and-UML-7" class="headerlink" title="Code and UML"></a>Code and UML</h3><blockquote>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原型对象只可用于clone新对象，不允许直接使用原型对象的接口</span></span><br><span class="line"><span class="comment">//Prototype基类规范了clone和其他稳定接口，新增变化的复杂类型是实现该接口即可</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/Design_Mode/image-20210722093126545.png" alt="image-20210722093126545"></p>
</blockquote>
<h2 id="Builder-模式"><a href="#Builder-模式" class="headerlink" title="Builder 模式"></a>Builder 模式</h2><h3 id="Motivation-8"><a href="#Motivation-8" class="headerlink" title="Motivation"></a>Motivation</h3><blockquote>
<p><strong>复杂对象</strong>由<strong>部分子对象</strong>通过一定<strong>算法</strong>构成</p>
<p>而子对象的复杂变化，使算法的稳定面临考验</p>
</blockquote>
<h3 id="Defination-8"><a href="#Defination-8" class="headerlink" title="Defination"></a>Defination</h3><blockquote>
<p>将复杂对象的<strong>构建</strong>和其<strong>表示</strong>相<strong>分离</strong></p>
<p>使得同样的构建过程(稳定)可以创建不同的表示(变化)</p>
<p><code>注意:</code>不能在构造函数中进行构建调用</p>
<blockquote>
<p>因为对象模型中会先调用父类构造函数，多态调用时子类虚函数还未定义便被父类调用</p>
</blockquote>
</blockquote>
<h3 id="Code-and-UML-8"><a href="#Code-and-UML-8" class="headerlink" title="Code and UML"></a>Code and UML</h3><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//House</span></span><br><span class="line"><span class="comment">//构造房子的步骤(算法)稳定，不能改变</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Builder</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">House</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">	<span class="built_in">House</span>(Builder* b):<span class="built_in">builder</span>(b)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">construct</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	Builder* builder;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Builder</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function">House* <span class="title">GetResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> pHouse;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	House* pHouse; <span class="comment">//方便访问到Hosue的某些属性</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">buildpart1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">buildpart2</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">buildpart3</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StoneBuilder</span> :</span><span class="keyword">public</span> Builder &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">		<span class="built_in">buildpart1</span>();</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">		<span class="built_in">buildpart2</span>();</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">		<span class="built_in">buildpart3</span>();</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;StoneHouse 建造完成&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;   </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">buildpart1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;部分1建造完成&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">buildpart2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;部分2建造完成&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">buildpart3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;部分3建造完成&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StoneHouse</span> :</span> <span class="keyword">public</span> House&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">StoneHouse</span>(Builder* b) :<span class="built_in">House</span>(b) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		builder-&gt;<span class="built_in">init</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	House* p = <span class="keyword">new</span> <span class="built_in">StoneHouse</span>(<span class="keyword">new</span> <span class="built_in">StoneBuilder</span>());</span><br><span class="line">	p-&gt;<span class="built_in">construct</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//进一步划分</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Builder</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">House</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">House</span>(Builder* b):<span class="built_in">builder</span>(b)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">construct</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	Builder* builder;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Builder</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="function">House* <span class="title">GetResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> pHouse;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">buildpart1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">buildpart2</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">buildpart3</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	House* pHouse; <span class="comment">//方便访问到Hosue的某些属性</span></span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StoneBuilder</span> :</span><span class="keyword">public</span> Builder &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">buildpart1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;部分1建造完成&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">buildpart2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;部分2建造完成&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">buildpart3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;部分3建造完成&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HouseDirector</span> &#123;</span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">HouseDirector</span>(Builder* b) :<span class="built_in">builder</span>(b) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">House* <span class="title">construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">		builder-&gt;<span class="built_in">buildpart1</span>();</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">		builder-&gt;<span class="built_in">buildpart2</span>();</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">		builder-&gt;<span class="built_in">buildpart3</span>();</span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;House 建造完成&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> builder-&gt;<span class="built_in">GetResult</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	Builder* builder;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StoneHouse</span> :</span> <span class="keyword">public</span> House&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	HouseDirector* p = <span class="keyword">new</span> <span class="built_in">HouseDirector</span>(<span class="keyword">new</span> <span class="built_in">StoneBuilder</span>());</span><br><span class="line">	House* h = p-&gt;<span class="built_in">construct</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/images/Design_Mode/image-20210722102754917.png" alt="image-20210722102754917"></p>
</blockquote>
<h1 id="“对象性能”-模式"><a href="#“对象性能”-模式" class="headerlink" title="“对象性能” 模式"></a>“对象性能” 模式</h1><h2 id="Singleton-模式"><a href="#Singleton-模式" class="headerlink" title="Singleton 模式"></a>Singleton 模式</h2><h3 id="Motivation-9"><a href="#Motivation-9" class="headerlink" title="Motivation"></a>Motivation</h3><blockquote>
<p>类在系统中只存在一个实例</p>
<p>这是类设计者的责任，而不是使用者的责任</p>
</blockquote>
<h3 id="Defination-9"><a href="#Defination-9" class="headerlink" title="Defination"></a>Defination</h3><blockquote>
<p>保证一个类仅有一个实例</p>
<p>并提供一个该实例的<strong>全局访问点</strong></p>
</blockquote>
<h3 id="Code-and-UML-9"><a href="#Code-and-UML-9" class="headerlink" title="Code and UML"></a>Code and UML</h3><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//限制构造函数和拷贝构造的访问权限 private / protected </span></span><br><span class="line"><span class="comment">//仅提供静态方法接口获取为一个的静态对象</span></span><br><span class="line"><span class="comment">//单线程环境下简单但是多线程环境下需要考虑完全性问题</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="built_in">Singleton</span>()&#123;&#125;</span><br><span class="line"> <span class="built_in">Singleton</span>(<span class="keyword">const</span> Singleton&amp; a)&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="keyword">static</span> Singleton* single;</span><br><span class="line"> <span class="function"><span class="keyword">static</span> Singleton* <span class="title">getSingle</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="comment">//..</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::single = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单线程安全</span></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getSingle</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(single==<span class="literal">nullptr</span>) &#123;</span><br><span class="line">     single = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> single;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断前加锁正确但是高并发代价太高</span></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getSingle</span><span class="params">()</span></span>&#123;</span><br><span class="line"> Lock lock;</span><br><span class="line"> <span class="keyword">if</span>(single==<span class="literal">nullptr</span>) &#123;</span><br><span class="line">     single = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> single;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双检查锁不安全</span></span><br><span class="line"><span class="comment">//因为reorder导致new运算可能未执行构造函数之前先为single赋予一个空的内存地址</span></span><br><span class="line"><span class="comment">//而别的线程在读时大概率可能出现问题</span></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getSingle</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(single==<span class="literal">nullptr</span>) &#123;</span><br><span class="line">     Lock lock;</span><br><span class="line">     <span class="keyword">if</span>(single==<span class="literal">nullptr</span>)&#123; <span class="comment">//注意第二层判断</span></span><br><span class="line">     single = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> single;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//c++11 volatile</span></span><br><span class="line"><span class="comment">//保证new先构造在指针转型</span></span><br><span class="line">std::atomic&lt;Singleton*&gt; Singleton::m_instance;</span><br><span class="line">std::mutex Singleton::m_mutex;</span><br><span class="line"></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getSingle</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> Singleton* tmp = m_instance.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line"> std::<span class="built_in">atomic_thread_fence</span>(std::memory_order_acquire);<span class="comment">//获取内存fence</span></span><br><span class="line"> <span class="keyword">if</span> (tmp == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">     <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">     tmp = m_instance.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">     <span class="keyword">if</span> (tmp == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">         tmp = <span class="keyword">new</span> Singleton;</span><br><span class="line">         std::<span class="built_in">atomic_thread_fence</span>(std::memory_order_release);<span class="comment">//释放内存fence</span></span><br><span class="line">         m_instance.<span class="built_in">store</span>(tmp, std::memory_order_relaxed);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Design_Mode/image-20210723082322431.png" alt="image-20210723082322431"></p>
</blockquote>
<h2 id="Flyweight-享元模式"><a href="#Flyweight-享元模式" class="headerlink" title="Flyweight 享元模式"></a>Flyweight 享元模式</h2><h3 id="Motivation-10"><a href="#Motivation-10" class="headerlink" title="Motivation"></a>Motivation</h3><blockquote>
<p>纯粹的<strong>面向对象方案</strong>会有大量<strong>细粒度对象</strong>充斥系统，造成<strong>内存方面性能消耗</strong></p>
</blockquote>
<h3 id="Defination-10"><a href="#Defination-10" class="headerlink" title="Defination"></a>Defination</h3><blockquote>
<p>运用<strong>共享技术</strong>有效支持大量<strong>细粒度对象</strong></p>
<p>共享对象存放在<strong>享元池</strong>中</p>
</blockquote>
<h3 id="Code-and-UML-10"><a href="#Code-and-UML-10" class="headerlink" title="Code and UML"></a>Code and UML</h3><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Font 字体与字符</span></span><br><span class="line"><span class="comment">//不同字符相同字体的情况下共享同一种字体对象</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Font</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Font</span>(string n) :<span class="built_in">name</span>(n) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FontFactory</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//享元池</span></span><br><span class="line">	map&lt;string, Font*&gt; font_pool;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">Font* <span class="title">getFont</span><span class="params">(<span class="keyword">const</span> string&amp; key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		map&lt;string, Font*&gt;::iterator ite = font_pool.<span class="built_in">find</span>(key);</span><br><span class="line">		<span class="keyword">if</span> (ite != font_pool.<span class="built_in">end</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> ite-&gt;second;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			Font* font = <span class="keyword">new</span> <span class="built_in">Font</span>(key);</span><br><span class="line">			font_pool[key] = font;</span><br><span class="line">			<span class="keyword">return</span> font;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	FontFactory* x = <span class="keyword">new</span> <span class="built_in">FontFactory</span>();</span><br><span class="line">	Font* f1 = x-&gt;<span class="built_in">getFont</span>(<span class="string">&quot;斜体&quot;</span>);</span><br><span class="line">	Font* f2 = x-&gt;<span class="built_in">getFont</span>(<span class="string">&quot;楷体&quot;</span>);</span><br><span class="line">	Font* f3 = x-&gt;<span class="built_in">getFont</span>(<span class="string">&quot;楷体&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> x : x-&gt;font_pool) &#123;</span><br><span class="line">		cout &lt;&lt; x.first &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Design_Mode/image-20210725153037160.png" alt="image-20210725153037160"></p>
</blockquote>
<h1 id="“接口隔离”-模式"><a href="#“接口隔离”-模式" class="headerlink" title="“接口隔离” 模式"></a>“接口隔离” 模式</h1><h2 id="Facade-模式"><a href="#Facade-模式" class="headerlink" title="Facade 模式"></a>Facade 模式</h2><h3 id="Motivation-11"><a href="#Motivation-11" class="headerlink" title="Motivation"></a>Motivation</h3><blockquote>
<p><strong>客户</strong>与<strong>系统组件</strong>有过多的耦合</p>
<p><img src="/images/Design_Mode/image-20210723085413221.png" alt="image-20210723085413221"></p>
</blockquote>
<h3 id="Defination-11"><a href="#Defination-11" class="headerlink" title="Defination"></a>Defination</h3><blockquote>
<p>Facade模式定义一个稳定接口，隔离子系统的内部变化对客户带来的影响</p>
<p>解耦了系统内部与系统外部的紧耦合关系，系统间的(单向)对象关联</p>
<p><code>注意:</code>Facade模式中子系统内部必须是相互耦合关系大的组件，而不是简单地功能组合  –高内聚</p>
</blockquote>
<h3 id="Code-and-UML-11"><a href="#Code-and-UML-11" class="headerlink" title="Code and UML"></a>Code and UML</h3><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Facade更注重层架构的层次去看整个系统，而不是单个类的层次</span></span><br></pre></td></tr></table></figure>

</blockquote>
<h2 id="Proxy-模式"><a href="#Proxy-模式" class="headerlink" title="Proxy 模式"></a>Proxy 模式</h2><h3 id="Motivation-12"><a href="#Motivation-12" class="headerlink" title="Motivation"></a>Motivation</h3><blockquote>
<p>有些对象由于某些原因通过<strong>原生接口</strong>直接访问(<strong>直接依赖</strong>)会带来很多麻烦或者根本不能直接访问</p>
<blockquote>
<ol>
<li>对象创建开销大</li>
<li>某些操作需要安全控制</li>
<li>进程外的访问</li>
<li>性能损失</li>
</ol>
</blockquote>
</blockquote>
<h3 id="Defination-12"><a href="#Defination-12" class="headerlink" title="Defination"></a>Defination</h3><blockquote>
<p>为其他对象<strong>提供一种代理</strong>以控制对这个对象的<strong>透明访问</strong></p>
<blockquote>
<p><strong>间接接口</strong>在保证<strong>透明操作</strong>的前提下进而<strong>控制</strong>额外的复杂<strong>问题</strong></p>
<p>若能够实现间接控制，有时损失一些透明度也是可以的</p>
</blockquote>
</blockquote>
<h3 id="Code-and-UML-12"><a href="#Code-and-UML-12" class="headerlink" title="Code and UML"></a>Code and UML</h3><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原生访问方式</span></span><br><span class="line">Subject* sub = <span class="keyword">new</span> <span class="built_in">RealSubject</span>();</span><br><span class="line"><span class="comment">//间接访问方式</span></span><br><span class="line">Subject* sub = <span class="keyword">new</span> <span class="built_in">Proxy</span>();</span><br></pre></td></tr></table></figure>

<p><img src="/images/Design_Mode/image-20210723095954374.png" alt="image-20210723095954374"></p>
</blockquote>
<h2 id="Adapter-模式"><a href="#Adapter-模式" class="headerlink" title="Adapter 模式"></a>Adapter 模式</h2><h3 id="Motivation-13"><a href="#Motivation-13" class="headerlink" title="Motivation"></a>Motivation</h3><blockquote>
<p>旧的对象，新的环境，要求旧的对象在新的环境中具有新的接口</p>
<p>迁移性的变化需求</p>
</blockquote>
<h3 id="Defination-13"><a href="#Defination-13" class="headerlink" title="Defination"></a>Defination</h3><blockquote>
<p>将一个类<strong>不兼容</strong>的旧接口<strong>转换</strong>成与新环境<strong>兼容</strong>的新接口</p>
<p>要求旧接口是<strong>adaptable</strong>的</p>
<p><strong>GOF 23 下的两种Adapter模式</strong></p>
<ul>
<li>对象适配器</li>
</ul>
<blockquote>
<p>Adapter实现新的接口规范，组合实现了旧接口的对象，复用旧接口来实现新的接口</p>
</blockquote>
<ul>
<li>类适配器 –不提倡</li>
</ul>
<blockquote>
<p>Apdater多继承，public继承新接口规范，protected继承旧接口规范</p>
<p>灵活度不高</p>
</blockquote>
</blockquote>
<h3 id="Code-and-UML-13"><a href="#Code-and-UML-13" class="headerlink" title="Code and UML"></a>Code and UML</h3><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//简单接口兼容处理</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Old</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print_old</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">xrint_old</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj_old</span> :</span><span class="keyword">public</span> Old &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print_old</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;print_old&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">xrint_old</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;xrint_old&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">New</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print_new</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj_new</span> :</span><span class="keyword">public</span> New &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	Old* interface_old;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Obj_new</span>(Old* p) :<span class="built_in">interface_old</span>(p) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print_new</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		interface_old-&gt;<span class="built_in">print_old</span>();</span><br><span class="line">		interface_old-&gt;<span class="built_in">xrint_old</span>();</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;这是新的接口哦&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	New* obj = <span class="keyword">new</span> <span class="built_in">Obj_new</span>(<span class="keyword">new</span> <span class="built_in">Obj_old</span>());</span><br><span class="line">	obj-&gt;<span class="built_in">print_new</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Design_Mode/image-20210723104524788.png" alt="image-20210723104524788"></p>
</blockquote>
<h2 id="Mediator-模式"><a href="#Mediator-模式" class="headerlink" title="Mediator 模式"></a>Mediator 模式</h2><h3 id="Motivation-14"><a href="#Motivation-14" class="headerlink" title="Motivation"></a>Motivation</h3><blockquote>
<p><strong>系统内部</strong>多个对象<strong>关联紧密</strong>，但由于是<strong>直接的引用依赖</strong>，导致一方发生变化，这种<strong>关系</strong>也将不断地发生变化</p>
<p><img src="/images/Design_Mode/image-20210723112631076.png" alt="image-20210723112631076"></p>
</blockquote>
<h3 id="Defination-14"><a href="#Defination-14" class="headerlink" title="Defination"></a>Defination</h3><blockquote>
<p>将<strong>系统内部</strong>的<strong>多个对象</strong>的复杂关系进行解耦，Mediator模式将多个对象间的<strong>控制逻辑</strong>进行<strong>集中管理</strong></p>
<p>多个对象间相互关联 -&gt; 多个对象与Mediator关联</p>
</blockquote>
<h3 id="Code-and-UML-14"><a href="#Code-and-UML-14" class="headerlink" title="Code and UML"></a>Code and UML</h3><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Facade模式解耦系统间(单向)关联关系 单方向的依赖</span></span><br><span class="line"><span class="comment">//Mediator模式解耦系统内部(双向)关联关系 双方向的依赖</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Mediator具体对象的实现，对控制逻辑的处理可能相当复杂</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="“状态变化”模式"><a href="#“状态变化”模式" class="headerlink" title="“状态变化”模式"></a>“状态变化”模式</h1><h2 id="State-模式"><a href="#State-模式" class="headerlink" title="State 模式"></a>State 模式</h2><h3 id="Motivation-15"><a href="#Motivation-15" class="headerlink" title="Motivation"></a>Motivation</h3><blockquote>
<p>状态变化，其行为也会发生变化，如何根据状态变化透明更改对象行为</p>
</blockquote>
<h3 id="Defination-15"><a href="#Defination-15" class="headerlink" title="Defination"></a>Defination</h3><blockquote>
<p>允许一个对象在其内部状态改变时改变它的行为</p>
</blockquote>
<h3 id="Code-and-UML-15"><a href="#Code-and-UML-15" class="headerlink" title="Code and UML"></a>Code and UML</h3><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//State 模式将所有 特定状态 以及有关的 特定行为 封装到state基类的子类对象中 </span></span><br><span class="line"><span class="comment">//使得在切换状态对象时候，在接口稳定的情况下，对象行为也随之改变</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">State</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">//用于返回状态对象</span></span><br><span class="line">	State* state;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//相应状态下的行为</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operator1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operator2</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> State* <span class="title">getState</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">State</span>() &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StateB</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StateA</span>:</span><span class="keyword">public</span> State &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">static</span> StateA* instance;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//单线程环境下单例创建对象</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> StateA* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			instance = <span class="keyword">new</span> <span class="built_in">StateA</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//相应状态下的行为</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operator1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;状态A下的operator1行为&quot;</span> &lt;&lt; endl;</span><br><span class="line">		state = StateB::<span class="built_in">getInstance</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operator2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;状态A下的operator2行为&quot;</span> &lt;&lt; endl;</span><br><span class="line">		state = StateB::<span class="built_in">getInstance</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> State* <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> state;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">StateA</span>() &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StateB</span> :</span><span class="keyword">public</span> State &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">static</span> StateB* instance;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//单线程环境下单例创建对象</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> StateB* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			instance = <span class="keyword">new</span> <span class="built_in">StateB</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//相应状态下的行为</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operator1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;状态B下的operator1行为&quot;</span> &lt;&lt; endl;</span><br><span class="line">		state = StateA::<span class="built_in">getInstance</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operator2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;状态B下的operator2行为&quot;</span> &lt;&lt; endl;</span><br><span class="line">		state = StateA::<span class="built_in">getInstance</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> State* <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> state;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">StateB</span>() &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">StateA* StateA::instance = <span class="literal">nullptr</span>;</span><br><span class="line">StateB* StateB::instance = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	State* p= StateB::<span class="built_in">getInstance</span>();</span><br><span class="line">	p-&gt;<span class="built_in">operator2</span>();</span><br><span class="line">	p = p-&gt;<span class="built_in">getState</span>();</span><br><span class="line">	p-&gt;<span class="built_in">operator2</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Design_Mode/image-20210725080900892.png" alt="image-20210725080900892"></p>
</blockquote>
<h2 id="Memento-模式"><a href="#Memento-模式" class="headerlink" title="Memento 模式"></a>Memento 模式</h2><blockquote>
<p>略</p>
</blockquote>
<h1 id="“数据结构”-模式"><a href="#“数据结构”-模式" class="headerlink" title="“数据结构” 模式"></a>“数据结构” 模式</h1><h2 id="Composite-模式"><a href="#Composite-模式" class="headerlink" title="Composite 模式"></a>Composite 模式</h2><h3 id="Motivation-16"><a href="#Motivation-16" class="headerlink" title="Motivation"></a>Motivation</h3><blockquote>
<p>客户端代码过度依赖于<strong>对象容器内部实现结构</strong>而非抽象接口</p>
</blockquote>
<h3 id="Defination-16"><a href="#Defination-16" class="headerlink" title="Defination"></a>Defination</h3><blockquote>
<p>将对象<strong>组合成树形结构</strong>来表示 “部分-整体” 的层次机构</p>
<p>使得单个对象和组合对象的使用具有一致性(对外提供稳定的一致的接口)</p>
</blockquote>
<h3 id="Code-and-UML-16"><a href="#Code-and-UML-16" class="headerlink" title="Code and UML"></a>Code and UML</h3><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//客户端使用一致性的接口调用对象，无需关系调用对象的结构的复合结构还是单个对象</span></span><br><span class="line"><span class="comment">//达到了客户代码与复杂对象内部和结构的解耦</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compoment</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Compoment* n)</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Compoment* n)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Compoment</span>() &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compoment_tree</span> :</span><span class="keyword">public</span> Compoment &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	string name;</span><br><span class="line">	list&lt;Compoment*&gt; list;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Compoment_tree</span>(string n) :<span class="built_in">name</span>(n) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Compoment* n)</span> </span>&#123;</span><br><span class="line">		list.<span class="built_in">push_back</span>(n);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(Compoment* n)</span> </span>&#123;</span><br><span class="line">		list.<span class="built_in">remove</span>(n);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//处理当前结点</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;当前String : &quot;</span> &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">		<span class="comment">//对子树进行遍历执行process()操作</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : list) &#123;</span><br><span class="line">			x-&gt;<span class="built_in">process</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compoment_node</span> :</span><span class="keyword">public</span> Compoment &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Compoment_node</span>(string n) :<span class="built_in">name</span>(n) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//处理叶子结点</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;当前String : &quot;</span> &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Compoment* n)</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(Compoment* n)</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Compoment* p = <span class="keyword">new</span> <span class="built_in">Compoment_tree</span>(<span class="string">&quot;node1&quot;</span>);</span><br><span class="line">	p-&gt;<span class="built_in">add</span>(<span class="keyword">new</span> <span class="built_in">Compoment_tree</span>(<span class="string">&quot;node2&quot;</span>));</span><br><span class="line">	p-&gt;<span class="built_in">add</span>(<span class="keyword">new</span> <span class="built_in">Compoment_tree</span>(<span class="string">&quot;node3&quot;</span>));</span><br><span class="line">	p-&gt;<span class="built_in">add</span>(<span class="keyword">new</span> <span class="built_in">Compoment_node</span>(<span class="string">&quot;node4&quot;</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//调用process时用户无需了解对象容器内部结构</span></span><br><span class="line">    p-&gt;<span class="built_in">process</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/images/Design_Mode/image-20210725103744204.png" alt="image-20210725103744204"></p>
</blockquote>
<h2 id="Iterator-模式"><a href="#Iterator-模式" class="headerlink" title="Iterator 模式"></a>Iterator 模式</h2><h2 id="Chain-of-Resposibility-模式"><a href="#Chain-of-Resposibility-模式" class="headerlink" title="Chain of Resposibility 模式"></a>Chain of Resposibility 模式</h2><h1 id="“行为变化”-模式"><a href="#“行为变化”-模式" class="headerlink" title="“行为变化” 模式"></a>“行为变化” 模式</h1><h2 id="Command-模式"><a href="#Command-模式" class="headerlink" title="Command 模式"></a>Command 模式</h2><blockquote>
<p>略</p>
</blockquote>
<h2 id="Visitor-模式"><a href="#Visitor-模式" class="headerlink" title="Visitor 模式"></a>Visitor 模式</h2><blockquote>
<p>略</p>
</blockquote>
<h1 id="“领域问题”-模式"><a href="#“领域问题”-模式" class="headerlink" title="“领域问题” 模式"></a>“领域问题” 模式</h1><h2 id="Interpreter-模式"><a href="#Interpreter-模式" class="headerlink" title="Interpreter 模式"></a>Interpreter 模式</h2><blockquote>
<p>略</p>
</blockquote>
<h1 id="重构获得模式"><a href="#重构获得模式" class="headerlink" title="重构获得模式"></a>重构获得模式</h1><blockquote>
<p><strong>变化点</strong>应用设计模式</p>
<p>将<strong>稳定部分</strong>不断抽象到<strong>上层代码</strong></p>
</blockquote>
<h2 id="静态-gt-动态"><a href="#静态-gt-动态" class="headerlink" title="静态 -&gt; 动态"></a>静态 -&gt; 动态</h2><blockquote>
<p>静态绑定 -&gt; 动态绑定</p>
<p>基类指针，虚函数机制，多态调用</p>
</blockquote>
<h2 id="早绑定-gt-晚绑定"><a href="#早绑定-gt-晚绑定" class="headerlink" title="早绑定 -&gt; 晚绑定"></a>早绑定 -&gt; 晚绑定</h2><blockquote>
<p>绑定 : <strong>函数体</strong>和<strong>函数调用</strong>关联起来</p>
<p><strong>晚绑定</strong> </p>
<blockquote>
<p>在Library中通过虚函数机制建立稳定函数体与(未定义，未实现)变化的函数接口调用的绑定</p>
</blockquote>
<p><strong>早绑定</strong></p>
<blockquote>
<p>在Application中建立主函数体和已有(已定义，已实现)函数接口调用的绑定</p>
</blockquote>
<p><img src="/images/Design_Mode/image-20210719100028440.png" alt="image-20210719100028440"></p>
</blockquote>
<h2 id="继承-gt-组合"><a href="#继承-gt-组合" class="headerlink" title="继承 -&gt; 组合"></a>继承 -&gt; 组合</h2><blockquote>
<p><strong>继承</strong></p>
<blockquote>
<p> 继承的是静态性质，拓展功能上灵活度不高</p>
</blockquote>
<p><strong>组合/委托</strong></p>
<blockquote>
<p>黑盒复用，因多态存在，可通过复合基类指针来实现拓展功能的<strong>组合</strong>，灵活度高</p>
</blockquote>
</blockquote>
<h2 id="编译时依赖-gt-运行时依赖"><a href="#编译时依赖-gt-运行时依赖" class="headerlink" title="编译时依赖 -&gt; 运行时依赖"></a>编译时依赖 -&gt; 运行时依赖</h2><blockquote>
<p><strong>编译时依赖</strong></p>
<blockquote>
<p> 编译时若无响应依赖对象的定义，则无法通过编译</p>
</blockquote>
<p><strong>运行时依赖</strong></p>
<blockquote>
<p>通过多态，运行时需要通过基类指针来访问响应子类的重写方法，运行时依赖于子类</p>
</blockquote>
</blockquote>
<h2 id="紧耦合-gt-松耦合"><a href="#紧耦合-gt-松耦合" class="headerlink" title="紧耦合 -&gt; 松耦合"></a>紧耦合 -&gt; 松耦合</h2><h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><h2 id="一个目标"><a href="#一个目标" class="headerlink" title="一个目标"></a>一个目标</h2><blockquote>
<p>管理变化，提高复用</p>
</blockquote>
<h2 id="两种手段"><a href="#两种手段" class="headerlink" title="两种手段"></a>两种手段</h2><blockquote>
<p>分解 vs 抽象</p>
</blockquote>
<h2 id="八大原则"><a href="#八大原则" class="headerlink" title="八大原则"></a>八大原则</h2><h3 id="依赖倒置原则-DIP-1"><a href="#依赖倒置原则-DIP-1" class="headerlink" title="依赖倒置原则 -DIP"></a>依赖倒置原则 -DIP</h3><blockquote>
<p>变化应该依赖于稳定，稳定不应该依赖于变化</p>
<p>高层模块不应该依赖于低层模块，二者都可以依赖于抽象</p>
<p>抽象不应该依赖于实现，实现细节可以依赖于抽象</p>
</blockquote>
<h3 id="开闭原则-OCP-1"><a href="#开闭原则-OCP-1" class="headerlink" title="开闭原则 -OCP"></a>开闭原则 -OCP</h3><blockquote>
<p>对<strong>拓展开放</strong>，对<strong>修改封闭</strong></p>
<p>类模块应该是可拓展的，但是不可修改</p>
<p>类应该以<strong>拓展方式</strong>来应对需求变化，而不是更改类中代码</p>
</blockquote>
<h3 id="单一职责原则-SRP-1"><a href="#单一职责原则-SRP-1" class="headerlink" title="单一职责原则 -SRP"></a>单一职责原则 -SRP</h3><blockquote>
<p>一个类应该<strong>仅有一个</strong>引起它变化的原因</p>
<p>桥模式</p>
</blockquote>
<h3 id="接口隔离原则-ISP-1"><a href="#接口隔离原则-ISP-1" class="headerlink" title="接口隔离原则 -ISP"></a>接口隔离原则 -ISP</h3><blockquote>
<p>不能让用户依赖于他们不使用的方法</p>
<p>就是一个类实现了多个接口，其中用户用不到的方法使用private等限定隔离</p>
</blockquote>
<h3 id="里氏替换原则-LSP-1"><a href="#里氏替换原则-LSP-1" class="headerlink" title="里氏替换原则 -LSP"></a>里氏替换原则 -LSP</h3><blockquote>
<p>子类型必须能替换掉它的父类型 IS-A</p>
<p>能使用父类对象的方法子类也能适用</p>
<p>假设有两个类，一个是Base类，另一个是Child类，并且Child类是Base的子类。那么一个方法如果可以接受一个基类对象b的话:method1(Base b)那么它必然可以接受一个子类的对象method1(Child c)</p>
</blockquote>
<h3 id="组合优先于继承-1"><a href="#组合优先于继承-1" class="headerlink" title="组合优先于继承"></a>组合优先于继承</h3><blockquote>
<p>组合为黑盒复用，继承是白盒复用</p>
<p>继承一定程度上破坏了封装性，子类父类耦合度高</p>
</blockquote>
<h3 id="封装变化点-1"><a href="#封装变化点-1" class="headerlink" title="封装变化点"></a>封装变化点</h3><blockquote>
<p>一侧变化，一侧稳定</p>
</blockquote>
<h3 id="针对接口编程，而不是针对实现编程-1"><a href="#针对接口编程，而不是针对实现编程-1" class="headerlink" title="针对接口编程，而不是针对实现编程"></a>针对接口编程，而不是针对实现编程</h3><blockquote>
<p>不将变量类型声明为某个特定的具体类，而是声明为某个接口</p>
<p>客户程序无需知道对象的具体类型，只需要知道对象所具有的接口</p>
</blockquote>
<h2 id="重构技法"><a href="#重构技法" class="headerlink" title="重构技法"></a>重构技法</h2><p>静态 -&gt; 动态</p>
<p>早绑定 -&gt; 晚绑定</p>
<p>继承 -&gt; 组合</p>
<p>编译时依赖 -&gt; 运行时依赖</p>
<p>紧耦合 -&gt; 松耦合</p>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h2><blockquote>
<p>常见场景下的设计模式应用 - 非定式</p>
<p>游戏场景的转换——状态模式<br>游戏子功能的整合——Facade 门面模式</p>
<blockquote>
<p>Facade 使用门面模式实现游戏主程序</p>
</blockquote>
<p>获取游戏服务的唯一对象——Singleton 单例模式<br>游戏内各系统的整合——Mediator 中介者模式<br>角色与武器的实现——Bridge 桥接模式<br>角色属性的计算——Strategy 策略模式<br>攻击特效与击中反应——Template Method 模板方法模式<br>角色AI——State 状态模式<br>游戏角色的产生——Factory Method 工厂方法模式<br>角色的组装——Builder 建造者模式<br>关卡设计——Chain of Responsibility 责任链模式</p>
</blockquote>
<h1 id="手中有剑，心中有剑"><a href="#手中有剑，心中有剑" class="headerlink" title="手中有剑，心中有剑"></a>手中有剑，心中有剑</h1>]]></content>
      <categories>
        <category>C++Primer</category>
      </categories>
      <tags>
        <tag>C++Primer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer-一刷</title>
    <url>/2021/10/30/Algorithm_Structure/SwordToOffer/</url>
    <content><![CDATA[<h1 id="DataStruct-and-Algorithm"><a href="#DataStruct-and-Algorithm" class="headerlink" title="DataStruct and Algorithm"></a>DataStruct and Algorithm</h1><h1 id="1-赋值运算符函数"><a href="#1-赋值运算符函数" class="headerlink" title="1 赋值运算符函数"></a>1 赋值运算符函数</h1><blockquote>
<p>为类型CMyString的声明添加赋值运算符函数</p>
</blockquote>
<h2 id="Testing-case"><a href="#Testing-case" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>一个CMyString实例赋予另外一个实例</li>
<li>一个CMyString实例赋值给它自己</li>
<li>连续赋值</li>
</ul>
<h2 id="Key"><a href="#Key" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>考虑测试用例，是否传入参数是对象本身</p>
<blockquote>
<p>若传入参数为自身，则释放原有内存后将无法继续赋值，因为参数内存也被释放</p>
</blockquote>
</li>
<li><p>考虑函数返回值是否为引用，并相应的返回引用</p>
<blockquote>
<p>引用作函数返回值使=运算符可连=</p>
</blockquote>
</li>
<li><p>函数参数是否为常引用</p>
<blockquote>
<p>传入参数类型为引用将避免无谓的消耗，常引用则不希望影响原对象</p>
<p>传值时会调用拷贝构造，降低效率</p>
</blockquote>
</li>
<li><p>为已存在指针创建新的内存前是否释放原内存并置空</p>
<blockquote>
<p>若为释放原内存则会造成内存泄漏</p>
<p>若释放后未置空，则导致野指针出现</p>
</blockquote>
</li>
</ul>
<h2 id="Answer"><a href="#Answer" class="headerlink" title="Answer"></a>Answer</h2><h3 id="经典解法"><a href="#经典解法" class="headerlink" title="经典解法"></a>经典解法</h3><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyString</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CMyString</span>(<span class="keyword">char</span>* pData = <span class="literal">nullptr</span>);</span><br><span class="line">	<span class="built_in">CMyString</span>(<span class="keyword">const</span> CMyString&amp; str);</span><br><span class="line">	~<span class="built_in">CMyString</span>(<span class="keyword">void</span>);</span><br><span class="line">	<span class="comment">//12</span></span><br><span class="line">	CMyString&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> CMyString&amp; str) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//3</span></span><br><span class="line">		<span class="keyword">if</span> (&amp;str == <span class="keyword">this</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//4</span></span><br><span class="line">		<span class="keyword">delete</span>[]m_pData;</span><br><span class="line">		m_pData = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//5</span></span><br><span class="line">		<span class="keyword">char</span>* m_pData = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str.m_pData) + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">		<span class="built_in">strcpy</span>(m_pData, str.m_pData);</span><br><span class="line">		<span class="comment">//copy时包括终止符&#x27;\0&#x27;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//6</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">char</span>* m_pData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="考虑异常安全性"><a href="#考虑异常安全性" class="headerlink" title="考虑异常安全性"></a>考虑异常安全性</h3><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//考虑异常安全性 -先new后delete</span></span><br><span class="line">CMyString&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> CMyString&amp; str) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (&amp;str == <span class="keyword">this</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span>* _m_pData = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str.m_pData) + <span class="number">1</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(_m_pData, str.m_pData);</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">delete</span>[]m_pData;</span><br><span class="line">	m_pData = _m_pData;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//考虑异常安全性 -临时对象交换</span></span><br><span class="line">CMyString&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> CMyString&amp; str) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (&amp;str == <span class="keyword">this</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function">CMyString <span class="title">temp</span><span class="params">(str)</span></span>;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">char</span>* p = temp.m_pData;</span><br><span class="line">	temp.m_pData = m_pData;</span><br><span class="line">	m_pData = p;</span><br><span class="line">    </span><br><span class="line">	p = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>临时指针</p>
<blockquote>
<p>完成copy操作，这样即使new时内存不足导致异常也不会影响原m_pData状态，不至于为nullptr</p>
</blockquote>
</li>
<li><p>临时对象</p>
<blockquote>
<p>该临时对象为传入对象的copy</p>
<p>将该对象与原对象的成员<strong>进行交换</strong>，在跳出临时对象作用域时，其内存会被自动释放</p>
<p>若不交换仍会导致内存泄漏，交换的目的就在于使用作用域机制，让系统自动释放内存</p>
</blockquote>
</li>
</ul>
<h1 id="2-1-数组中重复的数字"><a href="#2-1-数组中重复的数字" class="headerlink" title="2.1 数组中重复的数字"></a>2.1 数组中重复的数字</h1><blockquote>
<p>在一个长度为n的数组里的所有数字都在0~n-1的范围内。数组中某些数字是重复的,但不知道有几个数字重复了,也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如,如果输入长度为7的数组(2, 3, 1,0, 2, 5, 3,那么对应的输出是重复的数字2或者3.</p>
</blockquote>
<h2 id="Testing-case-1"><a href="#Testing-case-1" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>长度为n的数组里包含一个或多个重复数字</li>
<li>数组不包含重复的数字</li>
<li>无效输入(空指针;0~n-1范围之外的数字)</li>
</ul>
<h2 id="Key-1"><a href="#Key-1" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>数组可支持O(1)的随机访问，可使用该性质结合哈希表实现时间复杂度为O(n)，空间复杂度为O(n)的算法</p>
<blockquote>
<p>创建一个等大的数组，遍历原数组，从头开始将每一个元素模n，得到对应的索引位置(角标)</p>
<p>若角标处无元素，则存入，若有元素则为重复数字</p>
</blockquote>
</li>
<li><p>基于原数组，结合哈希表实现时间复杂度为O(n)，空间复杂度为O(1)的算法</p>
<blockquote>
<ol>
<li><p>从头遍历原数组，判断索引值与元素值是否相等</p>
</li>
<li><p>相等，则说明该元素位置正确</p>
</li>
<li><p>不相等，则将该元素置于其值对应的索引处，若对应索引处元素值与该元素相等，则重复，否则交换元素，重复1</p>
</li>
</ol>
<p>当遍历完原数组后，则无重复且元素排列有序(元素均位于”正确”的位置)或者找出重复</p>
</blockquote>
</li>
</ul>
<h2 id="Answer-1"><a href="#Answer-1" class="headerlink" title="Answer"></a>Answer</h2><h3 id="哈希表-T-n-O-n-S-n-O-n"><a href="#哈希表-T-n-O-n-S-n-O-n" class="headerlink" title="哈希表 T(n)=O(n) S(n)=O(n)"></a>哈希表 T(n)=O(n) S(n)=O(n)</h3><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">repeat</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (arr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span>* temp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line">		<span class="comment">//初始化哈希表值为-1，表示位置为空</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			temp[i] = <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//遍历原数组</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[i] &gt; n - <span class="number">1</span> || arr[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;存在无效数字&quot;</span> &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (temp[arr[i] % n] == arr[i]) &#123;</span><br><span class="line">				cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				temp[arr[i] % n] = arr[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="归位法-T-n-O-n-S-n-O-1"><a href="#归位法-T-n-O-n-S-n-O-1" class="headerlink" title="归位法 T(n)=O(n) S(n)=O(1)"></a>归位法 T(n)=O(n) S(n)=O(1)</h3><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">repeat</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> re = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="literal">nullptr</span> || n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (arr[i] &gt; n - <span class="number">1</span> || arr[i] &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (i != arr[i]) &#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[i] == arr[arr[i]]) &#123;</span><br><span class="line">				cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">				re = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">int</span> t = arr[i];</span><br><span class="line">				arr[i] = arr[arr[i]];</span><br><span class="line">				arr[arr[i]] = t;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="2-2-数组中的重复数字"><a href="#2-2-数组中的重复数字" class="headerlink" title="2.2 数组中的重复数字"></a>2.2 数组中的重复数字</h1><blockquote>
<p>在一个长度为n+1的数组里的所有数字都在1~n的范围内,所以数组中至少有一个数字是重复的。请找出数组中<strong>任意一个</strong>重复的数字,但<strong>不能修改输入的数组</strong>。例如,如果输入长度为8的数组(2, 3, 5, 4, 3, 2, 6,7,那么对应的输出是重复的数字2或者3</p>
</blockquote>
<h2 id="Testing-case-2"><a href="#Testing-case-2" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>长度为n的数组里包含一个重复数字</li>
<li>长度为n的数组里包含多个重复数字</li>
<li>无效输入(空指针;1~n范围之外的数字)</li>
</ul>
<h2 id="Key-2"><a href="#Key-2" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>哈希法 T(n)=O(n) S(n)=O(n) </p>
<ul>
<li>二分法 T(n)=O(nlogn) S(n)=O(1) </li>
</ul>
<blockquote>
<p>在一个长度为n+1的数组里的所有数字都在1~n的范围内,所以数组中至少有一个数字是重复的。</p>
<ol>
<li>将1<del>n范围内的数字分两部分，1</del>n/2  -  n/2+1~n，若1-2/n中的数字出现个数大于n/2，则认为这个范围内的数字存在重复数字，否则另一部分存在重复</li>
<li>重复数字部分重复步骤1</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li><p>不更改原数组，原数组仅用于遍历判断范围内的数字出现的次数</p>
</li>
<li><p>若出现个数与范围n同，则不能保证没有重复数字，精度有些问题</p>
</li>
<li><p>仅能找出一个重复数字</p>
</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-2"><a href="#Answer-2" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">repeat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="literal">nullptr</span> || n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (arr[i] &gt; n - <span class="number">1</span> || arr[i] &lt; <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//确定有重复数字的范围</span></span><br><span class="line">	<span class="keyword">int</span> low = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> high = n - <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//在该范围内进行二分，缩小重复数字的范围</span></span><br><span class="line">	<span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> mid = (high + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">int</span> nums = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//遍历数组判断指定范围内 (1 - mid) 的数字出现的次数</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (arr[i] &lt;= mid &amp;&amp; arr[i] &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">				nums++;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//得到该数字范围的长度</span></span><br><span class="line">		<span class="keyword">int</span> count = mid - low + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//若数组中数字出现次数大于该数字范围的长度，说明该数字范围内存在重复数字</span></span><br><span class="line">		<span class="keyword">if</span> (nums &gt; count) &#123;</span><br><span class="line">			high = mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			low = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; arr[high];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</blockquote>
<h1 id="4-二维数组中的查找"><a href="#4-二维数组中的查找" class="headerlink" title="4 二维数组中的查找"></a>4 二维数组中的查找</h1><blockquote>
<p>在一个二维数组中,每一行都按照从左到右递增的顺序排序,每一列都按照从上到下递增的顺序排序。请完成一个函数,输入这样的一个二维数组和一个整数,判断数组中是否含有该整数。</p>
</blockquote>
<h2 id="Testing-case-3"><a href="#Testing-case-3" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>二维数组中存在/不存在该整数</li>
</ul>
<h2 id="Key-3"><a href="#Key-3" class="headerlink" title="Key"></a>Key</h2><ul>
<li>选取右上角或者左下角开始作比较，每比较一次可缩减一次查找范围，直到找到或者不存在该整数</li>
</ul>
<h2 id="Answer-3"><a href="#Answer-3" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">int</span> rows,<span class="keyword">int</span> cols, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//锁定右上角位置</span></span><br><span class="line">	<span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> col = cols - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//直到越界结束查找</span></span><br><span class="line">	<span class="keyword">while</span> (row &lt; rows &amp;&amp; col &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n &gt; arr[row*cols + col]) &#123;</span><br><span class="line">			<span class="comment">//剔除一行</span></span><br><span class="line">			row++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (n == arr[row*cols + col]) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//剔除一列</span></span><br><span class="line">			col--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="5-1-替换空格"><a href="#5-1-替换空格" class="headerlink" title="5.1 替换空格"></a>5.1 替换空格</h1><blockquote>
<p>请实现一个函数,把字符串中的每个空格替换成”%20”。例如,输入”We are happy.”,则输出 “We%20are%20happy.”</p>
</blockquote>
<h2 id="Testing-case-4"><a href="#Testing-case-4" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>字符串中含有空格(空格位于字符串前面，后面，中间)，含有连续空格</li>
<li>字符串无空格</li>
<li>输入无效字符(空字符串，空指针)</li>
</ul>
<h2 id="Key-4"><a href="#Key-4" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>注意字符串变长导致的内存覆盖</p>
</li>
<li><p>从前往后替换空格 T(n)=O(n2)</p>
<blockquote>
<p>前向遍历字符数组，只要含有空格就将空格之后的字符后移两位并替换空格</p>
<p>缺点是每含一个空格就需要进行一次整体移位，含多次重复操作</p>
</blockquote>
</li>
<li><p>从后往前替换空格 T(n)=O(n)</p>
<blockquote>
<p>反向遍历字符数组，设置两个指针，一个指向原字符串末尾，一个指向将所有空格替换后(增长后)的末尾</p>
<ol>
<li>对于接受到的数组，遍历数组的同时记录空格数(<strong>每替换一个空格字符串长度加2</strong>)，进而定位两个指针的位置</li>
<li>循环开始，若p指向的元素不是空格，则将该元素转到q指向的位置，并前移1位</li>
<li>若p指向的元素是空格，则将q指向的位置使用%20替代空格，并p前移1位，q前移三位</li>
<li>直至p==q，循环终止，空格均替代完毕</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-4"><a href="#Answer-4" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replace</span><span class="params">(<span class="keyword">char</span>* arr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="literal">nullptr</span> || <span class="built_in">strlen</span>(arr) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">char</span>* p = arr;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//定位p指针位置并计数空格数，进而定位q指针位置</span></span><br><span class="line">	<span class="keyword">int</span> nums = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (; *p != <span class="string">&#x27;\0&#x27;</span>; p++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (*p == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">			nums++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span>* q = p + nums * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (p != q) &#123;</span><br><span class="line">		<span class="keyword">if</span> (*p != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">			*q = *p;</span><br><span class="line">			p--;</span><br><span class="line">			q--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			</span><br><span class="line">			p--;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">				<span class="keyword">if</span> (i == <span class="number">0</span>) &#123;		</span><br><span class="line">					*q = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">					q--;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">					*q = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">					q--;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					*q = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">					q--;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="5-2-合并两个有序数组"><a href="#5-2-合并两个有序数组" class="headerlink" title="5.2 合并两个有序数组"></a>5.2 合并两个有序数组</h1><blockquote>
<p>有两个排序的数组A1和A2,内存在<strong>A1的末尾有足够多的空余空间容纳A2</strong>,请实现一个函数,把A2中的所有数字插入A1中,并且所有的数字是排序的。</p>
</blockquote>
<h2 id="Testing-case-5"><a href="#Testing-case-5" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>长度相等/不等的升序数组合并</li>
<li>无效数组输入</li>
</ul>
<h2 id="Key-5"><a href="#Key-5" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>从后往前合并有序数组 T(n)=O(n + m)</p>
<blockquote>
<p>反向遍历两个数组，并于A1数组设置三个指针，一个p1指向A1元素末尾，一个p2指向A2元素末尾，一个q指向A1数组合并后预留位置后的末尾</p>
<ol>
<li>通过比较p1与p2指向的元素大小决定q指向的元素内容，合并元素后移动相应指针</li>
<li>直至有一个数组元素全部合并完毕后，将另一个数组未合并完成的数组元素按序填充至A1剩余空位处</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-5"><a href="#Answer-5" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&gt;<span class="function"><span class="keyword">void</span> <span class="title">combine</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; v1,<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp;v2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (v1.<span class="built_in">size</span>() == <span class="number">0</span> &amp;&amp; v2.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//vector扩容后为重新申请了一块两倍大小内存，注意获取迭代器的时机</span></span><br><span class="line">		v1.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>() + v2.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">	<span class="comment">//定位迭代器指向</span></span><br><span class="line">	<span class="keyword">auto</span> p1 = v1.<span class="built_in">end</span>() - <span class="number">1</span> - v2.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">auto</span> p2 = v2.<span class="built_in">end</span>() - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">auto</span> q = p1 + v2.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//合并数组</span></span><br><span class="line">	<span class="keyword">while</span> (q != v1.<span class="built_in">begin</span>() &amp;&amp; p1 &gt;= v1.<span class="built_in">begin</span>() &amp;&amp; p2 &gt;= v2.<span class="built_in">begin</span>()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (*p1 &gt;= *p2) &#123;			</span><br><span class="line">			*q = *p1;</span><br><span class="line">			q--;</span><br><span class="line">			<span class="keyword">if</span> (p1 == v1.<span class="built_in">begin</span>()) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			p1--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;	</span><br><span class="line">			*q = *p2;</span><br><span class="line">			q--;</span><br><span class="line">			<span class="keyword">if</span> (p2 == v2.<span class="built_in">begin</span>()) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			p2--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将剩余未合并元素有序合并</span></span><br><span class="line">	<span class="keyword">if</span> (p1 == v1.<span class="built_in">begin</span>() &amp;&amp; p2 != v2.<span class="built_in">begin</span>()) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">auto</span> re = v2.<span class="built_in">begin</span>();</span><br><span class="line">		<span class="keyword">while</span> (re &lt;= p2) &#123;</span><br><span class="line">			*p1 = *re;</span><br><span class="line">			re++;</span><br><span class="line">			p1++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</blockquote>
<h1 id="6-从尾到头打印链表"><a href="#6-从尾到头打印链表" class="headerlink" title="6 从尾到头打印链表"></a>6 从尾到头打印链表</h1><blockquote>
<p>输入一个链表的头节点,<strong>从尾到头</strong>反过来打印出每个节点的值。链表节点定义如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> m_nKey;</span><br><span class="line">    ListNode* m_pNext;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Testing-case-6"><a href="#Testing-case-6" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>输入的链表有多个结点</li>
<li>输入的链表只有一个结点</li>
<li>链表的头结点指针为nullptr</li>
</ul>
<h2 id="Key-6"><a href="#Key-6" class="headerlink" title="Key"></a>Key</h2><ul>
<li>正向遍历，压栈输出</li>
<li>正向遍历，递归输出</li>
</ul>
<h2 id="Answer-6"><a href="#Answer-6" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//压栈输出</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reprint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ListNode* q = head-&gt;m_pNext;</span><br><span class="line">	stack&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">	<span class="keyword">while</span> (q != <span class="literal">nullptr</span>) &#123;	</span><br><span class="line">		st.<span class="built_in">push</span>(q-&gt;m_nKey);</span><br><span class="line">		q = q-&gt;m_pNext;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		cout &lt;&lt; st.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		st.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rreprint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (head-&gt;m_pNext != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="built_in">reprint</span>(head-&gt;m_pNext);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; head-&gt;m_nKey &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="7-重建二叉树"><a href="#7-重建二叉树" class="headerlink" title="7 重建二叉树"></a>7 重建二叉树</h1><blockquote>
<p>输入某二又树的前序遍历和中序遍历的结果,请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
</blockquote>
<h2 id="Testing-case-7"><a href="#Testing-case-7" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>完全二叉树，非完全二叉树</li>
<li>特殊二叉树(无左子树，无右子树)</li>
<li>头结点为nullptr，两个遍历序列不匹配</li>
</ul>
<h2 id="Key-7"><a href="#Key-7" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>两者结合，相辅相成</p>
<blockquote>
<ol>
<li><p>前序遍历序列先出现的为根节点，可先于前序遍历序列中找到根节点</p>
</li>
<li><p>再于中序遍历序列中确定该根节点的左右子树，中序遍历序列中其左边结点属于左子树</p>
</li>
<li><p>递归再使用同样的方法在左子树中去前序遍历序列中找寻根节点，确定根节点后再回到中序遍历序列确定左右子树范围</p>
</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-7"><a href="#Answer-7" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BinaryTreeNode* <span class="title">constructBTreeCore</span><span class="params">(<span class="keyword">int</span>* stp, <span class="keyword">int</span>*sep, <span class="keyword">int</span>*itp, <span class="keyword">int</span>*iep)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//于先序遍历序列中找到根节点</span></span><br><span class="line">	<span class="keyword">int</span> rootValue = stp[<span class="number">0</span>];</span><br><span class="line">	<span class="comment">//创建根节点</span></span><br><span class="line">	BinaryTreeNode* root = <span class="keyword">new</span> <span class="built_in">BinaryTreeNode</span>();</span><br><span class="line">	root-&gt;m_nValue = rootValue;</span><br><span class="line">	root-&gt;m_pLeft = root-&gt;m_pRight = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置递归终止条件并判断异常</span></span><br><span class="line">	<span class="keyword">if</span> (stp == sep) &#123;</span><br><span class="line">		<span class="keyword">if</span> (itp == iep &amp;&amp; *stp == *itp) &#123;</span><br><span class="line">			<span class="keyword">return</span> root;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建左右子树</span></span><br><span class="line">	<span class="keyword">int</span> *Iroot = itp;</span><br><span class="line">	<span class="keyword">while</span> (Iroot != iep &amp;&amp; *Iroot != rootValue) &#123;</span><br><span class="line">		Iroot++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//异常处理</span></span><br><span class="line">	<span class="keyword">if</span> (Iroot == iep &amp;&amp; *Iroot != rootValue) &#123;</span><br><span class="line">		<span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//确定左右子树范围</span></span><br><span class="line">	<span class="keyword">int</span> leftlen = Iroot - itp;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//构建左子树</span></span><br><span class="line">	<span class="keyword">if</span> (leftlen &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		root-&gt;m_pLeft = <span class="built_in">constructBTreeCore</span>(stp + <span class="number">1</span>, stp + leftlen, itp, Iroot - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//构建右子树 - 若仅有左子树则无需构建</span></span><br><span class="line">	<span class="keyword">if</span> (leftlen &lt; iep - itp) &#123;</span><br><span class="line">		root-&gt;m_pRight = <span class="built_in">constructBTreeCore</span>(stp + leftlen + <span class="number">1</span>, sep, Iroot + <span class="number">1</span>, iep);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="8-二叉树的下一个结点"><a href="#8-二叉树的下一个结点" class="headerlink" title="8 二叉树的下一个结点"></a>8 二叉树的下一个结点</h1><blockquote>
<p>给定一棵二叉树和其中的一个节点,如何找出中序遍历序列的下一个节点?</p>
<p>树中的节点除了有两个分别指向左、右子节点的指针,还有一个指向父节点的指针</p>
</blockquote>
<h2 id="Testing-case-8"><a href="#Testing-case-8" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>普通二叉树(完全二叉树，不完全二叉树)</li>
<li>特殊二叉树(所有结点都没有右节点，所有结点都没有左子节点，只有一个结点，根节点为nullptr)</li>
<li>不同位置结点的下一个结点(下一个结点为当前结点的右子结点，右子结点的最左子节点，父结点，跨层的父结点等，或当前结点没有下一个结点)</li>
</ul>
<h2 id="Key-8"><a href="#Key-8" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>区分求结点下一结点的两种情况</p>
<blockquote>
<ol>
<li>该结点存在右子树，则该节点的下一个结点为右子树的最左结点</li>
<li>该节点不存在右子树，但是该节点存在父结点，则向上遍历，直至找到其及其上层子结点是其上层父结点的左子树，则该父结点为其下一个结点</li>
<li>该节点不存在右子树，且不存在父结点，则无下一个结点</li>
<li>该节点不存在右子树，存在父结点，但是不存在2的情况，则无下一个结点</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-8"><a href="#Answer-8" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BinaryTreeNode* <span class="title">GetNext</span><span class="params">(BinaryTreeNode* pNode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (pNode == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	BinaryTreeNode* pNext = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pNode-&gt;m_pRight != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		</span><br><span class="line">		BinaryTreeNode* pCurrent = pNode-&gt;m_pRight;</span><br><span class="line">		<span class="keyword">while</span> (pCurrent-&gt;m_pLeft != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			pCurrent = pCurrent-&gt;m_pLeft;</span><br><span class="line">		&#125;</span><br><span class="line">		pNext = pCurrent;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pNode-&gt;m_pParent != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		</span><br><span class="line">		BinaryTreeNode* pCurrent = pNode;</span><br><span class="line">		BinaryTreeNode* pParent = pNode-&gt;m_pParent;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (pParent-&gt;m_pParent != <span class="literal">nullptr</span> &amp;&amp; pCurrent == pParent-&gt;m_pRight) &#123;</span><br><span class="line">			pCurrent = pParent;</span><br><span class="line">			pParent = pParent-&gt;m_pParent;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (pCurrent == pParent-&gt;m_pLeft) &#123;</span><br><span class="line">			pNext = pParent;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pNext;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="9-用两个栈实现队列"><a href="#9-用两个栈实现队列" class="headerlink" title="9 用两个栈实现队列"></a>9 用两个栈实现队列</h1><blockquote>
<p>用两个栈实现一个队列,队列的声明如下,请实现它的两个函数appendTail和deleteHead,分别完成在队列尾部插入节点和在队列头部删除节点的功能。</p>
</blockquote>
<h2 id="Testing-case-9"><a href="#Testing-case-9" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>往空的队列中添加，删除元素</li>
<li>往非空的队列中添加，删除元素</li>
<li>连续删除元素直至队列为空</li>
</ul>
<h2 id="Key-9"><a href="#Key-9" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>熟悉栈与队列的特性</p>
<blockquote>
<p>队列先进先出，栈后进先出</p>
</blockquote>
</li>
<li><p>appendTail队尾插入</p>
<blockquote>
<p>插入的元素均置于stack1中</p>
</blockquote>
</li>
<li><p>deleteHead队头删除</p>
<blockquote>
<p>删除结点时，为保证删除结点的顺序，因此需要</p>
<ol>
<li>判断stack2是否为空，若不为空，则直接于stack2中弹出</li>
<li>若为空，则先将stack1中的元素全部弹出并插入到stack2中，再于stack2中弹出</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-9"><a href="#Answer-9" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> CQueue&lt;T&gt;::<span class="built_in">appendTail</span>(<span class="keyword">const</span> T&amp;node) &#123;</span><br><span class="line">	stack1.<span class="built_in">push</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T CQueue&lt;T&gt;::<span class="built_in">deleteHead</span>() &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (stack2.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (stack1.<span class="built_in">size</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">			stack2.<span class="built_in">push</span>(stack1.<span class="built_in">top</span>());</span><br><span class="line">			stack1.<span class="built_in">pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (stack2.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">exception</span>(<span class="string">&quot;stack2 is empty!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	T head = stack2.<span class="built_in">top</span>();</span><br><span class="line">	stack2.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="10-用两个队列实现栈"><a href="#10-用两个队列实现栈" class="headerlink" title="10 用两个队列实现栈"></a>10 用两个队列实现栈</h1><blockquote>
<p>用两个队列实现一个栈,栈的声明如下,请实现它的两个函数appendTail和deleteHead的功能。</p>
</blockquote>
<h2 id="Testing-case-10"><a href="#Testing-case-10" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>往空的栈中添加，删除元素</li>
<li>往非空的栈中添加，删除元素</li>
<li>连续删除元素直至栈为空</li>
</ul>
<h2 id="Key-10"><a href="#Key-10" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>熟悉栈与队列的特性</p>
<blockquote>
<p>队列先进先出，栈后进先出</p>
</blockquote>
</li>
<li><p>appendTail 栈顶插入</p>
<blockquote>
<ol>
<li>若插入元素时两个队列均为空，则随意，指定为queue1</li>
<li>若插入元素时含不为空的队列，则插入到不为空的队列中去</li>
</ol>
</blockquote>
</li>
<li><p>deleteHead 栈顶弹出</p>
<blockquote>
<p>删除结点时，为保证删除结点的顺序，因此需要</p>
<ol>
<li>先将不为空的队列的元素除最后插入的元素以外全部弹出并压入到空的队里中去</li>
<li>将该队列最后插入元素于队列中弹出</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-10"><a href="#Answer-10" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> CStack&lt;T&gt;::<span class="built_in">appendTail</span>(<span class="keyword">const</span> T&amp;node) &#123;</span><br><span class="line">	<span class="keyword">if</span> (queue1.<span class="built_in">size</span>() == <span class="number">0</span> &amp;&amp; queue2.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">		queue1.<span class="built_in">push</span>(node);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (queue1.<span class="built_in">size</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">		queue1.<span class="built_in">push</span>(node);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		queue2.<span class="built_in">push</span>(node);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T CStack&lt;T&gt;::<span class="built_in">deleteHead</span>() &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (queue2.<span class="built_in">size</span>() == <span class="number">0</span> &amp;&amp; queue1.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">exception</span>(<span class="string">&quot;queue is empty!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (queue2.<span class="built_in">size</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">while</span> (queue2.<span class="built_in">size</span>() != <span class="number">1</span>) &#123;</span><br><span class="line">			</span><br><span class="line">			queue1.<span class="built_in">push</span>(queue2.<span class="built_in">front</span>());</span><br><span class="line">			queue2.<span class="built_in">pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		T head = queue2.<span class="built_in">front</span>();</span><br><span class="line">		queue2.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">while</span> (queue1.<span class="built_in">size</span>() != <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">			queue2.<span class="built_in">push</span>(queue1.<span class="built_in">front</span>());</span><br><span class="line">			queue1.<span class="built_in">pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		T head = queue1.<span class="built_in">front</span>();</span><br><span class="line">		queue1.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</blockquote>
<h1 id="11-斐波那契数列"><a href="#11-斐波那契数列" class="headerlink" title="11 斐波那契数列"></a>11 斐波那契数列</h1><blockquote>
<p>求斐波那契数列的第n项。写一个函数,输入n,求斐波那契(Fibonacci)数列的第n项。</p>
</blockquote>
<h2 id="Testing-case-11"><a href="#Testing-case-11" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(3,5,10)</li>
<li>边界测试(0,1,2)</li>
<li>性能测试(40,50,100)</li>
</ul>
<h2 id="Key-11"><a href="#Key-11" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>T(n) = O(2^n) S(n) = O(n)</p>
<blockquote>
<p>自上而下回溯递归，按条件形式递归</p>
<p>缺陷:</p>
<ol>
<li>每次递归需要存放函数返回地址，临时变量等，占用栈空间</li>
<li>每次递归调用时栈的弹出，压入需要耗费时间</li>
<li>每个进程的栈空间有限，可能存在栈溢出问题</li>
</ol>
</blockquote>
</li>
<li><p>T(n) = O(n) S(n) = O(1)</p>
<blockquote>
<p>自下而上循环累加代替自上而下的回溯递归</p>
</blockquote>
</li>
</ul>
<h2 id="Answer-T-n-O-n"><a href="#Answer-T-n-O-n" class="headerlink" title="Answer - T(n) = O(n)"></a>Answer - T(n) = O(n)</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">Fibonaci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">long</span> one = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">long</span> two = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">long</span> FN = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			FN = one + two;</span><br><span class="line">			one = two;</span><br><span class="line">			two = FN;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> FN;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="11-1-青蛙跳台阶"><a href="#11-1-青蛙跳台阶" class="headerlink" title="11.1 青蛙跳台阶"></a>11.1 青蛙跳台阶</h1><blockquote>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p>
</blockquote>
<h2 id="Testing-case-12"><a href="#Testing-case-12" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(3,5,10)</li>
<li>边界测试(0,1,2)</li>
<li>性能测试(40,50,100)</li>
</ul>
<h2 id="Key-12"><a href="#Key-12" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>数学建模能力</p>
<blockquote>
<p>青蛙跳上一级台阶有一种跳法，青蛙跳上二级台阶有两种跳法，当N&gt;2时，的跳法总数可经过分析得为f(n) = f(n-1)+f(n-2)</p>
<p>分析:</p>
<p>青蛙第一跳可以选择跳一级台阶也可以选择跳两级台阶，总跳法取决于含第一跳的剩余台阶的跳法</p>
<ul>
<li><p>若选择跳一级台阶，则剩下n-1个台阶共含有f(n-1)种跳法</p>
</li>
<li><p>若选择跳二级台阶，则剩下n-2个台阶共含有f(n-2)种跳法</p>
</li>
</ul>
<p>因此f(n) = f(n-1) + f(n-2)</p>
</blockquote>
</li>
</ul>
<h2 id="Answer-11"><a href="#Answer-11" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">Fibonaci_F</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">long</span> one = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">long</span> two = <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">long</span> FN = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">			FN = one + two;</span><br><span class="line">			one = two;</span><br><span class="line">			two = FN;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> FN;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="11-2-青蛙变态跳台阶"><a href="#11-2-青蛙变态跳台阶" class="headerlink" title="11.2 青蛙变态跳台阶"></a>11.2 青蛙变态跳台阶</h1><blockquote>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶，也可以一次跳上n级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p>
</blockquote>
<h2 id="Testing-case-13"><a href="#Testing-case-13" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(3,5,10)</li>
<li>边界测试(0,1,2)</li>
<li>性能测试(40,50,100)</li>
</ul>
<h2 id="Key-13"><a href="#Key-13" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>数学建模能力</p>
<blockquote>
<ol>
<li><p>青蛙跳上最后一级台阶的跳法有，从n-1层台阶跳一级，或者从n-2级台阶跳二级…从1级台阶跳n级，所以f(n) = f(n-1) + f(n-2)+ … + f(1)</p>
</li>
<li><p>青蛙跳上n-1级台阶的跳法有 f(n-1) = f(n-2) + … + f(1)</p>
</li>
<li><p>所以f(n) = 2f(n-1) = 4f(n-2) = 2^(n-1) * f(1) =  2^(n-1)</p>
</li>
</ol>
</blockquote>
</li>
</ul>
<h1 id="—-快速排序算法-—"><a href="#—-快速排序算法-—" class="headerlink" title="—- 快速排序算法 —-"></a>—- 快速排序算法 —-</h1><h2 id="Testing-case-14"><a href="#Testing-case-14" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试</li>
<li>边界测试(nullptr)</li>
<li>性能测试</li>
</ul>
<h2 id="Key-14"><a href="#Key-14" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>随机基数分治法</p>
<blockquote>
<p>随机选择数组中的一个元素作为基数pivot，将比基数小的元素移动到基数左边，比基数大的元素移动到基数右边，递归对基数左右的元素再进行基数分治，直至范围长度为1</p>
</blockquote>
</li>
<li><p>随机基数分治法 - 双指针交替</p>
<blockquote>
<p>使用left,right指针与index指针三个指针实现</p>
<p>left: 时刻应指向比基数小的元素</p>
<p>right:时刻应指向不比基数小的元素</p>
<p>index:指向基数应存放的位置，在该位置未被赋予key值前，该位置均认为为空，原元素可被覆盖，暂存left或者right不应指向的元素</p>
<ol>
<li>从左开始，left指针指向的元素与基数比较，若比基数小，left指针后移，否则，将该元素赋值到index处，并将index设置到left当前指向</li>
<li>从right开始交替判断，若right指向的元素不比基数小，right指针前移，否则，将该元素赋值到index处，并将index设置到right当前指向</li>
<li>1,2往复交替，直至left==right，该位置为key值应存位置</li>
</ol>
</blockquote>
</li>
<li><p>随机基数分治法 - 单指针交换</p>
<blockquote>
<p>使用small指针单指针实现</p>
<p>small:small时刻指向当前最后一个比基数小的元素</p>
<ol>
<li>随机获取关键字索引，并于数组末暂存key，对key前元素进行排序</li>
<li>遍历数组，若元素比基数小，small++，使small指向比基数小的元素，否则，small不自增，继续向下遍历数组</li>
<li>直至再次遇到比基数小的元素，small自增，将该元素与small当前指向元素进行交换</li>
<li>重复3，直至遍历完数组，数组当前状态为small指向最后一个比基数小的元素，基数存放于数组末</li>
<li>将基数归位，与(++small)位置处的比基数大的元素进行交换</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-12"><a href="#Answer-12" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<p>1</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普遍方法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Position</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> len, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span> || start &lt; <span class="number">0</span> || end &gt;= len) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">exception</span>(<span class="string">&quot;数组异常&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//随机获取关键字索引</span></span><br><span class="line"> <span class="comment">//index必须使用范围内随机数或者首尾，不能使用常数，因为每次递归常量index可能会导致越界</span></span><br><span class="line">	<span class="keyword">int</span> index = start;</span><br><span class="line">	<span class="keyword">int</span> key = arr[index];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">		<span class="keyword">while</span> (start &lt; end &amp;&amp;arr[start] &lt; key) &#123;</span><br><span class="line">			start++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//移动元素时必须每次判断是否满足循环条件，否则将导致越界访问</span></span><br><span class="line">		<span class="keyword">if</span> (arr[start] &gt;= key) &#123;</span><br><span class="line">			arr[index] = arr[start];</span><br><span class="line">			index = start;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//移动元素时必须每次判断是否满足循环条件，否则将导致越界访问</span></span><br><span class="line">		<span class="keyword">while</span> (start &lt; end &amp;&amp;arr[end] &gt;= key) &#123;</span><br><span class="line">			end--;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (arr[end] &lt; arr[index]) &#123;</span><br><span class="line">			arr[index] = arr[end];</span><br><span class="line">			index = end;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	arr[index] = key;</span><br><span class="line">	<span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> len, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取关键字位置</span></span><br><span class="line">	<span class="keyword">int</span> index = <span class="built_in">Position</span>(arr, len, start, end);</span><br><span class="line">	<span class="comment">//递归快排index左边的数据</span></span><br><span class="line">	<span class="keyword">if</span> (index &gt; start)</span><br><span class="line">		<span class="built_in">QuickSort</span>(arr, len, start, index - <span class="number">1</span>);</span><br><span class="line">	<span class="comment">//递归快排index右边的数据</span></span><br><span class="line">	<span class="keyword">if</span> (index &lt; end)</span><br><span class="line">		<span class="built_in">QuickSort</span>(arr, len, index + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> length, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (data == <span class="literal">NULL</span> || length &lt;= <span class="number">0</span> || start &lt; <span class="number">0</span> || end &gt;= length)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;error1!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> index = <span class="built_in">RandomInRange</span>(start, end);</span><br><span class="line">	<span class="comment">//在数组末尾暂存基数，对基数前面的数据进行移动</span></span><br><span class="line">	<span class="built_in">swap_element</span>(&amp;data[index], &amp;data[end]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置small指针，时刻指向当前最后一个比基数小的元素</span></span><br><span class="line">	<span class="keyword">int</span> small = start - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历数组，移动small指针，最终使small指向当前最后一个比基数小的元素</span></span><br><span class="line">	<span class="keyword">for</span> (index = start; index &lt; end; index++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (data[index] &lt; data[end]) &#123;</span><br><span class="line">			small++;</span><br><span class="line">			<span class="keyword">if</span> (small != index) &#123;</span><br><span class="line">				<span class="built_in">swap_element</span>(&amp;data[index], &amp;data[small]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//移动small指针，使其指向基数应在的位置，但是当前存放着比基数大的元素</span></span><br><span class="line">	small++;</span><br><span class="line">	<span class="comment">//将末尾暂存的基数归位</span></span><br><span class="line">	<span class="built_in">swap_element</span>(&amp;data[end], &amp;data[small]);</span><br><span class="line">	<span class="keyword">return</span> small;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Quicksort</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> length, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (start == end)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> index = <span class="built_in">Partition</span>(data, length, start, end);</span><br><span class="line">	<span class="keyword">if</span> (index &gt; start)</span><br><span class="line">		<span class="built_in">Quicksort</span>(data, length, start, index - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (index &lt; end)</span><br><span class="line">		<span class="built_in">Quicksort</span>(data, length, index + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RandomInRange</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (end &gt; start)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));<span class="comment">//srand函数是随机数发生器的初始化函数,使得随机数种子随时间的变化而变化</span></span><br><span class="line">		<span class="keyword">return</span> start + <span class="built_in">rand</span>() % ((end - start));<span class="comment">//产生start~end之间的随机数</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_element</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp;</span><br><span class="line">	temp = *a;</span><br><span class="line">	*a = *b;</span><br><span class="line">	*b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</blockquote>
<h1 id="12-旋转数组最小数字"><a href="#12-旋转数组最小数字" class="headerlink" title="12 旋转数组最小数字"></a>12 旋转数组最小数字</h1><blockquote>
<p>把一个数组最开始的若干个元素搬到数组的末尾,我们称之为数组的旋转。</p>
<p>输入一个递增有序数组的一个旋转,输出旋转数组的最小元素。例如,数组(3,4,5,1,2}为{1,2,3,4,5}的一个旋转,该数组的最小值为1</p>
</blockquote>
<h2 id="Testing-case-15"><a href="#Testing-case-15" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(输入的数组是升序数组的一个旋转，有重复数字或无重复数字)</li>
<li>边界测试(仅含有一个元素的数组)</li>
<li>性能测试(nullptr)</li>
</ul>
<h2 id="Key-15"><a href="#Key-15" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>二分思维(缩小查找范围)</p>
<blockquote>
<p> 将整个旋转数组看做两个递增序列，且第一个递增序列的值始终大于等于第二个递增序列的值，且最小的元素位于两个递增序列的边界</p>
<ol>
<li>设置两个指针分别指向整个序列的首尾，选取两指针范围内的元素与两端进行比较，判断该元素位于哪一个递增序列中</li>
<li>若该元素位于左边递增序列中，则移动left指针至该元素处，否则，移动right指针至该元素处</li>
<li>直至left与right相差1，此时right指向最小的元素</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li><p>2中若左右两端元素相等且中间元素值也与端值相等，则无法判断该元素位于哪一个序列，需要顺序查找</p>
<p>10111 - 11101 无法判断1位于哪一个递增序列中</p>
</li>
<li><p>若旋转数组旋转尺度为0，则不存在两个序列，直接返回首元素即可</p>
</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-13"><a href="#Answer-13" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常处理</span></span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="literal">nullptr</span> || length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">exception</span>(<span class="string">&quot;数组异常！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//指针初始化</span></span><br><span class="line">	<span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> right = length - <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//考虑到旋转数组旋转尺度为0时，即整个数组递增有序时的情况，返回首元素</span></span><br><span class="line">	<span class="keyword">int</span> mid = left;</span><br><span class="line">	<span class="comment">/*int mid = left;*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (arr[left] &gt;= arr[right]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (right - left == <span class="number">1</span>) &#123;</span><br><span class="line">			mid = right;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//取范围内的一个数</span></span><br><span class="line">		mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (arr[left] == arr[right] &amp;&amp; arr[mid] == arr[left]) &#123;</span><br><span class="line">			<span class="comment">//指定范围内顺序查找</span></span><br><span class="line">			_getMin(arr, left, right);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (arr[mid] &gt;= arr[left]) &#123;</span><br><span class="line">			left = mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt;= arr[right]) &#123;</span><br><span class="line">			right = mid;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arr[mid];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _getMin(<span class="keyword">int</span> *arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right) &#123;</span><br><span class="line">	<span class="keyword">int</span> min = arr[left];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt;= right; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (arr[i] &lt;= min) &#123;</span><br><span class="line">			min = arr[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="—-Exhaustive-Search-穷举搜索-—"><a href="#—-Exhaustive-Search-穷举搜索-—" class="headerlink" title="—- Exhaustive Search 穷举搜索 —-"></a>—- Exhaustive Search 穷举搜索 —-</h1><h2 id="Pattern-决策树下的递归"><a href="#Pattern-决策树下的递归" class="headerlink" title="Pattern - 决策树下的递归"></a>Pattern - 决策树下的递归</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">explore</span><span class="params">(options, soFar)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (no more decisions to make) &#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// recursive case, we have a decision to make</span></span><br><span class="line">        <span class="keyword">for</span> (each available option) &#123;</span><br><span class="line">            <span class="built_in">choose</span> (update options/sofar)</span><br><span class="line">            <span class="built_in">explore</span> (recur on updated options/sofar)</span><br><span class="line">            [<span class="built_in">backtracking</span> (undo changes to options/sofar)] <span class="comment">//chooseable</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>base case 递归终止条件</li>
<li>make decisions 作决策</li>
<li>explore -递归处理该决策下的决策</li>
<li>backtracking 决策失败后的回溯</li>
</ul>
<h1 id="13-矩阵中的路径"><a href="#13-矩阵中的路径" class="headerlink" title="13 矩阵中的路径"></a>13 矩阵中的路径</h1><blockquote>
<p>请设计一个函数,用来判断在一个矩阵中是否存在一条包含某字符串<strong>所有字符的路径</strong>。路径可以从矩阵中的任意一格开始,每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格,那么该路径<strong>不能再次进入</strong>该格子。例如,在下面的3x4的矩阵中包含一条字符串”bfce”的路径(路径中的字母用下画线标出)。但矩阵中不包含字符串”abtb”的路径,因为字符串的第一个字符b占据了矩阵中的第一行第三个格子之后,路径不能再次进入这个格子。</p>
</blockquote>
<h2 id="Testing-case-16"><a href="#Testing-case-16" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(多行多列的矩阵中存在/不存在路径)</li>
<li>边界测试(矩阵只有一行/一列，矩阵中所有字符相同)</li>
<li>性能测试(nullptr)</li>
</ul>
<h2 id="Key-16"><a href="#Key-16" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>递归回溯-穷举法</p>
<blockquote>
<ol>
<li><p>对于给定的矩阵进行遍历，与给定字符串中的元素进行匹配</p>
</li>
<li><p>每匹配到一个元素，便对其相邻元素进行递归查找，若相邻元素无匹配项，则回溯到上一个元素</p>
<p><code>注意:</code>由于每个格子仅能访问一次，因此需要为每个格子设置访问标识</p>
</li>
</ol>
</blockquote>
</li>
<li><p>递归模式</p>
<ol>
<li>base case 递归终止的条件</li>
<li>对匹配元素的四周递归搜索</li>
<li>若四周无匹配元素，回溯回退到上一格</li>
</ol>
</li>
</ul>
<h2 id="Answer-14"><a href="#Answer-14" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>* arr, <span class="keyword">int</span> cols, <span class="keyword">int</span> rows, string str)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常处理</span></span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="literal">nullptr</span> || cols &lt; <span class="number">1</span> || rows &lt; <span class="number">1</span> || str.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">exception</span>(<span class="string">&quot;异常!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置访问标识数组</span></span><br><span class="line">	<span class="keyword">bool</span>* visited = <span class="keyword">new</span> <span class="keyword">bool</span>[cols*rows];</span><br><span class="line">	<span class="comment">//初始化</span></span><br><span class="line">	<span class="built_in">memset</span>(visited, <span class="number">0</span>, cols*rows);</span><br><span class="line">	<span class="comment">//设置路径状态变量，用于标识路径搜索状态，str中字符匹配位置状态</span></span><br><span class="line">	<span class="keyword">int</span> pathLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历矩阵每一个元素进行路径搜索</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; cols; col++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; rows; row++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">hasPathCore</span>(arr, cols, col, rows, row, pathLength, str, visited)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span> []visited;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasPathCore</span><span class="params">(<span class="keyword">char</span>* arr, <span class="keyword">int</span> cols, <span class="keyword">int</span> col, <span class="keyword">int</span> rows, <span class="keyword">int</span> row, <span class="keyword">int</span>&amp; pathLength,string str, <span class="keyword">bool</span>*&amp;visited)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//base case</span></span><br><span class="line">	<span class="keyword">if</span> (str[pathLength] == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//设置返回值</span></span><br><span class="line">	<span class="keyword">bool</span> hasPath = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (col &gt;= <span class="number">0</span> &amp;&amp; col &lt; cols&amp;&amp;row&gt;=<span class="number">0</span> &amp;&amp; row &lt; rows&amp;&amp;arr[row*cols + col] == str[pathLength] &amp;&amp; visited[row*cols + col] != <span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="comment">//找到匹配路径元素，查找下一个匹配的路径元素</span></span><br><span class="line">		pathLength++;</span><br><span class="line">		<span class="comment">//设置访问状态</span></span><br><span class="line">		visited[row*cols + col] == <span class="literal">true</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//查找该元素的相邻元素</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">hasPathCore</span>(arr, cols, col + <span class="number">1</span>, rows, row, pathLength, str, visited)</span><br><span class="line">			|| <span class="built_in">hasPathCore</span>(arr, cols, col, rows, row + <span class="number">1</span>, pathLength, str, visited)</span><br><span class="line">			|| <span class="built_in">hasPathCore</span>(arr, cols, col - <span class="number">1</span>, rows, row, pathLength, str, visited)</span><br><span class="line">			|| <span class="built_in">hasPathCore</span>(arr, cols, col, rows, row - <span class="number">1</span>, pathLength, str, visited)) &#123;</span><br><span class="line">			hasPath = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//若未找到下一个匹配元素，需要回溯到上一个元素</span></span><br><span class="line">		<span class="keyword">if</span> (!hasPath) &#123;</span><br><span class="line">			pathLength--;</span><br><span class="line">			visited[row*cols + col] == <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> hasPath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="14-机器人的运动范围"><a href="#14-机器人的运动范围" class="headerlink" title="14 机器人的运动范围"></a>14 机器人的运动范围</h1><blockquote>
<p>地上有一个m行n列的方格。一个机器人从坐标(0, 0)的格子开始移动,它每次可以向左、右、上、下移动一格,但不能进入行坐标和列坐标的数位之和大于k的格子。</p>
<p>例如,当k为18时,机器人能够进入方格(35, 37),因为3+5+3+7-18,但它不能进入方格(35, 38),因为3+5+3+8-19,请问该机器人能够到达多少个格子?</p>
</blockquote>
<h2 id="Testing-case-17"><a href="#Testing-case-17" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(矩阵为多行多列，k为正数)</li>
<li>边界测试(矩阵为一行一列，k为0)</li>
<li>性能测试(k为负数)</li>
</ul>
<h2 id="Key-17"><a href="#Key-17" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>递归</p>
<blockquote>
<ol>
<li>从矩阵左上角首元素开始，若元素所在行列不满足阈值条件，则直接返回0，表示从该元素开始的运动范围为0</li>
<li>若满足阈值条件，则从该元素位置开始计数，并对其四周进行递归计数，最终将该计数总和返回即可得到可抵达的所有范围</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-15"><a href="#Answer-15" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isOK</span><span class="params">(<span class="keyword">int</span> cols, <span class="keyword">int</span> rows, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (cols != <span class="number">0</span>) &#123;</span><br><span class="line">		sum += cols % <span class="number">10</span>;</span><br><span class="line">		cols /= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (rows != <span class="number">0</span>) &#123;</span><br><span class="line">		sum += rows % <span class="number">10</span>;</span><br><span class="line">		rows /= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sum &gt; k) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNum</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常处理</span></span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="literal">nullptr</span> || cols &lt; <span class="number">1</span> || rows &lt; <span class="number">1</span> || k &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">exception</span>(<span class="string">&quot;异常!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置访问标识数组</span></span><br><span class="line">	<span class="keyword">bool</span>* visited = <span class="keyword">new</span> <span class="keyword">bool</span>[cols*rows];</span><br><span class="line">	<span class="comment">//初始化</span></span><br><span class="line">	<span class="built_in">memset</span>(visited, <span class="number">0</span>, cols*rows);</span><br><span class="line">	<span class="comment">//设置出发点</span></span><br><span class="line">	<span class="keyword">int</span> col = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> num = <span class="built_in">getNumCore</span>(arr, row, rows, col, cols, k, visited);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//回收内存</span></span><br><span class="line">	<span class="keyword">delete</span>[] visited;</span><br><span class="line">	<span class="keyword">return</span> num;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNumCore</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">int</span> row, <span class="keyword">int</span> rows,<span class="keyword">int</span> col, <span class="keyword">int</span> cols, <span class="keyword">int</span> k, <span class="keyword">bool</span>*visited)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//base case</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">isOK</span>(cols, rows, k)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (!visited[row*cols + col]) &#123;</span><br><span class="line">			num++;</span><br><span class="line">			visited[row*cols + col] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">			num += <span class="built_in">getNumCore</span>(arr, row - <span class="number">1</span>, rows, col, cols, k, visited);</span><br><span class="line">			num += <span class="built_in">getNumCore</span>(arr, row + <span class="number">1</span>, rows, col, cols, k, visited);</span><br><span class="line">			num += <span class="built_in">getNumCore</span>(arr, row, rows, col - <span class="number">1</span>, cols, k, visited);</span><br><span class="line">			num += <span class="built_in">getNumCore</span>(arr, row, rows, col + <span class="number">1</span>, cols, k, visited);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> num;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="15-剪绳子"><a href="#15-剪绳子" class="headerlink" title="15 剪绳子"></a>15 剪绳子</h1><blockquote>
<p>给你一根长度为n的绳子,请把绳子剪成m段(m、n都是整数,n1并且m&gt;1),每段绳子的长度记为A[0].A[1]..A[m]</p>
<p>请问k[0]×…×k[m]可能的最大乘积是多少?例如,当绳子的长度是8时,我们把它剪成长度分别为2,3,3的三段,此时得到的最大乘积是18</p>
</blockquote>
<h2 id="Testing-case-18"><a href="#Testing-case-18" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(初始长度大于5)</li>
<li>边界测试(边界值1,2,3,4)</li>
</ul>
<h2 id="Key-18"><a href="#Key-18" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>动态规划 T(n)=O(n2) S(n)=O(n)</p>
<blockquote>
<p>自下而上的迭代计算代替自顶向下的递归计算，减少重复计算</p>
<ol>
<li>自顶向下分析可得，剪得的最后一次的绳子段长度可能为 1,2…n-1，共n-1种可能将0绳子分为两部分，所以最大乘积 f(n)=max{f(i)*f(n-i)}，最大乘积为最后两部分相应乘积最大值的乘积，max{f(i)*f(n-i)} =&gt;max{f(i)} × max{f(n-i)} ,而max{f(i)}仍可拆解为两段分析</li>
<li>自下向上迭代计算剩余长度为0,1…n的部分的最大乘积，并使用数组顺序存放每部分的最大乘积值</li>
</ol>
</blockquote>
</li>
<li><p>贪心算法 T(n)=O(1) S(n)=O(1)</p>
<blockquote>
<p>当n&gt;=5时，剪得的绳子段长度为3的数目越多越好，其中两段长度分别为3和1的需要用两段长度为2和2的绳子段代替，因为3×1 &lt; 2×2</p>
<ol>
<li>计算绳子最多可容纳的长度为3的绳子段的个数</li>
<li>计算是否存在长度为1的绳子段，若存在，则有一段长度为3的绳子段不可用，需用长度为2的代替</li>
<li>计算剩余长度可容纳的长度为2的绳子段的个数</li>
<li>返回乘积结果</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-16"><a href="#Answer-16" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<p>1</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//对输入长度作初始判断</span></span><br><span class="line">	<span class="keyword">if</span> (length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="comment">//没办法砍</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (length == <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="comment">//只能砍一刀</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (length == <span class="number">3</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//使用数组暂存自下向上的各长度的最大乘积值</span></span><br><span class="line">	<span class="keyword">int</span>* temp = <span class="keyword">new</span> <span class="keyword">int</span>[length + <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">		temp[i] = i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置记录长度为n时的乘积max变量</span></span><br><span class="line">	<span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//计算其余长度的最大乘积值</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= length; i++) &#123;</span><br><span class="line">		max = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//使用已记录的值迭代进行计算，防止重复计算乘积值，设置终止条件为i/2</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i / <span class="number">2</span>; j++) &#123;</span><br><span class="line">			max = temp[j] * temp[i - j];</span><br><span class="line">			<span class="keyword">if</span> (max &gt;= temp[i]) &#123;</span><br><span class="line">				temp[i] = max;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	max = temp[length];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//防止内存泄漏</span></span><br><span class="line">	<span class="keyword">delete</span>[] temp;</span><br><span class="line">	<span class="keyword">return</span> max;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaxx</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//对输入长度作初始判断</span></span><br><span class="line">	<span class="keyword">if</span> (length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="comment">//没办法砍</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (length == <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="comment">//只能砍一刀</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (length == <span class="number">3</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//记录绳子可剪为长度为3的绳子段的个数与长度为2的绳子段的个数</span></span><br><span class="line">	<span class="keyword">int</span> threeTimes = length / <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">int</span> twoTimes = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//记录是否存在裁剪为3*1的情况，需使用2*2替代</span></span><br><span class="line">	<span class="keyword">if</span> (length - <span class="number">3</span> * threeTimes == <span class="number">1</span>) &#123;</span><br><span class="line">		threeTimes -= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	twoTimes = (length - <span class="number">3</span> * threeTimes) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">2</span>, twoTimes) * <span class="built_in">pow</span>(<span class="number">3</span>, threeTimes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="16-二进制中1的个数"><a href="#16-二进制中1的个数" class="headerlink" title="16 二进制中1的个数"></a>16 二进制中1的个数</h1><blockquote>
<p>请实现一个函数,输入一个整数,输出该数二进制表示中1的个数。</p>
<p>例如,把9表示成二进制是1001,有2位是1。因此,如果输入9,则该函数输出2</p>
</blockquote>
<h2 id="Testing-case-19"><a href="#Testing-case-19" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>正数(边界值 1,0x7fffffff)</li>
<li>负数(0x80000000,0xffffffff)</li>
<li>0</li>
</ul>
<h2 id="Key-19"><a href="#Key-19" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>右移整数</p>
<blockquote>
<p>从低位开始判断是否为1，为1则右移一位继续判断次低位，直至整数为0</p>
<p>判断是否为1可与1作&amp;运算</p>
<p><code>注意:</code>若输入负数将引起死循环，负数右移左补1，不会使原数至0</p>
</blockquote>
</li>
<li><p>左移标志数</p>
<blockquote>
<p>从低位开始判断是否为1，为1则标志数左移一位继续判断整数的次低位，直至标志数为0</p>
<p>判断次低位是否为1可与10作&amp;运算，次次低位…</p>
<p>操作次数与整数二进制位数相同</p>
</blockquote>
</li>
<li><p>消除二进制中的所有1</p>
<blockquote>
<p>只要整数不为0，则其二进制中必含1，从低位开始将整数二进制中的1置为0，直至整数为0时的置0操作次数即为0的个数</p>
<p>将整数减去1后与自身作与运算即可消去低位的1</p>
<p>操作次数与整数二进制中1的个数相同</p>
</blockquote>
</li>
</ul>
<h2 id="Answer-17"><a href="#Answer-17" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<p>1</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNOne1</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> nums = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">			nums++;</span><br><span class="line">		&#125;</span><br><span class="line">		n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNOne2</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> nums = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (flag) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n &amp; flag) &#123;</span><br><span class="line">			nums++;</span><br><span class="line">		&#125;</span><br><span class="line">		flag &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNOne3</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> nums = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (n) &#123;</span><br><span class="line">		nums++;</span><br><span class="line">		n = (n - <span class="number">1</span>)&amp;n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="17-数值的整数次方"><a href="#17-数值的整数次方" class="headerlink" title="17 数值的整数次方"></a>17 数值的整数次方</h1><blockquote>
<p>实现函数double Power(double base, int exponent),求base的exponent次方。</p>
<p>不得使用库函数,同时不需要考虑大数问题。</p>
</blockquote>
<h2 id="Testing-case-20"><a href="#Testing-case-20" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(正数负数的任意整数次幂)</li>
<li>边界测试(0的负数次幂)</li>
</ul>
<h2 id="Key-20"><a href="#Key-20" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>考虑边界值的处理</p>
</li>
<li><p>考虑指数为负数时的倒数处理</p>
</li>
<li><p>考虑错误处理的方式 - 返回值，全局变量，异常</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="center">方式</th>
<th align="center">优缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="left">返回值</td>
<td align="center">返回0表示调用成功，否则调用失败</td>
<td align="center">与系统API一致但是执行结果不便于操作</td>
</tr>
<tr>
<td align="left">全局变量</td>
<td align="center">通过全局变量的值的情况反应函数是否调用成功</td>
<td align="center">便于操作计算结果但是容易忘记处理失败调用</td>
</tr>
<tr>
<td align="left">异常</td>
<td align="center">通过抛出异常的类型对不同类型的异常作不同的处理</td>
<td align="center">方便处理异常但是有性能开销，有的语言不支持异常</td>
</tr>
</tbody></table>
</li>
<li><p>累乘法</p>
<blockquote>
<p>累乘的次数与指数的大小相同</p>
</blockquote>
</li>
<li><p>递归法</p>
<blockquote>
<ol>
<li>若指数为偶数，则|index|整数次方可以由 |index/2| 的乘积得出</li>
<li>若指数为奇数，则|index|整数次方可以由 |index/2| 的乘积 × n 得出</li>
<li>由此可递归计算n的|index|整数次幂</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>使用右移一位操作代替除以2</li>
<li>使用&amp;0x1操作代替%2，可提高性能执行效率</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-18"><a href="#Answer-18" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<p>1.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置用于检查调用是否成功的全局变量</span></span><br><span class="line"><span class="keyword">bool</span> failed = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getPow</span><span class="params">(<span class="keyword">double</span> n, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//考虑n为0时index为负数的情况，无法求倒数</span></span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0.0</span>&amp;index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		failed = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//无论指数正负，先求指数求绝对值后的次方结果</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> absIndex;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		absIndex = -index;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		absIndex = index;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">double</span> result = <span class="built_in">getAbsPow</span>(n, absIndex);</span><br><span class="line">	<span class="comment">//对指数为负数的情况求倒数</span></span><br><span class="line">	<span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		result = <span class="number">1.0</span> / result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getAbsPow</span><span class="params">(<span class="keyword">double</span> n, <span class="keyword">unsigned</span> <span class="keyword">int</span> absIndex)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">double</span> sum = <span class="number">1.0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1.0</span>; i &lt;= absIndex; i++) &#123;</span><br><span class="line">		sum *= n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getAbsPow2</span><span class="params">(<span class="keyword">double</span> n, <span class="keyword">unsigned</span> <span class="keyword">int</span> absIndex)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//basecase</span></span><br><span class="line">	<span class="keyword">if</span> (absIndex == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (absIndex == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">double</span> pow = <span class="built_in">getAbsPow2</span>(n, absIndex &gt;&gt; <span class="number">1</span>);</span><br><span class="line">		pow *= pow;</span><br><span class="line">		<span class="keyword">if</span> (absIndex &amp; <span class="number">0x1</span> == <span class="number">1</span>) &#123;</span><br><span class="line">			pow *= n;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> pow;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</blockquote>
<h1 id="18-打印从1到最大的n位数"><a href="#18-打印从1到最大的n位数" class="headerlink" title="18 打印从1到最大的n位数"></a>18 打印从1到最大的n位数</h1><blockquote>
<p>输入数字n,按顺序打印出从1到最大的n位十进制数。</p>
<p>比如输入3,则打印出1,2,3一直到最大的3位数999</p>
</blockquote>
<h2 id="Testing-case-21"><a href="#Testing-case-21" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(1,2,3)</li>
<li>边界测试(0,-1)</li>
</ul>
<h2 id="Key-21"><a href="#Key-21" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>大数问题</p>
<blockquote>
<p>当n过大，无论是int还是long长整型均会溢出，因此无法预先算出max(n)后顺序输出</p>
</blockquote>
</li>
<li><p>字符串模拟</p>
<blockquote>
<p>使用字符串来存放数字并模拟数字加法，最终将字符串表达的数字输出</p>
<ol>
<li>设置字符串的长度为n+1,使用’\0’初始化而非0，并将末尾值为空操作符</li>
<li>在字符串上模拟对数字的加法，设置进位标志，先取出对应位上的数字(-‘\0’)，进行加法运算后覆盖置回</li>
<li>输出数字时从字符串第一个非零的数字字符开始输出</li>
<li>若进位产生于字符串第一个位置，则已到达最大数位，不再输出</li>
</ol>
</blockquote>
</li>
<li><p>全排列递归</p>
<blockquote>
<p>将1到最大n位数的所有数当做0-9的全排列问题</p>
<ol>
<li>从首位开始递归排列直至到达最后一位进行回溯顺序输出</li>
</ol>
</blockquote>
</li>
<li><p>Bitmap算法</p>
<blockquote>
<p>使用bit作存储单元，使用更贴合计算机底层的运算，性能与内存使用效率都很高</p>
<p>bitmap中0表示无意义，1表示存放了索引对应的数据</p>
</blockquote>
</li>
</ul>
<h2 id="Answer-19"><a href="#Answer-19" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<p>1.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常处理</span></span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		xfailed = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//考虑大数问题，设置字符串或者数组来存放数字(此处选择字符串)</span></span><br><span class="line">	<span class="keyword">char</span>* str = <span class="keyword">new</span> <span class="keyword">char</span>[n + <span class="number">1</span>];</span><br><span class="line">	<span class="built_in">memset</span>(str, <span class="string">&#x27;0&#x27;</span>, n);</span><br><span class="line">	str[n] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">increment</span>(str)) &#123;</span><br><span class="line">		<span class="built_in">printNumCore</span>(str);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//防止内存泄漏</span></span><br><span class="line">	<span class="keyword">delete</span>[] str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对字符串模拟加1</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">increment</span><span class="params">(<span class="keyword">char</span>* str)</span></span>&#123;</span><br><span class="line">	<span class="comment">//记录字符串长度</span></span><br><span class="line">	<span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">	<span class="comment">//设置进位值</span></span><br><span class="line">	<span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//设置返回值判断是否至最大数进位</span></span><br><span class="line">	<span class="keyword">bool</span> arrive = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="comment">//设置模拟加法的临时数字变量</span></span><br><span class="line">		<span class="keyword">int</span> num = str[i] - <span class="string">&#x27;0&#x27;</span> + carry;</span><br><span class="line">		<span class="comment">//若为个位，则直接进行加1即可</span></span><br><span class="line">		<span class="keyword">if</span> (i == len - <span class="number">1</span>) &#123;</span><br><span class="line">			num++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (num &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">				arrive = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">//设置进位后，将本位设置为0后写回</span></span><br><span class="line">				num -= <span class="number">10</span>;</span><br><span class="line">				str[i] = num + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">				carry = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//直接写回</span></span><br><span class="line">			str[i] = num + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">			<span class="comment">//break作用为:所有的直接加一运算仅作用于个位，其余位的加1运算均来自carry的进位</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> arrive;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNumCore</span><span class="params">(<span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//设置判断是否为第一个非零数的变量</span></span><br><span class="line">	<span class="keyword">bool</span> first = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len; i++) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!first&amp;&amp;str[i] != <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">			first = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (first)</span><br><span class="line">			cout &lt;&lt; str[i];</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNum2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常处理</span></span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		xxfailed = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//考虑大数问题，设置字符串或者数组来存放数字(此处选择字符串)</span></span><br><span class="line">	<span class="keyword">char</span>* str = <span class="keyword">new</span> <span class="keyword">char</span>[n + <span class="number">1</span>];</span><br><span class="line">	<span class="built_in">memset</span>(str, <span class="string">&#x27;0&#x27;</span>, n);</span><br><span class="line">	str[n] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从第一位开始递归排列</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		str[<span class="number">0</span>] = i + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		<span class="built_in">permutation</span>(str, n, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//防止内存泄漏</span></span><br><span class="line">	<span class="keyword">delete</span>[] str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">permutation</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">int</span> length, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//base case</span></span><br><span class="line">	<span class="keyword">if</span> (index == length - <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="built_in">printNumCore2</span>(str);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		str[index + <span class="number">1</span>] = i + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		<span class="built_in">permutation</span>(str, length, index + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNumCore2</span><span class="params">(<span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//设置判断是否为第一个非零数的变量</span></span><br><span class="line">	<span class="keyword">bool</span> first = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len; i++) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!first&amp;&amp;str[i] != <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">			first = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (first)</span><br><span class="line">			cout &lt;&lt; str[i];</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="19-1-删除链表的结点"><a href="#19-1-删除链表的结点" class="headerlink" title="19.1 删除链表的结点"></a>19.1 删除链表的结点</h1><blockquote>
<p>在0(1)时间内删除链表节点</p>
<p>给定单向链表的头指针和一个节点指针,定义一个函数在O(1)时间内删除该节点</p>
<p>假设待删除的结点位于链表中</p>
</blockquote>
<h2 id="Testing-case-22"><a href="#Testing-case-22" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(要删除的结点在首尾结点之间，删除首元结点，删除尾元结点)</li>
<li>边界测试(nullpter)</li>
</ul>
<h2 id="Key-22"><a href="#Key-22" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>顺序删除 T(n)=O(n)</p>
<blockquote>
<p>从头结点开始顺序遍历至待删除结点的前一个结点进行删除</p>
</blockquote>
</li>
<li><p>伪删除 T(n)=O(1)</p>
<blockquote>
<ol>
<li>使用待删除结点的后一个结点值赋值替代待删除结点的值，待删除结点”伪装”为后一个结点</li>
<li>将待删除结点的next指针指向后一个 结点的next指向</li>
<li>删除后一个结点即可</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-20"><a href="#Answer-20" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> &#123;</span></span><br><span class="line">	LinkNode* pNext;</span><br><span class="line">	<span class="keyword">int</span> pValue;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(LinkNode** pHead, LinkNode* dNode)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断异常</span></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span> || dNode == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		doFalse = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dNode == *pHead) &#123;</span><br><span class="line">		<span class="comment">//删除的结点为头结点</span></span><br><span class="line">		<span class="keyword">delete</span> dNode;</span><br><span class="line">		dNode = <span class="literal">nullptr</span>;</span><br><span class="line">		*pHead = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (dNode-&gt;pNext != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="comment">//删除的结点为首尾结点之间的结点</span></span><br><span class="line">		LinkNode* ppNext = dNode-&gt;pNext;</span><br><span class="line">		dNode-&gt;pValue = ppNext-&gt;pValue;</span><br><span class="line">		dNode-&gt;pNext = ppNext-&gt;pNext;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">delete</span> ppNext;</span><br><span class="line">		ppNext = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//删除的结点为尾元结点</span></span><br><span class="line">		LinkNode* pPre = (*pHead)-&gt;pNext;</span><br><span class="line">		<span class="comment">//遍历至待删除结点的前一个结点</span></span><br><span class="line">		<span class="keyword">while</span> (pPre-&gt;pNext != dNode) &#123;</span><br><span class="line">			pPre = pPre-&gt;pNext;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		pPre-&gt;pNext = <span class="literal">nullptr</span>;</span><br><span class="line">		<span class="keyword">delete</span> dNode;</span><br><span class="line">		dNode = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="19-2-删除链表中的重复连续结点"><a href="#19-2-删除链表中的重复连续结点" class="headerlink" title="19.2 删除链表中的重复连续结点"></a>19.2 删除链表中的重复连续结点</h1><blockquote>
<p>删除链表中重复连续的节点</p>
<p>重复结点指连续的值相同的结点</p>
</blockquote>
<h2 id="Testing-case-23"><a href="#Testing-case-23" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(要删除的结点在首尾结点之间，首元结点，尾元结点)</li>
<li>边界测试(nullpter)</li>
</ul>
<h2 id="Key-23"><a href="#Key-23" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>顺序删除</p>
<blockquote>
<ol>
<li><p>顺序遍历整个链表，从第一个结点开始查找，是否存在连续的相同的结点</p>
</li>
<li><p>若存在，则需要删除当前连续结点，且判断其后续结点是否仍然连续</p>
</li>
<li><p>若不存在，则向后遍历，直至遍历完所有结点</p>
</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>为了保证链表连续，需要时刻记录当前遍历结点的前一个结点，在进行删除操作后，将前一个结点的pNext更新，保持链表连续</li>
<li>使用一个ppNext时刻指针指向preNode的下一个结点</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-21"><a href="#Answer-21" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteNode2</span><span class="params">(LinkNode** PHead)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断异常</span></span><br><span class="line">	<span class="keyword">if</span> (PHead == <span class="literal">nullptr</span> || *PHead== <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="comment">/*doFalse = true;*/</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//为保证连续性需要每次记录当前未被删除结点的上一个结点</span></span><br><span class="line">	LinkNode* preNode = <span class="literal">nullptr</span>;</span><br><span class="line">	LinkNode* pNode = *PHead;</span><br><span class="line">	<span class="comment">//遍历链表找寻重复结点</span></span><br><span class="line">	<span class="keyword">while</span> (pNode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="comment">//设置结点是否需要删除的标志</span></span><br><span class="line">		<span class="keyword">bool</span> deleteY = <span class="literal">false</span>;</span><br><span class="line">		<span class="comment">//设置指向当前结点下一结点的指针</span></span><br><span class="line">		LinkNode* ppNext = pNode-&gt;pNext;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//判断当前结点是否需要删除</span></span><br><span class="line">		<span class="keyword">if</span> (ppNext != <span class="literal">nullptr</span> &amp;&amp; ppNext-&gt;pValue == pNode-&gt;pValue) &#123;</span><br><span class="line">			deleteY = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//若不要删除则继续向下遍历</span></span><br><span class="line">		<span class="keyword">if</span> (!deleteY) &#123;</span><br><span class="line">			preNode = pNode;</span><br><span class="line">			pNode = pNode-&gt;pNext;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//记录当前需要删除的结点</span></span><br><span class="line">			LinkNode* DeleteNeed = pNode;</span><br><span class="line">			<span class="comment">//记录重复的元素值</span></span><br><span class="line">			<span class="keyword">int</span> value = DeleteNeed-&gt;pValue;</span><br><span class="line">			<span class="comment">//若当前结点需要删除，继续循环判断当前结点的下一个是否需要删除，判断结束后再进行删除</span></span><br><span class="line">			ppNext = DeleteNeed-&gt;pNext;</span><br><span class="line">			<span class="comment">//删除当前结点</span></span><br><span class="line">			<span class="keyword">delete</span> DeleteNeed;</span><br><span class="line">			DeleteNeed = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">while</span> (ppNext != <span class="literal">nullptr</span>&amp;&amp;ppNext-&gt;pValue == value) &#123;																		<span class="comment">//设置当前结点为需要删除的结点，注意顺序，不可和下面调换</span></span><br><span class="line">				DeleteNeed = ppNext;																									<span class="comment">//继续判断下一结点是否需要删除</span></span><br><span class="line">				ppNext = ppNext-&gt;pNext;																					</span><br><span class="line">				<span class="comment">//删除结点</span></span><br><span class="line">				<span class="keyword">delete</span> DeleteNeed;</span><br><span class="line">				DeleteNeed = <span class="literal">nullptr</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (preNode == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				*PHead = ppNext;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				preNode-&gt;pNext = ppNext;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			pNode = ppNext;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</blockquote>
<h1 id="20-正则表达式匹配"><a href="#20-正则表达式匹配" class="headerlink" title="20 正则表达式匹配"></a>20 正则表达式匹配</h1><blockquote>
<p>请实现一个函数用来匹配包含‘.’和‘*’的正则表达式。模式中的字符’.’表示任意一个字符,而’米’表示它前面的字符可以出现任意次(含0次)。</p>
<p>在本题中,匹配是指字符串的所有字符匹配整个模式。例如,字符串”aa”与模式”a.a”和”ab米ac米a”匹配,但与”aa.a”和”ab*a”均不匹配。</p>
</blockquote>
<h2 id="Testing-case-24"><a href="#Testing-case-24" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(模式与输入字符串匹配或不匹配，模式字符串中含有普通字符,’.’,’*’，输入字符串为空字符串)</li>
<li>边界测试(nullptr)</li>
</ul>
<h2 id="Key-24"><a href="#Key-24" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>分治递归</p>
<blockquote>
<ol>
<li>在考虑当前字符是否匹配之前，先进行判断当前字符的下一个模式字符是否 ‘*’</li>
<li>若不是，则直接判断当前字符是否匹配，不匹配直接返回false，若匹配，移动指针，递归判断子字符串是否匹配</li>
<li>若是，则分三种情况讨论，当前字符出现0次，当前字符出现1次，当前字符出现多次</li>
<li>直至模式字符串匹配完成</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>‘*’ 可以忽略前一个字符(出现0次)，但是’.’不可以忽略，该字符必须参与比较</li>
<li>防止*(pattern + 1)越界，所以basecase使用pattern到末尾做基准</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-22"><a href="#Answer-22" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">char</span>* pattern)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (str == <span class="literal">nullptr</span> || pattern == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		isfalse = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">matchCore</span>(str, pattern);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">matchCore</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">char</span>* pattern)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//base case</span></span><br><span class="line">	<span class="keyword">if</span> (*str == <span class="string">&#x27;\0&#x27;</span>&amp;&amp;*pattern == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (*str != <span class="string">&#x27;\0&#x27;</span>&amp;&amp;*pattern == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//首先判断当前判定模式字符的下一位是否为*</span></span><br><span class="line">	<span class="keyword">if</span> (*(pattern + <span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (*str == *pattern || *pattern == <span class="string">&#x27;.&#x27;</span>&amp;&amp;*str != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">matchCore</span>(str, pattern + <span class="number">2</span>) || <span class="built_in">matchCore</span>(str + <span class="number">1</span>, pattern + <span class="number">2</span>) || <span class="built_in">matchCore</span>(str + <span class="number">1</span>, pattern);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">matchCore</span>(str, pattern + <span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (*str == *pattern || *pattern == <span class="string">&#x27;.&#x27;</span>&amp;&amp;*str != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">			<span class="comment">//第一个字符匹配,两个匹配字符串指针均后移一位</span></span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">matchCore</span>(str + <span class="number">1</span>, pattern + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="21-表示数值的字符串"><a href="#21-表示数值的字符串" class="headerlink" title="21 表示数值的字符串"></a>21 表示数值的字符串</h1><blockquote>
<p>请实现一个函数用来判断字符串是否表示数值(包括整数和小数)。例如,字符串”+100”，”5e2”，”-123”，”3.1416”及”-1E-16”都表示数值,但”12e”，”1a3.14”，”1.2.3”，”+-5”及”12e+5.4”都不是。</p>
</blockquote>
<h2 id="Testing-case-25"><a href="#Testing-case-25" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(有无整数部分，有无小数部分，有无指数部分，正数负数，含其他字符)</li>
<li>边界测试(nullptr，字符串为空)</li>
</ul>
<h2 id="Key-25"><a href="#Key-25" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>模式有序分析</p>
<blockquote>
<p>若一个字符串是数值字符串，则其满足[A][.B][e|EC],即A整数部分，B小数部分，C指数部分</p>
<ol>
<li>先判断整数部分，最大努力寻找整数，直至遇到’’.’或者’e|E’或其他字符停止或至末尾</li>
<li>再判断小数部分，若遇到’.’，则再向后最大努力寻找整数，直至遇到’e|E’或其他字符停止或至末尾</li>
<li>最后判断指数部分，若遇到’e|E’，则再向后最大努力寻找整数，直至遇到其他字符停止或至末尾</li>
<li>若三部分判断完毕且字符串也遍历完毕则为数值字符串</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>判断小数部分时使用 || 的原因为考虑无整数部分的小数也满足条件，无小数部分的整数也满足条件</li>
<li> 判断指数部分时使用 &amp;&amp; 的原因为考虑若含指数部分，则e之前至少含小数或整数，不可为空，e之后必含整数不可为空</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-23"><a href="#Answer-23" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isNum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (str == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//首先判断A整数部分是否满足条件</span></span><br><span class="line">	<span class="keyword">bool</span> numric = <span class="built_in">isInteger</span>(&amp;str);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断B小数部分是否满足条件</span></span><br><span class="line">	<span class="keyword">if</span> (*str == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">		str++;</span><br><span class="line"></span><br><span class="line">		numric = <span class="built_in">isUInteger</span>(&amp;str) || numric;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断C指数部分是否满足条件</span></span><br><span class="line">	<span class="keyword">if</span> (*str == <span class="string">&#x27;e&#x27;</span> || *str == <span class="string">&#x27;E&#x27;</span>) &#123;</span><br><span class="line">		str++;</span><br><span class="line">		numric = <span class="built_in">isInteger</span>(&amp;str) &amp;&amp; numric;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断字符串是否还有剩余的其他字符</span></span><br><span class="line"></span><br><span class="line">	numric = numric &amp;&amp; *str == <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> numric;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isUInteger</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>** str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *temp = *str;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (**str != <span class="string">&#x27;\0&#x27;</span> &amp;&amp; **str &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; **str &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">		(*str)++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//只要*str移动了则一定含有数字字符，一定大于temp，temp始终指向字符首部不变</span></span><br><span class="line">	<span class="keyword">return</span> *str &gt; temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isInteger</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>** str)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (**str == <span class="string">&#x27;+&#x27;</span> || **str == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">		(*str)++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">isUInteger</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="22-调整数组顺序使奇数位于偶数前面"><a href="#22-调整数组顺序使奇数位于偶数前面" class="headerlink" title="22 调整数组顺序使奇数位于偶数前面"></a>22 调整数组顺序使奇数位于偶数前面</h1><blockquote>
<p>输入一个整数数组,实现一个函数来调整该数组中数字的顺序使得所有奇数位于数组的前半部分,所有偶数位于数组的后半部分。</p>
</blockquote>
<h2 id="Testing-case-26"><a href="#Testing-case-26" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(数组奇数偶数交替，所有偶数在奇数前面，所有奇数在偶数前面)</li>
<li>边界测试(nullptr，仅含一个数字)</li>
</ul>
<h2 id="Key-26"><a href="#Key-26" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>双指针交换</p>
<blockquote>
<ol>
<li>设置两个指针分别为指向奇数的指针p1初始指向首元素，指向偶数的指针p2初始指向尾元素</li>
<li>移动两个指针，直至p1指向偶数，p2指向奇数，若p1&lt;=p2，表明存在一个偶数在奇数之前，交换其位置</li>
<li>当p1&gt;p2后，数组遍历完成，交换完成</li>
</ol>
</blockquote>
</li>
<li><p>考虑拓展性</p>
<blockquote>
<p>将性质判断从交换元素中解耦出来，使用函数指针指明判断方法即可</p>
</blockquote>
</li>
</ul>
<h2 id="Answer-24"><a href="#Answer-24" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Move</span><span class="params">(<span class="keyword">int</span>* base, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (base == <span class="literal">nullptr</span> || length &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置指针</span></span><br><span class="line">	<span class="keyword">int</span>* pOdd = base;</span><br><span class="line">	<span class="keyword">int</span>* pEven = base + length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过交换移动奇数于偶数之前</span></span><br><span class="line">	<span class="keyword">while</span> (pOdd &lt;= pEven) &#123;</span><br><span class="line">		<span class="keyword">while</span> (pOdd &lt;= pEven &amp;&amp; (*pOdd &amp; <span class="number">0x1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">			pOdd++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (pOdd &lt;= pEven &amp;&amp; (*pEven &amp; <span class="number">0x1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">			pEven--;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (pOdd &lt;= pEven) &#123;</span><br><span class="line">			<span class="keyword">int</span> temp;</span><br><span class="line">			temp = *pOdd; *pOdd = *pEven; *pEven = temp;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//考虑拓展性</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">standard</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (n &amp; <span class="number">0x1</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Move</span><span class="params">(<span class="keyword">int</span>* base, <span class="keyword">int</span> length, <span class="keyword">bool</span>(*func)(<span class="keyword">int</span>))</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (base == <span class="literal">nullptr</span> || length &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置指针</span></span><br><span class="line">	<span class="keyword">int</span>* pOdd = base;</span><br><span class="line">	<span class="keyword">int</span>* pEven = base + length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过交换移动奇数于偶数之前</span></span><br><span class="line">	<span class="keyword">while</span> (pOdd &lt;= pEven) &#123;</span><br><span class="line">		<span class="keyword">while</span> (pOdd &lt;= pEven &amp;&amp; !<span class="built_in">func</span>((*pOdd))) &#123;</span><br><span class="line">			pOdd++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (pOdd &lt;= pEven &amp;&amp; <span class="built_in">func</span>((*pEven))) &#123;</span><br><span class="line">			pEven--;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (pOdd &lt;= pEven) &#123;</span><br><span class="line">			<span class="keyword">int</span> temp;</span><br><span class="line">			temp = *pOdd; *pOdd = *pEven; *pEven = temp;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="23-1-链表中倒数第k个结点"><a href="#23-1-链表中倒数第k个结点" class="headerlink" title="23.1 链表中倒数第k个结点"></a>23.1 链表中倒数第k个结点</h1><blockquote>
<p>输入一个链表,输出该链表中倒数第k个节点。</p>
<p>为了符合大多数人的习惯,本题从1开始计数,即链表的尾节点是倒数第1个节点。</p>
<p>例如,一个链表有6个节点,从头节点开始,它们的值依次是1.2.3.4.5.6,这个链表的倒数第3个节点是值为4的节点。</p>
</blockquote>
<h2 id="Testing-case-27"><a href="#Testing-case-27" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(倒数第k个结点为首结点，尾结点，中间结点)</li>
<li>边界测试(nullptr，链表结点数小于k)</li>
</ul>
<h2 id="Key-27"><a href="#Key-27" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>遍历两次链表</p>
<blockquote>
<p>第一次从头遍历链表获取链表长度，第二次直接移动至 n-k+1 个结点处，即为倒数第k个结点</p>
</blockquote>
</li>
<li><p>遍历一次链表</p>
<blockquote>
<p>使用范围指针对，指针对始终相差k-1，当范围指针对右边界指针移动至链表尾部时，左边界指向的结点即为倒数第k个结点</p>
<ol>
<li>首先定位左右指针的边界，初始左边界为链表头，右边界为首部右移 k-1 次后的结点</li>
<li>移动该范围指针对，直至右边界指针指向尾部元素</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>注意代码的鲁棒性，对输入参数进行鲁棒性校验</li>
<li>在移动范围指针对时，注意k的取值是否会导致指针指向越界</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-25"><a href="#Answer-25" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> pValue;</span><br><span class="line">	ListNode* pNext;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">LastK</span><span class="params">(ListNode* pHead, <span class="keyword">unsigned</span> <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span> || k &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置范围指针对</span></span><br><span class="line">	ListNode* pRight = pHead;</span><br><span class="line">	<span class="comment">//设置范围指针对的左起始边界</span></span><br><span class="line">	ListNode* pLeft = pHead;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置范围指针对的右起始边界</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (pRight-&gt;pNext == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		pRight = pRight-&gt;pNext;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//移动范围指针对，直至右边界指针至尾结点</span></span><br><span class="line">	<span class="keyword">while</span> (pRight-&gt;pNext != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		pRight = pRight-&gt;pNext;</span><br><span class="line">		pLeft = pLeft-&gt;pNext;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pLeft;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="23-2-求链表的中间结点"><a href="#23-2-求链表的中间结点" class="headerlink" title="23.2 求链表的中间结点"></a>23.2 求链表的中间结点</h1><blockquote>
<p>求链表的中间节点</p>
<p>如果链表中的节点总数为奇数,则返回中间节点;如果节点总数是偶数,则返回中间两个节点的任意一个</p>
</blockquote>
<h2 id="Testing-case-28"><a href="#Testing-case-28" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(链表结点个数为奇数，为偶数，结点长度为1)</li>
<li>边界测试(nullptr，结点长度为0)</li>
</ul>
<h2 id="Key-28"><a href="#Key-28" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>遍历两次链表</p>
<blockquote>
<p>第一次从头遍历链表获取链表长度，根据长度奇偶性决定第二次移动的次数</p>
</blockquote>
</li>
<li><p>遍历一次链表</p>
<blockquote>
<p>使用两个指针，一个faster指针一次移动2单位，一个slower指针一次移动一单位</p>
<ol>
<li>设置两个指针的起始位置均为头结点，则faster指针移动至尾结点时，slower指针指向即为中间结点</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>faster指针在移动时只能一次一次移动，第二次移动时需要判断是否为nullptr，防止越界</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-26"><a href="#Answer-26" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> pValue;</span><br><span class="line">	ListNode* pNext;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">Middle</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断异常</span></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置遍历指针与定位指针</span></span><br><span class="line">	ListNode* faster = pHead;</span><br><span class="line">	ListNode* slower = pHead;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (faster-&gt;pNext != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		faster = faster-&gt;pNext;</span><br><span class="line">		<span class="keyword">if</span> (faster-&gt;pNext != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			faster = faster-&gt;pNext;</span><br><span class="line">		&#125;</span><br><span class="line">		slower = slower-&gt;pNext;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> slower;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="24-链表中环的入口结点"><a href="#24-链表中环的入口结点" class="headerlink" title="24 链表中环的入口结点"></a>24 链表中环的入口结点</h1><blockquote>
<p>如果一个链表中包含环,如何找出环的入口节点?</p>
</blockquote>
<h2 id="Testing-case-29"><a href="#Testing-case-29" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(链表有无环，链表中仅有一个结点)</li>
<li>边界测试(nullptr)</li>
</ul>
<h2 id="Key-29"><a href="#Key-29" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>顺序求解</p>
<blockquote>
<ol>
<li>首先判断链表中是否有环</li>
<li>若链表中有环，则进而判断环中结点的个数</li>
<li>进而求得环的入口结点</li>
</ol>
</blockquote>
</li>
<li><p>双指针</p>
<blockquote>
<ol>
<li>设置两个速度不同的指针，若某一时刻快的指针追赶到慢的指针，说明有环，若快的指针遍历完链表后为nullptr，则说明无环</li>
<li>若链表中有环，则1中两个指针相遇的结点必定在环中，只需设置一个指针从该结点开始向后移动，同时计数，回到该结点的计数值即为环中结点数</li>
<li>使用范围指针对，范围长度为n+1，n为环中结点数，初始左边界为首部结点，右边界向右移动n个单位，向后移动，两个指针相遇的结点即为环入口</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>范围指针对长度为n+1的原因为当右边界到达环末尾时，左边界将位于入口前一个结点，范围长度只会在 n+1 - 0 两值之间反复横跳</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-27"><a href="#Answer-27" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">getMeetNode</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//若仅有一个结点则无环，无相遇结点可</span></span><br><span class="line">	<span class="keyword">if</span> (pHead-&gt;pNext == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置快慢指针</span></span><br><span class="line">	ListNode* faster = pHead;</span><br><span class="line">	ListNode* slower = pHead;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (faster != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		faster = faster-&gt;pNext;</span><br><span class="line">		<span class="keyword">if</span> (faster != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			faster = faster-&gt;pNext;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		slower = slower-&gt;pNext;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (faster == slower) &#123;</span><br><span class="line">			<span class="keyword">return</span> faster;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//若无环，返回nullptr</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">getEntryPoint</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function">	ListNode* pMeetNode </span>= <span class="built_in">getMeetNode</span>(pH</span><br><span class="line">	<span class="keyword">if</span> (pMeetNode == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//若存在环，则计算环中结点个数</span></span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">	ListNode* p = pMeetNode;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (p-&gt;pNext != pMeetNode) &#123;</span><br><span class="line">		p = p-&gt;pNext;</span><br><span class="line">		num++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置范围指针对，并设置初始位置</span></span><br><span class="line">	ListNode* pRight = pHead;</span><br><span class="line">	ListNode* pLeft= pHead;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">		pRight = pRight-&gt;pNext;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//移动范围指针对找寻入口点</span></span><br><span class="line">	<span class="keyword">while</span> (pRight != pLeft) &#123;</span><br><span class="line">		pRight = pRight-&gt;pNext;</span><br><span class="line">		pLeft = pLeft-&gt;pNext;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pLeft;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="25-反转链表"><a href="#25-反转链表" class="headerlink" title="25 反转链表"></a>25 反转链表</h1><blockquote>
<p>定义一个函数,输入一个链表的头节点,反转该链表并输出反转后链表的头节点</p>
</blockquote>
<h2 id="Testing-case-30"><a href="#Testing-case-30" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(链表有一个或者多个结点)</li>
<li>边界测试(nullptr)</li>
</ul>
<h2 id="Key-30"><a href="#Key-30" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>遍历逐元素反转</p>
<blockquote>
<p>从头至尾遍历链表，将每个元素的pNext均置为前一个元素，首结点置为nullptr</p>
<ol>
<li>设置两个指针，一个pPre指向当前结点的前一个结点，一个pNode指向当前结点，初始首结点的pPre置为nullptr</li>
<li>开始向后遍历，每次遍历到下一个元素时马上通过ppNext记录其下一个结点，并使用pPre指向设置其pNext指向，使当前结点指向其前一个结点</li>
<li>反转当前结点后，更新下一个结点的pPre指向</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>由于单向链表向后遍历时，一个指针只能获得当前结点的状态，因此到下一个结点之前，需要使用pPre记录当前结点，使得设置下一个结点的pNext时可以获得前一个结点的状态</li>
<li>由于单向链表在反转某个结点时，会导致其与原本之后的结点断裂，导致无法向下遍历，因此在反转当前结点之前先记录当前结点的pNext值，反转之后，将该值赋值给pNode继续向下遍历</li>
</ol>
</blockquote>
</li>
<li><p>递归</p>
<blockquote>
<ol>
<li>从首节点开始，递归求得除当前结点外，其后剩余结点的反转链表</li>
<li>将当前结点作为其后反转链表的新尾部结点</li>
<li>直至当前结点为尾元结点</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>当前结点其后剩余结点的反转链表的尾元结点为当前结点的下一个结点，该结点由剩余结点的头结点反转后成为尾元结点</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-28"><a href="#Answer-28" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<p>1.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">Reverse</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//设置状态保存变量</span></span><br><span class="line">	ListNode* pPre = <span class="literal">nullptr</span>;</span><br><span class="line">	ListNode* pNode = pHead;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历链表并设置每一个结点的pNext为前一个结点</span></span><br><span class="line">	<span class="keyword">while</span> (pNode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="comment">//保存下一个结点，防止链表断裂后无法遍历</span></span><br><span class="line">		ListNode* ppNext = pNode-&gt;pNext;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//设置当前结点的pNext为s前一个结点</span></span><br><span class="line">		pNode-&gt;pNext = pPre;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//更新状态保存变量值对应于下一个结点</span></span><br><span class="line">		pPre = pNode;</span><br><span class="line">		pNode = ppNext;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pPre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">RReverseCore</span><span class="params">(ListNode* pNowHead)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//basecase</span></span><br><span class="line">	<span class="keyword">if</span> (pNowHead-&gt;pNext == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> pNowHead;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//记录分治后的尾元结点即当前结点的下一个结点</span></span><br><span class="line">	ListNode* LastTail = pNowHead-&gt;pNext;</span><br><span class="line">	<span class="comment">//递归返回分治后新的首结点</span></span><br><span class="line">	ListNode* NewHead = <span class="built_in">RReverseCore</span>(pNowHead-&gt;pNext);</span><br><span class="line">	<span class="comment">//将当前结点与已&quot;反转&quot;的后半部分的尾元结点连接</span></span><br><span class="line">	LastTail-&gt;pNext = pNowHead;</span><br><span class="line">	<span class="comment">//当前结点成为新的尾元结点</span></span><br><span class="line">	pNowHead-&gt;pNext = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> NewHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">RReverse</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">RReverseCore</span>(pHead);		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="26-合并两个排序的链表"><a href="#26-合并两个排序的链表" class="headerlink" title="26 合并两个排序的链表"></a>26 合并两个排序的链表</h1><blockquote>
<p>输入两个递增排序的链表,合并这两个链表并使新链表中的节点仍然是递增排序的</p>
</blockquote>
<h2 id="Testing-case-31"><a href="#Testing-case-31" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(两个链表均为长度不为0排序的链表)</li>
<li>边界测试(两个链表有一个为nullptr，两个链表均为nullptr)</li>
</ul>
<h2 id="Key-31"><a href="#Key-31" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>递归</p>
<blockquote>
<ol>
<li>比较两个链表的首元结点的值的大小，选取小的结点作为当前合并后的首元结点</li>
<li>选取除1中结点两个链表中较小的首元结点作剩余结点合并后的首节点，作1中结点的下一个结点</li>
<li>直至有一个链表选取完全，首元结点为nullptr，则选取另一个链表的首元结点作剩余结点的首元结点</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>鲁棒性的校验于basecase中完成，即使传入nullptr仍可作处理</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-29"><a href="#Answer-29" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">Merge</span><span class="params">(ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//basecase</span></span><br><span class="line">	<span class="keyword">if</span> (pHead1 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> pHead2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pHead2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> pHead1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置指向合并后首结点的指针</span></span><br><span class="line">	ListNode* MergedHead = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pHead1-&gt;pValue &lt;= pHead2-&gt;pValue) &#123;</span><br><span class="line">		MergedHead = pHead1;</span><br><span class="line">		MergedHead-&gt;pNext = <span class="built_in">Merge</span>(pHead1-&gt;pNext, pHead2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		MergedHead = pHead2;</span><br><span class="line">		MergedHead-&gt;pNext = <span class="built_in">Merge</span>(pHead1, pHead2-&gt;pNext);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> MergedHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="27-树的子结构"><a href="#27-树的子结构" class="headerlink" title="27 树的子结构"></a>27 树的子结构</h1><blockquote>
<p>输入两棵二叉树A和B,判断B是不是A的子结构</p>
</blockquote>
<h2 id="Testing-case-32"><a href="#Testing-case-32" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(AB均为普通二叉树，树B 是/不是 A的子结构)</li>
<li>边界测试(AB至少有一棵为空，二叉树仅有左子树，仅有右子树)</li>
</ul>
<h2 id="Key-32"><a href="#Key-32" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>穷举递归</p>
<blockquote>
<p>A树的每一个结点都有可能作B子结构的根节点(匹配)，因此需要穷举遍历A中所有结点</p>
<ol>
<li>选择A树的当前根节点与当前正匹配的B的根节点作比较</li>
<li>若相等，则进而判断该A中该根节点的左右子树是否与B中当前正匹配的根节点相等</li>
<li>若左右子树均匹配，则返回true，否则返回false</li>
<li>若不相等，则选择A中下一个结点作匹配的根节点</li>
<li>直至当前匹配的B中根结点为nullptr，即匹配完成</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>double类型数据在判断是否相等时需要考虑精度问题，即 |x-y| 的绝对值在某个精度内方可判断x,y是否相等</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-30"><a href="#Answer-30" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasSubTree</span><span class="params">(TreeNode* pHead, TreeNode* pSHead)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断异常</span></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span> || pSHead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//设置返回值</span></span><br><span class="line">	<span class="keyword">bool</span> result = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断是否是否含有与sub根结点相同的结点</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">Equal</span>(pHead-&gt;pValue, pSHead-&gt;pValue)) &#123;</span><br><span class="line">		<span class="comment">//若根结点相同则继续判断是否含有sub子树</span></span><br><span class="line">		result = <span class="built_in">hasSubTreeCore</span>(pHead, pSHead);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//若该根结点与sub子树根结点不同，或该根结点下的子树与sub子树结构不同，则向下遍历</span></span><br><span class="line">	<span class="keyword">if</span> (!result) &#123;</span><br><span class="line">		result = <span class="built_in">hasSubTreeCore</span>(pHead-&gt;pLeft, pSHead);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!result) &#123;</span><br><span class="line">		result = <span class="built_in">hasSubTreeCore</span>(pHead-&gt;pRight, pSHead);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasSubTreeCore</span><span class="params">(TreeNode* pHead, TreeNode* pSHead)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//base case</span></span><br><span class="line">	<span class="keyword">if</span> (pSHead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//判断当前结点是否相同</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">Equal</span>(pHead-&gt;pValue, pSHead-&gt;pValue)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//递归判断左右子树是否结构相同</span></span><br><span class="line">	<span class="keyword">bool</span> hasLeftSub = <span class="built_in">hasSubTreeCore</span>(pHead-&gt;pLeft, pSHead-&gt;pLeft);</span><br><span class="line">	<span class="keyword">bool</span> hasRightSub = <span class="built_in">hasSubTreeCore</span>(pHead-&gt;pRight, pSHead-&gt;pRight);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> hasLeftSub &amp;&amp; hasRightSub;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Equal</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (x - y &gt;= <span class="number">-0.001</span>) &amp;&amp; (x - y &lt;= <span class="number">0.001</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="28-二叉树的镜像"><a href="#28-二叉树的镜像" class="headerlink" title="28 二叉树的镜像"></a>28 二叉树的镜像</h1><blockquote>
<p>请完成一个函数,输入一棵二叉树,该函数输出它的镜像</p>
</blockquote>
<h2 id="Testing-case-33"><a href="#Testing-case-33" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(普通二叉树，仅有一个结点的二叉树，仅有左/右子树的二叉树)</li>
<li>边界测试(nullptr)</li>
</ul>
<h2 id="Key-33"><a href="#Key-33" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>递归交换</p>
<blockquote>
<ol>
<li>先序遍历一颗二叉树</li>
<li>每到根节点时交换根节点的左右子树，递归向下继续遍历</li>
<li>直至根节点为nullptr</li>
</ol>
</blockquote>
</li>
<li><p>层次遍历</p>
<blockquote>
<ol>
<li>使用队列进行层次遍历</li>
<li>每遍历到一个结点，将其左右子树交换后再重新压入队列</li>
<li>直至队列为空，即遍历完成</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-31"><a href="#Answer-31" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<p>1.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TreeMirro</span><span class="params">(TreeNode* pHead)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//base case</span></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//先根遍历的同时交换左右子结点，由根开始</span></span><br><span class="line">	TreeNode* pTemp = pHead-&gt;pLeft;</span><br><span class="line">	pHead-&gt;pLeft = pHead-&gt;pRight;</span><br><span class="line">	pHead-&gt;pRight = pTemp;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; pHead-&gt;pValue &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//左子树</span></span><br><span class="line">	<span class="keyword">if</span> (pHead-&gt;pLeft) &#123;</span><br><span class="line">		<span class="built_in">TreeMirro</span>(pHead-&gt;pLeft);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pHead-&gt;pRight) &#123;</span><br><span class="line">		<span class="built_in">TreeMirro</span>(pHead-&gt;pRight);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Non_RecursiveTreeMirro</span><span class="params">(TreeNode* pHead)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断异常</span></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//使用队列完成非递归遍历</span></span><br><span class="line">	queue&lt;TreeNode*&gt; Tqueue;</span><br><span class="line">	Tqueue.<span class="built_in">push</span>(pHead);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//层次遍历</span></span><br><span class="line">	<span class="keyword">while</span> (!Tqueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//弹出根结点</span></span><br><span class="line">		TreeNode* pTempHead = Tqueue.<span class="built_in">front</span>();</span><br><span class="line">		Tqueue.<span class="built_in">pop</span>();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//交换根节点的左右子树</span></span><br><span class="line">		TreeNode* pTemp = pTempHead-&gt;pLeft;</span><br><span class="line">		pTempHead-&gt;pLeft = pTempHead-&gt;pRight;</span><br><span class="line">		pTempHead-&gt;pRight = pTemp;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; pTempHead-&gt;pValue &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将交换后的左右子树压入队列遍历交换</span></span><br><span class="line">		<span class="keyword">if</span> (pTempHead-&gt;pLeft) &#123;</span><br><span class="line">			Tqueue.<span class="built_in">push</span>(pTempHead-&gt;pLeft);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        		<span class="keyword">if</span> (pTempHead-&gt;pRight) &#123;</span><br><span class="line">        			Tqueue.<span class="built_in">push</span>(pTempHead-&gt;pRight);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="29-对称的二叉树"><a href="#29-对称的二叉树" class="headerlink" title="29 对称的二叉树"></a>29 对称的二叉树</h1><blockquote>
<p>请实现一个函数,用来判断一棵二叉树是不是对称的</p>
<p>如果一棵二叉树和它的镜像一样,那么它是对称的</p>
</blockquote>
<h2 id="Testing-case-34"><a href="#Testing-case-34" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(对称/部队称的二叉树)</li>
<li>边界测试(nullptr，只有一个结点的二叉树，所有结点值相同的二叉树)</li>
</ul>
<h2 id="Key-34"><a href="#Key-34" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>对称前序遍历</p>
<blockquote>
<p>使用一个递归同时完成前序遍历与对称前序遍历，对称前序遍历为根右左</p>
<ol>
<li>设置递归的参数结点为两个，一个为前序遍历的结点，一个为对称前序遍历的结点</li>
<li>判断当前前序与对称前序遍历的结点的值是否相等，相等继续判断之后遍历结点的值是否相等(根左右-根右左)，若不相等则不对称</li>
<li>直至两种遍历次序下的结点同时为空，若不同时为空，表明不对称</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>对称为结构对称与值对称，若各结点值均相等，则需要将nullptr的孩子结点考虑在内，进而判断结构是否对称</li>
<li>通过设置两个参数同时完成两种遍历次序的递归，进而同时完成对称结点的相等判断</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-32"><a href="#Answer-32" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetry</span><span class="params">(TreeNode* pHead)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断异常</span></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">isSymmetryCore</span>(pHead, pHead);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetryCore</span><span class="params">(TreeNode* pHead, TreeNode* pSHead)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//base case</span></span><br><span class="line">	<span class="comment">//若前序遍历与对称前序遍历的头结点同时为空，满足对称条件</span></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span> &amp;&amp; pSHead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//若前序遍历与对称前序遍历的头结点不同时为空，则不满足对称条件</span></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span> || pSHead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(pHead-&gt;pValue == pSHead-&gt;pValue)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//递归判断前序遍历与对称前序遍历的结点</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">isSymmetryCore</span>(pHead-&gt;pLeft, pSHead-&gt;pRight) &amp;&amp; <span class="built_in">isSymmetryCore</span>(pHead-&gt;pRight, pSHead-&gt;pLeft);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="30-顺时针打印矩阵"><a href="#30-顺时针打印矩阵" class="headerlink" title="30 顺时针打印矩阵"></a>30 顺时针打印矩阵</h1><blockquote>
<p>输入一个矩阵,按照从外向里以顺时针的顺序依次打印出每一个数字</p>
</blockquote>
<h2 id="Testing-case-35"><a href="#Testing-case-35" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(数组具有多行多列，数组只有一行/一列)</li>
<li>边界测试(nullptr)</li>
</ul>
<h2 id="Key-35"><a href="#Key-35" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>逐圈输出</p>
<blockquote>
<ol>
<li>每次循环从圈的起点 (start,start) [start取值0,1…k] 开始顺时针输出</li>
<li>记录圈右边界与下边界，先从起始行开始输出至右边界</li>
<li>若起始行下界仍有未输出元素，则从当前列开始，起始行下一行向下输出该列元素，至下界</li>
<li>若右边界列左边仍有未输出元素，则从当前行开始，右边界列的前一行开始向左(前)输出该行元素，至左界</li>
<li>若左边界列的上边仍有未输出元素，则从当前列开始，下边界的上一行开始向上输出该列元素，至起始行的下一行</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>因为矩阵不是方阵，因此循环次数判断时需要行列分别判断是否大于 2 * start</li>
<li>将通过二级指针参数传递二维数组时，可以动态创建一个一级指针数组，使用二级指针指向，并使用已创建的二维数组的各行为其初始化后再传递该二级指针</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-33"><a href="#Answer-33" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sprint</span><span class="params">(<span class="keyword">int</span>** arr, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="literal">nullptr</span> || rows &lt;= <span class="number">0</span> || cols &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		hasException = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断循环输出圈的次数</span></span><br><span class="line">	<span class="keyword">while</span> (rows &gt; <span class="number">2</span> * start &amp;&amp; cols &gt; <span class="number">2</span> * start) &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">SprintCore</span>(arr, rows, cols, start);</span><br><span class="line">		start++;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SprintCore</span><span class="params">(<span class="keyword">int</span>** arr, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//当前坐上结点的坐标为 (start,start)</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//记录当前待输出圈的边界</span></span><br><span class="line">	<span class="keyword">int</span> endX = cols - <span class="number">1</span> - start;</span><br><span class="line">	<span class="keyword">int</span> endY = rows - <span class="number">1</span> - start;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//输出圈的上半部分</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= endX; i++) &#123;</span><br><span class="line">		cout &lt;&lt; arr[start][i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//判断圈是否需要继续向下输出右半部分</span></span><br><span class="line">	<span class="keyword">if</span> (endY &gt; start) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= endY; i++) &#123;</span><br><span class="line">			cout &lt;&lt; arr[i][endX] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//判断圈是否需要继续向左输出下半部分</span></span><br><span class="line">	<span class="keyword">if</span> (endY &gt; start &amp;&amp; endX &gt; start) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = endX - <span class="number">1</span>; i &gt;= start; i--) &#123;</span><br><span class="line">			cout &lt;&lt; arr[endY][i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//判断圈是否需要继续向上输出左半部分</span></span><br><span class="line">	<span class="keyword">if</span> (endY - <span class="number">1</span> &gt; start &amp;&amp; endX &gt; start) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = endY - <span class="number">1</span>; i &gt; start; i--) &#123;</span><br><span class="line">			cout &lt;&lt; arr[i][start] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="31-包含min函数的栈"><a href="#31-包含min函数的栈" class="headerlink" title="31 包含min函数的栈"></a>31 包含min函数的栈</h1><blockquote>
<p>定义栈的数据结构,请在该类型中实现一个能够得到栈的最小元素的min函数</p>
<p>在该栈中,调用min,push及pop的时间复杂度都是O(1)</p>
</blockquote>
<h2 id="Testing-case-36"><a href="#Testing-case-36" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>新压入的元素比数据栈中元素小</li>
<li>新压入的元素比数据栈中元素大</li>
<li>新弹出的元素是最小元素</li>
<li>新弹出的元素不是最小元素</li>
</ul>
<h2 id="Key-36"><a href="#Key-36" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>辅助栈记录数据栈的最小值状态</p>
<blockquote>
<ol>
<li>压入元素于数据栈，判断当前压入的元素与min栈栈顶元素的大小</li>
<li>若min栈为空，表示当前数据栈无元素，直接压入即可</li>
<li>否则将小的元素再次压入min栈，作为当前数据栈的最小元素，位于min栈栈顶</li>
<li>弹出时，若栈非空，则同时弹出数据栈，min栈的栈顶</li>
<li>取数据栈当前的最小元素直接取当前min栈的栈顶即可</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>为了保证O(1)的复杂度，因此必须在数据栈元素全部压入前进行最小值状态记录，否则压入后记录只能从栈顶取出</li>
<li>为保证min栈的每个元素均对应数据栈每一种状态下的最小值，需要保证两栈元素个数相同，即使压入的元素与当前最小值相同，仍需再次压入min栈</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-34"><a href="#Answer-34" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackWithMin</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">StackWithMin</span>() = <span class="keyword">default</span>;</span><br><span class="line">	~<span class="built_in">StackWithMin</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//压入元素</span></span><br><span class="line">		m_data.<span class="built_in">push</span>(value);</span><br><span class="line">		<span class="comment">//更新min栈的栈顶元素</span></span><br><span class="line">		<span class="keyword">if</span> (m_min.<span class="built_in">size</span>() == <span class="number">0</span> || value &lt;= m_min.<span class="built_in">top</span>()) &#123;</span><br><span class="line">			<span class="comment">//若min栈为空或者压入的元素为最小元素，即小于等于min栈栈顶元素</span></span><br><span class="line">			m_min.<span class="built_in">push</span>(value);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//保持两栈元素个数相等，保证min栈的每个栈顶元素均对应data栈不同状态下的最小值</span></span><br><span class="line">			m_min.<span class="built_in">push</span>(m_min.<span class="built_in">top</span>());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (m_data.<span class="built_in">size</span>() != <span class="number">0</span> &amp;&amp; m_min.<span class="built_in">size</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">			m_data.<span class="built_in">pop</span>();</span><br><span class="line">			m_min.<span class="built_in">pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">const</span> T&amp; <span class="title">getMin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (m_min.<span class="built_in">size</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> m_min.<span class="built_in">top</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	stack&lt;T&gt; m_data;</span><br><span class="line">	stack&lt;T&gt; m_min;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="32-栈的压入-弹出序列"><a href="#32-栈的压入-弹出序列" class="headerlink" title="32 栈的压入,弹出序列"></a>32 栈的压入,弹出序列</h1><blockquote>
<p>输入两个整数序列,第一个序列表示栈的压入顺序,请判断第二个序列是否为该栈的弹出顺序,假设压入栈的所有数字均不相等</p>
</blockquote>
<h2 id="Testing-case-37"><a href="#Testing-case-37" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(输入的数组有两个数字，一个数字，第二个序列是/不是第一个序列的输出序列)</li>
<li>边界测试(nullptr)</li>
</ul>
<h2 id="Key-37"><a href="#Key-37" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>辅助栈模拟序列的输入输出</p>
<blockquote>
<ol>
<li>从输出队列入手，遍历输出队列的每一个元素，判断当前输出队列元素是否与辅助栈中栈顶元素匹配</li>
<li>若匹配，将栈顶元素弹出，输出队列指针后移判断下一个元素是否匹配</li>
<li>若不匹配或者栈为空，则判断输入队列的元素是否已全部入栈，若未全部入栈，则将输入队列的中的一个元素压栈，进而继续1中判断</li>
<li>若输入队列的元素已全部入栈，且输出队列未遍历完毕，则不是匹配序列，退出遍历</li>
<li>若输出队列元素已全部匹配且栈为空，则是匹配队列</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-35"><a href="#Answer-35" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isIOMatch</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* pInput, <span class="keyword">const</span> <span class="keyword">int</span>* pOutput, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//设置返回值</span></span><br><span class="line">	<span class="keyword">bool</span> imatch = <span class="literal">false</span>;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (pInput == <span class="literal">nullptr</span> || pOutput == <span class="literal">nullptr</span> || length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		isException = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> imatch;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建辅助栈</span></span><br><span class="line">	stack&lt;<span class="keyword">int</span>&gt; helperStack;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置临时指针</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span>* tInput = pInput;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span>* tOutput = pOutput;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//逐个判断输出队列中的各元素是否匹配</span></span><br><span class="line">	<span class="keyword">while</span> (tOutput - pOutput != length) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//若栈中无元素或者当前栈顶元素与输出指针指向的元素不匹配，则将输入队列的元素压入栈</span></span><br><span class="line">		<span class="keyword">if</span> (helperStack.<span class="built_in">size</span>() == <span class="number">0</span> || helperStack.<span class="built_in">top</span>() != *tOutput) &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (tInput - pInput == length) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			helperStack.<span class="built_in">push</span>(*tInput);</span><br><span class="line">			tInput++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//若当前栈顶元素与当前输出指针指向的元素，则将栈顶元素弹出，判断当前栈顶与输出指针的下一个指向是否匹配</span></span><br><span class="line">		<span class="keyword">if</span> (helperStack.<span class="built_in">top</span>() == *tOutput) &#123;</span><br><span class="line">			helperStack.<span class="built_in">pop</span>();</span><br><span class="line">			tOutput++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//若输出队列遍历完毕且辅助栈为空，则表示匹配</span></span><br><span class="line">	<span class="keyword">if</span> (helperStack.<span class="built_in">size</span>() == <span class="number">0</span> &amp;&amp; tOutput - pOutput == length) &#123;</span><br><span class="line">		imatch = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> imatch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="33-1-从上到下打印二叉树"><a href="#33-1-从上到下打印二叉树" class="headerlink" title="33.1 从上到下打印二叉树"></a>33.1 从上到下打印二叉树</h1><blockquote>
<p>不分行</p>
<p>从上到下打印二叉树从上到下打印出二叉树的每个节点,同一层的节点按照从左到右的顺序打印</p>
</blockquote>
<h2 id="Testing-case-38"><a href="#Testing-case-38" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(完全二叉树,只有左/右子树的二叉树)</li>
<li>边界测试(nullptr,只有一个结点的二叉树)</li>
</ul>
<h2 id="Key-38"><a href="#Key-38" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>辅助队列存储当前遍历结点的左右子结点</p>
<blockquote>
<ol>
<li>将根节点压入队列</li>
<li>遍历队列的队首节点，并弹出队列</li>
<li>若当前遍历节点含有左右子结点，则从左至右将左右子节点压入队列尾部，否则结束本次循环</li>
<li>重复步骤2，直至队列为空</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-36"><a href="#Answer-36" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printTree</span><span class="params">(TreeNode* pHead)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置辅助队列</span></span><br><span class="line">	deque&lt;TreeNode*&gt; deque;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//首先将根节点压入队列</span></span><br><span class="line">	deque.<span class="built_in">push_back</span>(pHead);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历</span></span><br><span class="line">	<span class="keyword">while</span> (deque.<span class="built_in">size</span>() != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//取出当前队列中的头元素</span></span><br><span class="line">		TreeNode* pTemp = deque.<span class="built_in">front</span>();</span><br><span class="line">		deque.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//输出元素</span></span><br><span class="line">		cout &lt;&lt; pTemp-&gt;pValue &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//若取出的结点含左右子树，则重新压入队列</span></span><br><span class="line">		<span class="keyword">if</span> (pTemp-&gt;pLeft)</span><br><span class="line">			deque.<span class="built_in">push_back</span>(pTemp-&gt;pLeft);</span><br><span class="line">		<span class="keyword">if</span> (pTemp-&gt;pRight)</span><br><span class="line">			deque.<span class="built_in">push_back</span>(pTemp-&gt;pRight);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="33-2-从上到下打印二叉树"><a href="#33-2-从上到下打印二叉树" class="headerlink" title="33.2 从上到下打印二叉树"></a>33.2 从上到下打印二叉树</h1><blockquote>
<p>分行</p>
<p>从上到下打印二叉树从上到下打印出二叉树的每个节点,同一层的节点按照从左到右的顺序打印</p>
</blockquote>
<h2 id="Testing-case-39"><a href="#Testing-case-39" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(完全二叉树,只有左/右子树的二叉树)</li>
<li>边界测试(nullptr,只有一个结点的二叉树)</li>
</ul>
<h2 id="Key-39"><a href="#Key-39" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>辅助队列存储当前遍历结点的左右子结点</p>
<blockquote>
<ol>
<li>将根节点压入队列</li>
<li>遍历队列的队首节点，并弹出队列</li>
<li>若当前遍历节点含有左右子结点，则从左至右将左右子节点压入队列尾部，否则结束本次循环</li>
<li>重复步骤2，直至队列为空</li>
</ol>
</blockquote>
</li>
<li><p>状态记录变量</p>
<blockquote>
<ol>
<li>设置记录当前层仍未输出的节点数的变量 toBePrinted</li>
<li>设置记录下一层节点数的累加计数变量 numNextLayer</li>
<li>每遍历一个节点，toBePrinted减1，若减为0，则表示本层节点输出完毕，应换行</li>
<li>每将一个节点压入队列，numNextLayer增1，记录下一层的节点数，直至toBePrinted为0(本层节点输出完毕)时，使用numNextLayer更新toBePrinted，并将自身重置为0，进行下一层节点的输出</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-37"><a href="#Answer-37" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lprintTree</span><span class="params">(TreeNode* pHead)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置辅助队列</span></span><br><span class="line">	deque&lt;TreeNode*&gt; deque;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//首先将根节点压入队列</span></span><br><span class="line">	deque.<span class="built_in">push_back</span>(pHead);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置状态记录变量</span></span><br><span class="line">	<span class="comment">//记录下一层的节点个数</span></span><br><span class="line">	<span class="keyword">int</span> NextLayer = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//记录本层仍未输出的节点个数</span></span><br><span class="line">	<span class="keyword">int</span> toBePrinted = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历</span></span><br><span class="line">	<span class="keyword">while</span> (deque.<span class="built_in">size</span>() != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//取出当前队列中的头元素</span></span><br><span class="line">		TreeNode* pTemp = deque.<span class="built_in">front</span>();</span><br><span class="line">		deque.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//输出元素</span></span><br><span class="line">		cout &lt;&lt; pTemp-&gt;pValue &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		toBePrinted--;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//若取出的结点含左右子树，则重新压入队列</span></span><br><span class="line">		<span class="keyword">if</span> (pTemp-&gt;pLeft) &#123;</span><br><span class="line">			deque.<span class="built_in">push_back</span>(pTemp-&gt;pLeft);</span><br><span class="line">			NextLayer++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (pTemp-&gt;pRight) &#123;</span><br><span class="line">			deque.<span class="built_in">push_back</span>(pTemp-&gt;pRight);</span><br><span class="line">			NextLayer++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (toBePrinted == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">//本层的元素输出完毕，换行，进行下一行元素的输出</span></span><br><span class="line">			cout &lt;&lt; endl;</span><br><span class="line">			<span class="comment">//更新toBePrinted为下一层应输出的节点数</span></span><br><span class="line">			toBePrinted = NextLayer;</span><br><span class="line">			<span class="comment">//重置NextLayer，记录下一层的下一层节点数</span></span><br><span class="line">			NextLayer = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="33-3-从上到下打印二叉树"><a href="#33-3-从上到下打印二叉树" class="headerlink" title="33.3 从上到下打印二叉树"></a>33.3 从上到下打印二叉树</h1><blockquote>
<p>之字形打印二叉树</p>
<p>请实现一个函数按照之字形顺序打印二叉树,即第一行按照从左到右的顺序打印,第二层按照从右到左的顺序打印,第三行再按照从左到右的顺序打印,其他行以此类推</p>
</blockquote>
<h2 id="Testing-case-40"><a href="#Testing-case-40" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(完全二叉树,只有左/右子树的二叉树)</li>
<li>边界测试(nullptr,只有一个结点的二叉树)</li>
</ul>
<h2 id="Key-40"><a href="#Key-40" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>双栈完成之字形输出更替</p>
<blockquote>
<ol>
<li>将根节点压入栈1</li>
<li>遍历栈1元素，逐个将栈1中的元素弹出，并将弹出的每个元素的左右节点按自左向右的顺序压入栈2，直至栈1为空，并输出换行</li>
<li>遍历栈2元素，逐个将栈2中的元素弹出，并将弹出的每个元素的左右节点按自右向左的顺序压入栈1，直至栈2为空，并输出换行</li>
<li>重复2,3直至栈2与栈3均为空</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-38"><a href="#Answer-38" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SprintTree</span><span class="params">(TreeNode* pHead)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置两个辅助栈</span></span><br><span class="line">	deque&lt;TreeNode*&gt; deque1;</span><br><span class="line">	deque&lt;TreeNode*&gt; deque2;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//首先将根节点压入栈1</span></span><br><span class="line">	deque1.<span class="built_in">push_back</span>(pHead);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历</span></span><br><span class="line">	<span class="keyword">while</span> (deque1.<span class="built_in">size</span>() != <span class="number">0</span> || deque1.<span class="built_in">size</span>() != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//取出并遍历栈1中的元素</span></span><br><span class="line">		<span class="keyword">while</span> (deque1.<span class="built_in">size</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">			TreeNode* pTemp = deque1.<span class="built_in">back</span>();</span><br><span class="line">			deque1.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">			<span class="comment">//输出元素</span></span><br><span class="line">			cout &lt;&lt; pTemp-&gt;pValue &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//若取出的结点含左右子树，则自左向右压入栈2</span></span><br><span class="line">			<span class="keyword">if</span> (pTemp-&gt;pLeft) &#123;</span><br><span class="line">				deque2.<span class="built_in">push_back</span>(pTemp-&gt;pLeft);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (pTemp-&gt;pRight) &#123;</span><br><span class="line">				deque2.<span class="built_in">push_back</span>(pTemp-&gt;pRight);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//取出并遍历栈2中的元素</span></span><br><span class="line">		<span class="keyword">while</span> (deque2.<span class="built_in">size</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">			TreeNode* pTemp2 = deque2.<span class="built_in">back</span>();</span><br><span class="line">			deque2.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">			<span class="comment">//输出元素</span></span><br><span class="line">			cout &lt;&lt; pTemp2-&gt;pValue &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//若取出的结点含左右子树，则自右向左压入栈1</span></span><br><span class="line">			<span class="keyword">if</span> (pTemp2-&gt;pRight) &#123;</span><br><span class="line">				deque1.<span class="built_in">push_back</span>(pTemp2-&gt;pRight);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (pTemp2-&gt;pLeft) &#123;</span><br><span class="line">				deque1.<span class="built_in">push_back</span>(pTemp2-&gt;pLeft);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="34-二叉搜索树的后序遍历序列"><a href="#34-二叉搜索树的后序遍历序列" class="headerlink" title="34 二叉搜索树的后序遍历序列"></a>34 二叉搜索树的后序遍历序列</h1><blockquote>
<p>输入一个整数数组,判断该数组是不是某二叉搜索树的后序遍历结果</p>
<p>如果是则返回true,否则返回false,假设输入的数组的任意数字都互不相同</p>
</blockquote>
<h2 id="Testing-case-41"><a href="#Testing-case-41" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(后序遍历序列对应/不对应一颗搜索二叉树，二叉树可以为完全二叉搜索树，普通二叉搜索树，无左/右子树的二叉搜索树，只有一个结点的二叉树)</li>
<li>边界测试(nullptr)</li>
</ul>
<h2 id="Key-41"><a href="#Key-41" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>递归</p>
<blockquote>
<ol>
<li>二叉树后序遍历序列的最后一个节点为本树的根节点，选取该根节点</li>
<li>结合二叉搜索树的性质，找寻序列根节点之前第一个比根节点的大的节点作为该根节点左右子树的分界</li>
<li>在左子树满足均小于根节点的性质下，判断右子树中是否存在比根节点小的节点</li>
<li>完成一轮二叉搜索树判断后，进而递归判断该根节点的左右子树是否也满足二叉搜索树性质</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>二叉树的后序遍历序列的最后一个节点为根节点</li>
<li>二叉搜索树根节点的左子树所有节点均小于根节点，右子树的所有节点均大于根节点</li>
<li>递归时通过序列首部与序列长度确定左右子树范围，若当前根节点无左/右子树，则无需判断</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-39"><a href="#Answer-39" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span>* Seq, <span class="keyword">int</span> Slength)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (Seq == <span class="literal">nullptr</span> || Slength &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断当前根节点与其左右子树是否满足二叉搜索树</span></span><br><span class="line">	<span class="comment">//取当前根节点</span></span><br><span class="line">	<span class="keyword">int</span> root = Seq[Slength - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//找寻第一个比根节点大节点作为左右子树分界，此时左子树均比根节点小</span></span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (; i &lt; Slength - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (Seq[i] &gt; root) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断该根节点右子树是否存在比其小的节点</span></span><br><span class="line">	<span class="keyword">int</span> j = i;</span><br><span class="line">	<span class="keyword">for</span> (; j &lt; Slength - <span class="number">1</span>; j++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (Seq[j] &lt; root) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//此时根节点左子树的节点均比根节点小，右子树的节点均比根节点大，满足二叉搜索树性质</span></span><br><span class="line">	<span class="comment">//--------------------------------------------------------------------</span></span><br><span class="line">	<span class="comment">//进而判断该根节点的左右子树是否满足二叉搜索树性质</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//若含左子树，则判断左子树是否满足二叉搜索树性质</span></span><br><span class="line">	<span class="keyword">bool</span> left = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">		left = <span class="built_in">VerifySquenceOfBST</span>(Seq, i);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//若含右子树，判断右子树是否满足二叉搜索树性质</span></span><br><span class="line">	<span class="keyword">bool</span> Right = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (i &lt; Slength - <span class="number">1</span>)</span><br><span class="line">		Right = <span class="built_in">VerifySquenceOfBST</span>(Seq + i, Slength - i - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> left &amp;&amp; Right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="35-二叉树中和为某一值的路径"><a href="#35-二叉树中和为某一值的路径" class="headerlink" title="35 二叉树中和为某一值的路径"></a>35 二叉树中和为某一值的路径</h1><blockquote>
<p>输入一棵二叉树和一个整数,打印出二叉树中节点值的和为输入整数的所有路径</p>
<p>从树的<strong>根节点开始</strong>往下<strong>一直到叶节点</strong>所经过的节点形成一条<strong>路径</strong>。二叉树节点的定义如下:</p>
</blockquote>
<h2 id="Testing-case-42"><a href="#Testing-case-42" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(二叉树中有一/多条符合的路径，二叉树中没有符合的路径)</li>
<li>边界测试(nullptr)</li>
</ul>
<h2 id="Key-42"><a href="#Key-42" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>先序遍历寻找路径</p>
</li>
<li><p>设置路径数组与状态记录变量来记录当前路径状态</p>
<blockquote>
<ol>
<li>先序遍历二叉树，当遍历到根节点时，将当前节点压入数组并记录当前路径累加和</li>
<li>若当前路径数组中的结点已构成一条路径(当前压入的结点为叶子结点)且满足期望和，则对数组中的路径序列进行输出</li>
<li>否则递归判断左右子树(若含有左右子树)的路径情况</li>
<li>若已为一条路径却不满足期望和，则先将当前结点从路径数组中弹出后继续遍历</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>当前结点从路径数组中弹出后累加和currentSum也需要回退，但是currentSum为值传递，在递归回溯再递归时，currentSum始终表示当前的累加和，也就是说当函数回到上一级时，当前currentSum的状态不再保存，自动还原到上一级的状态</li>
<li>树的路径为从根节点出发到叶子结点，因此若为到叶子结点但是期望值满足的并不符合路径要求</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-40"><a href="#Answer-40" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindPathInTree</span><span class="params">(TreeNode* pHead, <span class="keyword">int</span> ExpectedNum)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断异常</span></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置存储路径的容器与记录和的变量</span></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">	<span class="keyword">int</span> currentSum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//转调路径函数</span></span><br><span class="line">	<span class="built_in">FindPathInTree</span>(pHead, ExpectedNum, path, currentSum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindPathInTree</span><span class="params">(TreeNode* pHead, <span class="keyword">int</span> ExpectedNum, vector&lt;<span class="keyword">int</span>&gt;&amp; path, <span class="keyword">int</span> currentSum)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//先序遍历</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//将当前结点的值压入路径数组，记录当前路径</span></span><br><span class="line">	path.<span class="built_in">push_back</span>(pHead-&gt;pValue);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//累加和，记录当前路径和</span></span><br><span class="line">	currentSum += pHead-&gt;pValue;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断当前路径和是否为期望值且为一条树的路径(该结点为叶子结点)</span></span><br><span class="line">	<span class="keyword">if</span> (pHead-&gt;pLeft == <span class="literal">nullptr</span> &amp;&amp; pHead-&gt;pRight == <span class="literal">nullptr</span> &amp;&amp; ExpectedNum == currentSum) &#123;</span><br><span class="line">		<span class="comment">//找到一条路径，输出该路径</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Path1 : &quot;</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> i : path) &#123;</span><br><span class="line">			cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//先序遍历，判断左右子树中是否存在路径</span></span><br><span class="line">	<span class="keyword">if</span> (pHead-&gt;pLeft != <span class="literal">nullptr</span>)</span><br><span class="line">		<span class="built_in">FindPathInTree</span>(pHead-&gt;pLeft, ExpectedNum, path, currentSum);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pHead-&gt;pRight != <span class="literal">nullptr</span>)</span><br><span class="line">		<span class="built_in">FindPathInTree</span>(pHead-&gt;pRight, ExpectedNum, path, currentSum);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//直到找寻到叶子结点且不满足路径和才回退</span></span><br><span class="line">	path.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="36-复杂链表的复制"><a href="#36-复杂链表的复制" class="headerlink" title="36 复杂链表的复制"></a>36 复杂链表的复制</h1><blockquote>
<p>请实现函数ComplexListNode* Clone(ComplexListNode* pHead)，复制一个复杂链表</p>
<p>在复杂链表中,每个节点除了有一个m_pNext指针指向下一个节点,还有一个m_pSibling指针指向链表中的任意节点或者nullptr</p>
</blockquote>
<h2 id="Testing-case-43"><a href="#Testing-case-43" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(结点中m_pSibling指向自身，两个结点m_pSibling形成环状结构，链表只有一个结点)</li>
<li>边界测试(nullptr)</li>
</ul>
<h2 id="Key-43"><a href="#Key-43" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>复杂问题分解 T(n) = O(n) S(n) = 1</p>
<ol>
<li><p>对链表结点进行复制并与原链表链接 A-A‘-B-B’</p>
<blockquote>
<p>遍历原链表逐个结点复制，并将复制后的结点插入到原结点与原节点的下一个结点之间</p>
<p><code>注意:</code></p>
<ol>
<li>链接的作用在于进行第二步时，复制后结点的m_pSibling指向为其原结点的m_pSibling的下一个结点</li>
</ol>
</blockquote>
</li>
<li><p>对复制后且与原链表链接的新链表的m_pSibling指向更新</p>
<blockquote>
<p>遍历原链表每个结点，若其m_pSibling不为nullptr则将其复制结点(下一个结点)的m_pSibling置为其m_pSibling的下一个结点</p>
</blockquote>
</li>
<li><p>拆解链接链表并返回新链表头</p>
<blockquote>
<ol>
<li>遍历链接链表，通过两个指针实现将每一个结点的pNext指向其下下一个结点</li>
<li>pNode指针从头开始将其指向的结点的pNext指向其下下一个结点(原链表)</li>
<li>pCNode指针记录pNode的下一个结点，并将该结点的pNext指向其下下一个结点(复制后链表)</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>在拆解过程中应注意需要将原链表还原，因为整个复制过程是基于原链表的</li>
</ol>
</blockquote>
</li>
</ol>
</li>
<li><p>哈希表 T(n) = O(n) S(n) = n</p>
<blockquote>
<ol>
<li>完成链表结点的复制与pNext的指向复制</li>
<li>同时使用map容器完成原结点与相应复制结点映射关系的存储</li>
<li>同时遍历原链表与复制链表，将新链表结点的pSibiling指向置为相应原链表结点pSibiling指向在map中的映射即可</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-41"><a href="#Answer-41" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<p>1.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CopyNode</span><span class="params">(LinkNode* pHead)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建临时指针</span></span><br><span class="line">	LinkNode* pNode = pHead;</span><br><span class="line">	<span class="comment">//遍历链表并完成结点创建与链接</span></span><br><span class="line">	<span class="keyword">while</span> (pNode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		LinkNode* pCopyNode = <span class="keyword">new</span> <span class="built_in">LinkNode</span>();</span><br><span class="line">		pCopyNode-&gt;pSibling = <span class="literal">nullptr</span>;</span><br><span class="line">		<span class="comment">//复制结点</span></span><br><span class="line">		pCopyNode-&gt;pValue = pNode-&gt;pValue;</span><br><span class="line">		<span class="comment">//链接结点</span></span><br><span class="line">		pCopyNode-&gt;pNext = pNode-&gt;pNext;</span><br><span class="line">		pNode-&gt;pNext = pCopyNode;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//向下遍历</span></span><br><span class="line">		pNode = pCopyNode-&gt;pNext;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConnectSibiling</span><span class="params">(LinkNode* pHead)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建临时指针</span></span><br><span class="line">	LinkNode* pNode = pHead;</span><br><span class="line">	<span class="comment">//遍历链表并完成sibiling指向的复制</span></span><br><span class="line">	<span class="keyword">while</span> (pNode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="comment">//创建指向当前结点对应的复制结点的指针</span></span><br><span class="line">		LinkNode* pCopyNode = pNode-&gt;pNext;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//设置复制结点的sibiling指向</span></span><br><span class="line">		<span class="keyword">if</span> (pNode-&gt;pSibling)</span><br><span class="line">			pCopyNode-&gt;pSibling = pNode-&gt;pSibling-&gt;pNext;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//向下遍历</span></span><br><span class="line">		pNode = pCopyNode-&gt;pNext;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LinkNode* <span class="title">ConnectNext</span><span class="params">(LinkNode* pHead)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建临时遍历指针</span></span><br><span class="line">	LinkNode* pNode = pHead;</span><br><span class="line">	LinkNode* pCNode = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="comment">//创建最终存放复制链表头的指针</span></span><br><span class="line">	LinkNode* pCopyHead = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//首先确定复制后的链表头</span></span><br><span class="line">	pCopyHead = pNode-&gt;pNext;</span><br><span class="line">	<span class="comment">//还原原链表</span></span><br><span class="line">	pNode-&gt;pNext = pCopyHead-&gt;pNext;</span><br><span class="line">	<span class="comment">//初始化复制链表遍历指针</span></span><br><span class="line">	pCNode = pCopyHead;</span><br><span class="line">	<span class="comment">//向下遍历</span></span><br><span class="line">	pNode = pNode-&gt;pNext;</span><br><span class="line">	<span class="comment">//此时pNode位于pCNode之后一个结点</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (pNode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="comment">//将复制后的结点的指向更新，使其指向下一个复制后的结点</span></span><br><span class="line">		pCNode-&gt;pNext = pNode-&gt;pNext;</span><br><span class="line">		<span class="comment">//向下遍历</span></span><br><span class="line">		pCNode = pCNode-&gt;pNext;</span><br><span class="line">		<span class="comment">//将复制前的结点的指向更新，使其指向下一个复制前的结点</span></span><br><span class="line">		pNode-&gt;pNext = pCNode-&gt;pNext;</span><br><span class="line">		<span class="comment">//向下遍历</span></span><br><span class="line">		pNode = pNode-&gt;pNext;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pCopyHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LinkNode* <span class="title">CopyFromComplexList</span><span class="params">(LinkNode* pHead)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//分三步完成复杂链表的复制</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//第一步 复制每个结点并与原链表链接</span></span><br><span class="line">	<span class="built_in">CopyNode</span>(pHead);</span><br><span class="line">	<span class="comment">//第二步 将原链表的sibiling指向复制到新链表</span></span><br><span class="line">	<span class="built_in">ConnectSibiling</span>(pHead);</span><br><span class="line">	<span class="comment">//第三步 拆解链表，并完成新链表的pNext指向</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">ConnectNext</span>(pHead);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkNode* <span class="title">CopyFromComplexListByMap</span><span class="params">(LinkNode* pHead)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//复制结点并将结点对应关系存入Map</span></span><br><span class="line">	map&lt;LinkNode*, LinkNode*&gt; NodeMap;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置临时遍历指针,并完成链表头的复制</span></span><br><span class="line">	LinkNode* pNode = pHead;</span><br><span class="line">	LinkNode* pCopyHead = <span class="keyword">new</span> <span class="built_in">LinkNode</span>();</span><br><span class="line"></span><br><span class="line">	pCopyHead-&gt;pValue = pNode-&gt;pValue;</span><br><span class="line">	pCopyHead-&gt;pNext = <span class="literal">nullptr</span>;</span><br><span class="line">	pCopyHead-&gt;pSibling = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//map存放原结点与复制结点的映射</span></span><br><span class="line">	NodeMap[pNode] = pCopyHead;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//向下遍历</span></span><br><span class="line">	LinkNode* pCNode = pCopyHead;</span><br><span class="line">	pNode = pNode-&gt;pNext;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//遍历原链表完成结点的复制与映射的存放</span></span><br><span class="line">	<span class="keyword">while</span> (pNode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//结点复制</span></span><br><span class="line">		LinkNode* pCTemp = <span class="keyword">new</span> <span class="built_in">LinkNode</span>();</span><br><span class="line">		pCTemp-&gt;pValue = pNode-&gt;pValue;</span><br><span class="line">		pCTemp-&gt;pNext = <span class="literal">nullptr</span>;</span><br><span class="line">		pCTemp-&gt;pSibling = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//map存放原结点与复制结点的映射</span></span><br><span class="line">		NodeMap[pNode] = pCTemp;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//复制链表的链接</span></span><br><span class="line">		pCNode-&gt;pNext = pCTemp;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//向下遍历</span></span><br><span class="line">		pCNode = pCNode-&gt;pNext;</span><br><span class="line">		pNode = pNode-&gt;pNext;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重置遍历指针于链表表头</span></span><br><span class="line">	pNode = pHead;</span><br><span class="line">	pCNode = pCopyHead;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历原链表完成复制链表的pSibiling指向</span></span><br><span class="line">	<span class="keyword">while</span> (pNode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (pNode-&gt;pSibling != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			pCNode-&gt;pSibling = NodeMap[pNode-&gt;pSibling];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//向下遍历</span></span><br><span class="line">		pNode = pNode-&gt;pNext;</span><br><span class="line">		pCNode = pCNode-&gt;pNext;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pCopyHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="37-二叉搜索树与双向链表"><a href="#37-二叉搜索树与双向链表" class="headerlink" title="37 二叉搜索树与双向链表"></a>37 二叉搜索树与双向链表</h1><blockquote>
<p>输入一棵二叉搜索树,将该二叉搜索树转换成一个<strong>排序的双向链表</strong></p>
<p>要求不能创建任何新的节点,只能调整树中节点指针的指向</p>
</blockquote>
<h2 id="Testing-case-44"><a href="#Testing-case-44" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(二叉搜索树为完全二叉树，无左/右子树，只有一个结点)</li>
<li>边界测试(nullptr)</li>
</ul>
<h2 id="Key-44"><a href="#Key-44" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>中序遍历与链表尾部实时记录</p>
<blockquote>
<ol>
<li>中序遍历二叉搜索树并使用PointToListTail指针实时记录当前形成双向链表的尾部</li>
<li>遍历至根节点时，将该根节点与双向链表链接，并作为新的尾部</li>
<li>直至遍历结点为nullptr</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>二叉搜索树的中序遍历序列为小大排序的</li>
<li>一定要使用PointToListTail记录双向链表末尾结点，否则仅依靠递归返回当前遍历结点会遗漏部分结点</li>
<li>从最左下的最小结点开始将整个二叉搜索树串成一个小大排序的双向链表</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-42"><a href="#Answer-42" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">Convert</span><span class="params">(TreeNode* pHead)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置记录当前双向链表尾部的指针</span></span><br><span class="line">	TreeNode* PointToListTail = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="comment">//将尾部的指针一并传入进行递归</span></span><br><span class="line">	<span class="built_in">ConvertCore</span>(pHead, &amp;PointToListTail);</span><br><span class="line">	<span class="comment">//返回双向链表的首部</span></span><br><span class="line">	<span class="keyword">while</span> (PointToListTail != <span class="literal">nullptr</span> &amp;&amp; PointToListTail-&gt;pLeft != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		PointToListTail = PointToListTail-&gt;pLeft;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> PointToListTail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConvertCore</span><span class="params">(TreeNode* pHead, TreeNode** PointToListTail)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//设置遍历指针</span></span><br><span class="line">	TreeNode* pCurrentNode = pHead;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//basecase</span></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//中序遍历</span></span><br><span class="line">	<span class="keyword">if</span> (pCurrentNode-&gt;pLeft != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="built_in">ConvertCore</span>(pCurrentNode-&gt;pLeft, PointToListTail);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置当前根节点为双向链表的新尾部</span></span><br><span class="line">	pCurrentNode-&gt;pLeft = *PointToListTail;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (*PointToListTail != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		(*PointToListTail)-&gt;pRight = pCurrentNode;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	*PointToListTail = pCurrentNode;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将新双向链表与右子树连接</span></span><br><span class="line">	<span class="keyword">if</span> (pCurrentNode-&gt;pRight != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="built_in">ConvertCore</span>(pCurrentNode-&gt;pRight, PointToListTail);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="38-序列化二叉树"><a href="#38-序列化二叉树" class="headerlink" title="38 序列化二叉树"></a>38 序列化二叉树</h1><blockquote>
<p>请实现两个函数,分别用来序列化和反序列化二叉树</p>
</blockquote>
<h2 id="Testing-case-45"><a href="#Testing-case-45" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(二叉树为完全二叉树，无左/右子树，只有一个结点，值均相同的二叉树)</li>
<li>边界测试(nullptr)</li>
</ul>
<h2 id="Key-45"><a href="#Key-45" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>先序遍历 -序列化</p>
<blockquote>
<p>先序遍历二叉树，并且将根结点为nullptr的左右孩子使用特殊字符表示</p>
</blockquote>
</li>
<li><p>遍历序列化数组 -反序列化</p>
<blockquote>
<ol>
<li>遍历序列化数组，为数字元素创建结点，特殊字符元素跳过</li>
<li>直至序列化数组元素遍历完毕</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>递归条件以序列化数组为主，并且在设置当前根节点的左右子树时，应注意序列化数组指针的移动</li>
<li>二级指针的使用目的在于使用参数记录一级指针的改动(传出参数)，如序列化数组指针，根节点指针</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-43"><a href="#Answer-43" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用于异常判断的全局变量</span></span><br><span class="line"><span class="keyword">bool</span> hasException = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//序列化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Serializaion</span><span class="params">(TreeNode* pHead)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;$,&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//先序遍历</span></span><br><span class="line">	cout &lt;&lt; pHead-&gt;pValue &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">	<span class="built_in">Serializaion</span>(pHead-&gt;pLeft);</span><br><span class="line">	<span class="built_in">Serializaion</span>(pHead-&gt;pRight);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反序列化</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isNumber</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (c == <span class="string">&#x27;$&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		hasException = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReSerializaionCore</span><span class="params">(TreeNode** pRoot, <span class="keyword">char</span>** ser)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">isNumber</span>(**ser)) &#123;</span><br><span class="line">		*pRoot = <span class="keyword">new</span> <span class="built_in">TreeNode</span>();</span><br><span class="line">		(*pRoot)-&gt;pValue = **ser - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		(*pRoot)-&gt;pLeft = <span class="literal">nullptr</span>;</span><br><span class="line">		(*pRoot)-&gt;pRight = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//序列指针后移</span></span><br><span class="line">		(*ser)++;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">ReSerializaionCore</span>(&amp;((*pRoot)-&gt;pLeft), ser);</span><br><span class="line">		<span class="built_in">ReSerializaionCore</span>(&amp;((*pRoot)-&gt;pRight), ser);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (hasException)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		<span class="comment">//序列指针后移</span></span><br><span class="line">		(*ser)++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="39-1-字符串的排列"><a href="#39-1-字符串的排列" class="headerlink" title="39.1 字符串的排列"></a>39.1 字符串的排列</h1><blockquote>
<p>输入一个字符串,打印出该字符串中字符的所有排列</p>
</blockquote>
<h2 id="Testing-case-46"><a href="#Testing-case-46" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(字符串有一个或多个字符，字符串中存在值相同的元素)</li>
<li>边界测试(nullptr,字符串为空)</li>
</ul>
<h2 id="Key-46"><a href="#Key-46" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>决策树 + 分治 + 穷举递归    无需额外的内存</p>
<blockquote>
<ol>
<li>使用pCurrntStart指针，从第一个位置开始逐个存放全排列后的元素</li>
<li>当决策好pCurrntStart位置的元素时，递归对pCurrntStart后其余位置进行元素决策</li>
<li>在进行下一次同位置(同层)决策前，需要还原字符串的排列顺序</li>
<li>直至每个全排列位置均已决策相应的元素，输出一次全排列结果</li>
<li>直至首位置水平决策全部作出且各决策均完成全排列输出，完成该字符串所有决策输出</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>pCurrntStart指针用于指向当前正作元素决策的全排列位置，初始为全排列后第一个位置开始，即字符串的首位置</li>
<li>决策的所有选择来自于当前字符串的所有元素，为保证能够作出所有同层决策，因此需要对当前剩余元素进行遍历</li>
<li>在2的决策作出之前，需要还原字符串状态，否则下一次决策将无意义</li>
<li>该方法直接使用原字符串内存作为排列后字符串的存储内存</li>
</ol>
</blockquote>
</li>
<li><p>决策树 + 分治 + 穷举递归 额外分配存储内存</p>
<blockquote>
<ol>
<li>遍历原字符串vector1，将第一个位置所有情况进行穷举决策</li>
<li>选择当前决策的元素压入到vector2，进行递归下一位置的穷举决策</li>
<li>在进行下一位置的穷举决策之前需要弹出已决策元素</li>
<li>在进行同层其他决策前，需要恢复已从vector1中弹出的元素以及对应的vector2的排列状态</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>使用一个vector暂存目前排列状态，无需在原内存上通过指针的较复杂操作</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-44"><a href="#Answer-44" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<p>1.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Permutation</span><span class="params">(<span class="keyword">char</span>* arr)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">PermutationCore</span>(arr, arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PermutationCore</span><span class="params">(<span class="keyword">char</span>* pAllStart, <span class="keyword">char</span>* pCurrntStart)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//base case</span></span><br><span class="line">	<span class="keyword">if</span> (*pCurrntStart == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">		cout &lt;&lt; pAllStart &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历字符串的每个元素 -- 保证作出所有可能的水平决策</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">char</span>* pCur = pCurrntStart; *pCur != <span class="string">&#x27;\0&#x27;</span>; pCur++) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//决策结果为 pCur元素位于pCurrntStart位置 --水平决策</span></span><br><span class="line">		<span class="keyword">char</span> pTemp = *pCur;</span><br><span class="line">		*pCur = *pCurrntStart;</span><br><span class="line">		*pCurrntStart = pTemp;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//pCurrntStart位置之后位置递归进行决策 --垂直决策</span></span><br><span class="line">		<span class="built_in">PermutationCore</span>(pAllStart, pCurrntStart + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//还原字符串  --水平决策复原</span></span><br><span class="line">		pTemp = *pCur;</span><br><span class="line">		*pCur = *pCurrntStart;</span><br><span class="line">		*pCurrntStart = pTemp;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PermutationCore</span><span class="params">(vector&lt;<span class="keyword">char</span>&gt;&amp; ori, vector&lt;<span class="keyword">char</span>&gt;&amp; pmt)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//base case</span></span><br><span class="line">	<span class="keyword">if</span> (ori.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="comment">//输出当前的全排列结果</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> i : pmt) &#123;</span><br><span class="line">			cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历字符串的每个元素 -- 保证作出所有可能的水平决策</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ori.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将当前决策结果存放于pmt数组中去 --水平决策</span></span><br><span class="line">		pmt.<span class="built_in">push_back</span>(ori[i]);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//为了确保在剩余元素中作出下次垂直决策，需要将当前元素暂时弹出，因为需要恢复，因此先暂存</span></span><br><span class="line">		<span class="keyword">char</span> temp = ori[i];</span><br><span class="line">		ori.<span class="built_in">erase</span>(ori.<span class="built_in">begin</span>() + i);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//对已决策的下一个位置作出元素决策 --垂直决策</span></span><br><span class="line">		<span class="built_in">PermutationCore</span>(ori, pmt);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//还原  --水平决策复原</span></span><br><span class="line">		ori.<span class="built_in">insert</span>(ori.<span class="built_in">begin</span>() + i, temp);</span><br><span class="line">		pmt.<span class="built_in">pop_back</span>();</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="39-2-字符串的组合"><a href="#39-2-字符串的组合" class="headerlink" title="39.2 字符串的组合"></a>39.2 字符串的组合</h1><blockquote>
<p>输入一个字符串,打印出该字符串中字符的所有组合</p>
</blockquote>
<h2 id="Testing-case-47"><a href="#Testing-case-47" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(字符串有一个或多个字符，字符串中存在值相同的元素)</li>
<li>边界测试(nullptr,字符串为空)</li>
</ul>
<h2 id="Key-47"><a href="#Key-47" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>分治 + 决策树 + 递归</p>
<blockquote>
<ol>
<li>辅助接口函数完成n次子问题的循环，从求长度为1的组合开始一直至长度为n的组合</li>
<li>对当前指针指向的字符进行决策</li>
<li>若含当前元素，则将当前元素压入组合数组，并递归在剩余元素中求长度为 k-1 的元素组合</li>
<li>若不含当前元素，则递归在剩余元素中求长度为 k 的元素组合</li>
<li>在进行4之前需要对组合数组进行复原</li>
<li>直至组合数组中的元素达到要求的元素长度k，即k=0时，终止递归</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>n个字符串的左右组合问题可以拆解为n次 m个元素中找寻长度为k的元素组合 k=1,2,…,n</li>
<li>决策树的分支为2，两种选择分别为k长度的组合中含/不含当前元素</li>
<li>两种决策必须均作出，因此不可以使用if-else进行决策</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-45"><a href="#Answer-45" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Combination</span><span class="params">(<span class="keyword">char</span>* arr)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将n个元素的所有组合拆解为求n次 mlen个元素中长度为k的组合</span></span><br><span class="line">	<span class="keyword">char</span> *len = arr;</span><br><span class="line">	<span class="keyword">int</span> mlen = <span class="number">0</span>;</span><br><span class="line">	vector&lt;<span class="keyword">char</span>&gt; comb;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (; *len != <span class="string">&#x27;\0&#x27;</span>; len++) &#123;</span><br><span class="line">		mlen++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= mlen; k++) &#123;</span><br><span class="line">		<span class="built_in">CombinationCore</span>(arr, k, comb);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CombinationCore</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">int</span> k, vector&lt;<span class="keyword">char</span>&gt;&amp; comb)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//base case</span></span><br><span class="line">	<span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">//输出组合结果</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> i : comb) &#123;</span><br><span class="line">			cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (*str == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//对str中的每个元素进行决策 长度为k的组合是否含有当前元素</span></span><br><span class="line">	<span class="comment">//yes k个元素组合中含当前元素</span></span><br><span class="line">	comb.<span class="built_in">push_back</span>(*str);</span><br><span class="line">	<span class="comment">//在str剩余元素中取k-1个元素进行组合</span></span><br><span class="line">	<span class="built_in">CombinationCore</span>(str + <span class="number">1</span>, k - <span class="number">1</span>, comb);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//在进行同层结果为no的决策前，需要恢复</span></span><br><span class="line">	comb.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//no k个元素组合中不含当前元素</span></span><br><span class="line">	<span class="comment">//在str剩余元素中取k个元素进行组合</span></span><br><span class="line">	<span class="built_in">CombinationCore</span>(str + <span class="number">1</span>, k, comb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="39-3-8皇后摆法问题"><a href="#39-3-8皇后摆法问题" class="headerlink" title="39.3 8皇后摆法问题"></a>39.3 8皇后摆法问题</h1><blockquote>
<p>在8x8的国际象棋上摆放8个皇后,使其不能相互攻击,即任意两,个皇后不得处在同一行、同一列或者同一条对角线上</p>
<p>请问总共有多少种符合条件的摆法？</p>
</blockquote>
<h2 id="Testing-case-48"><a href="#Testing-case-48" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(整数数组长度为8)</li>
<li>边界测试(nullptr)</li>
</ul>
<h2 id="Key-48"><a href="#Key-48" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>全排列 + 筛选</p>
<blockquote>
<ol>
<li>使用长度为8的数组代表8个皇后的位置 (i,ColIndex[i]) 并为其初始化为0 - 7，角标 i 表示行，数组元素 ColIndex[i] 表示 i 列</li>
<li>对ColIndex数组各元素进行全排列，将各元素的所有列排列情况列出</li>
<li>选取不在同一行，同一列，同一对角线的排列进行输出并计数</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>因为使用了不同的下标表示8个皇后的行数，因此8个皇后此条件下一定不在同一行</li>
<li>因为使用了不同的元素初始化ColIndex数组，因此8个皇后此条件下一定不在同一列</li>
<li>在同一对角线 i - j == ColIndex[i] - ColIndex[j] || j - i == ColIndex[i] - ColIndex[j]</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-46"><a href="#Answer-46" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//记录符合条件的摆法</span></span><br><span class="line"><span class="keyword">int</span> Num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SameCheck</span><span class="params">(<span class="keyword">int</span>* str, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断是否存在同行，同列，同对角线的元素</span></span><br><span class="line">	<span class="comment">//双重循环时i，j必然不会相同，因此在于判断两元素是否在同一个对角线上</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i - j == str[i] - str[j] || j - i == str[i] - str[j]) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EightQueen</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">int</span> QueenNum)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">EightQueenCore</span>(arr, arr, QueenNum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EightQueenCore</span><span class="params">(<span class="keyword">int</span>* pAllStart, <span class="keyword">int</span>* pCurrntStart, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//base case</span></span><br><span class="line">	<span class="comment">//len为进行全排列的整数数目，当len减至0时，代表已将len长度的所有整数进行了全排列</span></span><br><span class="line">	<span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">		 </span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">SameCheck</span>(pAllStart, pCurrntStart - pAllStart))</span><br><span class="line">		&#123;</span><br><span class="line">			Num++;</span><br><span class="line">			<span class="keyword">int</span>* pStart = pAllStart;</span><br><span class="line">			cout &lt;&lt; Num &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">for</span> (; pStart &lt; pCurrntStart; pStart++) &#123;</span><br><span class="line">				cout &lt;&lt; *pStart &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历字符串的每个元素 -- 保证作出所有可能的水平决策</span></span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span>* pCur = pCurrntStart; i &lt; len; pCur++, i++) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//决策结果为 pCur元素位于pCurrntStart位置 --水平决策</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> pTemp = *pCur;</span><br><span class="line">		*pCur = *pCurrntStart;</span><br><span class="line">		*pCurrntStart = pTemp;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//pCurrntStart位置之后位置递归进行决策 --垂直决策</span></span><br><span class="line">		<span class="built_in">EightQueenCore</span>(pAllStart, pCurrntStart + <span class="number">1</span>, len - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//还原字符串  --水平决策复原</span></span><br><span class="line">		pTemp = *pCur;</span><br><span class="line">		*pCur = *pCurrntStart;</span><br><span class="line">		*pCurrntStart = pTemp;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="39-4-正方体顶点数分布"><a href="#39-4-正方体顶点数分布" class="headerlink" title="39.4 正方体顶点数分布"></a>39.4 正方体顶点数分布</h1><blockquote>
<p>输入一个含有8个数字的数组,判断有没有可能把这8个数字分别,放到正方体的8个顶点上</p>
<p>使得正方体上三组相对的面上的4个顶点的和都相等</p>
</blockquote>
<h2 id="Testing-case-49"><a href="#Testing-case-49" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(整数数组长度为8)</li>
<li>边界测试(nullptr)</li>
</ul>
<h2 id="Key-49"><a href="#Key-49" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>全排列 + 筛选</p>
<blockquote>
<ol>
<li>对传入的数组元素进行全排列</li>
<li>对全排列的结果进行筛选，若满足条件，则对分布情况进行输出</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>8个数字满足分布于正方体上的条件 a1+a2+a3+a4 == a5+a6+a7+a8 &amp;&amp; a1+a3+a5+a7 == a2+a4+a6+a8 &amp;&amp; a1+a2+a5+a6 == a3+a4+a7+a8</li>
</ol>
</blockquote>
</li>
</ul>
<h1 id="40-数组中出现次数超过一半的数字"><a href="#40-数组中出现次数超过一半的数字" class="headerlink" title="40 数组中出现次数超过一半的数字"></a>40 数组中出现次数超过一半的数字</h1><blockquote>
<p>数组中有一个数字出现的次数超过数组长度的一半,请找出这个数字</p>
<p>若不存在此数字则视为异常</p>
</blockquote>
<h2 id="Testing-case-50"><a href="#Testing-case-50" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(数组中 存在/不存在 次数超过一半的数字)</li>
<li>边界测试(nullptr，只有一个数字)</li>
</ul>
<h2 id="Key-50"><a href="#Key-50" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>排序后遍历计数 O(n) = nlogn</p>
</li>
<li><p>中位数 + 快排 O(n) = n</p>
<blockquote>
<ol>
<li>对数组进行快排划分，并记录返回的基数位置</li>
<li>若该基数位置不等于数组中位数位置 len &gt;&gt; 1(len / 2)，则继续在基数左/右继续划分记录基数位置</li>
<li>若基数位置大于数组中位数位置 len &gt;&gt; 1(len / 2)，则在基数左边的数字中寻找中位数位置</li>
<li>若基数位置小于数组中位数位置 len &gt;&gt; 1(len / 2)，则在基数右边的数字中寻找中位数位置</li>
<li>直至基数的位置等于数组中位数的位置，进一步判断该基数是否为要求数字</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>若数组中存在出现次数超过一半的数字，则该数字一定是数组的中位数</li>
<li>1的逆命题并不成立，在得到数组的中位数后应进一步判断是否为要求数</li>
</ol>
</blockquote>
</li>
<li><p>打擂 可能数字 -&gt; 确切数字 O(n) = n</p>
<blockquote>
<ol>
<li>设置result擂主与coefficient可能系数，遍历数组开始打擂</li>
<li>若下一个元素等于该result，则擂主可能系数加1，否则，擂主可能系数减一</li>
<li>若擂主系数减至0，则代表当前擂主不可能为要求数字，更换擂主并同时更新coefficient为1</li>
<li>最终得到最可能成为要求数字的擂主后进行最终遍历计数判断即可</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>数组中出现次数超过一半的数字只能有一个</li>
<li>coefficient可能系数并不代表result的出现次数，而是其成为要求数字的可能系数</li>
<li>若存在要求数字，则该数字一定是擂主并最终coefficient&gt;=1，但是若擂主最终coefficient&gt;=1，其不一定是要求数字，因此最后需要在此判断是否为要求数字</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-47"><a href="#Answer-47" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<p>1.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MedianMoreThanHalf</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IsValidInput</span>(arr, len)) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//记录数组的中位数位置</span></span><br><span class="line">	<span class="keyword">int</span> median = len &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取当前快排划分得到的基数位置</span></span><br><span class="line">	<span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> end = len - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> pivot = <span class="built_in">Partition</span>(arr, len, start, end);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//若此基数位置不为中位数，则在划分后的数中进而求基数位置直到基数位置等于median</span></span><br><span class="line">	<span class="keyword">while</span> (median != pivot) &#123;</span><br><span class="line">		<span class="keyword">if</span> (pivot &gt; median) &#123;</span><br><span class="line">			<span class="comment">//在基数左边的数字中寻找</span></span><br><span class="line">			end = pivot - <span class="number">1</span>;</span><br><span class="line">			pivot = <span class="built_in">Partition</span>(arr, len, start, end);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//在基数右边的数字中寻找</span></span><br><span class="line">			start = pivot + <span class="number">1</span>;</span><br><span class="line">			pivot = <span class="built_in">Partition</span>(arr, len, start, end);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//此时基数位置即为中位数位置，该基数可能为要求数，进一步判断</span></span><br><span class="line">	<span class="keyword">int</span> result = arr[pivot];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">IsMoreThanHalf</span>(arr, len, result)) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		result = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> len, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span> || start &lt; <span class="number">0</span> || end &gt;= len) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置small时刻指向当前最后一个比small小的元素</span></span><br><span class="line">	<span class="keyword">int</span> small = start - <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//数组某位暂存pivot基数 默认取start元素，此处并未随机</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> pivot = arr[start];</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">int</span> temp = arr[start];</span><br><span class="line">	arr[start] = arr[end];</span><br><span class="line">	arr[end] = temp;	</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历数组，以基数为基准进行划分</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> index = start; index &lt; end; index++) &#123;</span><br><span class="line">		<span class="comment">//若遍历元素比pivot基数小，则small后移，否则不作处理</span></span><br><span class="line">		<span class="keyword">if</span> (arr[index] &lt; pivot) &#123;</span><br><span class="line"></span><br><span class="line">			small++;</span><br><span class="line">			<span class="comment">//若遇到比pivot大的元素后又遇到比pivot小的元素，则small++后交换这两个元素位置</span></span><br><span class="line">			<span class="keyword">if</span> (index != small) &#123;</span><br><span class="line">				<span class="keyword">int</span> temp = arr[index];</span><br><span class="line">				arr[index] = arr[small];</span><br><span class="line">				arr[small] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将small指针指向pivot基数应存放位置</span></span><br><span class="line">	small++;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//交换基数与第一个比其大的元素</span></span><br><span class="line">	temp = arr[small];</span><br><span class="line">	arr[small] = arr[end];</span><br><span class="line">	arr[end] = temp;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> small;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&gt;<span class="function"><span class="keyword">bool</span> <span class="title">IsMoreThanHalf</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> len, <span class="keyword">int</span> result)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置bool变量返回值</span></span><br><span class="line">	<span class="keyword">bool</span> isMoreThanHalf = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//记录result在数组中的出现次数</span></span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (arr[i] == result) &#123;</span><br><span class="line">			num++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置全局异常判断变量初始为true</span></span><br><span class="line">	isExcption = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (num &gt; (len / <span class="number">2</span>)) &#123;</span><br><span class="line"></span><br><span class="line">		isExcption = <span class="literal">false</span>;</span><br><span class="line">		isMoreThanHalf = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> isMoreThanHalf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsValidInput</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> isExc = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		isExc = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> isExc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LikelyMoreThanHalf</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IsValidInput</span>(arr, len)) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置变量记录可能数字</span></span><br><span class="line">	<span class="keyword">int</span> result = arr[<span class="number">0</span>];</span><br><span class="line">	<span class="comment">//设置其可能系数</span></span><br><span class="line">	<span class="keyword">int</span> coefficient = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//挑选出数组中最可能成为result的数字</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (coefficient == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//若此系数减弱至0，则表示该数字不可能为终值，切换至下一个值		</span></span><br><span class="line">			result = arr[i];</span><br><span class="line">			<span class="comment">//重新设置系数为1</span></span><br><span class="line">			coefficient = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (result == arr[i]) &#123;</span><br><span class="line">			<span class="comment">//系数增强</span></span><br><span class="line">			coefficient++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//系数减弱</span></span><br><span class="line">			coefficient--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//检查result是否为终值</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">IsMoreThanHalf</span>(arr, len, result)) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		result = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="41-最小的k个数"><a href="#41-最小的k个数" class="headerlink" title="41 最小的k个数"></a>41 最小的k个数</h1><blockquote>
<p>输入n个整数,找出其中最小的k个数</p>
</blockquote>
<h2 id="Testing-case-51"><a href="#Testing-case-51" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(数组中有相同数字，数组中无相同数字)</li>
<li>边界测试(nullptr，k&lt;=1，k&gt;=数组长度)</li>
</ul>
<h2 id="Key-51"><a href="#Key-51" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>快排划分 T(n) = O(n)</p>
<blockquote>
<ol>
<li>对数组进行快排划分，并记录返回的基数的位置</li>
<li>若该基数位置不等于 k - 1，则继续在基数左/右继续划分记录基数位置</li>
<li>若基数位置大于 k - 1，则在基数左边的数字中寻找划分后基准位置为 k - 1 的划分</li>
<li>若基数位置小于 k - 1，则在基数右边的数字中寻找划分后基准位置为 k - 1 的划分</li>
<li>直至基数的位置等于 k - 1，对该基准左边的数字(含该基准)进行输出</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>若快排划分后的基准位置即第k位，则该基准左边的数字(含该基准)即为最小的k个数</li>
<li>划分将导致原数组被修改</li>
</ol>
</blockquote>
</li>
<li><p>红黑树 / 堆 T(n) = O(nlogk)</p>
<blockquote>
<ol>
<li>对于输入的元素，若容器大小小于k，则直接压入容器</li>
<li>否则判断当前输入元素与容器中最大元素的大小</li>
<li>若输入元素小，则替换当前容器最大元素，否则，跳过该输入元素</li>
<li>直至遍历完输入元素容器</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>大顶堆或者红黑树结构可以O(1)复杂度取得最大元素，O(logn)复杂度插入删除元素</li>
<li>适合用于数据庞大或者无法一次载入内存的情形</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-48"><a href="#Answer-48" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<p>1.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> len, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span> || start &lt; <span class="number">0</span> || end &gt;= len) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置small时刻指向当前最后一个比small小的元素</span></span><br><span class="line">	<span class="keyword">int</span> small = start - <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//数组某位暂存pivot基数 默认取start元素，此处并未随机</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> pivot = arr[start];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> temp = arr[start];</span><br><span class="line">	arr[start] = arr[end];</span><br><span class="line">	arr[end] = temp;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历数组，以基数为基准进行划分</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> index = start; index &lt; end; index++) &#123;</span><br><span class="line">		<span class="comment">//若遍历元素比pivot基数小，则small后移，否则不作处理</span></span><br><span class="line">		<span class="keyword">if</span> (arr[index] &lt; pivot) &#123;</span><br><span class="line"></span><br><span class="line">			small++;</span><br><span class="line">			<span class="comment">//若遇到比pivot大的元素后又遇到比pivot小的元素，则small++后交换这两个元素位置</span></span><br><span class="line">			<span class="keyword">if</span> (index != small) &#123;</span><br><span class="line">				<span class="keyword">int</span> temp = arr[index];</span><br><span class="line">				arr[index] = arr[small];</span><br><span class="line">				arr[small] = temp;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将small指针指向pivot基数应存放位置</span></span><br><span class="line">	small++;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//交换基数与第一个比其大的元素</span></span><br><span class="line">	temp = arr[small];</span><br><span class="line">	arr[small] = arr[end];</span><br><span class="line">	arr[end] = temp;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> small;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetLeastNumbers</span><span class="params">(<span class="keyword">int</span>* input, <span class="keyword">int</span> len, <span class="keyword">int</span>* output, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (input == <span class="literal">nullptr</span> || len &lt; <span class="number">0</span> || k &gt; len || k &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//基于快排划分找到划分基准为 k-1 的划分结果</span></span><br><span class="line">	<span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> end = len - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> index = <span class="built_in">Partition</span>(input, len, start, end);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (index != k - <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (index &gt; k - <span class="number">1</span>) &#123;</span><br><span class="line">			end = index - <span class="number">1</span>;</span><br><span class="line">			index = <span class="built_in">Partition</span>(input, len, start, end);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			start = index + <span class="number">1</span>;</span><br><span class="line">			index = <span class="built_in">Partition</span>(input, len, start, end);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将划分后的前k个元素存入输出数组</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">		output[i] = input[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetLeastNumbersByRB</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; data, SetType&amp; store, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (data.<span class="built_in">size</span>() == <span class="number">0</span> || k &lt; <span class="number">0</span> || k &gt; data.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历输入数组，将前k大的元素存入到store容器中</span></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;::const_iterator ite = data.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">for</span> (; ite &lt; data.<span class="built_in">end</span>(); ite++) &#123;</span><br><span class="line">		<span class="comment">//若容器元素未满k个，则直接插入</span></span><br><span class="line">		<span class="keyword">if</span> (store.<span class="built_in">size</span>() &lt; k) &#123;</span><br><span class="line">			store.<span class="built_in">insert</span>(*ite);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//若满k个且当前输入元素小于红黑树根结点，则替换掉该根节点</span></span><br><span class="line">			<span class="keyword">if</span> (*ite &lt; *store.<span class="built_in">begin</span>()) &#123;</span><br><span class="line">				store.<span class="built_in">erase</span>(*(store.<span class="built_in">begin</span>()));</span><br><span class="line">				store.<span class="built_in">insert</span>(*ite);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</blockquote>
<h1 id="42-数据流中的中位数"><a href="#42-数据流中的中位数" class="headerlink" title="42 数据流中的中位数"></a>42 数据流中的中位数</h1><blockquote>
<p>如何得到一个数据流中的中位数</p>
<p>如果从数据流中读出奇数个数1值,那么中位数就是所有数值排序之后位于中间的数值</p>
<p>如果从数据流中读出偶数个数值,那么中位数就是所有数值排序之后中间两个数的平均值</p>
</blockquote>
<h2 id="Testing-case-52"><a href="#Testing-case-52" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(数据流中有奇数/偶数个数字)</li>
<li>边界测试(数据流中无数字)</li>
</ul>
<h2 id="Key-52"><a href="#Key-52" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>快排划分 O(1) 插入 O(n) 中位数</p>
</li>
<li><p>排序数组 O(n) 插入 O(1) 中位数</p>
</li>
<li><p>排序链表 O(n)插入 O(1) 中位数</p>
</li>
<li><p>二叉搜索树 O(logn) - O(n) 插入 O(logn) - O(n) 中位数</p>
</li>
<li><p>AVL树 O(logn) 插入 O(1) 中位数</p>
</li>
<li><p>双堆 O(logn) 插入 O(1) 中位数</p>
<blockquote>
<ol>
<li>建立一个动态数组，动态数组底层为两个堆，一个是大顶堆，一个为小顶堆</li>
<li>每次向动态数组中压入数字时，若目前动态数组中的元素个数为偶数(0)，则压入到min堆，保证数据流中数字的均匀分配</li>
<li>若压入min堆时，max不为空，则应先于max堆顶元素比较，若小于max堆顶元素，则将max堆顶元素压入min堆，当前元素压入max堆</li>
<li>若目前动态数组中的元素个数为奇数，则压入到max堆</li>
<li>若压入max堆时，min不为空，则应先于min堆顶元素比较，若大于min堆顶元素，则将min堆顶元素压入max堆，当前元素压入min堆</li>
</ol>
<p>-</p>
<ol>
<li>求中位数时若当前动态数组元素个数为奇数，则返回min堆堆顶</li>
<li>否则返回 ( max[0] + min[0] ) / 2</li>
</ol>
<h2 id="Answer-49"><a href="#Answer-49" class="headerlink" title="Answer"></a>Answer</h2><p><code>注意:</code></p>
<ol>
<li>中位数将整个数组划分为两部分，这两部分有如下特点<ul>
<li>左边部分的数字均比右边部分的数字小</li>
<li>左边部分数字个数与右边数字个数相差不超过1</li>
<li>中位数为左边部分最大值/右边部分最小值/两者的平均值</li>
</ul>
</li>
<li>如果压入时动态数组中元素个数为偶数，则压入到min堆，否则压入到max堆，保证数据流中数字的均匀分配</li>
<li>选择DynamicArray封装当前数据流中的数据</li>
<li>push_heap,pop_heap 的操作对象必须为已经形成的堆</li>
<li>push_heap应确保元素已经压入堆中</li>
<li>pop_heap并不会弹出堆顶元素，只要将堆顶元素与堆尾元素交换，徐亚使用pop_back弹出</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-50"><a href="#Answer-50" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> isExcption = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DynamicArray</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">DynamicArray</span>() = <span class="keyword">default</span>;</span><br><span class="line">	~<span class="built_in">DynamicArray</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(T num)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">GetMedian</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	vector&lt;T&gt; max;</span><br><span class="line">	vector&lt;T&gt; min;</span><br><span class="line">&#125;;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> DynamicArray&lt;T&gt;::<span class="built_in">Insert</span>(T num) &#123;</span><br><span class="line">	<span class="comment">//如果压入时动态数组中元素个数为偶数，则压入到min堆，否则压入到max堆，保证数据流的均匀分配</span></span><br><span class="line">	<span class="keyword">if</span> (((max.<span class="built_in">size</span>() + min.<span class="built_in">size</span>()) &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">//若压入的元素比max堆中的最大元素大，则需要将该元素压入max堆并将max堆中最大元素压入min堆</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (max.<span class="built_in">size</span>() &gt; <span class="number">0</span> &amp;&amp; num &lt; max[<span class="number">0</span>]) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//将当前元素压入到max堆中</span></span><br><span class="line">			max.<span class="built_in">push_back</span>(num);</span><br><span class="line">			<span class="built_in">push_heap</span>(max.<span class="built_in">begin</span>(), max.<span class="built_in">end</span>(), less&lt;T&gt;());</span><br><span class="line">			num = max[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">			<span class="built_in">pop_heap</span>(max.<span class="built_in">begin</span>(), max.<span class="built_in">end</span>(), less&lt;T&gt;());</span><br><span class="line">			max.<span class="built_in">pop_back</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		min.<span class="built_in">push_back</span>(num);</span><br><span class="line">		<span class="built_in">push_heap</span>(min.<span class="built_in">begin</span>(), min.<span class="built_in">end</span>(), greater&lt;T&gt;());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//如果压入时动态数组中元素个数为奇数，则压入到max堆</span></span><br><span class="line">		<span class="comment">//若压入的元素比min堆中的最小大，则需要将该元素压入min堆并将min堆中最小元素压入max堆</span></span><br><span class="line">		<span class="keyword">if</span> (min.<span class="built_in">size</span>() &gt; <span class="number">0</span> &amp;&amp; num &gt; min[<span class="number">0</span>]) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//将当前元素压入到max堆中</span></span><br><span class="line">			min.<span class="built_in">push_back</span>(num);</span><br><span class="line">			<span class="built_in">push_heap</span>(min.<span class="built_in">begin</span>(), min.<span class="built_in">end</span>(), greater&lt;T&gt;());</span><br><span class="line"></span><br><span class="line">			num = min[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">			<span class="built_in">pop_heap</span>(min.<span class="built_in">begin</span>(), min.<span class="built_in">end</span>(), greater&lt;T&gt;());</span><br><span class="line">			min.<span class="built_in">pop_back</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		max.<span class="built_in">push_back</span>(num);</span><br><span class="line">		<span class="built_in">push_heap</span>(max.<span class="built_in">begin</span>(), max.<span class="built_in">end</span>(), less&lt;T&gt;());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">double</span> DynamicArray&lt;T&gt;::<span class="built_in">GetMedian</span>() &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断异常</span></span><br><span class="line">	<span class="keyword">int</span> size = max.<span class="built_in">size</span>() + min.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	T median;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((size &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">		median = (max[<span class="number">0</span>] + min[<span class="number">0</span>]) / <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		median = min[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> median;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="—-堆-—"><a href="#—-堆-—" class="headerlink" title="—- 堆 —-"></a>—- 堆 —-</h1><h2 id="Interfaces"><a href="#Interfaces" class="headerlink" title="Interfaces"></a>Interfaces</h2><ul>
<li><p>make_heap(start_ite,end_ite,functor)</p>
<blockquote>
<p>对于给定的范围元素生成堆，默认为大顶堆</p>
<p>start_ite: 指向开始元素的迭代器</p>
<p>end_ite: 指向末尾元素的迭代器</p>
<p>functor: greater&lt; T &gt;() - 小顶堆, less&lt; T &gt;() - 大顶堆</p>
</blockquote>
</li>
<li><p>push_heap(start_ite,end_ite,functor)</p>
<blockquote>
<p>在堆的基础上进行数据的插入，本身不会有数据插入操作，须确保数据已经插入后再作堆调整</p>
<p>start_ite: 指向开始元素的迭代器</p>
<p>end_ite: 指向末尾元素的迭代器</p>
<p>functor: greater&lt; T &gt;() - 小顶堆, less&lt; T &gt;() - 大顶堆</p>
</blockquote>
</li>
<li><p>pop_heap(start_ite,end_ite,functor)</p>
<blockquote>
<p>在堆的基础上进行堆顶的弹出，本身不会有数据弹出操作，仅仅是将堆顶元素与堆尾元素进行了交换</p>
<p>start_ite: 指向开始元素的迭代器</p>
<p>end_ite: 指向末尾元素的迭代器</p>
<p>functor: greater&lt; T &gt;() - 小顶堆, less&lt; T &gt;() - 大顶堆</p>
</blockquote>
</li>
</ul>
<h1 id="43-连续子数组的最大和"><a href="#43-连续子数组的最大和" class="headerlink" title="43 连续子数组的最大和"></a>43 连续子数组的最大和</h1><blockquote>
<p>输入一个整型数组,数组里有正数也有负数，数组中的一个或连续多个整数组成一个子数组</p>
<p>求所有子数组的和的最大值</p>
<p>要求时间复杂度为0(n)。</p>
</blockquote>
<h2 id="Testing-case-53"><a href="#Testing-case-53" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(输入的数组有正数有负数，全是正数，全是负数)</li>
<li>边界测试(nullptr)</li>
</ul>
<h2 id="Key-53"><a href="#Key-53" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>动态规划 T(n) = O(n)</p>
<blockquote>
<ol>
<li>正向迭代计算由f(0)至f(len-1)，并记录当前元素作连续子数组末尾时的最大和currentSum</li>
<li>使用打擂法计算 len 个元素的数组中的连续子数组的最大和MaxNum</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>连续子数组的最大和是数组某个元素作连续子数组末尾元素时的最大和</li>
<li>只需求出每个元素作连续子数组末尾元素时的最大和并记录最大值即可</li>
<li>递归分析可得第 i 个元素作连续子数组末尾元素时的最大和为，记为f(i)<ul>
<li>a(i) — f(i - 1) &lt;= 0 || i = 0</li>
<li>a(i) + f(i) — f(i - 1) &gt; 0 &amp;&amp; i &gt; 0</li>
</ul>
</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-51"><a href="#Answer-51" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetGreatestNum</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//记录第 i-1 元素为尾的最大子数组的和</span></span><br><span class="line">	<span class="keyword">int</span> currentSum = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//记录最大子数组的和</span></span><br><span class="line">	<span class="keyword">int</span> MaxNum = arr[<span class="number">0</span>];</span><br><span class="line">	<span class="comment">//正向迭代 求i元素为尾的最大子数组和</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (currentSum &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">//如果第 i-1 元素为尾的最大子数组和小于等于0，则舍弃之前元素，当前元素构成的子数组和即为当前位置的最大和</span></span><br><span class="line">			currentSum = arr[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//如果第 i-1 元素为尾的最大子数组和大于0，则累加</span></span><br><span class="line">			currentSum += arr[i];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//打擂记录最大子数组和</span></span><br><span class="line">		<span class="keyword">if</span> (currentSum &gt;= MaxNum) &#123;</span><br><span class="line">			MaxNum = currentSum;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> MaxNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="44-1-n-整数中1出现的次数-—跳过"><a href="#44-1-n-整数中1出现的次数-—跳过" class="headerlink" title="44 1-n 整数中1出现的次数  —跳过"></a>44 1-n 整数中1出现的次数  —跳过</h1><blockquote>
</blockquote>
<h2 id="Testing-case-54"><a href="#Testing-case-54" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(输入的数组有正数有负数，全是正数，全是负数)</li>
<li>边界测试(nullptr)</li>
</ul>
<h2 id="Key-54"><a href="#Key-54" class="headerlink" title="Key"></a>Key</h2><ul>
<li></li>
</ul>
<h2 id="Answer-52"><a href="#Answer-52" class="headerlink" title="Answer"></a>Answer</h2><h1 id="45-数字序列中的某一位数字"><a href="#45-数字序列中的某一位数字" class="headerlink" title="45 数字序列中的某一位数字"></a>45 数字序列中的某一位数字</h1><blockquote>
<p>数字以0123456789101112131415 的格式序列化到一个字符序列中</p>
<p>在这个序列中,第5位(从0开始计数)是5,第13位是1,第19位是4,等等</p>
<p>请写一个函数,求任意第n位对应的数字</p>
</blockquote>
<h2 id="Testing-case-55"><a href="#Testing-case-55" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(10,190,1000等)</li>
<li>边界测试(0,1)</li>
</ul>
<h2 id="Key-55"><a href="#Key-55" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>穷举遍历数字</p>
<blockquote>
<ol>
<li>从数字1开始向下遍历，每次记录当前位数总数并与输入n进行比较</li>
<li>若小于等于n，则说明第n位在此数字所在序列中的位数之后，向下遍历</li>
<li>若大于n，则说明第n位数字在序列中的位置位于此数字之间</li>
<li>进而在此数字中根据偏移量找到最终的某一位数字</li>
</ol>
</blockquote>
</li>
<li><p>跳级定位范围</p>
<blockquote>
<ol>
<li>从1位数开始判断第n位数字所在的位数范围，将n不断与m位数的所有数字包含的位数作比较</li>
<li>若n&lt;m，则表示第n位数字所在的数为m位数，否则继续向后循环判断</li>
<li>锁定所在位数范围后，根据该m位数的首位数字与偏移量求得第n位数字所在的数字</li>
<li>进而在此数字中根据偏移量找到最终的某一位数字</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>数字序列排列递增有序，依次为所有一位数，二位数……..</li>
<li>不再穷举遍历定位所在的数字，而是先定位其位于哪一个位数范围内，进而定位位于该位数范围内的那个数中，再根据偏移量的最终数字</li>
<li>由于是从0开始计数，因此范围定位时注意条件是否能等于</li>
<li>各子功能分模块，防止代码冗余</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-53"><a href="#Answer-53" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> isExcption = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetNum</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetDiditNums</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetNumCore</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetHead</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetHead</span><span class="params">(<span class="keyword">int</span> digit)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (digit == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in"><span class="keyword">return</span></span> (<span class="keyword">int</span>)(<span class="built_in">pow</span>(<span class="number">10</span>, digit - <span class="number">1</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetNumCore</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> digit)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//获取digit位数的首位数字</span></span><br><span class="line">	<span class="keyword">int</span> NumHead = <span class="built_in">GetHead</span>(digit);</span><br><span class="line">	<span class="comment">//判断index位数位于哪个数字子序列中</span></span><br><span class="line">	<span class="keyword">int</span> indexInNum = NumHead + index / digit;</span><br><span class="line">	<span class="comment">//判断index位数于indexInNum子序列中相对于右侧的偏移量</span></span><br><span class="line">	<span class="keyword">int</span> offSetRight = digit - index % digit - <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//取终值index数</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; offSetRight; i++) &#123;</span><br><span class="line">		indexInNum /= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> indexInNum % <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetDiditNums</span><span class="params">(<span class="keyword">int</span> digit)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (digit == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">9</span> * (<span class="keyword">int</span>)(<span class="built_in">pow</span>(<span class="number">10</span>, digit - <span class="number">1</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetNum</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="comment">//多测试环境下需复原</span></span><br><span class="line">	isExcption = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//范围筛选位于某位数范围中</span></span><br><span class="line">	<span class="keyword">int</span> digit = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="comment">//从1位数开始锁定n位数字所在的位数范围</span></span><br><span class="line">		<span class="keyword">int</span> digitNums = <span class="built_in">GetDiditNums</span>(digit);</span><br><span class="line">		<span class="keyword">if</span> (index &lt; digitNums * digit) &#123;</span><br><span class="line">			<span class="comment">//锁定n位的数在digit位数范围内</span></span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">GetNumCore</span>(index, digit);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//n位的数不在digit位数的范围内，向下遍历</span></span><br><span class="line">		index -= digitNums * digit;</span><br><span class="line">		digit++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="46-把数组排成最小的数"><a href="#46-把数组排成最小的数" class="headerlink" title="46 把数组排成最小的数"></a>46 把数组排成最小的数</h1><blockquote>
<p>输入一个<strong>正整数数组</strong>,把数组里<strong>所有数字拼接</strong>起来排成一个数,打印能拼接出的所有数字中<strong>最小的一个</strong></p>
</blockquote>
<h2 id="Testing-case-56"><a href="#Testing-case-56" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(数组只有一个数字，含多个数字，数字相同，数字位数相同)</li>
<li>边界测试(nullptr)</li>
</ul>
<h2 id="Key-56"><a href="#Key-56" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>全排列筛选</p>
<blockquote>
<p>将整型数组中的元素进行全排列后求得最小的拼接数</p>
<p><code>注意:</code></p>
<ol>
<li>n个数字的全排列数为 n!</li>
<li>元素在int型的范围内，但是拼接后的元素不一定在int范围内，隐含大数问题，需要使用字符串进行拼接运算并比较大小</li>
</ol>
</blockquote>
</li>
<li><p>“排序”的二维字符数组</p>
<blockquote>
<ol>
<li>将整型数组中的数字元素转存至二维字符数组中</li>
<li>对二维字符数组一维度的每个数字字符串进行排序，按照自定义的字符串比较大小方法</li>
<li>对排序后的二维字符数组按序输出即可</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>考虑到大数问题，由数字字符串的拼接代替整数拼接比较大小进而判断两个数字字符串的排序顺序</li>
<li>sprintf(str, “%d”, intNum);将intNum整数打印成字符串保存于str字符串中</li>
<li>void qsort(    void *base,  size_t nmemb,  size_t size,  int (compare)(const void *, const void *)    ); 将元素大小为size，元素个数为nmemb的base按照compare规则进行排序 T(n) = O(nlogn)</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-54"><a href="#Answer-54" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> isExcption = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置全局拼接数暂存字符串</span></span><br><span class="line"><span class="keyword">int</span> MaxLen = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span>* PlusOne = <span class="keyword">new</span> <span class="keyword">char</span>[MaxLen * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">char</span>* PlusTwo = <span class="keyword">new</span> <span class="keyword">char</span>[MaxLen * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>*, <span class="keyword">const</span> <span class="keyword">void</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SortMinNum</span><span class="params">(<span class="keyword">int</span>*, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较规则</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* strNum1, <span class="keyword">const</span> <span class="keyword">void</span>* strNum2)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//拼接后字符串PlusOne strNum1在前，strNum2在后																				//*(char**)strNum1为取字符串首部取整个字符串而非某个字符</span></span><br><span class="line">	<span class="built_in">strcpy</span>(PlusOne, *(<span class="keyword">char</span>**)strNum1);</span><br><span class="line">	<span class="built_in">strcat</span>(PlusOne, *(<span class="keyword">char</span>**)strNum2);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//拼接后字符串PlusTwo strNum2在前，strNum1在后</span></span><br><span class="line">	<span class="built_in">strcpy</span>(PlusTwo, *(<span class="keyword">char</span>**)strNum2);</span><br><span class="line">	<span class="built_in">strcat</span>(PlusTwo, *(<span class="keyword">char</span>**)strNum1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//若返回值小于0 strNum1在前，大于0 strNum1在后，等于0 无法确定</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strcmp</span>(PlusOne, PlusTwo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SortMinNum</span><span class="params">(<span class="keyword">int</span>* intNum, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (intNum == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将整数数组元素存于二维字符数组中																							//动态创建二维字符数组									</span></span><br><span class="line">	<span class="keyword">char</span>** strNum = <span class="keyword">new</span> <span class="keyword">char</span>* [len];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		strNum[i] = <span class="keyword">new</span> <span class="keyword">char</span>[MaxLen + <span class="number">1</span>];</span><br><span class="line">		<span class="comment">//将整数输入到字符串中</span></span><br><span class="line">		<span class="built_in">sprintf</span>(strNum[i], <span class="string">&quot;%d&quot;</span>, intNum[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//对该二维字符数组进行排序</span></span><br><span class="line">	<span class="built_in">qsort</span>(strNum, len, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>*), Compare);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//输出拼接后的最小数字</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;最小数字:&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		cout &lt;&lt; strNum[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//内存回收</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		<span class="keyword">delete</span>[] strNum[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span> strNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="47-把数字翻译成字符串"><a href="#47-把数字翻译成字符串" class="headerlink" title="47 把数字翻译成字符串"></a>47 把数字翻译成字符串</h1><blockquote>
<p>给定一个数字,我们按照如下规则把它翻译为字符串: 0翻译成“a”, 1翻译成”b”, …, 11翻译成”l”,…., 25翻译成“z”</p>
<p>一个数字可能有多个翻译,请编程实现一个函数,用来计算一个数字有多少种不同的翻译方法</p>
</blockquote>
<h2 id="Testing-case-57"><a href="#Testing-case-57" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试()</li>
<li>边界测试(nullptr)</li>
</ul>
<h2 id="Key-57"><a href="#Key-57" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>自上而下递归</p>
<blockquote>
<ol>
<li>从首元素开始决策当前元素是否与后一个元素拼接</li>
<li>若不拼接，则 count += f(i + 1) </li>
<li>若拼接，则判断是否可拼接</li>
<li>若可拼接且不是倒数第二个元素，count += f(i + 2)，若是倒数第二个元素， count += 1</li>
<li>若不可拼接，则跳过</li>
<li>直至进行最后一个元素的决策，返回1</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li><p>记第i个位置可翻译的字符串数为f(i),则</p>
<p>f(i) = 1 i元素为末尾元素</p>
<p>f(i) = f(i + 1) i元素与i+1元素拼接结果不位于10-25之间</p>
<p>f(i) = f(i + 1) + 1 i元素与i+1元素拼接结果位于10-25之间，但是为倒数第二个元素</p>
<p>f(i) = f(i + 1) + f(i + 2) i元素与i+1元素拼接结果位于10-25之间</p>
</li>
<li><p>递归操作含多次重复操作</p>
</li>
<li><p>使用指针更方便拆分字符串</p>
</li>
</ol>
</blockquote>
</li>
<li><p>自下而上动态规划</p>
<blockquote>
<ol>
<li>从末尾元素计算可翻译的字符串数并记录当前结果</li>
<li>向前遍历，遍历同时计算当前元素作首元素可翻译的字符串数</li>
<li>直至遍历至首元素，得最终数字可翻译的字符串数</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>使用数组记录结果，因为数组角标可对应当前正遍历的元素</li>
<li>判断涉及是否为末尾元素，是否可拼接，若可拼接则该元素是否为倒数第二个元素</li>
<li>to_string(int) 可将一整数转换为字符串</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-55"><a href="#Answer-55" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<p>1.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Concat</span><span class="params">(<span class="keyword">char</span> cnum1, <span class="keyword">char</span> cnum2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> result = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> num1 = cnum1 - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	<span class="keyword">int</span> num2 = cnum2 - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> concat = num1 * <span class="number">10</span> + num2;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (concat &gt;= <span class="number">10</span> &amp;&amp; concat &lt;= <span class="number">25</span>) &#123;</span><br><span class="line">		result = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RecursiveTranslationNums</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">char</span> arr[<span class="number">10</span>];</span><br><span class="line">	<span class="built_in">sprintf</span>(arr, <span class="string">&quot;%d&quot;</span>, num);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">RecursiveTranslationNumsCore</span>(arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RecursiveTranslationNumsCore</span><span class="params">(<span class="keyword">char</span>* num)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//base case</span></span><br><span class="line">	<span class="keyword">if</span> ((*(num + <span class="number">1</span>)) == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//当前元素不与后一个元素组合</span></span><br><span class="line">	count += <span class="built_in">RecursiveTranslationNumsCore</span>(num + <span class="number">1</span>);</span><br><span class="line">	<span class="comment">//当前元素与后一个元素组合</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">Concat</span>(*num, *(num + <span class="number">1</span>))) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((*(num + <span class="number">2</span>)) != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">			count += <span class="built_in">RecursiveTranslationNumsCore</span>(num + <span class="number">2</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			count += <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Concat</span><span class="params">(<span class="keyword">char</span> cnum1, <span class="keyword">char</span> cnum2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> result = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> num1 = cnum1 - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	<span class="keyword">int</span> num2 = cnum2 - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> concat = num1 * <span class="number">10</span> + num2;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (concat &gt;= <span class="number">10</span> &amp;&amp; concat &lt;= <span class="number">25</span>) &#123;</span><br><span class="line">		result = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TranslationNums</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	string n = <span class="built_in">to_string</span>(num);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">TranslationNumsCore</span>(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TranslationNumsCore</span><span class="params">(<span class="keyword">const</span> string&amp; num)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//设置记录各个位置起可翻译的字符串数结果，避免重复计算</span></span><br><span class="line">	<span class="keyword">int</span>* counts = <span class="keyword">new</span> <span class="keyword">int</span>[num.<span class="built_in">length</span>()];</span><br><span class="line">	<span class="comment">//设置记录从当前位置元素开始的可翻译字符串数</span></span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从后向前遍历字符串，直至计算出第一个位置起的可翻译字符串数</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = num.<span class="built_in">length</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="comment">//清零，计算当前位置作起始位置的可翻译字符串数</span></span><br><span class="line">		count = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//若当前元素为末尾元素，则只能翻译1种字符串</span></span><br><span class="line">		<span class="keyword">if</span> (i == num.<span class="built_in">length</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">			count += <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//否则当前元素作起始位置的可翻译字符串数等于下一个位置的结果</span></span><br><span class="line">			count += counts[i + <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (i != num.<span class="built_in">length</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="comment">//若不为末尾元素，判断当前元素能否与后一个元素拼接</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">Concat</span>(num[i], num[i + <span class="number">1</span>])) &#123;</span><br><span class="line">				<span class="comment">//若可拼接但是当前元素为倒数第二个元素，则可翻译字符串数增1</span></span><br><span class="line">				<span class="keyword">if</span> (i == num.<span class="built_in">length</span>() - <span class="number">2</span>) &#123;</span><br><span class="line">					count += <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					count += counts[i + <span class="number">2</span>];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		counts[i] = count;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//释放内存</span></span><br><span class="line">	<span class="keyword">delete</span>[] counts;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="48-礼物的最大价值"><a href="#48-礼物的最大价值" class="headerlink" title="48 礼物的最大价值"></a>48 礼物的最大价值</h1><blockquote>
<p>在一个m×n的棋盘的每一格都放有一个礼物,每个礼物都有一定的价值(价值大于0),你可以从棋盘的左上角开始拿格子里的礼物,并每次向左或者向下移动一格,直到到达棋盘的右下角</p>
<p>给定一个棋盘及其上面的礼物,请计算你最多能拿到多少价值的礼物?</p>
</blockquote>
<h2 id="Testing-case-58"><a href="#Testing-case-58" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(多行多列矩阵，一行/列矩阵，只有一个数字的矩阵)</li>
<li>边界测试(nullptr)</li>
</ul>
<h2 id="Key-58"><a href="#Key-58" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>决策树 + 递归</p>
<blockquote>
<ol>
<li>从首元素开始进行决策，向下or向右</li>
<li>先进行向下的决策后对下方元素继续递归决策</li>
<li>后进行向右的决策后对友方元素继续递归决策</li>
<li>在作另一决策之前需要将当前决策恢复后再进行决策，但是注意恢复的位置</li>
<li>直至进行右下角元素的决策</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>从左上角开始，找寻所有至有右下角的路径，并记录路径上的礼物价值，打擂求解并使用全局变量记录</li>
<li>二维数组中的起点确定的各元素路径遍历的边界值问题，若边界选取不当并未作处理，将导致边界值的重复决策</li>
<li>注意对边界只能作一种决策的处理，此处统一处理，末尾元素单独处理</li>
<li>恢复的位置若位于2,3之间，则在作出另一决策前，当前正作出决策的结点将被弹出，因此应该置于3之后，仅弹出左决策结点而非本身</li>
</ol>
</blockquote>
</li>
<li><p>递归公式 + 递归</p>
<blockquote>
<ol>
<li>从右下角开始套用公式递归计算返回结果</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li><p>记(i,j)位置处礼物的最大价值为f(i,j),(i,j)位置处礼物的价值为gift(i,j)</p>
<p>f(i,j) = max(f(i-1,j),f(i,j-1)) + gift(i,j) , i!=0 &amp;&amp; j!=0 </p>
<p>f(i,j) = f(i-1,j)+ gift(i,j) , j=0</p>
<p>f(i,j) = f(i,j-1)+ gift(i,j) , i=0</p>
<p>f(i,j) = gift(i,j) , i=j=0</p>
</li>
</ol>
</blockquote>
</li>
<li><p>动态规划 + 迭代计算</p>
<blockquote>
<ol>
<li>自左上角开始遍历整个礼物矩阵，计算每个位置的礼物最大价值</li>
<li>分别使用left,up记录当前位置的左边与上边的礼物最大价值</li>
<li>取max(left,up) + gift(i,j) 作为当前位置处的礼物最大价值</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>使用二维数组记录相应位置处的礼物最大价值</li>
<li>left,up初始化为0，考虑边界情况，需每次判断是否位于某个边界</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-56"><a href="#Answer-56" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<p>1.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> isExcption = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> MaxGift = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxValueOfGift</span><span class="params">(<span class="keyword">int</span>**, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MaxValueOfGiftCore</span><span class="params">(<span class="keyword">int</span>**, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxValueOfGift</span><span class="params">(<span class="keyword">int</span>** arr, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="literal">nullptr</span> || rows &lt;= <span class="number">0</span> || cols &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; Gift;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">MaxValueOfGiftCore</span>(arr, <span class="number">0</span>, <span class="number">0</span>, rows, cols, Gift);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> MaxGift;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MaxValueOfGiftCore</span><span class="params">(<span class="keyword">int</span>** gift, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, vector&lt;<span class="keyword">int</span>&gt;&amp; Gift)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//base case</span></span><br><span class="line">	<span class="keyword">if</span> (row == rows - <span class="number">1</span> &amp;&amp; col == cols - <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">		Gift.<span class="built_in">push_back</span>(gift[row][col]);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> i : Gift) &#123;</span><br><span class="line">			cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">			sum += i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (sum &gt;= MaxGift) &#123;</span><br><span class="line">			MaxGift = sum;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;max = &quot;</span> &lt;&lt; MaxGift;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (Gift.<span class="built_in">size</span>() != <span class="number">0</span>)</span><br><span class="line">			Gift.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将从左上角至右下角的一条路径经过的所有礼物进行记录</span></span><br><span class="line">	<span class="comment">//防止边界元素的重复压入</span></span><br><span class="line"></span><br><span class="line">	Gift.<span class="built_in">push_back</span>(gift[row][col]);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//向下移动</span></span><br><span class="line">	<span class="keyword">if</span> (row &lt; rows - <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">//down = false;</span></span><br><span class="line">		<span class="built_in">MaxValueOfGiftCore</span>(gift, row + <span class="number">1</span>, col, rows, cols, Gift);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//向右移动</span></span><br><span class="line">	<span class="keyword">if</span> (col &lt; cols - <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">//right = false;</span></span><br><span class="line">		<span class="built_in">MaxValueOfGiftCore</span>(gift, row, col + <span class="number">1</span>, rows, cols, Gift);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//恢复</span></span><br><span class="line">	<span class="keyword">if</span> (Gift.<span class="built_in">size</span>() != <span class="number">0</span>)</span><br><span class="line">		Gift.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxValueOfGiftByFunc</span><span class="params">(<span class="keyword">int</span>** arr, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="literal">nullptr</span> || rows &lt;= <span class="number">0</span> || cols &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> max = <span class="built_in">MaxValueOfGiftCoreByFunc</span>(arr, rows - <span class="number">1</span>, cols - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxValueOfGiftCoreByFunc</span><span class="params">(<span class="keyword">int</span>** gift, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//base case</span></span><br><span class="line">	<span class="keyword">if</span> (row == <span class="number">0</span> &amp;&amp; col == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> gift[row][col];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (row == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">MaxValueOfGiftCoreByFunc</span>(gift, row, col - <span class="number">1</span>) + gift[row][col];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (col == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">MaxValueOfGiftCoreByFunc</span>(gift, row - <span class="number">1</span>, col) + gift[row][col];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">MaxValueOfGiftCoreByFunc</span>(gift, row - <span class="number">1</span>, col), <span class="built_in">MaxValueOfGiftCoreByFunc</span>(gift, row, col - <span class="number">1</span>)) + gift[row][col];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxValueOfGift</span><span class="params">(<span class="keyword">int</span>** gift, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (gift == <span class="literal">nullptr</span> || rows &lt;= <span class="number">0</span> || cols &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//辅助二维数组记录各个位置处的礼物最大价值</span></span><br><span class="line">	<span class="keyword">int</span>** MaxValue = <span class="keyword">new</span> <span class="keyword">int</span>*[rows];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">		MaxValue[i] = <span class="keyword">new</span> <span class="keyword">int</span>[cols];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//自左上角开始遍历，计算各个位置处的礼物最大价值</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//设置记录当前位置左边与上边礼物最大价值的变量</span></span><br><span class="line">			<span class="keyword">int</span> up = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">				up = MaxValue[i - <span class="number">1</span>][j];</span><br><span class="line">			<span class="keyword">if</span> (j &gt; <span class="number">0</span>)</span><br><span class="line">				left = MaxValue[i][j - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">			<span class="comment">//设置当前位置的礼物最大价值</span></span><br><span class="line">			MaxValue[i][j] = <span class="built_in">max</span>(up, left) + gift[i][j];</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> max = MaxValue[rows - <span class="number">1</span>][cols - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//释放内存</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">		<span class="keyword">delete</span>[] MaxValue[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span>[] MaxValue;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="49-最长不含重复字符的子字符串"><a href="#49-最长不含重复字符的子字符串" class="headerlink" title="49 最长不含重复字符的子字符串"></a>49 最长不含重复字符的子字符串</h1><blockquote>
<p>请从字符串中找出一个最长的不包含重复字符的子字符串,计算该最长子字符串的长度</p>
<p>假设字符串中只包含a~z的字符</p>
</blockquote>
<h2 id="Testing-case-59"><a href="#Testing-case-59" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(字符串含多个字符，字符均相同，仅含一个字符)</li>
<li>边界测试(字符串为空)</li>
</ul>
<h2 id="Key-59"><a href="#Key-59" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>暴力求解 T(n) = O(n3)</p>
<blockquote>
<ol>
<li>求解字符串的所有连续的子字符串 O(n2)</li>
<li>在所有子字符串中找寻并记录最长不含重复字符的子字符串 O(n)</li>
</ol>
</blockquote>
</li>
<li><p>动态规划 + 正向迭代</p>
<blockquote>
<ol>
<li>自首部开始遍历字符串，计算以 i(0,1..str.length()) 处元素作尾部元素时的最长不含重复字符的子字符串</li>
<li>每次遍历记录当前以i为末尾不含重复字符的子字符串的长度，并记录当前元素本次在str中出现的位置</li>
<li>当currentSubLen发生截断前打擂判断maxSum</li>
<li>直至 i=str.length()，最后打擂判断maxSum</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li><p>最长不含重复字符的子字符串为连续的字符串</p>
</li>
<li><p>入手点在于分析i处元素作该连续字符串末尾时的最长长度，i取值由 0-&gt;str.length() 即可得出当前长度的字符串的最长不含重复字符的子字符串</p>
</li>
<li><p>记f(i)为i处元素作该连续字符串末尾时的最长长度，则</p>
<p>f(i) = f(i-1) + 1 , f(i-1)对应的子字符串中不含i处元素(LastAppear[index] &lt; 0 || distance &gt; currentSubLen)</p>
<p>f(i) = distance , 对应的子字符串中含i处元素</p>
<p>distance为截断i处元素上一次出现位置到i所包含的所有元素</p>
</li>
<li><p>使用 currentSubLen 来记录 f(i-1)</p>
</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-57"><a href="#Answer-57" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> isExcption = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LongestSubstrWithoutDuplication</span><span class="params">(<span class="keyword">const</span> string&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LongestSubstrWithoutDuplication</span><span class="params">(<span class="keyword">const</span> string&amp; str)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (str.<span class="built_in">length</span>() == <span class="number">0</span> ) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置LastAppear数组记录&#x27;a&#x27;-&#x27;z&#x27;字符上一次在字符串中出现的位置，若当前未出现，则为-1</span></span><br><span class="line">	<span class="keyword">int</span>* LastAppear = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">		LastAppear[i] = <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置currentSum存储f(i-1)的值</span></span><br><span class="line">	<span class="keyword">int</span> currentSubLen = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//设置maxSum打擂存储最长字符串</span></span><br><span class="line">	<span class="keyword">int</span> maxSum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//自前向后求得目前第i个元素作满足要求的子字符串末尾时的最长长度</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">		<span class="comment">//判断当前元素是否位于f(i-1)对应的子字符串中</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//获取当前遍历元素在LastAppear数组中的映射关系,从而获取当前元素上次在str中出现的位置</span></span><br><span class="line">		<span class="keyword">int</span> index = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		<span class="comment">//获取当前元素与上一次出现位置的差值</span></span><br><span class="line">		<span class="keyword">int</span> distance;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(LastAppear[index] &gt;= <span class="number">0</span>)</span><br><span class="line">			distance = i - LastAppear[index];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (LastAppear[index] &lt; <span class="number">0</span> || distance &gt; currentSubLen) &#123;</span><br><span class="line">			<span class="comment">//若之前最长子字符串中不含当前位置字符，则子字符串长度增1</span></span><br><span class="line">			currentSubLen += <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//若之前最长子字符串中含当前位置字符，则存在重复，需要截断上一次出现位置以及之前的元素</span></span><br><span class="line">			<span class="comment">//此时maxSum才需要更新</span></span><br><span class="line">			<span class="keyword">if</span> (currentSubLen &gt;= maxSum) &#123;</span><br><span class="line">				maxSum = currentSubLen;</span><br><span class="line">			&#125;</span><br><span class="line">			currentSubLen = distance;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//记录当前元素本次在str出现的位置</span></span><br><span class="line">		LastAppear[index] = i;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//最后更新maxSum，记录最长不含重复字符的子字符串</span></span><br><span class="line">	<span class="keyword">if</span> (currentSubLen &gt;= maxSum) &#123;</span><br><span class="line">		maxSum = currentSubLen;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//清理内存</span></span><br><span class="line">	<span class="keyword">delete</span>[] LastAppear;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="—-动态规划-—"><a href="#—-动态规划-—" class="headerlink" title="—- 动态规划 —-"></a>—- 动态规划 —-</h1><ul>
<li>求解某个问题的最优解(最大，最小，最多有…)</li>
<li>某个问题可划分为多个子问题</li>
<li>多个子问题有相互重叠的更小的子问题</li>
<li>自上而下递归分析问题，自下而上迭代解决问题(记录上次结果)</li>
</ul>
<h1 id="50-丑数"><a href="#50-丑数" class="headerlink" title="50 丑数"></a>50 丑数</h1><blockquote>
<p>我们把只包含因子2、3和5的数称作丑数(Ugly Number)</p>
<p>求1按从小到大的顺序的第1500个丑数</p>
<p>我们把1当作第一个丑数。</p>
</blockquote>
<h2 id="Testing-case-60"><a href="#Testing-case-60" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(2,3,4,5,6)</li>
<li>边界测试(1,0)</li>
<li>性能测试(1500)</li>
</ul>
<h2 id="Key-60"><a href="#Key-60" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>暴力遍历所有数</p>
<blockquote>
<ol>
<li>从1开始遍历所有正整数，并判断是否为丑数</li>
<li>若为丑数则丑数计数器增1</li>
<li>直至找到第1500个丑数</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>若一个数为丑数，则其将2,3,5因子均除尽之后值为1.</li>
<li>需要遍历第1500个丑数之前的所有数字</li>
</ol>
</blockquote>
</li>
<li><p>使用数组仅记录所有丑数</p>
<blockquote>
<ol>
<li>使用一个数组递增有序记录前num个丑数</li>
<li>设置三个标志指针分别记录第一个 ×2，×3，×5 大于目前最大丑数的丑数元素，初始化为数组首元素</li>
<li>取min(*Multiply2 * 2, *Multiply3 * 3, *Multiply5 * 5),作为下一个丑数</li>
<li>更新三个标志指针指向</li>
<li>向下遍历，直至丑数数组元素满num个，即得出第num个丑数</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>使用大小为num的数组递增有序存放所有丑数，最后一个元素即为第num个丑数</li>
<li>一个丑数一定由之前某丑数乘某个因子(2,3,5)得之,1除外</li>
<li>为使数组有序，需要三个指针分别记录第一个 ×2，×3，×5 大于目前最大丑数的丑数元素</li>
<li>使用丑数数组记录前num个丑数可省去记录其余无关整数，但是增加了空间消耗</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-58"><a href="#Answer-58" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<p>1.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isUglyNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//丑数只含有2,3,5因子，将每个因子除尽若为1则为丑数</span></span><br><span class="line">	<span class="keyword">while</span> (num % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">		num /= <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (num % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">		num /= <span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (num % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">		num /= <span class="number">5</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getUglyNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (num &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//记录当前数字与丑数</span></span><br><span class="line">	<span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> uglyNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (uglyNum &lt; num) &#123;</span><br><span class="line">		<span class="comment">//遍历自1开始的数字</span></span><br><span class="line">		number++;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">isUglyNum</span>(number)) &#123;</span><br><span class="line">			uglyNum++;</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">(<span class="keyword">int</span> n1, <span class="keyword">int</span> n2, <span class="keyword">int</span> n3)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> min;</span><br><span class="line">	<span class="keyword">if</span> (n1 &lt; n2) &#123;</span><br><span class="line">		min = n1;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		min = n2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (n3 &lt; min) &#123;</span><br><span class="line">		min = n3;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getUglyNum2</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (num &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置由小到大排序的丑数数组</span></span><br><span class="line">	<span class="keyword">int</span>* Ugly = <span class="keyword">new</span> <span class="keyword">int</span>[num];</span><br><span class="line">	Ugly[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//三个标志指针，分别指向第一个 ×2，×3，×5 大于目前最大丑数的丑数元素</span></span><br><span class="line">	<span class="keyword">int</span>* Multiply2 = Ugly;</span><br><span class="line">	<span class="keyword">int</span>* Multiply3 = Ugly;</span><br><span class="line">	<span class="keyword">int</span>* Multiply5 = Ugly;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置指向下一个丑数的角标标志,用于遍历记录前num个丑数</span></span><br><span class="line">	<span class="keyword">int</span> pNextUgly = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (pNextUgly &lt; num) &#123;</span><br><span class="line">		<span class="comment">//获取当前最大丑数</span></span><br><span class="line">		<span class="keyword">int</span> min = <span class="built_in">getMin</span>(*Multiply2 * <span class="number">2</span>, *Multiply3 * <span class="number">3</span>, *Multiply5 * <span class="number">5</span>);</span><br><span class="line">		Ugly[pNextUgly] = min;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//重新定位三个标志指针,使分别指向第一个 ×2，×3，×5 大于目前最大丑数的丑数元素</span></span><br><span class="line">		<span class="comment">//分别×2，×3，×5 小于等于目前最大丑数的丑数元素一定已经位于丑数数组中</span></span><br><span class="line">		<span class="keyword">while</span> (*Multiply2 * <span class="number">2</span> &lt;= min) &#123;</span><br><span class="line">			Multiply2++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (*Multiply3 * <span class="number">3</span> &lt;= min) &#123;</span><br><span class="line">			Multiply3++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (*Multiply5 * <span class="number">5</span> &lt;= min) &#123;</span><br><span class="line">			Multiply5++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//向下遍历，直至丑数数组元素满num个，即得出第num个丑数</span></span><br><span class="line">		pNextUgly++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> uglyNum = Ugly[pNextUgly - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//清理内存</span></span><br><span class="line">	<span class="keyword">delete</span>[] Ugly;</span><br><span class="line">	Ugly = <span class="literal">nullptr</span>;</span><br><span class="line">	Multiply2 = <span class="literal">nullptr</span>;</span><br><span class="line">	Multiply3 = <span class="literal">nullptr</span>;</span><br><span class="line">	Multiply5 = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> uglyNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="51-第一次只出现一次的字符"><a href="#51-第一次只出现一次的字符" class="headerlink" title="51 第一次只出现一次的字符"></a>51 第一次只出现一次的字符</h1><blockquote>
<p>字符串中第一个只出现一次的字符</p>
</blockquote>
<h2 id="Testing-case-61"><a href="#Testing-case-61" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(字符串中有/无只出现一次的字符，字符串中所有字符均只出现一次)</li>
<li>边界测试(nullptr)</li>
</ul>
<h2 id="Key-61"><a href="#Key-61" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>哈希表 T(n) = O(n) S(n) = O(1) 1KB</p>
<blockquote>
<ol>
<li>第一遍历字符串根据字符串ascll码值在哈希表对应位置处记录其出现次数</li>
<li>恢复遍历字符串的指针，使其重新指向字符串首部</li>
<li>第二次遍历字符串根据哈希表中的出现次数返回第一次只出现一次的字符</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>哈希表可使用map或者unordered_map形成 字符-次数 键值对,哈希表存256个元素，共占用256*4=1024 1KB内存</li>
<li>此处考虑 ascll码 映射其在数组中的存放位置，形成简易哈希表</li>
<li>两次遍历使用同一个遍历指针，注意第二次使用该指针时需要还原位置</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-59"><a href="#Answer-59" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> isExcption = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">FirstNotRepeatChar</span><span class="params">(<span class="keyword">char</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">FirstNotRepeatChar</span><span class="params">(<span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (str == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//字符1byte 8bit 256中状态 256中不同字符表示</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> Allchar = <span class="number">256</span>;</span><br><span class="line">	<span class="comment">//设置大小为256的哈希表，使用取字符的ascll码值作哈希函数</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> hash[Allchar];</span><br><span class="line">	<span class="comment">//设置哈希表初值为0以便记录次数</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Allchar; i++) &#123;</span><br><span class="line">		hash[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//设置遍历字符串的指针</span></span><br><span class="line">	<span class="keyword">char</span>* pCur = str;</span><br><span class="line">	<span class="comment">//第一次遍历字符串记录各字符出现的次数并映射到哈希表的相应位置</span></span><br><span class="line">	<span class="keyword">while</span> (*pCur != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">		hash[*pCur]++;</span><br><span class="line">		pCur++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//第二次遍历前需要将遍历指针还原</span></span><br><span class="line">	pCur = str;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//第二次遍历字符串找寻第一个只出现一次的字符</span></span><br><span class="line">	<span class="keyword">while</span> (*pCur != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (hash[*pCur] == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> *pCur;</span><br><span class="line">		&#125;</span><br><span class="line">		pCur++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//若执行至此处说明无只出现一次的字符</span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="51-2-哈希表应用拓展"><a href="#51-2-哈希表应用拓展" class="headerlink" title="51.2 哈希表应用拓展"></a>51.2 哈希表应用拓展</h1><ul>
<li><p>定义两个字符串，在第一个字符串中删除第二个字符串中出现过的所有元素</p>
<blockquote>
<ol>
<li>遍历第二个字符串，并建立一个哈希表记录第二个字符串中的元素出现状态 键值对为 字符-bool</li>
<li>遍历第一个字符串，根据字符映射对应哈希表判断当前字符是否应该删除</li>
</ol>
</blockquote>
</li>
<li><p>定义一个函数删除字符串中重复出现的字符</p>
<blockquote>
<ol>
<li>遍历该字符串，并建立哈希表记录元素的出现状态</li>
<li>若 字符-bool bool为fasle，则将该值设置为true</li>
<li>若 字符-bool bool为true，则表明该字符之前已经出现过，删除该字符</li>
</ol>
</blockquote>
</li>
<li><p>英语单词的变位词，两个词中出现的字母相同，且各字母的出现次数相同</p>
<blockquote>
<ol>
<li>遍历其中一个英语单词，并建立一个哈希表记录字符的出现次数 键值对为 字符-num</li>
<li>遍历另一个英语单词，并将相应的哈希表中的值减1</li>
<li>若遍历完后，哈希表中各值均为0，则表明这两个词互为变位词</li>
</ol>
</blockquote>
</li>
</ul>
<h1 id="51-3-字符流中只出现一次的字符"><a href="#51-3-字符流中只出现一次的字符" class="headerlink" title="51.3 字符流中只出现一次的字符"></a>51.3 字符流中只出现一次的字符</h1><blockquote>
<p>字符流中第一个只出现一次的字符</p>
<p>请实现一个函数,用来找出字符流中第一个只出现一次的字符</p>
<p>例如,当从字符流中只读出前两个字符”go”时,第一个只出现一次的字符是g:当从该字符流中读出前6个字符”google”时,第一个只出现一次的字符是1。</p>
</blockquote>
<h2 id="Testing-case-62"><a href="#Testing-case-62" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(字符串中有/无只出现一次的字符，字符串中所有字符均只出现一次)</li>
<li>边界测试(nullptr)</li>
</ul>
<h2 id="Key-62"><a href="#Key-62" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>哈希表</p>
<blockquote>
<p><strong>插入元素</strong></p>
<ol>
<li>每插(输)入一个字符，则根据字符ascll码值判断对应哈希表的值是否为-1</li>
<li>若为-1，表明该字符为首次出现，将该字符的在字符流中的位置index值写入哈希表对应位置,然后index++，表明下一个字符在字符流中的位置</li>
<li>若&gt;=0，则表明该字符已经出现一次，将该字符的对应哈希表位置处的值设置为非法值-2，表明不可能为要求字符,然后index++，表明下一个字符在字符流中的位置</li>
<li>若为非法值，则仅需index++即可</li>
</ol>
<p><strong>获取要求字符</strong></p>
<ol>
<li><p>从头遍历整个哈希表，判断键值对对应值的状态</p>
<p>若&gt;=0，则表明该字符在字符流中仅出现了一次，但是无法确保为第一个字符，进而通过打擂判断其index是否为最小的index</p>
</li>
<li><p>遍历完后，最小index对应的键标识的字符即为最小字符</p>
</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>字符流区别于字符数组的点在于字符流无法遍历，因此需要有介质存放字符在字符流中的位置</li>
<li>仅仅通过遍历哈希表(记录字符出现次数)无法保证值为1的字符是第一次出现</li>
<li>因此哈希表中 键值对 值应存放字符在字符流中的位置索引，若重复出现，则值为非法值，标志该字符不可能为要求字符</li>
<li>对于流的操作考虑使用类来模拟流的输入并实时更新状态与获取状态</li>
<li>numeric_limits<int>::max() 可获取int类型中最大的int型数</int></li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-60"><a href="#Answer-60" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CharStatics</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CharStatics</span>():<span class="built_in">index</span>(<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Allchar; i++) &#123;</span><br><span class="line">			hash[i] = <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (hash[ch] == <span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="comment">//当前字符仅出现了一次，因此键值对值存放其在字符流中的位置</span></span><br><span class="line">			hash[ch] = index;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (hash[ch] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">//当前字符已经在字符流中出现了一次，因此当前元素不可能为要求元素,将值设置为-2标识</span></span><br><span class="line">			hash[ch] = <span class="number">-2</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//若当前字符已经重复出现了多次，则仅需更新index</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//index++用于标识下一个元素在字符流中的位置</span></span><br><span class="line">		index++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">char</span> <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//Front记录字符在字符流中出现的位置，初始化为int中的最大值</span></span><br><span class="line">		<span class="keyword">int</span> min = numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//minChar记录最小字符</span></span><br><span class="line">		<span class="keyword">char</span> minChar = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Allchar; i++) &#123;</span><br><span class="line">			<span class="comment">//因为哈希表中为元素顺序不代表在字符流中出现顺序，因此需要遍历整个哈希表，根据index记得位置判断是否靠前</span></span><br><span class="line">			<span class="keyword">if</span> (hash[i] &gt;= <span class="number">0</span> &amp;&amp; hash[i] &lt;= min) &#123;</span><br><span class="line">				minChar = (<span class="keyword">char</span>)i;</span><br><span class="line">				min = hash[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> minChar;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//哈希表，记录字符流中字符出现的次数</span></span><br><span class="line">	<span class="keyword">int</span> hash[Allchar];</span><br><span class="line">	<span class="comment">//记录当前字符流中字符在字符流中的位置</span></span><br><span class="line">	<span class="keyword">int</span> index;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="52-数组中的逆序对"><a href="#52-数组中的逆序对" class="headerlink" title="52 数组中的逆序对"></a>52 数组中的逆序对</h1><blockquote>
<p>在数组中的两个数字,如果前面一个数字大于后面的数字,则这两个数字组成一个逆序对</p>
<p>输入一个数组,求出这个数组中的逆序对的总数</p>
<p>例如,在数组7, 5, 6, 4中,一共存在5个逆序对,分别是(7, 6)(7, 5), (7, 4), (6, 4)和(5, 4)</p>
</blockquote>
<h2 id="Testing-case-63"><a href="#Testing-case-63" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(未经排序的数组，递增排序的数组，递减排序的数组，输入的数组包含重复数字)</li>
<li>边界测试(nullptr，只有两个数字，只有一个数字)</li>
</ul>
<h2 id="Key-63"><a href="#Key-63" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>暴力遍历 T(n) = O(n2)</p>
<blockquote>
<ol>
<li>从头遍历数组，将当前元素与后续O(n)元素进行比较计算含当前元素的逆序对数</li>
<li>直至遍历完数组，数组所有逆序数计算完毕</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>暴力遍历，时间效率低</li>
</ol>
</blockquote>
</li>
<li><p>归并划分 T(n) = (nlogn) S(n) = O(n)</p>
<blockquote>
<ol>
<li><p>基于归并排序对数组进行划分</p>
</li>
<li><p>计算左子数组中的逆序数</p>
</li>
<li><p>计算右子数组中的逆序数</p>
</li>
<li><p>设置三个指针和一个暂存数组，在递增有序的基础上，自左右子数组末位开始判断</p>
<p>若data[Lend] &gt; data[Rend]，将大者写入暂存数组，并将相应指针前移，此时data[Lend]的逆序数为data[Rend]以及之前所有元素个数</p>
<p>若data[Lend] &lt;= data[Rend]，将大者写入暂存数组，并将相应指针前移，此时无逆序数产生</p>
</li>
<li><p>将剩余未存入暂存数组中的元素进行判断并存入</p>
</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li><p>在进行相邻子数组逆序数判断时，如何保证判断完逆序数后的两个子数组递增有序</p>
<p>进行子数组逆序数计算时，copy与data参数不断对调，使下一次相邻子数组逆序数的计算基于两者中有序的一方</p>
</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-61"><a href="#Answer-61" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InversePair</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//判断异常</span></span><br><span class="line">		<span class="keyword">if</span> (data == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">			isExcption = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//设置辅助暂存数组,并初始化为arr</span></span><br><span class="line">		<span class="keyword">int</span>* copy = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">			copy[i] = data[i];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> count = <span class="built_in">InversePairCore</span>(data, copy, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//清理内存</span></span><br><span class="line">		<span class="keyword">delete</span>[] copy;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">InversePairCore</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span>* copy, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//base case</span></span><br><span class="line">		<span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">			<span class="comment">//递归终止条件为划分至仅有一个元素,此时子数组的逆序数为0																		//保证数组有序，将值存入暂存数组</span></span><br><span class="line">			copy[start] = data[start];</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//设置划分界限,对半划分</span></span><br><span class="line">		<span class="keyword">int</span> len = (end - start) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//获取左子数组中的逆序数</span></span><br><span class="line">		<span class="keyword">int</span> left = <span class="built_in">InversePairCore</span>(copy, data, start, start + len);</span><br><span class="line">		<span class="comment">//获取右子数组中的逆序数</span></span><br><span class="line">		<span class="keyword">int</span> right = <span class="built_in">InversePairCore</span>(copy, data, start + len + <span class="number">1</span>, end);</span><br><span class="line">		<span class="comment">//获取左右子数组合并后的逆序数</span></span><br><span class="line">		<span class="keyword">int</span> inNum = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//设置三个指针，分别指向左右与合并后子数组的末位</span></span><br><span class="line">		<span class="keyword">int</span> Lend = start + len;</span><br><span class="line">		<span class="keyword">int</span> Rend = end;</span><br><span class="line">		<span class="keyword">int</span> Mend = end;</span><br><span class="line">		<span class="comment">//从后向前遍历左右子数组所有元素进行合并</span></span><br><span class="line">		<span class="keyword">while</span> (Lend &gt;= start &amp;&amp; Rend &gt;= start + len + <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (data[Lend] &gt; data[Rend]) &#123;</span><br><span class="line">				<span class="comment">//若左子数组的末位元素大于右子树组的末位元素，将大者写入暂存数组</span></span><br><span class="line">				copy[Mend] = data[Lend];</span><br><span class="line">				<span class="comment">//并将相应指针前移</span></span><br><span class="line">				Mend--;</span><br><span class="line">				Lend--;</span><br><span class="line">				<span class="comment">//根据右子数组末位元素位置计算此时逆序数</span></span><br><span class="line">				inNum += Rend - start - len;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="comment">//若左子数组的末位元素小于等于右子树组的末位元素，将大者写入暂存数组</span></span><br><span class="line">				<span class="comment">//此时不构成逆序数</span></span><br><span class="line">				<span class="comment">//并将相应指针前移			</span></span><br><span class="line">				copy[Mend] = data[Rend];</span><br><span class="line">				Mend--;</span><br><span class="line">				Rend--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//定有一个子数组率先存入暂存数组，此时将另一数组元素按序存入暂存数组</span></span><br><span class="line">		<span class="keyword">while</span> (Lend &gt;= start) &#123;</span><br><span class="line">			copy[Mend] = data[Lend];</span><br><span class="line">			Mend--;</span><br><span class="line">			Lend--;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (Rend &gt;= start + len + <span class="number">1</span>) &#123;</span><br><span class="line">			copy[Mend] = data[Rend];</span><br><span class="line">			Mend--;</span><br><span class="line">			Rend--;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> left + right + inNum;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="53-在排序数组中查找数字"><a href="#53-在排序数组中查找数字" class="headerlink" title="53 在排序数组中查找数字"></a>53 在排序数组中查找数字</h1><blockquote>
<p>统计一个数字在排序数组中出现的次数</p>
</blockquote>
<h2 id="Testing-case-64"><a href="#Testing-case-64" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(数组中存在/不存在要查找的数字，要查找的数字出现多次/一次)</li>
<li>边界测试(nullptr，数组中只有一个数字，查找的值为数组最大/最小值)</li>
</ul>
<h2 id="Key-64"><a href="#Key-64" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>暴力遍历 T(n) = O(n)</p>
<blockquote>
<p>遍历数组，若当前元素与待查找数字相同，则计数变量增1</p>
</blockquote>
</li>
<li><p>二分查找 T(n) = O(logn)</p>
<blockquote>
<p><strong>获取基于二分查找的k第一次出现的位置</strong></p>
<ol>
<li><p>若mid值与待查找数字相同，则判断是否为第一次出现，若为第一次出现，返回该元素</p>
<p>首元素 / 非首元素且该元素之前的元素不是待查找数字 mid == 0 || (mid &gt; 0 &amp;&amp; data[mid - 1] != k)</p>
</li>
<li><p>若mid值与待查找数字相同，但不是第一次出现，则在其前子数组中继续查找第一次出现的位置</p>
</li>
<li><p>若mid值与待查找数字不相同，则在子数组中继续查询(二分思路略)</p>
</li>
</ol>
<p><strong>获取基于二分查找的k最后一次出现的位置</strong></p>
<ol start="4">
<li><p>若mid值与待查找数字相同，则判断是否为最后一次出现，若为最后一次出现，返回该元素</p>
<p>尾元素 / 非尾元素且该元素之后的元素不是待查找数字 mid == len - 1 || ((mid &lt; (len - 1)) &amp;&amp; data[mid + 1] != k)</p>
</li>
<li><p>若mid值与待查找数字相同，但不是最后一次出现，则在其后子数组中继续查找最后一次出现的位置</p>
</li>
<li><p>若mid值与待查找数字不相同，则在子数组中继续查询(二分思路略)</p>
</li>
<li><p>最后基于两个位置的差值返回数字在排序数组中出现的次数</p>
</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>利用二分查找查找数字在数组中第一次和最后一次出现的位置，即可省去遍历所有数字，利用差值计算数字出现次数</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-62"><a href="#Answer-62" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetNumOfK</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> length, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断异常</span></span><br><span class="line">	<span class="keyword">if</span> (data == <span class="literal">nullptr</span> || length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取基于二分查找的k第一次出现的位置</span></span><br><span class="line">	<span class="keyword">int</span> first = <span class="built_in">GetFirstK</span>(data, length, k, <span class="number">0</span>, length - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> last = <span class="built_in">GetLastK</span>(data, length, k, <span class="number">0</span>, length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (first != <span class="number">-1</span> &amp;&amp; last != <span class="number">-1</span>) &#123;</span><br><span class="line">		num = last - first + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> num;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetFirstK</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> len, <span class="keyword">int</span> k, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//base case</span></span><br><span class="line">	<span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span> (data[mid] == k) &#123;</span><br><span class="line">		<span class="comment">//若当前中值等于k，判断该值是否为第一个值为k的元素</span></span><br><span class="line">		<span class="keyword">if</span> (mid == <span class="number">0</span> || (mid &gt; <span class="number">0</span> &amp;&amp; data[mid - <span class="number">1</span>] != k)) &#123;</span><br><span class="line">			<span class="keyword">return</span> mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//若不是，则继续在该元素之前的子数组中查找</span></span><br><span class="line">		end = mid - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (data[mid] &lt; k) &#123;</span><br><span class="line">		start = mid + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		end = mid - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//二分递归</span></span><br><span class="line">	<span class="built_in">GetFirstK</span>(data, len, k, start, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetLastK</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> len, <span class="keyword">int</span> k, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//base case</span></span><br><span class="line">	<span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span> (data[mid] == k) &#123;</span><br><span class="line">		<span class="comment">//若当前中值等于k，判断该值是否为最后一个值为k的元素</span></span><br><span class="line">		<span class="keyword">if</span> (mid == len - <span class="number">1</span> || ((mid &lt; (len - <span class="number">1</span>)) &amp;&amp; data[mid + <span class="number">1</span>] != k)) &#123;</span><br><span class="line">			<span class="keyword">return</span> mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//若不是，则继续在该元素之后的子数组中查找</span></span><br><span class="line">		start = mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (data[mid] &lt; k) &#123;</span><br><span class="line">		start = mid + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		end = mid - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//二分递归</span></span><br><span class="line">	<span class="built_in">GetLastK</span>(data, len, k, start, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="53-1-0-n-1中缺失的数字"><a href="#53-1-0-n-1中缺失的数字" class="headerlink" title="53.1 0-n-1中缺失的数字"></a>53.1 0-n-1中缺失的数字</h1><blockquote>
<p>一个<strong>长度为n-1</strong>的<strong>递增排序</strong>数组中的所有<strong>数字都是唯一</strong>的,并且每个数字都在<strong>范围0-n-1之内</strong></p>
<p>在范围0~n-1内的n个数字中有且只有一个数字不在该数组中,请找出这个数字</p>
</blockquote>
<h2 id="Testing-case-65"><a href="#Testing-case-65" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(缺失的数字为数组首元素，尾元素，数组中某个元素)</li>
<li>边界测试(nullptr，数组中仅一个元素0)</li>
</ul>
<h2 id="Key-65"><a href="#Key-65" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>暴力遍历 T(n) = O(n)</p>
<blockquote>
<ol>
<li>通过公式 n(n-1) / 2，计算 0-n-1 数字的和</li>
<li>计算数组中所有数字元素的和</li>
<li>差值即为缺失的数字</li>
</ol>
</blockquote>
</li>
<li><p>二分查找 T(n) = O(logn)</p>
<blockquote>
<ol>
<li><p>二分查找，若data[mid] != mid，则进一步判断该元素是否为第一个下标不等于元素值的元素</p>
<p>(mid == 0) &amp;&amp; isSort，是数组首位元素且为缺失元素<br>mid &gt; 0 &amp;&amp; data[mid - 1] == mid - 1，不是数组首位元素且为缺失元素</p>
</li>
<li><p>若该元素是第一个下标不等于元素值的元素，则返回其下标，否则，在左子数组中继续查找</p>
</li>
<li><p>若data[mid] == mid，则在右子数组中进一步查找</p>
</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>数组长度为n-1且有序，若缺失数字为m，则数组中m位置之前的元素值均等于其下标，m以及m位置之后的元素均不等于其下标且差值为1</li>
<li>因此问题转换为求有序数组中第一个下标与元素不相等的下标值，缺失数字位置m处存放着元素m+1</li>
<li>注意代码鲁棒性，对于非法情况要有预防性处理</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-63"><a href="#Answer-63" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetMissingNum</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断异常</span></span><br><span class="line">	<span class="keyword">if</span> (data == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//二分查找第一个元素值不等于下标的元素</span></span><br><span class="line">	<span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> end = len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(start &lt;= end) &#123;</span><br><span class="line">		<span class="keyword">int</span> mid = (start + end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (data[mid] != mid) &#123;</span><br><span class="line">			<span class="comment">//首先判断该元素是否为非法元素</span></span><br><span class="line">			<span class="keyword">if</span> (data[mid] &gt;= len) &#123;</span><br><span class="line">				isExcption = <span class="literal">true</span>;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//进一步判断该元素是否为第一个下标不等于元素值的元素，两种可能</span></span><br><span class="line">			<span class="comment">//- 是首位元素且为缺失元素</span></span><br><span class="line">			<span class="comment">//- 不是首位元素且为缺失元素</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//若数组有序，则该元素与对应角标差值不超过1 --预防性处理</span></span><br><span class="line">			<span class="keyword">bool</span> isSort = data[mid] - mid == <span class="number">1</span>;</span><br><span class="line">			<span class="comment">//判断非首位的元素是否为第一个值不等于下标的元素</span></span><br><span class="line">			<span class="keyword">bool</span> isMFirst = mid &gt; <span class="number">0</span> &amp;&amp; data[mid - <span class="number">1</span>] == mid - <span class="number">1</span>;</span><br><span class="line">			<span class="comment">//判断首位元素是否为第一个一个值不等于下标的元素 --预防性处理</span></span><br><span class="line">			<span class="keyword">bool</span> isFFirst = (mid == <span class="number">0</span>) &amp;&amp; isSort;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (isFFirst || isMFirst) &#123;</span><br><span class="line">				<span class="keyword">return</span> mid;</span><br><span class="line">			&#125;</span><br><span class="line">			end = mid - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			start = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//考虑仅一个元素0的情况返回1</span></span><br><span class="line">	<span class="keyword">if</span> (start == len) &#123;</span><br><span class="line">		<span class="keyword">return</span> len;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//若二分遍历完都没有找到，则存在异常</span></span><br><span class="line">	<span class="comment">//非法数字，数组不是排序的</span></span><br><span class="line">	isExcption = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="53-2-数组中数值与下标相等的元素"><a href="#53-2-数组中数值与下标相等的元素" class="headerlink" title="53.2 数组中数值与下标相等的元素"></a>53.2 数组中数值与下标相等的元素</h1><blockquote>
<p>假设一个单调递增的数组里的每个元素都是整数并且是唯一的</p>
<p>请编程实现一个函数,找出数组中任意一个数值等于其下标的元素</p>
</blockquote>
<h2 id="Testing-case-66"><a href="#Testing-case-66" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(数组中含/不含数值与下标相等的元素)</li>
<li>边界测试(nullptr，数组中仅一个元素，要求元素位置数组首部/尾部)</li>
</ul>
<h2 id="Key-66"><a href="#Key-66" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>暴力遍历 T(n) = O(n)</p>
<blockquote>
<ol>
<li>遍历数组每个元素判断当前下标是否与对应元素相等</li>
</ol>
</blockquote>
</li>
<li><p>二分查找 T(n) = O(logn)</p>
<blockquote>
<ol>
<li><p>二分查找，若data[mid] != mid，则进一步缩小要求元素所在的范围</p>
<p>若data[mid]&lt;mid，由于数组单调递增，则mid左边的元素一定不存在值与下标相等的元素，在mid右边元素中继续查找</p>
<p>若data[mid]&gt;mid，由于数组单调递增，则mid右边的元素一定不存在值与下标相等的元素，在mid左边元素中继续查找</p>
</li>
<li><p>若data[mid] == mid，则返回mid</p>
</li>
<li><p>若数组中不存在要求元素，则返回-1</p>
</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li><p>数组为单调递增且元素唯一，基于二分查找，每次查找可将查找范围可缩小一半</p>
<p>若mid对应元素与mid不等，若data[mid]&lt;mid，由于数组单调递增，则mid左边的元素一定不存在值与下标相等的元素</p>
<p>若data[mid]&gt;mid，由于数组单调递增，则mid右边的元素一定不存在值与下标相等的元素</p>
</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-64"><a href="#Answer-64" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetNumberSameAsIndex</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断异常</span></span><br><span class="line">	<span class="keyword">if</span> (data == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> end = len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> mid = (start + end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (data[mid] == mid) &#123;</span><br><span class="line">			<span class="keyword">return</span> mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (data[mid] &lt; mid) &#123;</span><br><span class="line">			start = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			end = mid - <span class="number">1</span>;</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="54-二叉搜索树的第k大结点"><a href="#54-二叉搜索树的第k大结点" class="headerlink" title="54 二叉搜索树的第k大结点"></a>54 二叉搜索树的第k大结点</h1><blockquote>
<p>给定一棵二叉搜索树,请找出其中第k大的节点</p>
</blockquote>
<h2 id="Testing-case-67"><a href="#Testing-case-67" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(各种不同形态的二叉搜索树)</li>
<li>边界测试(nullptr，k=0,1,len，或k&gt;len len为二叉搜索树结点数)</li>
</ul>
<h2 id="Key-67"><a href="#Key-67" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>中序遍历</p>
<blockquote>
<ol>
<li>中序遍历二叉树搜索树，先判断左子树中是否存在第k大结点</li>
<li>若左子树中不存在，则判断当前根结点是否为第k大结点</li>
<li>若当前根结点不是，则判断其右子树中是否存在第k大结点</li>
<li>最终将pKthNode返回</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>二叉搜索树的中序遍历序列为由小到大的有序排列</li>
<li>异常判断是除了入口异常判断，还需注意k&gt;len时的越界处理</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-65"><a href="#Answer-65" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">GetKthNodePtr</span><span class="params">(TreeNode* pHead, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断异常</span></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span> || k &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		isException = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	TreeNode* pKthNode = <span class="built_in">GetKthNodePtrCore</span>(pHead, k);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//进行k越界的异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (pKthNode == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		isException = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pKthNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">GetKthNodePtrCore</span><span class="params">(TreeNode* pHead, <span class="keyword">int</span>&amp; k)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	TreeNode* pKthNode = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//左子树中找第k个结点</span></span><br><span class="line">	<span class="keyword">if</span> (pHead-&gt;pLeft != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		pKthNode = <span class="built_in">GetKthNodePtrCore</span>(pHead-&gt;pLeft, k);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//若左子树未找到第k个结点，判断当前结点是否为第k个结点</span></span><br><span class="line">	<span class="keyword">if</span> (pKthNode == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">			pKthNode = pHead;</span><br><span class="line">		&#125;</span><br><span class="line">		k--;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//若当前结点不是第k个结点，则在当前结点的右子树中找第k个结点</span></span><br><span class="line">	<span class="keyword">if</span> (pKthNode == <span class="literal">nullptr</span> &amp;&amp; pHead-&gt;pRight != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="built_in">GetKthNodePtrCore</span>(pHead-&gt;pRight, k);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pKthNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="55-二叉树的深度"><a href="#55-二叉树的深度" class="headerlink" title="55 二叉树的深度"></a>55 二叉树的深度</h1><blockquote>
<p>输入一棵二叉树的根节点,求该树的深度</p>
<p>从根节点到叶节点依次经过的节点(含根、叶节点)形成树的一条路径,最长路径的长度为树的深度</p>
</blockquote>
<h2 id="Testing-case-68"><a href="#Testing-case-68" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(普通二叉树，仅含左/右子树的二叉树)</li>
<li>边界测试(nullptr，二叉树仅含一个结点)</li>
</ul>
<h2 id="Key-68"><a href="#Key-68" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>先序遍历</p>
<blockquote>
<ol>
<li>先序遍历二叉树，对当前遍历的根节点进行计数</li>
<li>对于每一条路径，当到达叶子结点时打擂记录最大路径长度</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>遍历每一条路径记录最长的路径长度作为二叉树的深度</li>
<li>使用辅助接口函数返回二叉树的深度</li>
</ol>
</blockquote>
</li>
<li><p>后序遍历</p>
<blockquote>
<ol>
<li>后序遍历二叉树，使用两个变量记录当前根节点的左子树和右子树的深度</li>
<li>取左子树与右子树中深度较大者+1作为当前子树的深度</li>
<li>若当前根节点为空，则深度为0</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>每个子树的深度为其根节点左子树与右子树中深度较大者+1</li>
<li>base case若是对叶子结点的判断，则在对左/右子树遍历前需要保证左/右子树不为空</li>
<li>base case若是对nullptr的判断，则可放心递归获取左/右子树深度</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-66"><a href="#Answer-66" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<p>1.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode* pHead)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		isException = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//记录深度的变量</span></span><br><span class="line">	<span class="keyword">int</span> Depth = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//记录最大深度的变量</span></span><br><span class="line">	<span class="keyword">int</span> MaxDepth = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">TreeDepthCore</span>(pHead, Depth, MaxDepth);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> MaxDepth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TreeDepthCore</span><span class="params">(TreeNode* pHead, <span class="keyword">int</span> Depth, <span class="keyword">int</span>&amp; MaxDepth)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//先序遍历</span></span><br><span class="line">	Depth++;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//到达叶子结点</span></span><br><span class="line">	<span class="keyword">if</span> (pHead-&gt;pLeft == <span class="literal">nullptr</span> &amp;&amp; pHead-&gt;pRight == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (Depth &gt;= MaxDepth) &#123;</span><br><span class="line">			MaxDepth = Depth;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pHead-&gt;pLeft != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="built_in">TreeDepthCore</span>(pHead-&gt;pLeft, Depth, MaxDepth);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pHead-&gt;pRight != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="built_in">TreeDepthCore</span>(pHead-&gt;pRight, Depth, MaxDepth);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TreeDepthByPost</span><span class="params">(TreeNode* pHead)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		isException = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">TreeDepthByPostCore</span>(pHead);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TreeDepthByPostCore</span><span class="params">(TreeNode* pHead)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//base case</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	if (pHead == nullptr) &#123;</span></span><br><span class="line"><span class="comment">		return 0;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	int Left = TreeDepthByPostCore(pHead-&gt;pLeft);</span></span><br><span class="line"><span class="comment">	int Right = TreeDepthByPostCore(pHead-&gt;pRight);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	return (Left &gt; Right) ? Left + 1 : Right + 1;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pHead-&gt;pLeft == <span class="literal">nullptr</span> &amp;&amp; pHead-&gt;pRight == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> Left = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (pHead-&gt;pLeft != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		Left = <span class="built_in">TreeDepthByPostCore</span>(pHead-&gt;pLeft);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> Right = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (pHead-&gt;pRight != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		Right = <span class="built_in">TreeDepthByPostCore</span>(pHead-&gt;pRight);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (Left &gt; Right) ? Left + <span class="number">1</span> : Right + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="55-1-平衡二叉树"><a href="#55-1-平衡二叉树" class="headerlink" title="55.1 平衡二叉树"></a>55.1 平衡二叉树</h1><blockquote>
<p>输入一棵二叉树的根节点,判断该树是不是平衡二叉树</p>
<p>如果某二叉树中任意节点的左、右子树的深度相差不超过1,那么它就是一棵平衡二叉树</p>
</blockquote>
<h2 id="Testing-case-69"><a href="#Testing-case-69" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(普通二叉树/平衡二叉树，仅含左/右子树的平衡二叉树)</li>
<li>边界测试(nullptr，二叉树仅含一个结点)</li>
</ul>
<h2 id="Key-69"><a href="#Key-69" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>先序遍历</p>
<blockquote>
<ol>
<li>先序遍历二叉树的每一个结点</li>
<li>对于当前根结点基于TreeDepth求得当前结点的左右子树深度并判断当前结点的平衡因子是否满足要求</li>
<li>进而判断左右子树中的各结点是否满足要求</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>求解结点的平衡因子时存在大量的重复计算</li>
<li>设置两个全局异常判断变量，防止不同类型的异常混乱</li>
</ol>
</blockquote>
</li>
<li><p>后序遍历</p>
<blockquote>
<ol>
<li>后序遍历二叉树，在左右子树均满足平衡二叉树的条件下</li>
<li>根据两个子树的深度记录参数，判断当前根节点的平衡因子是否满足要求，并计算当前结点为根节点的子树的深度</li>
<li>直至根节点为nullptr返回true，深度记录为0</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>后序遍历二叉树，在左右子树均满足平衡二叉树的条件下，再判断当前根节点的平衡因子是否满足要求</li>
<li>当前根节点的平衡因子判断需要在遍历左右子树时实时记录左右子树的深度，增加一个记录深度的输出参数即可</li>
<li>对所有结点仅遍历了一次</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-67"><a href="#Answer-67" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<p>1.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalancedTreeByPre</span><span class="params">(TreeNode* pHead)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断异常</span></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		isBalancedException = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">isBalancedTreeByPreCore</span>(pHead);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalancedTreeByPreCore</span><span class="params">(TreeNode* pHead)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//base case</span></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取当前结点的左右子树深度</span></span><br><span class="line">	<span class="keyword">int</span> left = <span class="built_in">TreeDepthByPost</span>(pHead-&gt;pLeft);</span><br><span class="line">	<span class="keyword">int</span> Right = <span class="built_in">TreeDepthByPost</span>(pHead-&gt;pRight);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断当前结点的平衡因子是否满足要求</span></span><br><span class="line">	<span class="keyword">int</span> diff = left - Right;</span><br><span class="line">	<span class="keyword">if</span> (diff &lt; <span class="number">-1</span> || diff &gt; <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//若当前结点平衡因子满足要求，则进而判断其左右子树中各结点是否满足要求</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">isBalancedTreeByPreCore</span>(pHead-&gt;pLeft) &amp;&amp; <span class="built_in">isBalancedTreeByPreCore</span>(pHead-&gt;pRight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalancedTreeByPostCore</span><span class="params">(TreeNode* pHead, <span class="keyword">int</span>&amp; Depth)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//base case</span></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		Depth = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置记录左右子树深度的输出参数</span></span><br><span class="line">	<span class="keyword">int</span> Left;</span><br><span class="line">	<span class="keyword">int</span> Right;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">isBalancedTreeByPostCore</span>(pHead-&gt;pLeft, Left) &amp;&amp; <span class="built_in">isBalancedTreeByPostCore</span>(pHead-&gt;pRight, Right)) &#123;</span><br><span class="line">		<span class="keyword">int</span> diff = Left - Right;</span><br><span class="line">		<span class="keyword">if</span> (diff &gt;= <span class="number">-1</span> &amp;&amp; diff &lt;= <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//记录当前结点作根结点的子树的深度</span></span><br><span class="line">			Depth = <span class="number">1</span> + (Left &gt; Right ? Left : Right);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//若当前结点平衡因子不满足要求，则无需记录深度，直接返回false即可</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="56-数组中只出现一次的两个数字"><a href="#56-数组中只出现一次的两个数字" class="headerlink" title="56 数组中只出现一次的两个数字"></a>56 数组中只出现一次的两个数字</h1><blockquote>
<p>一个整型数组里除两个数字之外,其他数字都出现了两次</p>
<p>请写程序找出这两个只出现一次的数字</p>
<p>要求时间复杂度是0(n),空间复杂度是0(1)</p>
</blockquote>
<h2 id="Testing-case-70"><a href="#Testing-case-70" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(数组中有多对重复数字，数组中无重复数字)</li>
<li>边界测试(nullptr)</li>
</ul>
<h2 id="Key-70"><a href="#Key-70" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>位运算 - 异或 T(n) = O(n) S(n) = O(1)</p>
<blockquote>
<ol>
<li><p>遍历整个数组求所有元素的异或结果</p>
</li>
<li><p>根据1自低位起出现的出现的位置作为划分依据，将数组划分为分别包含一个只出现一次数字的两个子数组</p>
<p>FirstIndex位为1的为1组，FirstIndex位为0的为1组</p>
</li>
<li><p>分别计算两个子数组中只出现一次的数字</p>
</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>先分析数组中只出现一次的一个数字的求法，将数组每个元素进行异或运算，结果即为只出现一次的数字，因为重复的数字异或结果为0</li>
<li>而两个数字的求法基于方法1，可以想办法将这两个数字分于两个子数组中，分别求两个子数组中只出现一次的数字即可</li>
<li>因为返回值有两个，因此使用输出参数返回结果</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-68"><a href="#Answer-68" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isOneInIndex</span><span class="params">(<span class="keyword">int</span> Num, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//右移index次到达index位</span></span><br><span class="line">	Num &gt;&gt; index;</span><br><span class="line">	<span class="comment">//判断该位是否为1</span></span><br><span class="line">	<span class="keyword">return</span> Num &amp; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetIndexOfNum1</span><span class="params">(<span class="keyword">int</span> Num)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//自低位开始判断是否为1，若不是则右移，但注意防止溢出，注意边界判断，共 8*sizeof(int) 位</span></span><br><span class="line">	<span class="keyword">while</span> (((Num &amp; <span class="number">1</span>) == <span class="number">0</span>) &amp;&amp; (index &lt; <span class="number">8</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>))) &#123;</span><br><span class="line">		Num &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">		index++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> len, <span class="keyword">int</span>&amp; Num1, <span class="keyword">int</span>&amp; Num2)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断异常</span></span><br><span class="line">	<span class="keyword">if</span> (data == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//首次遍历数组，求得所有数字的异或结果</span></span><br><span class="line">	<span class="keyword">int</span> ExclusiveOr = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		ExclusiveOr ^= data[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//求得异或结果从低位记起 1 第一次出现的位置</span></span><br><span class="line">	<span class="keyword">int</span> FirstIndex = <span class="built_in">GetIndexOfNum1</span>(ExclusiveOr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将数组分成两组 一组FirstIndex位为0 一组FirstIndex位为1</span></span><br><span class="line">	<span class="comment">//分别计算两组的异或结果，结果即为两个出现次数为1的数字</span></span><br><span class="line"></span><br><span class="line">	Num1 = <span class="number">0</span>;</span><br><span class="line">	Num2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">isOneInIndex</span>(data[i], FirstIndex)) &#123;</span><br><span class="line">			Num1 ^= data[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			Num2 ^= data[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="56-1-数组中唯一只出现一次的数字"><a href="#56-1-数组中唯一只出现一次的数字" class="headerlink" title="56.1 数组中唯一只出现一次的数字"></a>56.1 数组中唯一只出现一次的数字</h1><blockquote>
<p>在一个数组中除一个数字只出现一次之外,其他数字都出现了三次</p>
<p>请找出那个只出现一次的数字</p>
</blockquote>
<h2 id="Testing-case-71"><a href="#Testing-case-71" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(只出现一次的数字为0，正数，负数，重复出现的数字为0，正数，负数)</li>
<li>边界测试(nullptr)</li>
</ul>
<h2 id="Key-71"><a href="#Key-71" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>位运算 T(n) = O(n) S(n) = O(1)</p>
<blockquote>
<ol>
<li>遍历数组，由低位起，将数组元素每一位的值累加到indexSum数组的对应位上</li>
<li>由indexSum的每一位累加和求得只出现一次的数字的每一位的值并作移位累加</li>
<li>将移位累加和返回</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>其他数字都出现了三次，数组各元素异或结果重复数字仍为原数字，异或不可取</li>
<li>但是若对数组各元素的每一位求和，并记录每一位的和，若该位求和结果可被3整除，则只出现一次的数字该位为0，否则为1</li>
<li>对int型数字的每一位均记录求和结果，可使用大小为32的int型数组，indexSum数组</li>
<li>选取更新掩码的方法来由低到高遍历整数的每一位</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-69"><a href="#Answer-69" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindNumAppearOnce</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断异常</span></span><br><span class="line">	<span class="keyword">if</span> (data == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历数组每一个元素，累加计算每个元素每一位上的和</span></span><br><span class="line">	<span class="keyword">int</span> indexSum[<span class="number">32</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		<span class="comment">//累加当前元素的各位上的和，整型元素共32位</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//各位遍历时不希望右移数据元素更改数据，而选择移动掩码来进行下一位的累加和计算</span></span><br><span class="line">		<span class="keyword">int</span> indexMask = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">31</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">			<span class="comment">//低位起记录当前位上的值</span></span><br><span class="line">			<span class="keyword">int</span> result = data[i] &amp; indexMask;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="comment">//若当前位值为1，则累加1，而非累加result，是该位的累加和不再考虑低位</span></span><br><span class="line">				indexSum[j] += <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//进行下一位的判断</span></span><br><span class="line">			indexMask &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//计算只出现一次数字的值，以位为单位计算最终得到Num值</span></span><br><span class="line">	<span class="keyword">int</span> Num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">		Num &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">		Num += indexSum[i] % <span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> Num;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="57-和为s的数字"><a href="#57-和为s的数字" class="headerlink" title="57 和为s的数字"></a>57 和为s的数字</h1><blockquote>
<p>输入一个递增排序的数组和一个数字S,在数组中查找两个数,使得它们的和正好是S</p>
<p>如果有多对数字的和等于S,则输出任意一对即可</p>
</blockquote>
<h2 id="Testing-case-72"><a href="#Testing-case-72" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(数组中存在/不存在和为s的两个数字)</li>
<li>边界测试(nullptr)</li>
</ul>
<h2 id="Key-72"><a href="#Key-72" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>暴力遍历 T(n) = O(n2)</p>
<blockquote>
<ol>
<li>遍历数组，同时固定当前数字，计算当前数字与其后数字的和是否满足和为S</li>
</ol>
</blockquote>
</li>
<li><p>双指针遍历 T(n) = O(n)</p>
<blockquote>
<ol>
<li><p>设置两个遍历指针，分别初始化为指向数组最小值与最大值</p>
</li>
<li><p>计算两个指针指向位置的和s，判断与S的大小关系，若与s=S，则设置传出参数返回</p>
<p>若 s&lt;S,则将指向较小元素的指针后移，增大s</p>
<p>若 s&gt;S,则将指向较大元素的指针前移，缩小s</p>
</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>数组为排序数组，因此当选择两个数计算和后，通过判断与s的大小关系可以缩小查找范围</li>
<li>设置双指针，一个指向较小的元素，一个指向较大的元素，通过指针的交替移动完成查找</li>
<li>涉及多个结果的返回，通过传出参数返回结果</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-70"><a href="#Answer-70" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FindNumWithSum</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> length, <span class="keyword">int</span> Sum, <span class="keyword">int</span>&amp; Num1, <span class="keyword">int</span>&amp; Num2)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断异常</span></span><br><span class="line">	<span class="keyword">if</span> (data == <span class="literal">nullptr</span> || length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置返回值</span></span><br><span class="line">	<span class="keyword">bool</span> find = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置两个指针分别用于指向Num1与Num2，初始化为排序数组最大值与最小值</span></span><br><span class="line">	<span class="keyword">int</span> maxIndex = length - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> minIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (minIndex &lt; maxIndex) &#123;</span><br><span class="line">		<span class="keyword">int</span> sum = data[maxIndex] + data[minIndex];</span><br><span class="line">		<span class="keyword">if</span> (sum == Sum) &#123;</span><br><span class="line">			find = <span class="literal">true</span>;</span><br><span class="line">			Num2 = data[maxIndex];</span><br><span class="line">			Num1 = data[minIndex];</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; Sum) &#123;</span><br><span class="line">			<span class="comment">//若此时指针指向的两个元素和小于Sum,则将指向较小元素的指针后移(数组由小到大排序)</span></span><br><span class="line">			minIndex++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//若此时指针指向的两个元素和大于Sum,则将指向较大元素的指针后移(数组由小到大排序)</span></span><br><span class="line">			maxIndex--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> find;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="57-1-和为s的连续正数序列"><a href="#57-1-和为s的连续正数序列" class="headerlink" title="57.1 和为s的连续正数序列"></a>57.1 和为s的连续正数序列</h1><blockquote>
<p>输入一个正数s,打印出所有和为s的连续正数序列(至少含有两个数)</p>
<p>例如,输入T5,由于1+2+3+4+5=4+5+6=7+8=15,所以打印出3个连续序列1<del>5,4</del>6和7~8</p>
</blockquote>
<h2 id="Testing-case-73"><a href="#Testing-case-73" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(存在/不存在和为s的序列,例如4)</li>
<li>边界测试(3)</li>
</ul>
<h2 id="Key-73"><a href="#Key-73" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>范围指针对</p>
<blockquote>
<ol>
<li>设置一对范围遍历指针，并使用curSum记录当前范围序列的累加和</li>
<li>移动指针对自1开始的正数序列进行遍历，若curSum == Sum ,则对当前序列进行输出，并进一步扩大范围，先对end++，后对curSum累加</li>
<li>若 curSum &gt; Sum，则一直缩小序列范围，curSum 剔除start当前指向的元素，并将start后移，直到curSum == Sum or curSum &lt; Sum</li>
<li>若 curSum &lt; Sum，则一直扩大序列范围，先对end++，后对curSum累加，直到curSum == Sum or curSum &gt; Sum</li>
<li>最终直至start &gt;= (sum + 1) / 2</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li><p>curSum记录当前范围序列的累加和</p>
<p>缩小序列范围时，应先将curSum剔除掉start对应的数，后对start++</p>
<p>扩大序列范围时，应先对end++，后对curSum累加</p>
</li>
<li><p>范围遍历指针时刻指向正数序列的两个边界</p>
</li>
<li><p>由于需要找到所有的正数序列，因此即使输出了一个正数序列之后，也应再次扩大范围，进行查找</p>
</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-71"><a href="#Answer-71" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSequene</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">		cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindContinuousSequene</span><span class="params">(<span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断异常</span></span><br><span class="line">	<span class="keyword">if</span> (sum &lt; <span class="number">3</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//设置序列范围指针</span></span><br><span class="line">	<span class="keyword">int</span> start = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> end = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//记录序列范围中所有数字的和</span></span><br><span class="line">	<span class="keyword">int</span> curSum = start + end;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历找寻满足条件的序列</span></span><br><span class="line">	<span class="keyword">while</span> (start &lt; (sum + <span class="number">1</span>) / <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="comment">//简化版</span></span><br><span class="line">        </span><br><span class="line">		<span class="keyword">if</span> (curSum == sum) &#123;</span><br><span class="line">			<span class="built_in">printSequene</span>(start, end);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (curSum &gt; sum &amp;&amp; start &lt; (sum + <span class="number">1</span>) / <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="comment">//剔除序列中最小的正数，先累减后++</span></span><br><span class="line">			curSum -= start;</span><br><span class="line">			start++;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (curSum == sum) &#123;</span><br><span class="line">				<span class="built_in">printSequene</span>(start, end);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//扩大序列的范围，先++后累加</span></span><br><span class="line">		end++;</span><br><span class="line">		curSum += end;		</span><br><span class="line"></span><br><span class="line">		<span class="comment">//冗余版</span></span><br><span class="line">		<span class="comment">//if (curSum == sum) &#123;</span></span><br><span class="line">		<span class="comment">//	printSequene(start, end);</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//	end++;</span></span><br><span class="line">		<span class="comment">//	curSum += end;</span></span><br><span class="line">		<span class="comment">//&#125;</span></span><br><span class="line">		<span class="comment">//else if (curSum &gt; sum) &#123;</span></span><br><span class="line">		<span class="comment">//	curSum -= start;</span></span><br><span class="line">		<span class="comment">//	start++;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//	if (curSum == sum) &#123;</span></span><br><span class="line">		<span class="comment">//		printSequene(start, end);</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//		end++;</span></span><br><span class="line">		<span class="comment">//		curSum += end;</span></span><br><span class="line">		<span class="comment">//	&#125;</span></span><br><span class="line">		<span class="comment">//&#125;</span></span><br><span class="line">		<span class="comment">//else &#123;</span></span><br><span class="line">		<span class="comment">//	//扩大序列的范围，先++后累加</span></span><br><span class="line">		<span class="comment">//	end++;</span></span><br><span class="line">		<span class="comment">//	curSum += end;</span></span><br><span class="line">		<span class="comment">//&#125;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="58-翻转字符串"><a href="#58-翻转字符串" class="headerlink" title="58 翻转字符串"></a>58 翻转字符串</h1><blockquote>
<p>输入一个英文句子,翻转句子中单词的顺序,但单词内字符的顺序不变</p>
<p>为简单起见,标点符号和普通字母一样处理</p>
<p>例如输入字符串”I am a student.”,则输出”student. a am I”</p>
</blockquote>
<h2 id="Testing-case-74"><a href="#Testing-case-74" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(句子中有多个单词，句子中只有一个单词)</li>
<li>边界测试(nullptr，空字符串，只有空格)</li>
</ul>
<h2 id="Key-74"><a href="#Key-74" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>范围指针对 + 整体与局部</p>
<blockquote>
<ol>
<li>设置范围指针对分别指向字符串首尾</li>
<li>根据范围指针对，先将整个字符串进行翻转</li>
<li>由范围指针对，对单个单词进行翻转，pEnd后移找寻单词末尾(‘ ‘ or ‘\0’ )，pStart进行遍历并时刻指向单词首部</li>
<li>直至 pStart == ‘\0’ ，字符串翻转完毕</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>对单词进行翻转判断时，注意pEnd后移找到单词末尾时，需要翻转不包含 ‘ ‘ or ‘\0’ 的子字符串,传参时注意指针的前移</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-72"><a href="#Answer-72" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">ReverseSentence</span><span class="params">(<span class="keyword">char</span>* pSen)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断异常</span></span><br><span class="line">	<span class="keyword">if</span> (pSen == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span>* pStart = pSen;</span><br><span class="line">	<span class="keyword">char</span>* pEnd = pStart;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置范围指针对的范围，使pEnd指向字符串尾部</span></span><br><span class="line">	<span class="keyword">while</span> (*pEnd != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">		pEnd++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pEnd--;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//翻转整个字符串</span></span><br><span class="line">	<span class="built_in">ReverseWords</span>(pStart, pEnd);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//翻转每个单词</span></span><br><span class="line">	<span class="comment">//重置范围指针对指向范围</span></span><br><span class="line">	pStart = pEnd = pSen;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (*pStart != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (*pStart == <span class="string">&#x27; &#x27;</span> &amp;&amp; *pEnd == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">			pStart++;</span><br><span class="line">			pEnd++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (*pEnd == <span class="string">&#x27; &#x27;</span> || *pEnd == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">			<span class="comment">//翻转单词</span></span><br><span class="line">			<span class="built_in">ReverseWords</span>(pStart, --pEnd);</span><br><span class="line">			pStart = ++pEnd;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			pEnd++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pSen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReverseWords</span><span class="params">(<span class="keyword">char</span>* pStart, <span class="keyword">char</span>* pEnd)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断异常</span></span><br><span class="line">	<span class="keyword">if</span> (pStart == <span class="literal">nullptr</span> || pEnd == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (pStart &lt; pEnd) &#123;</span><br><span class="line">		<span class="keyword">char</span> temp = *pStart;</span><br><span class="line">		*pStart = *pEnd;</span><br><span class="line">		*pEnd = temp;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//缩小范围</span></span><br><span class="line">		pStart++;</span><br><span class="line">		pEnd--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="58-1-左旋转字符串"><a href="#58-1-左旋转字符串" class="headerlink" title="58.1 左旋转字符串"></a>58.1 左旋转字符串</h1><blockquote>
<p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部</p>
<p>请定义一个函数实现字符串左旋转操作的功能</p>
<p>比如,输入字符串”abcdefg”和数字2,该函数将返回左旋转两位得到的结果”cdefgab”</p>
</blockquote>
<h2 id="Testing-case-75"><a href="#Testing-case-75" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(长度为n的字符串左旋0,1,2,n,n-1,n+1个字符)</li>
<li>边界测试(nullptr)</li>
</ul>
<h2 id="Key-75"><a href="#Key-75" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>范围指针对 + 整体与局部</p>
<blockquote>
<ol>
<li>设置范围指针对分别指向字符串首尾</li>
<li>根据范围指针对，先将整个字符串进行翻转</li>
<li>由范围指针对,根据左旋的字符数确定待翻转的子串范围，并将该范围子串翻转</li>
<li>将不需要左旋的字符串进行翻转恢复</li>
<li>将两个子字符串翻转完毕后，字符串左旋完毕</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>注意空串，待旋转子串长度越界问题，代码鲁棒性检查</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-73"><a href="#Answer-73" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReverseWords</span><span class="params">(<span class="keyword">char</span>* pStart, <span class="keyword">char</span>* pEnd)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断异常</span></span><br><span class="line">	<span class="keyword">if</span> (pStart == <span class="literal">nullptr</span> || pEnd == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (pStart &lt; pEnd) &#123;</span><br><span class="line">		<span class="keyword">char</span> temp = *pStart;</span><br><span class="line">		*pStart = *pEnd;</span><br><span class="line">		*pEnd = temp;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//缩小范围</span></span><br><span class="line">		pStart++;</span><br><span class="line">		pEnd--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">LeftRotateString</span><span class="params">(<span class="keyword">char</span>* pStr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断异常</span></span><br><span class="line">	<span class="keyword">if</span> (pStr == <span class="literal">nullptr</span> || *pStr == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span>* pStart = pStr;</span><br><span class="line">	<span class="keyword">char</span>* pEnd = pStart;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置范围指针对的范围，使pEnd指向字符串尾部</span></span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (*pEnd != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">		pEnd++;</span><br><span class="line">		num++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (n &gt; num) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pEnd--;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//翻转整个字符串</span></span><br><span class="line">	<span class="built_in">ReverseWords</span>(pStart, pEnd);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//对指定范围进行翻转</span></span><br><span class="line">	<span class="comment">//将需要左旋子字符串进行翻转</span></span><br><span class="line">	<span class="built_in">ReverseWords</span>(pEnd - n + <span class="number">1</span>, pEnd);</span><br><span class="line">	<span class="comment">//将不需要左旋的字符串进行恢复</span></span><br><span class="line">	<span class="built_in">ReverseWords</span>(pStart, pEnd - n);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pStr;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="59-滑动窗口的最大值"><a href="#59-滑动窗口的最大值" class="headerlink" title="59 滑动窗口的最大值"></a>59 滑动窗口的最大值</h1><blockquote>
<p>给定一个数组和滑动窗口的大小,请找出所有滑动窗口里的最大值</p>
<p>例如,如果输入数组(2,3,4,2,6,2,5,1)及滑动窗口的大小3,那么一共存在6个滑动窗口,它们的最大值分别为4,4,6,6,6,5</p>
</blockquote>
<h2 id="Testing-case-76"><a href="#Testing-case-76" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(输入的数组无序/单调递增/单调递减)</li>
<li>边界测试(数组为空，滑动窗口的大小为0，1，等于/大于 输入数组的大小)</li>
</ul>
<h2 id="Key-76"><a href="#Key-76" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>双向队列</p>
<blockquote>
<ol>
<li>设置一个双向队列Window以及待返回的存放各窗口最大值的maxInWindows数组</li>
<li>在窗口元素未满WinSize前，先遍历数组data的前WinSize个元素，若Window非空，则从队尾开始循环判断，将小于等于当前数组元素的Window元素(下标)从队尾弹出(将不可能成为当前滑动窗口的元素由Window队尾开始逐个弹出)，最终将当前元素下标压入</li>
<li>在窗口元素未满WinSize后，对数组剩余元素进行遍历，先将WinSize队首元素(当前滑动窗口的最大值元素在data中的下标)进行记录，进而将不可能成为当前滑动窗口的元素由Window队尾开始逐个弹出，再将已不在当前窗口内的队首元素逐个弹出，最终将当前元素下标压入</li>
<li>将最后一个滑动窗口的最大值元素下标记录后，返回maxInWindows数组</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>使用一个双向队列，仅存放当前滑动窗口中的最大值元素以及可能成为其后滑动窗口最大值的元素，队首始终为当前滑动窗口的最大值元素 -下标</li>
<li>为了确保队列滑动时此队列能排除窗口之外的元素，队列中存放数组元素下标而非元素，通过下标根据窗口大小判断队首元素是否已不在此窗口中</li>
<li>在窗口元素未满WinSize前，当前队列队首元素并不是最大值元素的下标，因此单独处理</li>
<li>在窗口元已满WinSize后，每遍历一个元素后，队首元素即为当前滑动窗口最大值元素的下标，记录该最大值元素</li>
<li>deque同时允许队首队尾删除元素，在非最值元素时队尾弹出，在超出窗口范围时队首弹出</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-74"><a href="#Answer-74" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">MaxInWindows</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; data, <span class="keyword">int</span> WinSize)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置返回各窗口最大值的数组</span></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; maxInWindows;</span><br><span class="line">	<span class="comment">//判断异常</span></span><br><span class="line">	<span class="keyword">if</span> (data.<span class="built_in">size</span>() &lt; WinSize || WinSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> maxInWindows;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置窗口队列，仅存可能为窗口最大值的元素</span></span><br><span class="line">	deque&lt;<span class="keyword">int</span>&gt; Window;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历数组元素，并对窗口状态进行更新，弹出不可能为窗口最大值的元素</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//先对数组前WinSize进行遍历，因为此时并未填满窗口</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; WinSize; i++) &#123;</span><br><span class="line">		<span class="comment">//根据当前元素值判断，弹出不可能为当前窗口最大值的元素</span></span><br><span class="line">		<span class="keyword">while</span> (!Window.<span class="built_in">empty</span>() &amp;&amp; data[i] &gt;= data[Window.<span class="built_in">back</span>()]) &#123;</span><br><span class="line">			Window.<span class="built_in">pop_back</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将当前元素数组下标压入窗口</span></span><br><span class="line">		Window.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = WinSize; i &lt; data.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		<span class="comment">//将窗口队列队首元素压入maxInWindows，记录窗口最大值</span></span><br><span class="line">		maxInWindows.<span class="built_in">push_back</span>(data[Window.<span class="built_in">front</span>()]);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//根据当前元素值判断，弹出不可能为当前窗口最大值的元素</span></span><br><span class="line">		<span class="keyword">while</span> (!Window.<span class="built_in">empty</span>() &amp;&amp; data[i] &gt;= data[Window.<span class="built_in">back</span>()]) &#123;</span><br><span class="line">			Window.<span class="built_in">pop_back</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//根据当前元素的下标判断，弹出当前窗口之外的的元素</span></span><br><span class="line">		<span class="keyword">while</span> (!Window.<span class="built_in">empty</span>() &amp;&amp; (i - Window.<span class="built_in">front</span>() &gt;= WinSize)) &#123;</span><br><span class="line">			Window.<span class="built_in">pop_front</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将当前元素数组下标压入窗口</span></span><br><span class="line">		Window.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将窗口队列队首元素压入maxInWindows，记录窗口最大值</span></span><br><span class="line">	maxInWindows.<span class="built_in">push_back</span>(data[Window.<span class="built_in">front</span>()]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> maxInWindows;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="59-1-队列的最大值"><a href="#59-1-队列的最大值" class="headerlink" title="59.1 队列的最大值"></a>59.1 队列的最大值</h1><blockquote>
<p>请定义一个队列并实现函数max得到队列里的最大值,要求函数max,push_back和pop_front的时间复杂度都是0(1)</p>
</blockquote>
<h2 id="Testing-case-77"><a href="#Testing-case-77" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(对队列进行 插入/删除 操作后求最大值)</li>
<li>边界测试(队列为空)</li>
</ul>
<h2 id="Key-77"><a href="#Key-77" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>队列特性</p>
<blockquote>
<p>队列的特性与栈不同，队列为先进先出</p>
<p>若当前压入的元素成为了队列的最大值，那么在该元素弹出之前(未压入新元素)，队列的最大值始终为该元素</p>
</blockquote>
</li>
<li><p>双向队列</p>
<blockquote>
<p>使用一个双向队列max来记录队列data不同状态下的最大值</p>
<p>max队列仅存放当前data队列最大值以及该最大值弹出后剩余状态的可能最大值，队首为当前data队列状态对应的最大值</p>
</blockquote>
</li>
<li><p>数据内部封装</p>
<blockquote>
<p>在弹出元素时需要根据data队列弹出的元素来更新当前最大值状态，通过index与相应元素的绑定封装可以标识当前弹出的元素是否为当前data队列的最大值，从而更新max队列相应的最大值状态</p>
</blockquote>
</li>
<li><p>push_back压入元素</p>
<blockquote>
<ol>
<li><p>将压入的元素封装为内部数据压入data队列</p>
</li>
<li><p>更新相应的max队列最大值状态，剔除max队列自队尾开始比当前压入元素小的元素，将当前元素压入max队列</p>
<p>由于队列特性，只要压入元素，那么该元素就可能成为data队列某一状态的最大值</p>
</li>
<li><p>更新currentIndex索引绑定下一个元素</p>
</li>
</ol>
</blockquote>
</li>
<li><p>pop_front弹出元素</p>
<blockquote>
<ol>
<li>先判断当前弹出元素是否会影响max队列状态，若当前弹出元素绑定的currentIndex索引与max队首currentIndex索引相同，则需弹出max队首</li>
<li>在将该元素从data队首弹出</li>
<li>若 data 队列 or max队列 为空，则弹异常</li>
</ol>
</blockquote>
</li>
<li><p>getMax取最大值</p>
<blockquote>
<ol>
<li>取max队列队首元素</li>
<li>若 data队列 or max队列 为空，则弹异常</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-75"><a href="#Answer-75" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueueWithMax</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">QueueWithMax</span>() :<span class="built_in">currentIndex</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(T val)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//将数据封装为内部数据</span></span><br><span class="line">		InternalData internalData;</span><br><span class="line">		internalData.number = val;</span><br><span class="line">		internalData.index = currentIndex;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将内部数据压入到data队列中</span></span><br><span class="line">		data.<span class="built_in">push_back</span>(internalData);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//更新目前data队列的最大值，目前data队列的最大值位于max队首</span></span><br><span class="line">		<span class="comment">//先将已不可能成为data队列剩余状态的最大值的元素弹出</span></span><br><span class="line">		<span class="keyword">while</span> (!max.<span class="built_in">empty</span>() &amp;&amp; val &gt;= max.<span class="built_in">back</span>().number) &#123;</span><br><span class="line">			max.<span class="built_in">pop_back</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//剔除掉不可能元素后，剩余元素即为可能成为队列某一状态下的最大值，当前最大值为max队首元素</span></span><br><span class="line">		<span class="comment">//当前元素可能作为data队列某一状态下的最大值，压入</span></span><br><span class="line">		max.<span class="built_in">push_back</span>(internalData);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将索引更新指向下一个元素</span></span><br><span class="line">		currentIndex++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!data.<span class="built_in">empty</span>() &amp;&amp; !max.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (data.<span class="built_in">front</span>().index == max.<span class="built_in">front</span>().index) &#123;</span><br><span class="line">				max.<span class="built_in">pop_front</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			data.<span class="built_in">pop_front</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">exception</span>(<span class="string">&quot;异常&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">T <span class="title">getMax</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!max.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">			<span class="keyword">return</span> max.<span class="built_in">front</span>().number;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">exception</span>(<span class="string">&quot;异常&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">InternalData</span> &#123;</span></span><br><span class="line">		T number;</span><br><span class="line">		<span class="keyword">int</span> index;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	deque&lt;InternalData&gt; data;</span><br><span class="line">	deque&lt;InternalData&gt; max;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> currentIndex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="60-n个骰子的点数"><a href="#60-n个骰子的点数" class="headerlink" title="60 n个骰子的点数"></a>60 n个骰子的点数</h1><blockquote>
<p>把n个骰子扔在地上,所有骰子朝上一面的点数之和为s</p>
<p>输入n,打印出s的所有可能的值出现的概率</p>
</blockquote>
<h2 id="Testing-case-78"><a href="#Testing-case-78" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(1,2,3,4)</li>
<li>边界测试(0)</li>
<li>性能测试(11)</li>
</ul>
<h2 id="Key-78"><a href="#Key-78" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>穷举递归</p>
<blockquote>
<ol>
<li>base case 剩余骰子数为0时记录骰子点数之和于数组中，对应存放位置累加计数</li>
<li>explore 向下递归，对剩余骰子点数之和进行记录</li>
<li>backtracking 在进行本骰子下一结果决策之前，先恢复骰子点数和，剔除上一次的结果</li>
<li>根据骰子各点数和与所有可能结果(6^n)计算某骰子和出现的概率</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>使用一个数组对n个骰子朝上一面点数之和的出现次数进行记录，无需使用maxSum大小的数组直接使用点数和映射位置，而是仅存minSum - maxSum之间的maxSum - minSum + 1 个元素，使用 点数和 - minSum 映射存放位置</li>
<li>递归含多次重复计算</li>
</ol>
</blockquote>
</li>
<li><p>自下而上 + 迭代计算 + 哈希表</p>
<blockquote>
<ol>
<li><p>计算并记录一个骰子的所有点数和出现次数，使用数组记录，角标对应点数和，元素值对应该点数和出现的次数</p>
</li>
<li><p>根据一个骰子的结果，计算两个骰子的结果，基于第一个数组结果在第二个数组中记录结果</p>
<blockquote>
<p>f(n,sum) = f(n-1,sum-1) + f(n-1,sum-2) + … + f(n-1,sum-6)，(n&gt;1,n &lt;= sum &lt;= n*6) </p>
</blockquote>
</li>
<li><p>根据两个骰子的结果，计算三个骰子的结果，基于第二个数组结果在第一个数组中记录结果</p>
</li>
<li><p>直至计算出n个骰子的结果，进而计算各结果出现的概率</p>
</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li><p>记 f(n,sum) 为n个骰子时，和为sum的出现次数，则</p>
<p>f(n,sum) = f(n-1,sum-1) + f(n-1,sum-2) + … + f(n-1,sum-6)，(n&gt;1,n &lt;= sum &lt;= n*6) </p>
<p>f(n,sum) = 1，(n=1,1 &lt;= sum &lt;= 6)</p>
</li>
<li><p>n个骰子时各点数和的出现次数与且仅与n-1个骰子时的各点数和的出现次数有关</p>
</li>
<li><p>使用两个数组交替记录n个骰子时各点数和的出现次数与n-1个骰子时的各点数和的出现次数，自n=1时记录，直至计算至n=num，并使用flag标志位来交替记录</p>
</li>
<li><p>数组角标对应n个骰子的某点数和，元素值为其出现次数</p>
</li>
<li><p>注意在交替记录本次骰子各点数和时需要清零数组，因为仅使用两个数组记录，若不清零，会使计算混乱</p>
</li>
<li><p>注意边界值的考量，代码鲁棒性，条件的判断</p>
</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-76"><a href="#Answer-76" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<p>1.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProbabilityCore</span><span class="params">(<span class="keyword">int</span> minSum, <span class="keyword">int</span> remainingDice, <span class="keyword">int</span> curSum, <span class="keyword">int</span>* countSum)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//base case </span></span><br><span class="line">	<span class="keyword">if</span> (remainingDice == <span class="number">0</span>) &#123;</span><br><span class="line">		countSum[curSum - minSum]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">			<span class="comment">//记录当前骰子点数</span></span><br><span class="line">			curSum += i;</span><br><span class="line">			<span class="comment">//向下递归，求剩余骰子的点数</span></span><br><span class="line">			<span class="built_in">ProbabilityCore</span>(minSum, remainingDice - <span class="number">1</span>, curSum, countSum);</span><br><span class="line">			<span class="comment">//在进行下一种决策前回退</span></span><br><span class="line">			curSum -= i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Probability</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>* countSum)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">ProbabilityCore</span>(n, n, <span class="number">0</span>, countSum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintProbability</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断异常</span></span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//记录骰子和的最大值与最小值</span></span><br><span class="line">	<span class="keyword">int</span> maxNum = <span class="number">6</span>;</span><br><span class="line">	<span class="keyword">int</span> maxSum = maxNum * n;</span><br><span class="line">	<span class="keyword">int</span> minSum = n;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置记录骰子和出现次数的数组，和为 0 - (minSum-1) 的无需记录，因此无需maxSum长度，只需记录 minSum - maxSum 之间的数</span></span><br><span class="line">	<span class="keyword">int</span>* countSum = <span class="keyword">new</span> <span class="keyword">int</span>[maxSum - minSum + <span class="number">1</span>];</span><br><span class="line">	<span class="comment">//计数数组的初始化</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt;= maxSum; i++) &#123;</span><br><span class="line">		countSum[i - minSum] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//递归计算各种骰子和出现的次数</span></span><br><span class="line">	<span class="built_in">Probability</span>(n, countSum);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置概率分母</span></span><br><span class="line">	<span class="keyword">int</span> countMax = <span class="built_in">pow</span>(maxNum, n);</span><br><span class="line">	<span class="comment">//计算各骰子和出现的概率</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt;= maxSum; i++) &#123;</span><br><span class="line">		cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;概率: &quot;</span>;</span><br><span class="line">		cout &lt;&lt; countSum[i - minSum] &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; countMax &lt;&lt; <span class="string">&quot; ≈ &quot;</span>;</span><br><span class="line">		cout &lt;&lt; ((<span class="keyword">double</span>)(countSum[i - minSum])) / countMax &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//清理内存</span></span><br><span class="line">	<span class="keyword">delete</span>[] countSum;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintProbabilityNR</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断异常</span></span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//记录n个骰子和的最大值与最小值以及单个骰子的最大值</span></span><br><span class="line">	<span class="keyword">int</span> maxNum = <span class="number">6</span>;</span><br><span class="line">	<span class="keyword">int</span> maxSum = maxNum * n;</span><br><span class="line">	<span class="keyword">int</span> minSum = n;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//开辟暂存n个骰子点数和所有结果出现次数的数组</span></span><br><span class="line">	<span class="comment">//使用两个数组交替存放n-1个骰子的点数和所有结果出现次数 与 当前n个骰子的点数和所有结果出现次数</span></span><br><span class="line">	<span class="comment">//下标对应点数和，元素值为该点数和出现的次数</span></span><br><span class="line">	<span class="keyword">int</span>** curSum = <span class="keyword">new</span> <span class="keyword">int</span>*[<span class="number">2</span>];</span><br><span class="line">	curSum[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[maxSum + <span class="number">1</span>];</span><br><span class="line">	curSum[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[maxSum + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= maxSum; i++) &#123;</span><br><span class="line">		curSum[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">		curSum[<span class="number">1</span>][i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置交替时的标志位</span></span><br><span class="line">	<span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//记录一个骰子点数和的所有结果出现的次数</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxNum; i++) &#123;</span><br><span class="line">		curSum[flag][i] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//自下而上计算两个，三个，...，n个骰子的点数和结果的出现次数</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> Dicenum = <span class="number">2</span>; Dicenum &lt;= n; Dicenum++) &#123;</span><br><span class="line">		<span class="comment">//借用上次Dicenum - 1个骰子的点数和次数结果计算本次Dicenum个骰子的点数和出现结果</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//先清空记录本次Dicenum个骰子的点数和出现结果的数组</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= maxSum; i++) &#123;</span><br><span class="line">			curSum[<span class="number">1</span> - flag][i] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//记录Dicenum个骰子的每种点数和出现的次数，最小为Dicenum，最大为 maxNum * Dicenum</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> curDiceSum = Dicenum; curDiceSum &lt;= maxNum * Dicenum; curDiceSum++) &#123;</span><br><span class="line">			<span class="comment">//累加记录之前先清零</span></span><br><span class="line">			curSum[<span class="number">1</span> - flag][curDiceSum] = <span class="number">0</span>;</span><br><span class="line">			<span class="comment">//n个骰子时的和curDiceSum出现次数等于n-1个骰子时 f(curDiceSum-1) + f(curDiceSum-2) + ... + f(curDiceSum-6)</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> presum = <span class="number">1</span>; presum &lt;= curDiceSum &amp;&amp; presum &lt;= maxNum; presum++) &#123;</span><br><span class="line">				curSum[<span class="number">1</span> - flag][curDiceSum] += curSum[flag][curDiceSum - presum];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//交替数组，使用本次结果计算++Dicenum的结果</span></span><br><span class="line">		flag = <span class="number">1</span> - flag;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置概率分母</span></span><br><span class="line">	<span class="keyword">int</span> countMax = <span class="built_in">pow</span>(maxNum, n);</span><br><span class="line">	<span class="comment">//计算各骰子和出现的概率</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt;= maxSum; i++) &#123;</span><br><span class="line">		cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;概率: &quot;</span>;</span><br><span class="line">		cout &lt;&lt; curSum[flag][i] &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; countMax &lt;&lt; <span class="string">&quot; ≈ &quot;</span>;</span><br><span class="line">		cout &lt;&lt; ((<span class="keyword">double</span>)(curSum[flag][i])) / countMax &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//清理内存</span></span><br><span class="line">	<span class="keyword">delete</span>[] curSum[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">delete</span>[] curSum[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">delete</span>[] curSum;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="61-扑克牌中的顺子"><a href="#61-扑克牌中的顺子" class="headerlink" title="61 扑克牌中的顺子"></a>61 扑克牌中的顺子</h1><blockquote>
<p>从扑克牌中随机抽5张牌,判断是不是一个顺子,即这5张牌是不是连续的</p>
<p>2~10为数字本身, A为1,J为11, Q为12, K为13,而大,小王可以看成任意数字</p>
</blockquote>
<h2 id="Testing-case-79"><a href="#Testing-case-79" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(有一个/多个大小王，无大小王，有对子)</li>
<li>边界测试(nullptr)</li>
</ul>
<h2 id="Key-79"><a href="#Key-79" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>抽象建模 + 双指针</p>
<blockquote>
<ol>
<li>先对整型数组中的数字进行排序</li>
<li>对排序后的数组计算0:大小王的出现次数</li>
<li>从第一个不是0:大小王的位置起求各相邻数字的间隙数，并排除对子</li>
<li>通过判断大小王出现次数与相邻数字的间隙数大小，来判断是否大小王的张数能够填补非连续空隙，从而判断是否是顺子</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>扑克牌中的顺子可抽象为计算机中的整型数组中的连续数字，大小王用0表示</li>
<li>相邻元素的比较判断可使用间隔为1的双指针遍历</li>
<li>相邻数字的间隙数 = data[big] - data[small] - 1</li>
<li>使用T(n) = O(nlogn) 的qsort排序，因为扑克牌只有13种牌，而时间复杂度仅当n足够大时才有意义</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-77"><a href="#Answer-77" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* data1, <span class="keyword">const</span> <span class="keyword">void</span>* data2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> d1 = *((<span class="keyword">int</span>*)data1);</span><br><span class="line">	<span class="keyword">int</span> d2 = *((<span class="keyword">int</span>*)data2);</span><br><span class="line">	<span class="keyword">return</span> d1 - d2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsContinuous</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断异常</span></span><br><span class="line">	<span class="keyword">if</span> (data == <span class="literal">nullptr</span> || length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置记录扑克牌中记录 0:大小王，相邻数字间隙的变量</span></span><br><span class="line">	<span class="keyword">int</span> NumOfZero = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> NumOfGap = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//对数组进行排序</span></span><br><span class="line">	<span class="built_in">qsort</span>(data, length, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>), Compare);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//记录数组中0出现的次数</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (data[i] == <span class="number">0</span>) &#123;</span><br><span class="line">			NumOfZero++;</span><br><span class="line">			<span class="keyword">if</span> (NumOfZero &gt; <span class="number">2</span>) &#123;</span><br><span class="line">				isExcption = <span class="literal">true</span>;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line"></span><br><span class="line">	<span class="comment">//记录数组中所有数字的相邻数字的间隙大小</span></span><br><span class="line">	<span class="keyword">int</span> small = NumOfZero;</span><br><span class="line">	<span class="keyword">int</span> big = small + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (big != length) &#123;</span><br><span class="line">		<span class="comment">//排除对子</span></span><br><span class="line">		<span class="keyword">if</span> (data[small] == data[big]) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//累加计算间隙数</span></span><br><span class="line">		NumOfGap += data[big] - data[small] - <span class="number">1</span>;</span><br><span class="line">		<span class="comment">//向下遍历，移动游标</span></span><br><span class="line">		small = big++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过判断0:大小王是否能够填补空隙来判断是否为顺子</span></span><br><span class="line">	<span class="keyword">return</span> NumOfZero &gt;= NumOfGap ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="62-圆圈中最后剩下的数字"><a href="#62-圆圈中最后剩下的数字" class="headerlink" title="62 圆圈中最后剩下的数字"></a>62 圆圈中最后剩下的数字</h1><blockquote>
<p>0,1,..-1这n个数字排成一个圆圈,从数字0开始,每次从这个圆圈里删除第m个数字</p>
<p>求出这个圆圈里剩下的最后一个数字</p>
</blockquote>
<h2 id="Testing-case-80"><a href="#Testing-case-80" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(m&lt;n或m&gt;=n)</li>
<li>边界测试(0)</li>
<li>性能测试(n=4000,m=997)</li>
</ul>
<h2 id="Key-80"><a href="#Key-80" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>环形链表 T(n) = O(mn) S(n) = O(n)</p>
<blockquote>
<ol>
<li>使用双向链表模拟环状链表并将0至n-1的元素压入到链表中</li>
<li>剔除自0起的第m个元素，首先将迭代器自当前元素起移动至第m个元素(向后移动m-1次)，记录第m个元素的下一个元素，剔除第m个元素</li>
<li>自第m个元素在环状链表中的下一个元素起重复2，直至环状链表中的元素仅有一个</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>使用双向链表list模拟环形链表，注意遍历至end()迭代器时需要重置与链表首部</li>
</ol>
</blockquote>
</li>
<li><p>数学分析 + 递归or循环 T(n) = O(n) S(n) = O(1)</p>
<blockquote>
<p>有点顶，先不作要求</p>
</blockquote>
</li>
</ul>
<h2 id="Answer-78"><a href="#Answer-78" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> isExcption = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断异常</span></span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">0</span> || m &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//使用双向链表模拟环状链表</span></span><br><span class="line">	list&lt;<span class="keyword">int</span>&gt; RingList;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将0至n-1的元素压入到链表中</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		RingList.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置遍历迭代器</span></span><br><span class="line">	<span class="keyword">auto</span> currentIte = RingList.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//剔除自0起的第m个元素,直至仅剩一个元素</span></span><br><span class="line">	<span class="keyword">while</span> (RingList.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">//定位迭代器于自当前元素起的第m个元素</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">			currentIte++;</span><br><span class="line">			<span class="keyword">if</span> (currentIte == RingList.<span class="built_in">end</span>()) &#123;</span><br><span class="line">				<span class="comment">//通过手动设置来模拟环形链表</span></span><br><span class="line">				currentIte = RingList.<span class="built_in">begin</span>();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//记录环状链表中当前元素的下一个元素</span></span><br><span class="line">		<span class="keyword">auto</span> nextIte = ++currentIte;</span><br><span class="line">		<span class="keyword">if</span> (nextIte == RingList.<span class="built_in">end</span>()) &#123;</span><br><span class="line">			nextIte = RingList.<span class="built_in">begin</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//恢复currentIte迭代器指向元素</span></span><br><span class="line">		currentIte--;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//剔除元素</span></span><br><span class="line">		RingList.<span class="built_in">erase</span>(currentIte);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//向下遍历</span></span><br><span class="line">		currentIte = nextIte;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> *currentIte;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="63-股票的最大利润"><a href="#63-股票的最大利润" class="headerlink" title="63 股票的最大利润"></a>63 股票的最大利润</h1><blockquote>
<p>假设把某股票的价格按照时间先后顺序存储在数组中,请问买卖该股票一次可能获得的最大利润是多少?</p>
<p>例如,一只股票在某些时间节点的价格为{9,11,8,5,7,12,16,14},如果我们能在价格为5的时候买入并在价格为16时卖出,则能收获最大的利润11</p>
</blockquote>
<h2 id="Testing-case-81"><a href="#Testing-case-81" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(数组无序/单调递增/单调递减)</li>
<li>边界测试(nullptr，数组只有两个数字)</li>
</ul>
<h2 id="Key-81"><a href="#Key-81" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>蛮力尾部遍历 + 打擂 T(n) = S(n2)</p>
<blockquote>
<ol>
<li>自数组尾部开始，逐个元素作卖出点，向前遍历元素组成(卖出,买入)数对打擂计算最大利润</li>
<li>直至卖出点为数组第二个元素</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>暴力遍历，含多次重复计算，可进一步优化记录最小买入点并自首部遍历</li>
</ol>
</blockquote>
</li>
<li><p>最小买入 + 三指针 + 打擂 T(n) = S(n)</p>
<blockquote>
<ol>
<li>自首部遍历数组，通过curSell遍历数组，计算每一个元素(自第二个元素起)作卖出点时的最大利润</li>
<li>在进行本次利润计算前，先根据上次卖出点的值与最小买入点的值比较，更新最小买入点</li>
<li>计算本次最大利润并打擂记录至目前为止的最大利润</li>
<li>进行下一利润计算前，先更新preSell，curSell的状态</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>设置三个指针分别记录最小买入点smallestBuy，当前卖出点curSell与上一次卖出点preSell</li>
<li>curDiff = data[curSell] - data[smallestBuy] ，当前卖出点的最大利润为当前卖出值 - 之前最小买入值</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-79"><a href="#Answer-79" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> isExcption = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//股票的最大利润</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxDiff</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>*, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxDiff</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* data, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断异常</span></span><br><span class="line">	<span class="keyword">if</span> (data == <span class="literal">nullptr</span> || length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置记录股票最小买入点与当前卖出点的指针</span></span><br><span class="line">	<span class="keyword">int</span> smallestBuy = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> curSell = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//打擂记录big指向的元素作卖出点的最大利润</span></span><br><span class="line">	<span class="keyword">int</span> maxDiff = data[curSell] - data[smallestBuy];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//记录上一次卖出点的价格并向下遍历</span></span><br><span class="line">	<span class="keyword">int</span> preSell = curSell++;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历剩余元素，记录剩余元素作卖出点的最大利润</span></span><br><span class="line">	<span class="keyword">while</span> (curSell &lt; length) &#123;</span><br><span class="line">		<span class="comment">//若上一次卖出点的值小于最小买入点的值，则应在上一点买入，更新最小买入点</span></span><br><span class="line">		<span class="keyword">if</span> (data[preSell] &lt; data[smallestBuy]) &#123;</span><br><span class="line">			smallestBuy = preSell;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//计算当前最大利润</span></span><br><span class="line">		<span class="keyword">int</span> curDiff = data[curSell] - data[smallestBuy];</span><br><span class="line">		<span class="comment">//打擂记录到目前为止的最大利润</span></span><br><span class="line">		<span class="keyword">if</span> (curDiff &gt;= maxDiff) &#123;</span><br><span class="line">			maxDiff = curDiff;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//向后遍历</span></span><br><span class="line">		preSell = curSell;</span><br><span class="line">		curSell++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> maxDiff;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="64-求-1-2-…-n"><a href="#64-求-1-2-…-n" class="headerlink" title="64 求 1+2+…+n"></a>64 求 1+2+…+n</h1><blockquote>
<p>要求不能使用乘除法,for,while,if else,switch,case等关键字及条件判断语句(A?B:C)</p>
</blockquote>
<h2 id="Testing-case-82"><a href="#Testing-case-82" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(5,10)</li>
<li>边界测试(0，1)</li>
</ul>
<h2 id="Key-82"><a href="#Key-82" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>围绕循环与递归展开</p>
<blockquote>
<ol>
<li>创造循环实现累加</li>
<li>无法在一个函数中通过if完成递归，则设置两个函数，一个函数作递归函数使用，一个函数作bacecase终止递归使用</li>
<li>通过类似bool类型的变量选择调用的函数，!!n , n&gt;0时 !!n = true(1)，n=0时 !!n = false(0)</li>
</ol>
</blockquote>
</li>
<li><p>基于循环 - 构造函数 + 静态成员</p>
<blockquote>
<ol>
<li>创建一个类含两个静态成员变量，一个为N，一个为Sum，并初始化为0</li>
<li>设置相应的静态获取函数GetSum，用于返回静态成员变量Sum</li>
<li>在类的构造函数处对N进行累加，并使用Sum记录N的累加和</li>
<li>创建N个对象后，直接类名::GetSum()获取累加和</li>
</ol>
</blockquote>
</li>
<li><p>基于递归 - 函数指针</p>
<blockquote>
<ol>
<li>在递归函数中设置函数指针数组，并通过!!n来区分下标选择函数进行调用</li>
<li>当n=0时，!!0 = 0 ，选择arr[0]函数终止递归</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li> 设置一个静态函数指针数组存放两个函数地址，静态数组只会初始化一次</li>
</ol>
</blockquote>
</li>
<li><p>基于递归 - 虚函数</p>
<blockquote>
<ol>
<li>父类的待重写虚函数作终止递归函数</li>
<li>子类的重写函数中，根据!!n选择 父类/子类重写 函数进行绑定，调用GetSum方法</li>
<li>子类设置一个基类指针数组，并在构造函数中使用相应的指针参数完成初始化</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>通过虚函数的动态绑定完成对递归函数的选择</li>
</ol>
</blockquote>
</li>
<li><p>基于递归 - 非类型模板参数 + 模板特化</p>
<blockquote>
<ol>
<li>使用非类型模板类并基于枚举常量元素完成递归累加</li>
<li>递归终止时的枚举元素值由特化模板确定</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>当一个模板的参数非类型而是一个编译期间可确定的常量时，在模板中可直接使用该常量</li>
<li>递归编译时的递归深度受限，n不能太大</li>
<li>n必须能够在编译时确定，不能动态输入</li>
<li>使用枚举常量元素的值完成累加</li>
<li>编译时的递归</li>
<li>::作用域运算符 若运算符前无类/命名空间/结构体，则默认为全局作用域，可通过该运算符取对应作用域中共有的成员</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-80"><a href="#Answer-80" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<p>1.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基于循环 - 构造函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GSum</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetSumFrom1TonByClass</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GSum</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">GSum</span>() &#123;</span><br><span class="line">		<span class="comment">//记录当前数字</span></span><br><span class="line">		N++;</span><br><span class="line">		<span class="comment">//记录累加和</span></span><br><span class="line">		Sum += N;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ResetSum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		N = Sum = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">GetSum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Sum;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> N;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> Sum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员初始化</span></span><br><span class="line"><span class="keyword">int</span> GSum::N = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> GSum::Sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetSumFrom1TonByClass</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//重置</span></span><br><span class="line">	GSum::<span class="built_in">ResetSum</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建n个GSum对象，进而累加1-n的和</span></span><br><span class="line">	GSum* arr = <span class="keyword">new</span> GSum[n];</span><br><span class="line">	<span class="comment">//清理内存</span></span><br><span class="line">	<span class="keyword">delete</span>[] arr;</span><br><span class="line">	arr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> GSum::<span class="built_in">GetSum</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基于递归 - 函数指针</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*func)</span> <span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetSumByPointerBaseCase</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetSumByPointer</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetSumByPointer</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> func arr[<span class="number">2</span>] = &#123; GetSumByPointerBaseCase,GetSumByPointer &#125;;</span><br><span class="line">	<span class="keyword">return</span> arr[!!n](n - <span class="number">1</span>) + n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetSumByPointerBaseCase</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基于递归 - 虚函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GSumByVirtualBase</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">GetSum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GSumByVirtual</span> :</span> <span class="keyword">public</span> GSumByVirtualBase &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">GSumByVirtual</span>(GSumByVirtualBase* GBS) :<span class="built_in">GSumByVirtualBase</span>() &#123;</span><br><span class="line">		arr[<span class="number">0</span>] = GBS;</span><br><span class="line">		arr[<span class="number">1</span>] = <span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">GetSum</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> n + arr[!!n]-&gt;<span class="built_in">GetSum</span>(n - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	GSumByVirtualBase* arr[<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetSumByVirtual</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetSumByVirtual</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	GSumByVirtualBase* GBS = <span class="keyword">new</span> <span class="built_in">GSumByVirtualBase</span>();</span><br><span class="line">	GSumByVirtual* GS = <span class="keyword">new</span> <span class="built_in">GSumByVirtual</span>(GBS);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> GS-&gt;<span class="built_in">GetSum</span>(n);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基于递归 - 非类型模板参数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">const</span> <span class="keyword">int</span> n&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GetSumByTem</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">value</span> &#123;</span> N = GetSumByTem&lt;n - <span class="number">1</span>&gt;::N + n &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GetSumByTem</span>&lt;</span><span class="number">1</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">value</span> &#123;</span> N = <span class="number">1</span> &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="65-不用加减乘除做加法"><a href="#65-不用加减乘除做加法" class="headerlink" title="65 不用加减乘除做加法"></a>65 不用加减乘除做加法</h1><blockquote>
<p>写一个函数,求两个整数之和,要求在函数体内不得使用”+”,”-“,”×”,”÷”四则运算符号</p>
</blockquote>
<h2 id="Testing-case-83"><a href="#Testing-case-83" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(整数，负数)</li>
<li>边界测试(0)</li>
</ul>
<h2 id="Key-83"><a href="#Key-83" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>异或运算 + 与运算 + 移位运算 - 递归</p>
<blockquote>
<ol>
<li>通过异或运算，计算两数不产生进位的和</li>
<li>通过与运算后左移一位，计算两数产生的进位值</li>
<li>递归向下计算1,2结果的和，直至无进位产生，即进位值为0，则返回最终结果</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>可使用底层的位运算模拟加减乘除运算</li>
<li>加法的运算法则<ul>
<li>计算两数不产生进位的和</li>
<li>计算两数产生的进位值</li>
<li>计算上述两个结果的和</li>
</ul>
</li>
<li>二进制下的进位，逢2进1，若某位产生进位，则应左移一位(乘基数2)，才为进位值</li>
</ol>
</blockquote>
</li>
<li><p>异或运算 + 与运算 + 移位运算 - 循环</p>
<blockquote>
<pre><code>1. 通过异或运算，计算两数不产生进位的和
2. 通过与运算后左移一位，计算两数产生的进位值
3. 循环计算1,2结果的和，但是在进行下次计算之前需要记录本次计算的结果作下次的加数
4. 直至第二个加数(进位值)为0终止循环
</code></pre>
</blockquote>
</li>
</ul>
<h2 id="Answer-81"><a href="#Answer-81" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<p>1.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> isExcption = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加法计算 - 递归</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PlusByRecursive</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//base case </span></span><br><span class="line">	<span class="keyword">if</span> (num2 == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> num1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//记录两数不产生进位的和 异或运算结果</span></span><br><span class="line">	<span class="keyword">int</span> NoCarrySum = num1 ^ num2;</span><br><span class="line">	<span class="comment">//记录两数产生进位的和 与运算结果后左移一位</span></span><br><span class="line">	<span class="keyword">int</span> Carry = (num1 &amp; num2) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//计算上述两个结果的和</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">PlusByRecursive</span>(NoCarrySum, Carry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> isExcption = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加法计算 - 循环</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PlusNotByRecursive</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//a 记录两数不产生进位的和 异或运算结果</span></span><br><span class="line">		<span class="keyword">int</span> NoCarrySum = num1 ^ num2;</span><br><span class="line">		<span class="comment">//b 记录两数产生进位的和 与运算结果后左移一位</span></span><br><span class="line">		<span class="keyword">int</span> Carry = (num1 &amp; num2) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">		<span class="comment">//下次循环计算a+b，但是在进行下次计算之前需要记录本次计算的结果作下次的加数</span></span><br><span class="line">		num1 = NoCarrySum;</span><br><span class="line">		num2 = Carry;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">while</span> (num2 != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> num1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="65-1-不使用新的变量交换两个变量的值"><a href="#65-1-不使用新的变量交换两个变量的值" class="headerlink" title="65.1 不使用新的变量交换两个变量的值"></a>65.1 不使用新的变量交换两个变量的值</h1><blockquote>
<p>不使用新的变量交换两个变量的值</p>
</blockquote>
<h2 id="Key-84"><a href="#Key-84" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>异或运算</p>
<blockquote>
<p><code>注意:</code></p>
<ol>
<li>a0,b0为初始值，a1,b1为交换后的值</li>
<li>第一次异或结果含a0,b0</li>
<li>第二次异或将 (a0^b0) ^ b0，剔除结果中的b0，留下a0存于b1中，此时b1已交换为a0</li>
<li>第三次异或将 (a0^b0) ^ b1，剔除结果中的a0，留下b0存于a1中，此时完成交换</li>
</ol>
</blockquote>
</li>
<li><p>加减法运算</p>
<blockquote>
<p><code>注意:</code></p>
<ol>
<li>a0,b0为初始值，a1,b1为交换后的值</li>
<li>第一次加法结果为 a0 + b0</li>
<li>第二次减法将 (a0+b0) - b0，剔除结果中的b0，留下a0存于b1中，此时b1已交换为a0</li>
<li>第三次减法将 (a0+b0) - b1，剔除结果中的a0，留下b0存于a1中，此时完成交换</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Anwser"><a href="#Anwser" class="headerlink" title="Anwser"></a>Anwser</h2><blockquote>
<p>1.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a = a ^ b;</span><br><span class="line">b = a ^ b;</span><br><span class="line">a = a ^ b;</span><br></pre></td></tr></table></figure>

<p>2.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a = a + b;</span><br><span class="line">b = a - b;</span><br><span class="line">a = a - b;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="66-构建乘积数组"><a href="#66-构建乘积数组" class="headerlink" title="66 构建乘积数组"></a>66 构建乘积数组</h1><blockquote>
<p>暂略</p>
</blockquote>
<h1 id="67-把字符串转换为整数"><a href="#67-把字符串转换为整数" class="headerlink" title="67 把字符串转换为整数"></a>67 把字符串转换为整数</h1><blockquote>
<p>写一个函数，完成函数库中atoi函数的功能，把字符串转换为整数</p>
</blockquote>
<h2 id="Testing-case-84"><a href="#Testing-case-84" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(正数，负数，0)</li>
<li>边界测试(最大正整数，最小负整数)</li>
<li>特殊输入测试(nullptr,””,含非数字字符)</li>
</ul>
<h2 id="Key-85"><a href="#Key-85" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>基本 字符串 -&gt; 整数 方法</p>
<blockquote>
<ol>
<li><p>设置累加各位数字的long long变量num，并初始化为0</p>
</li>
<li><p>自首部遍历字符串，先根据首位判断数字正负情况，设置isNegative值</p>
</li>
<li><p>若2含+/-号，设置isNegative值后结束本次子循环，向下遍历</p>
</li>
<li><p>若当前判断字符是数字字符，则记录各位数字(数字+位)于num中，num = num * 10 + (*p - ‘0’)</p>
</li>
<li><p>进行下次记录前，先判断是否发生溢出</p>
</li>
<li><p>重复4,5直至遍历至字符串尾部，此时完成对整数绝对值的记录</p>
</li>
<li><p>根据isNegative返回正/负整数num</p>
</li>
</ol>
</blockquote>
</li>
<li><p>非法字符的考量</p>
<blockquote>
<p>isNumber完成是否为数字字符的考量，排除空字符串，非法字符串</p>
</blockquote>
</li>
<li><p>整数的三种情况</p>
<blockquote>
<ol>
<li>带+号的正数</li>
<li>不带+号的正数</li>
<li>带-号的负数</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>在对字符串各位进行判断并累加时，注意首位的字符情况</li>
<li>若为+号，更新状态，结束本次循环，继续向下遍历</li>
<li>若为-号，更新状态，结束本次循环，继续向下遍历</li>
<li>若为数字，则需要记录，然后向下遍历</li>
</ol>
</blockquote>
</li>
<li><p>异常处理</p>
<blockquote>
<p>设置全局变量作异常判断</p>
<p>若出现异常，在设置返回值为0并设置全局变量，最后通过全局变量值完成异常判断</p>
<p><code>注意:</code></p>
<ol>
<li>数字字符0与发生异常返回值相同，切记不要忘记对全局变量的判断来区分这两种返回情况</li>
</ol>
</blockquote>
</li>
<li><p>溢出判断</p>
<blockquote>
<ol>
<li><p>无法通过int型变量完成溢出的判断，借助范围更大的long long型完成溢出判断</p>
<p>int型最大值 = numeric_limits<int>::max() = 0x7FFFFFFF<br>int型最小值 = numeric_limits<int>::min() = (signed int)0x80000000</int></int></p>
</li>
<li><p>进行溢出判断时，不能仅根据绝对值的大小完成溢出判断，而需要结合整数的正负情况来完成最大正整数与最小负整数的溢出判断</p>
</li>
</ol>
</blockquote>
</li>
<li><p>一元减运算符</p>
<blockquote>
<p>作用于单个操作数以产生新值</p>
<p><code>注意:</code></p>
<ol>
<li>当一元减运算符作用于无符号整数时，返回值不是其取反值，而是该无符号整数本身</li>
<li>-2147483648表达式分两阶段进行<ul>
<li>判断2147483648作为int型已溢出，因此将其当做unsigned int处理</li>
<li>-2147483648结果为2147483648</li>
</ul>
</li>
<li>-2147483648 != (signed int)2147483648</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-82"><a href="#Answer-82" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串转换为整数</span></span><br><span class="line"><span class="keyword">bool</span> isExcption = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isNumber</span><span class="params">(<span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> isNum = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断空串</span></span><br><span class="line">	<span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">		isNum = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断是否为数字字符串，含空格判断，以及正负号判断</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//判断首字符是否为+,-号，若均不是，则进而判断是否为数字字符</span></span><br><span class="line">		<span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; str[i] == <span class="string">&#x27;+&#x27;</span> || i == <span class="number">0</span> &amp;&amp; str[i] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//判断剩余字符是否为数字字符</span></span><br><span class="line">		<span class="keyword">if</span> (str[i]&lt;<span class="string">&#x27;0&#x27;</span> || str[i]&gt;<span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">			isNum = <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> isNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(<span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//边界异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (str == <span class="literal">nullptr</span> || !<span class="built_in">isNumber</span>(str)) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//转换字符串</span></span><br><span class="line">	<span class="keyword">char</span>*p = str;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断是否为首位</span></span><br><span class="line">	<span class="keyword">bool</span> isFirst = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">bool</span> isNegative = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (*p != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">		<span class="comment">//判断正负号</span></span><br><span class="line">		<span class="keyword">if</span> (isFirst &amp;&amp; (*p) == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">			isNegative = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//向下遍历</span></span><br><span class="line">			p++;</span><br><span class="line">			<span class="comment">//更新首位判断遍历状态</span></span><br><span class="line">			isFirst = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (isFirst &amp;&amp; (*p) == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">			<span class="comment">//向下遍历</span></span><br><span class="line">			p++;</span><br><span class="line">			<span class="comment">//更新首位判断遍历状态</span></span><br><span class="line">			isFirst = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//累加转换为数字</span></span><br><span class="line">		num = num * <span class="number">10</span> + (*p - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//进行下次前先判断当前是否产生越界溢出,正数判断最大正整数溢出，负数判断最小负整数溢出</span></span><br><span class="line">		<span class="keyword">if</span> ((!isNegative &amp;&amp; num &gt; <span class="number">0x7fffffff</span>) || (isNegative &amp;&amp; num &lt; (<span class="keyword">signed</span> <span class="keyword">int</span>)<span class="number">0x80000000</span>)) &#123;</span><br><span class="line">			isExcption = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		<span class="comment">//向下遍历</span></span><br><span class="line">		p++;</span><br><span class="line">		<span class="comment">//更新首位判断遍历状态</span></span><br><span class="line">		isFirst = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> isNegative ? -num : num;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="68-链表的第一个公共结点"><a href="#68-链表的第一个公共结点" class="headerlink" title="68 链表的第一个公共结点"></a>68 链表的第一个公共结点</h1><blockquote>
<p>输入两个链表,找出它们的第一个公共节点</p>
</blockquote>
<h2 id="Testing-case-85"><a href="#Testing-case-85" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(两个链表 有/无 公共结点，两个链表的公共结点位于首部/尾部/中部)</li>
<li>边界测试(nullptr)</li>
</ul>
<h2 id="Key-86"><a href="#Key-86" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>两个链表组合型</p>
<blockquote>
<p>含公共结点的两个链表组合型可以为Y型(公共结点位于链表中间)，V型(公共结点位于链表末尾)，l型(公共结点位于链表首部)</p>
<p>上为链表首部，下为链表尾部</p>
</blockquote>
</li>
<li><p>蛮力首部遍历 T(n) = O(mn)</p>
</li>
<li><p>尾部遍历 + 辅助栈 T(n) = O(m+n) S(n) = O(m+n)</p>
<blockquote>
<ol>
<li>将两个链表元素分别压入两个栈，设置pCommonNode指针指向公共结点，初始为nullptr</li>
<li>判断两个栈的栈顶结点是否为公共结点</li>
<li>若是公共结点，则使用pCommonNode指针记录当前公共结点，弹出栈顶结点后继续2，直至某一栈为空</li>
<li>若不是公共结点，则跳出循环，返回pCommonNode</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>单链表无法完成尾部遍历，因此使用辅助栈完成结点的尾部遍历</li>
<li>自尾部开始查找第一个产生分叉的结点(两链表自该结点后的下一个结点值不同)，该结点即为第一个公共结点</li>
</ol>
</blockquote>
</li>
<li><p>同步移动 T(n) = O(m+n) S(n) = O(1)</p>
<blockquote>
<ol>
<li>设置较长链表的遍历指针pLongerHead，默认为pHead1</li>
<li>计算两个链表的表长并计算偏移量pOffset，初始为pLen1-pLen2</li>
<li>根据两链表表长判断使pLongerHead指向较长链表的表头</li>
<li>先将pLongerHead后移|pOffset|个单位</li>
<li>同步移动pShorterHead，pLongerHead，使用pCommonNode记录第一次值相同的结点，直至表尾</li>
<li>返回pCommonNode</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>将较长链表先向后偏移pOffset(两链表长度之差的绝对值)，因为确保两个链表遍历指针同时到达尾部</li>
<li>若两个表长不同的链表含公共结点，则该公共结点一定不存在于较长链表的前pOffset个结点中</li>
<li>取代蛮力法中固定一链表结点遍历另一个链表的方法，时间效率更高</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-83"><a href="#Answer-83" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<p>1.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">GetFirstCommonNodeByStack</span><span class="params">(ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (pHead1 == <span class="literal">nullptr</span> || pHead2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置两个辅助栈分别存放两个链表的结点</span></span><br><span class="line">	stack&lt;ListNode*&gt; pStack1;</span><br><span class="line">	stack&lt;ListNode*&gt; pStack2;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历两个链表并分别将结点压栈</span></span><br><span class="line">	ListNode* pNode1 = pHead1;</span><br><span class="line">	ListNode* pNode2 = pHead2;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (pNode1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		pStack1.<span class="built_in">push</span>(pNode1);</span><br><span class="line">		pNode1 = pNode1-&gt;pNext;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (pNode2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		pStack2.<span class="built_in">push</span>(pNode2);</span><br><span class="line">		pNode2 = pNode2-&gt;pNext;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//根据栈中结点从尾结点开始向前比较是否存在 Y or V 型公共链表结点</span></span><br><span class="line">	<span class="comment">//设置指针存放公共结点的地址</span></span><br><span class="line">	ListNode* pCommonNode = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (pStack1.<span class="built_in">size</span>() != <span class="number">0</span> &amp;&amp; pStack2.<span class="built_in">size</span>() != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (pStack1.<span class="built_in">top</span>()-&gt;pValue == pStack2.<span class="built_in">top</span>()-&gt;pValue) &#123;</span><br><span class="line">			pCommonNode = pStack1.<span class="built_in">top</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		pStack1.<span class="built_in">pop</span>();</span><br><span class="line">		pStack2.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pCommonNode;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetListLength</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	ListNode* pNode = pHead;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (pNode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		len++;</span><br><span class="line">		pNode = pNode-&gt;pNext;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">GetFirstCommonNode</span><span class="params">(ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (pHead1 == <span class="literal">nullptr</span> || pHead2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置两个指针分别指向较长的链表头和较短的链表头</span></span><br><span class="line">	ListNode* pLongerHead = pHead1;</span><br><span class="line">	ListNode* pShorterHead = pHead2;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//取两个链表的长度，并获取两链表长度之差</span></span><br><span class="line">	<span class="keyword">int</span> pLen1 = <span class="built_in">GetListLength</span>(pHead1);</span><br><span class="line">	<span class="keyword">int</span> pLen2 = <span class="built_in">GetListLength</span>(pHead2);</span><br><span class="line">	<span class="keyword">int</span> pOffset = pLen1 - pLen2;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//使两个指针分别指向较长的链表头和较短的链表头</span></span><br><span class="line">	<span class="keyword">if</span> (pLen2 &gt; pLen1) &#123;</span><br><span class="line">		pLongerHead = pHead2;</span><br><span class="line">		pShorterHead = pHead1;</span><br><span class="line">		<span class="comment">//使差值取正</span></span><br><span class="line">		pOffset = -pOffset;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//先将指向长度较长链表的指针后移pOffset，使两个指针同步移动</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pOffset; i++) &#123;</span><br><span class="line">		pLongerHead = pLongerHead-&gt;pNext;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//向后遍历，直至找到第一个公共结点或至末尾</span></span><br><span class="line">	<span class="keyword">while</span> (pLongerHead != <span class="literal">nullptr</span> &amp;&amp; pShorterHead != <span class="literal">nullptr</span> &amp;&amp; pLongerHead-&gt;pValue != pShorterHead-&gt;pValue) &#123;</span><br><span class="line">		pLongerHead = pLongerHead-&gt;pNext;</span><br><span class="line">		pShorterHead = pShorterHead-&gt;pNext;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ListNode* pCommonNode = pLongerHead;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pCommonNode;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="69-树中两个结点的最低公共祖先"><a href="#69-树中两个结点的最低公共祖先" class="headerlink" title="69 树中两个结点的最低公共祖先"></a>69 树中两个结点的最低公共祖先</h1><blockquote>
<p>输入两个树节点,求它们的最低公共祖先</p>
<p>二叉搜索树，含/不含 指向父结点指针的普通树</p>
</blockquote>
<h2 id="Testing-case-86"><a href="#Testing-case-86" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(普通二叉树，退化为链表的树)</li>
<li>边界测试(nullptr)</li>
</ul>
<h2 id="Key-87"><a href="#Key-87" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>最低公共祖先</p>
<blockquote>
<p>若两个结点为同一个结点，则返回其本身</p>
<p>若两个结点在同一条路径上，则返回更靠近根结点的结点</p>
</blockquote>
</li>
<li><p>二叉搜索树</p>
<blockquote>
<ol>
<li>由根结点开始作判断，若当前结点比两结点值都大，则在此根结点的左子树中查找</li>
<li>若当前结点比两结点值都小，则在此根结点的右子树中查找</li>
<li>若当前结点值介于两结点值之间或等于其中一者，则返回该根结点</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>由于二叉搜索树性质，所以最低公共祖先一定是值介于两者之间的的结点(含等于某一结点)</li>
<li>注意若结点不在树结构中，本方法无法作出异常判断，需要先判断结点是否位于树结构中</li>
</ol>
</blockquote>
</li>
<li><p>含指向父结点指针的普通树</p>
<blockquote>
<ol>
<li>自两个结点开始，分别依据pParent指针向上遍历，直接将遍历的结点分别压入栈</li>
<li>设置记录最低公共祖先的指针pCommon，初始为nullptr</li>
<li>自两个栈的栈顶开始找寻(自两链表尾部开始)第一个不相等结点，若两栈顶结点值相同，则记录该结点并弹出向下找寻，直至某一个栈为空</li>
<li>返回pCommon</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>转换为两个链表的第一个公共结点，两个链表的表头分别为pNode1，pNode2，表尾均为pHead</li>
<li>注意若结点不在树结构中，本方法返回nullptr</li>
<li>栈由栈顶-&gt;栈底 存放 链表尾部-&gt;链表首部</li>
</ol>
</blockquote>
</li>
<li><p>不含指向父结点指针的普通树</p>
<blockquote>
<p><strong>获取根节点 -&gt; 要求结点 的路径链表</strong></p>
<ol>
<li>基于先序遍历，使用两个双向链表List，分别记录到两个结点的路径上的所有结点</li>
<li>先将记录当前遍历结点，并判断当前路径是否为要求路径，即当前压入结点是否等于给定结点value值</li>
<li>若当前压入结点等于给定结点value值，则已找到要求路径，设置返回值，返回结果</li>
<li>若不等，则进而在该结点的左子树中继续查找路径</li>
<li>当左子树中仍不存在要求路径时，进而在该根结点的右子树中查找路径</li>
<li>最后若hasPath仍等于false，表明要求路径不含当前结点，剔除已记录的当前结点</li>
<li>返回判断结果</li>
</ol>
<p><strong>根据路径链表找寻最低公共祖先</strong></p>
<ol>
<li>正向遍历两个路径链表，若遍历的两个结点值相同，则表明该结点可能为其公共祖先，记录于pCommon指针中</li>
<li>若遍历的两个结点值不相同，则上一次pCommon指针记录结点即为最低公共祖先</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>普通树的递归遍历只能是基于前序/中序/后序遍历，对先序遍历进行改良，添加遍历左右子树的条件</li>
<li>对左右子树遍历的先决条件是当前仍为找到要求路径(hasPath==false)</li>
<li>注意若要求路径不含当前结点，需要回溯剔除</li>
<li>对路径链表的正向遍历，即从尾部遍历(根节点)找寻两链表的的第一个公共结点</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-84"><a href="#Answer-84" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<ol>
<li>二叉搜索树</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">GetLastCommonNodeCore</span><span class="params">(TreeNode* pHead, TreeNode* pNode1, TreeNode* pNode2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//base case</span></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//若当前结点比两个结点值都大，根据二叉搜索树性质，在其左子树中继续查找</span></span><br><span class="line">	<span class="keyword">if</span> (pHead-&gt;pValue &gt; pNode1-&gt;pValue &amp;&amp; pHead-&gt;pValue &gt; pNode2-&gt;pValue) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">GetLastCommonNodeCore</span>(pHead-&gt;pLeft, pNode1, pNode2);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//若当前结点比两个结点值都小，根据二叉搜索树性质，在其右子树中继续查找</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pHead-&gt;pValue &lt; pNode1-&gt;pValue &amp;&amp; pHead-&gt;pValue &lt; pNode2-&gt;pValue) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">GetLastCommonNodeCore</span>(pHead-&gt;pRight, pNode1, pNode2);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//此时pHead结点值要么介于两结点之间，要么等于其中一者的值</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> pHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">GetLastCommonNode</span><span class="params">(TreeNode* pHead, TreeNode* pNode1, TreeNode* pNode2)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断异常</span></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span> || pNode1 == <span class="literal">nullptr</span> || pNode2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		isException = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;																													<span class="comment">//应添加判断两结点是否位于树结构中的异常判断</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">GetLastCommonNodeCore</span>(pHead, pNode1, pNode2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>含指向父结点指针的普通树</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> pValue;</span><br><span class="line">	TreeNode* pLeft;</span><br><span class="line">	TreeNode* pRight;</span><br><span class="line">	TreeNode* pParent;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">GetLastCommonNodeCoreByStack</span><span class="params">(TreeNode* pNode1, TreeNode* pNode2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置两个辅助栈</span></span><br><span class="line">	stack&lt;TreeNode*&gt; List1;</span><br><span class="line">	stack&lt;TreeNode*&gt; List2;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将两个链表结点分别压栈</span></span><br><span class="line">	<span class="keyword">while</span> (pNode1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		List1.<span class="built_in">push</span>(pNode1);</span><br><span class="line">		pNode1 = pNode1-&gt;pParent;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (pNode2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		List2.<span class="built_in">push</span>(pNode2);</span><br><span class="line">		pNode2 = pNode2-&gt;pParent;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置记录公共祖先的指针</span></span><br><span class="line">	TreeNode* pCommon = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//自链表尾部开始找寻第一次产生分叉的结点</span></span><br><span class="line">	<span class="keyword">while</span> (!List1.<span class="built_in">empty</span>() &amp;&amp; !List2.<span class="built_in">empty</span>() &amp;&amp; List1.<span class="built_in">top</span>() == List2.<span class="built_in">top</span>()) &#123;</span><br><span class="line">		</span><br><span class="line">		pCommon = List1.<span class="built_in">top</span>();</span><br><span class="line">		List1.<span class="built_in">pop</span>();</span><br><span class="line">		List2.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;		</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pCommon;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">GetLastCommonNode</span><span class="params">(TreeNode* pNode1, TreeNode* pNode2)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断异常</span></span><br><span class="line">	<span class="keyword">if</span> (pNode1 == <span class="literal">nullptr</span> || pNode2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		isException = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">GetLastCommonNodeCoreByStack</span>(pNode1, pNode2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>不含指向父结点指针的普通树</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通树中两个结点的最低公共祖先</span></span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">GetLastCommonNodeCore</span><span class="params">(list&lt;TreeNode*&gt;&amp; PathList1, list&lt;TreeNode*&gt;&amp; PathList2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置记录公共结点的指针</span></span><br><span class="line">	TreeNode* pCommon = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//正向遍历两个链表(根节点为头结点)，找寻第一个产生分叉的结点</span></span><br><span class="line">	<span class="keyword">auto</span> ite1 = PathList1.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">auto</span> ite2 = PathList2.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (ite1 != PathList1.<span class="built_in">end</span>() &amp;&amp; ite2 != PathList2.<span class="built_in">end</span>()) &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> ((*ite1)-&gt;pValue == (*ite2)-&gt;pValue) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//记录当前公共结点</span></span><br><span class="line">			pCommon = *ite1;</span><br><span class="line">			<span class="comment">//向后遍历</span></span><br><span class="line">			ite1++;</span><br><span class="line">			ite2++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pCommon;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetLastCommonNodePath</span><span class="params">(TreeNode* pHead, TreeNode* pNode, list&lt;TreeNode*&gt;&amp; PathList)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置返回值记录变量</span></span><br><span class="line">	<span class="keyword">bool</span> hasPath = <span class="literal">false</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//路径链表中记录当前遍历结点</span></span><br><span class="line">	PathList.<span class="built_in">push_back</span>(pHead);	</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断当前压入结点构成的路径是否为要求的路径</span></span><br><span class="line">	<span class="keyword">if</span> (pHead-&gt;pValue == pNode-&gt;pValue) &#123;</span><br><span class="line">		hasPath = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//若当前压入结点构成的路径不满足要求，则在当前结点的左子树中继续找寻路径</span></span><br><span class="line">	<span class="keyword">if</span> (!hasPath &amp;&amp; pHead-&gt;pLeft != <span class="literal">nullptr</span>)</span><br><span class="line">		hasPath = <span class="built_in">GetLastCommonNodePath</span>(pHead-&gt;pLeft, pNode, PathList);</span><br><span class="line">	<span class="comment">//若左子树中未找寻到路径，则在当前结点的右子树中继续找寻路径</span></span><br><span class="line">	<span class="keyword">if</span> (!hasPath &amp;&amp; pHead-&gt;pRight != <span class="literal">nullptr</span>)</span><br><span class="line">		hasPath = <span class="built_in">GetLastCommonNodePath</span>(pHead-&gt;pRight, pNode, PathList);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//回溯</span></span><br><span class="line">	<span class="keyword">if</span>(!hasPath)</span><br><span class="line">		PathList.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> hasPath;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">GetLastCommonNode</span><span class="params">(TreeNode* pHead, TreeNode* pNode1, TreeNode* pNode2)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断异常</span></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span> || pNode1 == <span class="literal">nullptr</span> || pNode2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		isException = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建存储路径的辅助空间</span></span><br><span class="line">	list&lt;TreeNode*&gt; PathList1;</span><br><span class="line">	list&lt;TreeNode*&gt; PathList2;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置返回值</span></span><br><span class="line">	TreeNode* pCommonNode = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取根结点到两个结点的路径，若有一条路径不存在，则无公共结点</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">GetLastCommonNodePath</span>(pHead, pNode1, PathList1) &amp;&amp; <span class="built_in">GetLastCommonNodePath</span>(pHead, pNode2, PathList2)) &#123;</span><br><span class="line">		pCommonNode = <span class="built_in">GetLastCommonNodeCore</span>(PathList1, PathList2);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pCommonNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
]]></content>
      <categories>
        <category>Algorithm and DataStruture</category>
      </categories>
      <tags>
        <tag>Algorithm and DataStruture</tag>
      </tags>
  </entry>
  <entry>
    <title>TurtoiseSVN</title>
    <url>/2022/03/22/SVN/%E6%96%B0%E4%BA%BATortoiseSVN%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="TurtoiseSVN"><a href="#TurtoiseSVN" class="headerlink" title="TurtoiseSVN"></a>TurtoiseSVN</h1><blockquote>
<p> SVN乌龟客户端</p>
</blockquote>
<h2 id="———-First-Things———–"><a href="#———-First-Things———–" class="headerlink" title="———-First Things———–"></a>———-First Things———–</h2><ol>
<li>领取SVN授权账号</li>
<li>checkout项目组代码调试</li>
</ol>
<h2 id="——-Basic-Operatings——"><a href="#——-Basic-Operatings——" class="headerlink" title="——-Basic Operatings——-"></a>——-Basic Operatings——-</h2><h2 id="CheckOut-检出提取"><a href="#CheckOut-检出提取" class="headerlink" title="CheckOut 检出提取"></a>CheckOut 检出提取</h2><blockquote>
<p>将远程代码库中的项目clone到本地指定目录，创建一个工作副本</p>
</blockquote>
<ol>
<li><p>URL of repository</p>
<blockquote>
<p>远程代码库的url地址</p>
<p>具体菜鸟教程 or CSDN 需要时检索 版本库浏览器简化了一系列操作</p>
</blockquote>
<p><code>注意:</code></p>
<ol>
<li>checkout时的版本地址不能直接使用地址栏中的地址，需要版本库页面生成的Repository URL地址</li>
<li>svn不会自动创建远程代码库的目录，直接将最后目录的文件clone下来，因此需要将远程库中指定的文件夹包含到自己指定的目录层级中</li>
</ol>
</li>
<li><p>Checkout directory</p>
<blockquote>
<p>clone代码库的目录层深度，中文版本直接对即可</p>
</blockquote>
<ul>
<li>Fully recursive：全递归。检出完整的目录树，包含所有的文件或子目录；</li>
<li>Immediate children,including folders：直接子节点，包含文件夹。检出当前所选目录（在本文中对应目录为 cgi_oss，下同），包含其中的文件或子目录，但是不递归展开子目录；</li>
<li>Only file chlidren：仅文件子节点。检出当前所选目录，包含所有文件，但是不检出任何子目录；</li>
<li>Only this item：仅此项。只检出目录，不包含其中的文件或子目录；</li>
<li>omit externals：忽略外部设备，默认不选；</li>
<li>choose items：选择项目，默认不选；</li>
</ul>
</li>
<li><p>Revision</p>
<blockquote>
<p>版本信息选择</p>
</blockquote>
<ul>
<li>Head revison: 最新版本代码</li>
<li>Revision: 根据展示的log历史版本选择指定版本进行clone</li>
</ul>
</li>
</ol>
<h2 id="Commite-提交"><a href="#Commite-提交" class="headerlink" title="Commite 提交"></a>Commite 提交</h2><blockquote>
<p>当你已经修改了代码，你需要Commit到repository，这样repository才会更新</p>
<p>add -  添加至版本控制系统 </p>
<p>commit - 将更改上传至远程仓库</p>
<p>具体菜鸟教程 or CSDN 需要时检索 版本库浏览器简化了一系列操作</p>
</blockquote>
<h2 id="UpDate-更新"><a href="#UpDate-更新" class="headerlink" title="UpDate 更新"></a>UpDate 更新</h2><blockquote>
<p>当你已经Checkout了一份源代码有段时间， Update以便与repository同步，保证手上的代码有最新的变更</p>
<p>具体菜鸟教程 or CSDN 需要时检索 版本库浏览器简化了一系列操作</p>
</blockquote>
<h2 id="——-Other-Operatings——–"><a href="#——-Other-Operatings——–" class="headerlink" title="——-Other Operatings——–"></a>——-Other Operatings——–</h2><h2 id="Revert-回退"><a href="#Revert-回退" class="headerlink" title="Revert 回退"></a>Revert 回退</h2><blockquote>
<p>Revert 可以重置对工作副本的修改，他可以重置一个或者多个文件/目录</p>
</blockquote>
<h2 id="Merge-合并-Resolve-解决"><a href="#Merge-合并-Resolve-解决" class="headerlink" title="Merge 合并 + Resolve 解决"></a>Merge 合并 + Resolve 解决</h2><blockquote>
<p>Merge可以自动处理可安全合并的东西，其余的会当做冲突</p>
<p>Resolve是在用户手动解决冲突后通过该操作告知版本库如何处理这些冲突</p>
</blockquote>
<h2 id="Brunch-Tag"><a href="#Brunch-Tag" class="headerlink" title="Brunch / Tag"></a>Brunch / Tag</h2><blockquote>
<p>Subversion 建立分支与标签的方法, 就只是复制该项目, 使用的方法就类似于硬连接 (hard-link) 所以这些操作只会花费很小, 而且是固定的时间</p>
</blockquote>
<h1 id="githubtoken推送代码问题"><a href="#githubtoken推送代码问题" class="headerlink" title="githubtoken推送代码问题"></a>githubtoken推送代码问题</h1><blockquote>
<p>2021.8.13 github更新再支持使用密码push的方式</p>
</blockquote>
<ol>
<li><p>在github中设置一个自己的Personal access tokens</p>
<blockquote>
<p>Settings -&gt; Developer settings -&gt; Personal access tokens -&gt; Generate new token</p>
<p>-&gt; 勾选 repo / admin:repo_hook / delete_repo 选项即可 -&gt; Generate</p>
</blockquote>
</li>
<li><p>在git与远程仓库链接设置别名时将该token复制与https://[你的token]github…即可</p>
</li>
<li><p>YumiGame Access Token : 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</p>
</li>
</ol>
<p>2021/12/20 - 2021/12/22 </p>
<hr>
]]></content>
      <categories>
        <category>YumiGame</category>
      </categories>
      <tags>
        <tag>TurtoiseSVN</tag>
      </tags>
  </entry>
  <entry>
    <title>Siggraph Asia 2019 - 神经状态机</title>
    <url>/2022/03/22/Animation/CenterAI_%E7%A5%9E%E7%BB%8F%E7%8A%B6%E6%80%81%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="Siggraph-Asia-2019-用于角色与场景交互动画的神经状态机"><a href="#Siggraph-Asia-2019-用于角色与场景交互动画的神经状态机" class="headerlink" title="Siggraph Asia 2019 - 用于角色与场景交互动画的神经状态机"></a>Siggraph Asia 2019 - 用于角色与场景交互动画的神经状态机</h1><h1 id="The-Current-Progress-当前进度"><a href="#The-Current-Progress-当前进度" class="headerlink" title="The Current Progress / 当前进度"></a>The Current Progress / 当前进度</h1><ul>
<li>Unity初级编程 - 中级编程 / √</li>
<li>动画系统demo实践 完成模型导入-&gt; 动画绑定 -&gt; 状态机组织动画 / √</li>
<li>工具 fbx -&gt; motiondate -&gt; 中间数据 / √</li>
<li>AIAnimation框架，神经状态机了解 / ing</li>
<li>ue4状态机 + AI + 行为树</li>
<li>着手Ue版动画系统的架构</li>
</ul>
<h1 id="Outline-概要"><a href="#Outline-概要" class="headerlink" title="Outline / 概要"></a>Outline / 概要</h1><blockquote>
<p><code>With the Neural State Machine as the core machinery, we achieve the smooth transitions in high-level states with a goal-driven control while realizing precise scene interactions with a bi-directional character control scheme and volumetric sensors.</code></p>
<p>以神经网络状态机为核心机制，通过目标驱动控制实现高级状态的平滑过渡，通过双向角色控制方案与体积传感器实现精确的场景交互</p>
</blockquote>
<h1 id="Neural-State-Machine-神经状态机"><a href="#Neural-State-Machine-神经状态机" class="headerlink" title="Neural State Machine / 神经状态机"></a>Neural State Machine / 神经状态机</h1><blockquote>
<p><code>The Neural State Machine consists of a Motion Prediction Network and a Gating Network. </code></p>
<p>神经状态机主要由两部分组成，如下图，一部分为 Gating Network / 门控网络，另一部分为 Motion Prediction Network / 运动预测网络</p>
</blockquote>
<p><img src="/.com//image-20220210105722924.png" alt="image-20220210105722924"></p>
<h2 id="Gating-Network-门控网络"><a href="#Gating-Network-门控网络" class="headerlink" title="Gating Network / 门控网络"></a>Gating Network / 门控网络</h2><blockquote>
<p> <code>The Gating Network decides the blending coefficients of expert weights based on the given goal and the phase of the motion to dynamically generate the Motion Prediction Network. The intuition behind this design is to encode different modes of motion in drastically different tasks separately in multiple experts to avoid blurry motions and adapt to different tasks. We further modulate the expert blending weights using a learned cyclic function to ensure the state will move forward in time.</code></p>
<p>门控网络决定了专家权重的混合系数，进而动态的生成运动预测网络.</p>
<p>专家混合系数会进一步调节以保证运动状态将及时更新</p>
</blockquote>
<h3 id="Input-输入"><a href="#Input-输入" class="headerlink" title="Input / 输入"></a>Input / 输入</h3><blockquote>
<p><code>Input Features of the Gating Network: We design the input features of the gating network such that the expert weights are selected and interpolated according to both the action labels and phase values. At each frame i, the input of the Gating Network Xˆ i is computed by composing two vectors as follows: Xiˆ = Pi ⊗ X′</code></p>
<p>Pi : 2D相位矢量</p>
<p>X’ : 含有当前动作，目标位置，目标朝向，沿整个运动轨迹的目标动作</p>
</blockquote>
<h3 id="Output-输出"><a href="#Output-输出" class="headerlink" title="Output / 输出"></a>Output / 输出</h3><blockquote>
<p>ω = Ω(Xˆ;µ) = σ(W′2 ELU( W′ 1 ELU( W′0 Xˆ + b′0 ) + b′1 ) + b′2)</p>
<p><code>ω is the blending coefficients of the expert weights to compute the network parameters of the Motion Prediction Network; </code></p>
<p>门控网络将通过以上运算得出专家权重的混合系数以用于计算运动预测网络的网络参数，即用于生成运动预测网络</p>
</blockquote>
<h2 id="Motion-Prediction-Network-运动预测网络"><a href="#Motion-Prediction-Network-运动预测网络" class="headerlink" title="Motion Prediction Network / 运动预测网络"></a>Motion Prediction Network / 运动预测网络</h2><blockquote>
<p><code>The Motion Prediction Network is the main component of our system where it computes the pose of the character in the current frame, given the pose in the previous frame, the geometry of the surrounding environment, and the high-level instructions including the goal location and the action state.</code></p>
<p>运动预测网络基于之前帧中的角色姿势，周边环境的几何体，含有目标位置和动作状态的高级指令，最终计算当前帧角色的姿势，其含有两个模块，分别是编码器模块与预测模块</p>
</blockquote>
<ul>
<li><p>Encoder Module / 编码器模块</p>
<blockquote>
<p><code>This module receives the components of the character state in the previous frame and encodes them individually using simple three-layer networks.</code></p>
<p>该模块提取角色状态中的四个分量，并使用简单的三层网络分别编码</p>
</blockquote>
</li>
<li><p>Prediction Module / 预测模块</p>
<blockquote>
<p><code>This module receives the output of the encoder module and predicts the state of the character in the current frame. The prediction module is a three-layer network whose weights are dynamically blended from a group of expert weights with coefficients from the Gating Network.</code></p>
<p>预测模块接受编码器模块的输出对当前帧的角色状态进行预测，该网络层的权重由混合系数与专家权重组合动态混合而成</p>
</blockquote>
</li>
</ul>
<h3 id="Input-输入-1"><a href="#Input-输入-1" class="headerlink" title="Input / 输入"></a>Input / 输入</h3><blockquote>
<p><code>The inputs of the Motion Prediction Network Xi at frame i consist of four components, namely the Frame Input Fi, Goal Input Gi, Interaction Geometry Input Ii and Environment Geometry Input Ei, such Xi = &#123;Fi , Gi , Ii , Ei &#125;.</code></p>
<p>预测网络于当前帧的输入包含四部分，F(i)，G(i)，I(i)，E(i)</p>
</blockquote>
<ul>
<li><p>Frame Input F(i)</p>
<blockquote>
<ol>
<li>角色在 i-1 帧的<strong>角色姿势</strong>(23个关节的位置、旋转值与相对于根坐标的速度)</li>
<li><strong>根</strong>在采样时间段(in the past/future in a 2 second window)内的<strong>轨迹线数据</strong>(采样范围内的坐标、前向向量数据)，相对于 i-1 帧</li>
<li>采样时间段内连续的<strong>行为标签</strong>，该行为标签会在每一个t轨迹点上由0到1变化</li>
</ol>
</blockquote>
</li>
<li><p>Goal Input G(i)</p>
<blockquote>
<ol>
<li>目标位置，目标沿采样轨迹线的朝向</li>
<li>目标点的热动作标签(目标行为标签)</li>
</ol>
</blockquote>
</li>
<li><p>The Interaction Geometry Input I(i) and Environment Geometry Encoder Input E(i)</p>
<blockquote>
<p>角色周围交互对象的体积表示</p>
</blockquote>
</li>
</ul>
<h3 id="Output-输出-1"><a href="#Output-输出-1" class="headerlink" title="Output / 输出"></a>Output / 输出</h3><blockquote>
<p><code>The outputs are used to animate the character, directly fed back into the inputs or blended with the user inputs to be a control signal for the next iteration. </code></p>
<p>该网络层的输出将用于动画化角色，并且将直接反馈到输入或者与用户输入混合，形成控制信号用于下一次迭代预测 - 自回归</p>
</blockquote>
<ul>
<li>角色坐标系统中的角色姿态预测结果</li>
<li>在角色坐标系统中的未来的（1秒内）根的轨迹</li>
<li>在目标坐标系统中的未来的（1秒内）根的轨迹</li>
<li>Goal Output G0(目标数据的更新值)，含更新后的位置，朝向与目标行为等</li>
<li>关键关节的接触点标签，用于IK</li>
<li>当前的相位更新</li>
</ul>
<h1 id="Goal-Driven-Character-Control-目标驱动的角色控制"><a href="#Goal-Driven-Character-Control-目标驱动的角色控制" class="headerlink" title="Goal-Driven Character Control / 目标驱动的角色控制"></a>Goal-Driven Character Control / 目标驱动的角色控制</h1><blockquote>
<p><code>Our system has two modes of control: the high-level goal-driven mode and the low-level locomotion mode.</code></p>
<p>该系统提供两个控制模式，高级目标驱动模式，低级运动模式，并且可以无缝切换</p>
</blockquote>
<ul>
<li><p>High-level goal-driven mode / 高级目标驱动模式</p>
<blockquote>
<p>鼠标选中目标对象，再通过键盘按键执行欲执行的行为</p>
</blockquote>
</li>
<li><p>Low-level locomotion mode / 低级运动模式</p>
<blockquote>
<p>键盘控制角色行走/奔跑</p>
</blockquote>
</li>
</ul>
<h1 id="Bi-Directional-Control-Scheme-双向控制方案"><a href="#Bi-Directional-Control-Scheme-双向控制方案" class="headerlink" title="Bi-Directional Control Scheme / 双向控制方案"></a>Bi-Directional Control Scheme / 双向控制方案</h1><blockquote>
<p><code>The idea of the bi-directional controller is to infer the motion from both the egocentric and goal point of view, match both predictions during runtime, and feedback such inference into the Neural State Machine to increase the precision of the character to reach the goal during the tasks</code></p>
<p>双向控制方案可以从角色与目标两个角度同时出发，预测角色的轨迹，运行时将两种预测都反馈给神经状态机，以提高角色轨迹的精度</p>
<p><code>Instead, predicting such information in the goal-space gives more accurate values for where the character would actually need to be, and back-transforming those into root-space during runtime enables avoidance of such error accumulation. </code></p>
<p>双向控制方案可以从目标角度出发，更精确地提供角色的轨迹预测值，并于运行时将信息反向转换至角色根空间，解决了单向控制方案存在的误差累积问题，尤其在数据量不足时，由随机位置运动到目标点，效果显著</p>
<p><code>In more detail, the bi-directional controller is part of the Neural State Machine and computes the future trajectory in the goal-centric coordinate system </code></p>
<p>双向控制时神经状态机的一部分，从目标坐标系出发计算角色未来的根轨迹</p>
</blockquote>
<h1 id="Volumetric-Sensors-体积传感器"><a href="#Volumetric-Sensors-体积传感器" class="headerlink" title="Volumetric Sensors / 体积传感器"></a>Volumetric Sensors / 体积传感器</h1><blockquote>
<p><code>We use two voluemtric sensors to evaluate the status of the body with respect to the object: the Environment Sensor and the Interaction Sensor.</code></p>
<p>使用体积感知器来评估角色与目标物体的空间状态，一个是环境感知器，一个是交互感知器</p>
</blockquote>
<ul>
<li><p>Environment Sensor / 环境感知器</p>
<blockquote>
<p><code>To recognize the surrounding geometry of the character and let it affect the motion in the next frame, we use a volumetric sensor that we call the Environment Sensor that has a cylindrical shape. The collision between objects/environment and a cylindrical volume of radius R and height H is evaluated while the character is moving and fed into the Environment Geometry Input Ei.</code></p>
<p>Environment Sensor 使用一个半径为 R，高度为 H 的圆柱体，在角色运动时评估角色与目标物体的碰撞，并将结果写入Ei，传至神经状态机中，影响角色下一帧的运动</p>
<p><code>Within the volume, spheres of radius r &lt;&lt; R are sampled and their intersections with the objects/environment are tested.</code></p>
<p>圆柱体中将使用半径为 r&lt;&lt;R 的球体对目标物体与圆柱体的交集部分进行采样，这样可以提供连续的输入用于碰撞计算，从而产生更平滑的动作</p>
</blockquote>
</li>
<li><p>Interaction Sensor / 交互感知器</p>
<blockquote>
<p><code>We prepare another volumetric sensor that we call the Interaction Sensor to provide further details of the object geometry from the goal point of view.</code></p>
<p>Interaction Sensor 可以从目标几何体出发，提供目标几何体的具体细节，如椅子的扶手，以便角色作出更精确的动作</p>
<p><code>As the Environment Sensor can be too coarse, and the character can be moving, the fine details of the object, such as the arm rests of the chair, can be missed.</code></p>
<p>Environment Sensor 从角色出发，以圆柱体 + 球体感知周围物体，可能忽略目标物体的细节，而通过 Interaction Sensor 可以弥补该缺陷</p>
</blockquote>
</li>
</ul>
<h1 id="Data-Preparation-数据准备"><a href="#Data-Preparation-数据准备" class="headerlink" title="Data Preparation / 数据准备"></a>Data Preparation / 数据准备</h1><ul>
<li><p>Motion Capture / 动捕数据</p>
</li>
<li><p>Motion  Labelling / 动作标签</p>
<blockquote>
<p>每一帧的数据都会标记一个动作标签，标签含有以下内容</p>
<ol>
<li><p>当前动作标签</p>
</li>
<li><p>目标动作标签</p>
</li>
<li><p>当前的相位标量</p>
</li>
</ol>
<p>相位标量用于确定角色在 周期运动(行走)/非周期运动 中的具体位置信息</p>
</blockquote>
</li>
</ul>
<p><strong>Questions :</strong> </p>
<ul>
<li>相位向量？</li>
<li>预测模块预测处状态，怎么进行的状态过渡？哪一模块负责了值的写入？</li>
<li>训练得出的数据集的作用在于？更好的预测？在哪一模块被使用？</li>
</ul>
]]></content>
      <categories>
        <category>YumiGame</category>
      </categories>
      <tags>
        <tag>Animation Systems</tag>
      </tags>
  </entry>
  <entry>
    <title>Ue4 - Animation System</title>
    <url>/2022/03/22/Unreal/Ue4_%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F%E6%9C%AA%E5%AE%8C/</url>
    <content><![CDATA[<h1 id="Skeletal-Mesh-Animation-System-Ue骨架网格体动画系统"><a href="#Skeletal-Mesh-Animation-System-Ue骨架网格体动画系统" class="headerlink" title="Skeletal Mesh Animation System - Ue骨架网格体动画系统"></a>Skeletal Mesh Animation System - Ue骨架网格体动画系统</h1><h1 id="The-Current-Progress-当前进度"><a href="#The-Current-Progress-当前进度" class="headerlink" title="The Current Progress / 当前进度"></a>The Current Progress / 当前进度</h1><ul>
<li>Unity初级编程 - 中级编程 / √</li>
<li>动画系统demo实践 完成模型导入-&gt; 动画绑定 -&gt; 状态机组织动画 / √</li>
<li>工具 fbx -&gt; motiondate -&gt; 中间数据 / √</li>
<li>ue4状态机 + AI + 行为树 / ing</li>
<li>着手AIAnimation框架，着手动画系统的改写</li>
</ul>
<h1 id="Skinned-Mesh-Animation-骨骼蒙皮动画"><a href="#Skinned-Mesh-Animation-骨骼蒙皮动画" class="headerlink" title="Skinned Mesh Animation / 骨骼蒙皮动画"></a>Skinned Mesh Animation / 骨骼蒙皮动画</h1><blockquote>
<p>骨骼蒙皮动画独立出了两个概念，一个是骨骼，一个是蒙皮，其核心原理是由骨骼来决定模型顶点的最终世界坐标，动画数据直接包含的不是模型顶点变换数据，而是骨骼的运动信息，进而由骨骼变换来驱动 Skinned Mesh 顶点的变形，进而形成动画</p>
</blockquote>
<ul>
<li>Skinned Mesh 应包含 动画数据，骨骼数据，含Skin Info的Mesh数据，BoneOffset Matrix 骨骼偏移矩阵用于组织动画</li>
</ul>
<h2 id="Bone-Struct-骨骼结构"><a href="#Bone-Struct-骨骼结构" class="headerlink" title="Bone Struct / 骨骼结构"></a>Bone Struct / 骨骼结构</h2><h3 id="Bone-and-Joint-Defination-骨骼关节定义"><a href="#Bone-and-Joint-Defination-骨骼关节定义" class="headerlink" title="Bone and Joint Defination / 骨骼关节定义"></a>Bone and Joint Defination / 骨骼关节定义</h3><blockquote>
<p>骨骼可以理解为一个<strong>坐标空间</strong>.</p>
<p>关节为骨骼坐标空间的原点，用来描述骨骼的位置(以该关节为原点的骨骼)，骨骼位置即该原点在父坐标空间(骨骼)中的位置，关节不仅决定了骨骼空间的位置，又是骨骼空间的旋转与缩放中心.</p>
<p><code>注意:</code></p>
<ol>
<li>Bone 下的位置信息不是真实骨骼的位置，因为该骨骼并不实际存在，而是该坐标空间(骨骼)原点在父坐标空间(骨骼)中的位置信息</li>
<li>4*4 的矩阵可以用来同时描述骨骼的位置，旋转，缩放信息</li>
<li>骨骼的长度由关节位置与蒙皮结果决定</li>
</ol>
</blockquote>
<h3 id="Bone-Hierarchy-骨骼层级"><a href="#Bone-Hierarchy-骨骼层级" class="headerlink" title="Bone Hierarchy / 骨骼层级"></a>Bone Hierarchy / 骨骼层级</h3><blockquote>
<p>骨骼层级为嵌套的坐标空间，父坐标空间的变换带动子坐标空间变换.</p>
<p>可以认为 root 骨骼的父坐标空间为世界坐标空间，root 骨骼的位置即整个骨骼体系在世界坐标中的位置，进而由父骨骼的运动驱动子骨骼的运动，子骨骼的运动信息将由计算自动得出.</p>
<p><code>注意:</code></p>
<ol>
<li>可使用额外骨骼用于定位动画模型整体的世界坐标，一般会在人双脚之间额外添加一根 root 骨骼，并不是实际存在，但是可以以此为准，使得当设置整个人物模型位置为(0,0,0)时，可以使人物在地面之上</li>
</ol>
</blockquote>
<h3 id="UpdateBoneMatrix-Update-骨骼更新"><a href="#UpdateBoneMatrix-Update-骨骼更新" class="headerlink" title="UpdateBoneMatrix Update / 骨骼更新"></a>UpdateBoneMatrix Update / 骨骼更新</h3><blockquote>
<p>根据时间从动画数据中获取当前时刻的 <em>Transform</em> Matrix 变换矩阵</p>
</blockquote>
<p><strong>TransformMatrix 变换矩阵</strong></p>
<blockquote>
<p>TransformMatrix 可以记录骨骼坐标空间相对于坐标原点的变换信息(骨骼的变换信息)，逐帧更新</p>
<p><code>注意:</code></p>
<ol>
<li>TransformMatrix 变换信息是相对于父骨骼而言的</li>
<li>变换信息可包含位置，旋转，缩放信息</li>
<li>动画数据也可包含骨骼旋转，缩放信息，动画数据，因此动画关键帧数据可仅通过四元数表示，而位置由 TransformMatrix 表示</li>
</ol>
</blockquote>
<p><strong>CombinedMatrix 世界变换矩阵</strong></p>
<blockquote>
<p>骨骼最终带动的网格顶点的变换需要使用 CombinedMatrix 世界变换矩阵</p>
</blockquote>
<h2 id="Skinned-Mesh-蒙皮网格体"><a href="#Skinned-Mesh-蒙皮网格体" class="headerlink" title="Skinned Mesh / 蒙皮网格体"></a>Skinned Mesh / 蒙皮网格体</h2><blockquote>
<p>Skinned Mesh 实际上是具有 Skin Info 此类蒙皮信息的特殊网格体.</p>
<p><code>注意:</code></p>
<ol>
<li>网格体模型的顶点定义在网格体模型坐标系中，而骨骼关节定义在骨骼坐标系中，若要使骨骼驱动网格体顶点于世界坐标系中的变换，需要 Skin Info 此类蒙皮信息 使网格体顶点可以与骨骼关节建立关联.</li>
</ol>
</blockquote>
<h3 id="Skin-Info-蒙皮信息"><a href="#Skin-Info-蒙皮信息" class="headerlink" title="Skin Info / 蒙皮信息"></a>Skin Info / 蒙皮信息</h3><blockquote>
<p>Skin Info 可定义在顶点中，包含有最大链接骨骼数，关联到的骨骼实例数组，对应到每个骨骼实例的作用权重数组</p>
</blockquote>
<h2 id="Mesh-deform-Mesh-形变"><a href="#Mesh-deform-Mesh-形变" class="headerlink" title="Mesh deform / Mesh 形变"></a>Mesh deform / Mesh 形变</h2><blockquote>
<p>骨骼网格体动画，骨骼随时间变换，顶点位置随骨骼变换，而每个顶点又可关联多根骨骼，在将顶点与相应骨骼建立关联后，可依次计算顶点在各个骨骼驱动下的世界坐标，进而根据权重进行加权平均，得到最终在多根骨骼影响下的世界坐标</p>
<p><code>注意:</code></p>
<ol>
<li>实际上是依据关联骨骼坐标空间下的 TransformMatrix 计算其在该骨骼空间影响下的世界坐标，该 TransformMatrix 会逐帧更新的</li>
</ol>
</blockquote>
<h3 id="Vertex-Calculation-Process-单个骨骼下的顶点变换计算流程"><a href="#Vertex-Calculation-Process-单个骨骼下的顶点变换计算流程" class="headerlink" title="Vertex Calculation Process / 单个骨骼下的顶点变换计算流程"></a>Vertex Calculation Process / 单个骨骼下的顶点变换计算流程</h3><blockquote>
<p>Mesh Vertex (Mesh Space) – [BoneOffsetMatrix] -&gt; Mesh Vertex (Bone Space) – [BoneCombinedTransformMatrix] -&gt; Mesh Vertex (World Space)</p>
</blockquote>
<ol>
<li>要通过骨骼计算出顶点的世界变换，需要先将顶点坐标变换至关联骨骼的骨骼坐标空间中</li>
<li>利用关联骨骼的世界变换，计算变换后顶点的世界坐标</li>
</ol>
<h4 id="BoneOffset-Matrix-骨骼偏移矩阵"><a href="#BoneOffset-Matrix-骨骼偏移矩阵" class="headerlink" title="BoneOffset Matrix / 骨骼偏移矩阵"></a>BoneOffset Matrix / 骨骼偏移矩阵</h4><blockquote>
<p>BoneOffset Matrix 可以将模型顶点坐标变换至关联骨骼的坐标空间.</p>
<p><code>注意:</code></p>
<ol>
<li>BoneOffset Matrix 保存在 Bone 下，以便当 Bone 关联多个顶点时，无需保存每个顶点在骨骼坐标空间的坐标，只需要保存变换方式即可，只需通过该变换计算坐标</li>
<li>因为 BoneOffset Matrix 需要根据对应骨骼在初始姿势下的 TransformMatrix 得出，因此其包含的相关信息依赖于对应 TransformMatrix</li>
</ol>
</blockquote>
<h4 id="BoneOffsetMatrix-and-BoneCombinedTransformMatrix-关系"><a href="#BoneOffsetMatrix-and-BoneCombinedTransformMatrix-关系" class="headerlink" title="BoneOffsetMatrix and BoneCombinedTransformMatrix 关系"></a>BoneOffsetMatrix and BoneCombinedTransformMatrix 关系</h4><ul>
<li>一般为互为逆矩阵</li>
</ul>
<blockquote>
<p>若 Mesh Space 与 World Space 坐标原点重合，即 Mesh 与 World 空间重合，则它们为互为逆矩阵的关系.</p>
<p>由指定 Bone Space 变换至 World Space，需要通过其 TransformMatrix(指定Bone Space 至 父Bone Space 的变换矩阵 ) 向上逐层变换，直至由 Root Bone Space 得到 Combined Transform Matrix (由 Bone Space 到 World Space 的变换矩阵)，可通过此矩阵计算得出 指定Bone Space 中的变换在 World Space 下的变换，由于 World Space 与 Mesh Space 重合，即得到了 指定Bone Space 到 Mesh Space 的变换矩阵，反之即为逆矩阵</p>
<p><code>注意:</code></p>
<ol>
<li>若 Mesh 与 World 空间不重合，则需要先将顶点数据由 Mesh Space 变换至 World Space，再执行后续变换</li>
</ol>
</blockquote>
<ul>
<li><p>Initial Pose / 初始姿势</p>
<blockquote>
<p>骨骼层级建立后的还未动画化的初始姿势，一般为T型</p>
</blockquote>
</li>
</ul>
<h2 id="Calculation-Process-流程概要"><a href="#Calculation-Process-流程概要" class="headerlink" title="Calculation Process / 流程概要"></a>Calculation Process / 流程概要</h2><ul>
<li>载入并建立骨骼层次结构，根据 Initial Pose 计算 TransformMatrix，进而计算 BoneOffset Matrix</li>
<li>载入含 Skin Info 蒙皮信息的 Mesh 数据</li>
<li>逐帧获取动画数据，更新各骨骼的 Transform Matrix，计算各 Bone Space 至 World Space 的变换矩阵 CombinedMatrix</li>
<li>对网格各个顶点根据 Skin Info 信息，通过 BoneOffset Matrix 关联至相应 Bone Space，进而计算各骨骼影响下的世界坐标的加权平均，用于最终顶点的渲染</li>
</ul>
<h1 id="To-be-continued-未完待续"><a href="#To-be-continued-未完待续" class="headerlink" title="To be continued / 未完待续"></a>To be continued / 未完待续</h1><blockquote>
<p>动画系统研究未完待续，Animation项目终止.</p>
</blockquote>
<ul>
<li>动画混合 - 使用不同混合节点进行完成。</li>
<li>动画节点 - 用于在输入姿势上执行如混合、直接骨骼操控等操作。</li>
<li>动画序列 - 可直接放入AnimGraph中驱动最终动画姿势。</li>
<li>混合空间 - 可在AnimGraph中使用，以基于变量混合姿势。</li>
<li>骨架控制 - 可直接用于驱动骨架内骨骼的节点。</li>
<li>空间转换 - 可切换姿势在局部空间或组件空间内的节点。</li>
<li>状态机 - 是一系列图表、规则和变量，可决定角色要进入的动画状态。</li>
<li>同步组 - 可用于保留已同步不同长度的相关动画。</li>
<li>Animation Sequences</li>
<li>Anim Montages</li>
<li>Morph Targets</li>
<li>Skeletal Controls</li>
<li>State Machines</li>
<li>Code Driven</li>
<li>Data Driven</li>
<li>虚拟骨骼</li>
<li>坐标系</li>
<li>Mesh空间</li>
<li>骨骼空间</li>
<li>坐标系的变换与渲染</li>
</ul>
]]></content>
      <categories>
        <category>YumiGame</category>
      </categories>
      <tags>
        <tag>Animation Systems</tag>
      </tags>
  </entry>
  <entry>
    <title>Tensorflow - 环境配置</title>
    <url>/2022/03/22/Tensorflow/CenterAI_GPU%E6%B8%B2%E6%9F%93%E7%8E%AF%E5%A2%83%E8%AF%A6%E7%BB%86%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="AIAnimation-GPU渲染环境详细配置"><a href="#AIAnimation-GPU渲染环境详细配置" class="headerlink" title="AIAnimation GPU渲染环境详细配置"></a>AIAnimation GPU渲染环境详细配置</h1><h1 id="The-Current-Progress-当前进度"><a href="#The-Current-Progress-当前进度" class="headerlink" title="The Current Progress / 当前进度"></a>The Current Progress / 当前进度</h1><ul>
<li>Unity初级编程 - 中级编程 / √</li>
<li>动画系统demo实践 完成模型导入-&gt; 动画绑定 -&gt; 状态机组织动画 / √</li>
<li>工具 fbx -&gt; motiondate -&gt; 中间数据 -&gt; 模型训练 / ing</li>
<li>ue4状态机 + AI + 行为树 / Waiting</li>
<li>着手AIAnimation框架，着手动画系统的改写 / Waiting</li>
</ul>
<h1 id="Cuda-and-CunNN-安装与配置"><a href="#Cuda-and-CunNN-安装与配置" class="headerlink" title="Cuda and CunNN 安装与配置"></a>Cuda and CunNN 安装与配置</h1><ul>
<li>检查 NVIDIA 显卡</li>
<li>安装 Cuda</li>
<li>安装 CuDNN</li>
<li>配置环境变量</li>
</ul>
<h2 id="检查-NVIDIA-显卡"><a href="#检查-NVIDIA-显卡" class="headerlink" title="检查 NVIDIA 显卡"></a>检查 NVIDIA 显卡</h2><blockquote>
<p>电脑显卡必须为NVIDIA显卡，否则无法安装CUDA，CUDA仅为NVIDA提供的面向编程的加速库</p>
</blockquote>
<ul>
<li><strong>cmd 命令行中输入 nvidia-smi 检查</strong></li>
</ul>
<blockquote>
<p>CUDA Version 为 NVIDIA 支持的最高 CUDA 版本，这里里以 v11.0 为例</p>
<p><code>注意:</code></p>
<ol>
<li>仅在安装了 NVIDIA 显卡驱动后，该命令才会有效，若未安装，自行安装</li>
</ol>
</blockquote>
<p><img src="/images/YumiImages/image-20220119141001491.png" alt="image-20220119141001491"></p>
<h2 id="Cuda-安装"><a href="#Cuda-安装" class="headerlink" title="Cuda 安装"></a>Cuda 安装</h2><blockquote>
<p>以 tensorflow_gpu-2.4.0 - python 3.6.2 - CUDA 11.0 - cuDNN 8.0 为例</p>
<p><code>注意:</code></p>
<ol>
<li>cuda 安装时仍使用C盘默认路径，避免路径错误</li>
</ol>
</blockquote>
<ul>
<li><p><strong>搜索 nvidia developer，进入官网，并进入下载页面</strong></p>
</li>
<li><p><strong>CUDA Toolkit -&gt; LEARN MORE -&gt; Download Now</strong></p>
</li>
</ul>
<p><img src="/images/YumiImages/image-20220119142224369.png" alt="image-20220119142224369"></p>
<ul>
<li><strong>Resources 下 点击 Archive of Previous CUDA Releases 下载指定版本</strong></li>
</ul>
<p><img src="/images/YumiImages/image-20220119142516674.png" alt="image-20220119142516674"></p>
<ul>
<li><strong>选择其中任一版本进行安装 Windows -&gt; x86_64 -&gt; 10 -&gt; exe[local]</strong></li>
</ul>
<p><img src="/images/YumiImages/image-20220119142801922.png" alt="image-20220119142801922"></p>
<ul>
<li><strong>关闭所有安全软件，进入安装程序，选择默认路径进行自定义安装</strong></li>
</ul>
<p><code>注意:</code></p>
<ol>
<li>NVIDIA GetForce… 组件 可以去除</li>
<li>若安装失败，可能由于未安装配置VS，可以去除 CUDA -&gt; Documentation -&gt; Visual Studio Integration 组件</li>
<li>若安装失败，可能由于 CUDA自带的NVIDIA驱动版本是小于你电脑已有的版本，需要去除 Driver components -&gt; Display Driver 组件</li>
</ol>
<h2 id="CuDNN-安装"><a href="#CuDNN-安装" class="headerlink" title="CuDNN 安装"></a>CuDNN 安装</h2><blockquote>
<p>cuDNN的全称为NVIDIA CUDA® Deep Neural Network library，是NVIDIA专门针对深度神经网络（Deep Neural Networks）中的基础操作而设计基于GPU的加速库。cuDNN为深度神经网络中的标准流程提供了高度优化的实现方式，并通过调用cuda显卡驱动实现</p>
</blockquote>
<ul>
<li><p><strong>搜素 cuDNN Archive 进入官网下载，需要注册账号</strong></p>
</li>
<li><p><strong>下载该版本即可</strong></p>
</li>
</ul>
<p><img src="/images/YumiImages/image-20220119143954600.png" alt="image-20220119143954600"></p>
<h2 id="环境变量配置"><a href="#环境变量配置" class="headerlink" title="环境变量配置"></a>环境变量配置</h2><ul>
<li>下载后解压，将文件里面的cuda文件重命名为cudnn，然后整个复制到 C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.0 中，同时需要将重命名后的cudnn文件夹的bin里面的 cudnn64_7.dll 复制到 C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.0\bin 中</li>
<li>将 cudnn 中 bin，include，lib 文件夹中的所有文件复制到 C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.0 下对应的文件夹中</li>
<li>将 C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.0\cudnn\bin 添加至系统环境变量中</li>
<li>将 C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.0\extras\CUPTI\lib64 添加至系统环境变量中</li>
<li>并将前两步添加的环境变量上移至前面两个变量（在安装过程中系统已经自动配置的）路径之下</li>
</ul>
<p><img src="/images/YumiImages/image-20220119145526443.png" alt="image-20220119145526443"></p>
<h2 id="测试-Cuda-是否安装成功"><a href="#测试-Cuda-是否安装成功" class="headerlink" title="测试 Cuda 是否安装成功"></a>测试 Cuda 是否安装成功</h2><blockquote>
<p>cmd 命令行中输入 nvcc -V，若出现以下信息，则成功</p>
</blockquote>
<p><img src="/images/YumiImages/image-20220119145719052.png" alt="image-20220119145719052"></p>
<h1 id="Tensorflow-环境安装"><a href="#Tensorflow-环境安装" class="headerlink" title="Tensorflow 环境安装"></a>Tensorflow 环境安装</h1><ul>
<li>Anaconda 安装</li>
<li>Tensorflow_env 环境搭建</li>
<li>Tensorflow 版本升级</li>
<li>pycharm 环境配置</li>
</ul>
<h2 id="Anaconda-安装"><a href="#Anaconda-安装" class="headerlink" title="Anaconda 安装"></a>Anaconda 安装</h2><blockquote>
<p> <a href="http://www.anaconda.com/">www.anaconda.com</a> 安装最新版本即可.</p>
</blockquote>
<ol>
<li>自定安装时使用c盘默认路径即可，若更改，环境配置时可能出现跨磁盘的路径错误</li>
</ol>
<p><img src="/images/YumiImages/image-20220118212728334.png" alt="image-20220118212728334"></p>
<ol start="2">
<li>勾选 Add PATH</li>
<li>完成安装</li>
</ol>
<h2 id="Tensorflow-env-环境搭建"><a href="#Tensorflow-env-环境搭建" class="headerlink" title="Tensorflow_env 环境搭建"></a>Tensorflow_env 环境搭建</h2><ul>
<li><strong>打开 Prompt 命令行工具</strong></li>
</ul>
<p><img src="/images/YumiImages/image-20220118213113795.png" alt="image-20220118213113795"></p>
<ul>
<li><strong>查看python版本</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">python -V / python --version</span><br></pre></td></tr></table></figure>

<blockquote>
<p>python 版本取决于待安装的 tensorflow 版本，可根据所需的版本更改 python 版本，自查版本对应关系</p>
<p><code>注意:</code></p>
<ol>
<li>注意 python 版本在不同的 conda 环境下是可以不同的，需要配置指定环境下的 python 版本，此处为 tensorflow_env 环境下的 python 版本</li>
</ol>
</blockquote>
<p><img src="/images/YumiImages/image-20220118215241852.png" alt="image-20220118215241852"></p>
<ul>
<li><strong>创建 Tensorflow_env 环境</strong></li>
</ul>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">conda create -n tensorflow_env tensorflow <span class="comment">// 创建tensorflow_env环境</span></span><br><span class="line">conda activate tensorflow_env <span class="comment">//切换至tensorflow_env环境进行配置</span></span><br></pre></td></tr></table></figure>

<p><code>注意:</code></p>
<ol>
<li>Anaconda 默认环境为 base，留意当前配置的环境是否为自己所需的环境</li>
<li>以下的所有环境配置需要切换至 Tensorflow_env 环境后进行</li>
<li>Tensorflow_env 环境下默认的 Tensorflow 版本为1.2.1，需要进行升级</li>
<li>Tensorflow_env 环境下默认的 pyhon 版本为 3.6.2</li>
</ol>
<h2 id="Tensorflow-版本升级"><a href="#Tensorflow-版本升级" class="headerlink" title="Tensorflow 版本升级"></a>Tensorflow 版本升级</h2><ul>
<li><p><strong>更新 python 版本</strong></p>
<blockquote>
<p>python 版本与 tensorflow 具有对应关系，若默认python符合要求，略过即可</p>
</blockquote>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">conda install python=<span class="number">3.</span>x <span class="comment">//安装指定python版本</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>升级 Tensorflow 版本</strong></li>
</ul>
<blockquote>
<p>AIAnimation 所需的 Tensorflow 版本至少为 2.0.0，此处以2.4.0为例</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pip install tensorflow==<span class="number">2.4</span><span class="number">.0</span> <span class="comment">//需要挂VPN</span></span><br><span class="line">pip install tensorflow-gpu==<span class="number">2.4</span><span class="number">.0</span> -i https:<span class="comment">//mirrors.aliyun.com/pypi/simple/ // 或者使用阿里镜像</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>检查 Tensorflow 版本</strong></p>
<blockquote>
<p>Anaconda Navigator 下 Environments -&gt; tensorflow_env -&gt; Installed -&gt; tensorflow 可查询到对应的版本，这里为2.0.0</p>
</blockquote>
</li>
</ul>
<p><img src="/images/YumiImages/image-20220118215605441.png" alt="image-20220118215605441"></p>
<h2 id="Pycharm下配置Anaconda环境"><a href="#Pycharm下配置Anaconda环境" class="headerlink" title="Pycharm下配置Anaconda环境"></a>Pycharm下配置Anaconda环境</h2><ul>
<li><strong>新建项目 -&gt; Pure Python -&gt; Existing interpreter -&gt; …选项</strong></li>
</ul>
<p><img src="/images/YumiImages/image-20220119101021774.png" alt="image-20220119101021774"></p>
<ul>
<li><strong>Conda Environment -&gt; 配置Interpreter 找到对应配置环境下的 python.exe -&gt; Conda executable 找到Anaconda下的 conda.exe</strong></li>
</ul>
<blockquote>
<p><code>注意:</code></p>
<ol>
<li><p>Interpreter 路径在 C:\Users\UserName\anaconda3\envs\… 下寻找</p>
</li>
<li><p>Conda executable 路径为 C:\Users\UserName\anaconda3\Scripts\conda.exe 即可</p>
</li>
</ol>
</blockquote>
<p><img src="/images/YumiImages/image-20220119101215355.png" alt="image-20220119101215355"></p>
<ul>
<li><strong>创建完成后，配置运行项目的解释器为指定解释器即可</strong></li>
</ul>
<p><img src="/images/YumiImages/image-20220119101725657.png" alt="image-20220119101725657"></p>
]]></content>
      <categories>
        <category>YumiGame</category>
      </categories>
      <tags>
        <tag>Tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>YumiGame - Ue4 - GamePlay</title>
    <url>/2022/03/22/Unreal/Ue4_GamePlay%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>注意: 类体结构以旧版本为主，目前以能看懂源码为主，具体深入到某一个类时，以源码为主！</p>
<h1 id="Outline-View-大纲视图"><a href="#Outline-View-大纲视图" class="headerlink" title="Outline View / 大纲视图"></a>Outline View / 大纲视图</h1><blockquote>
<p>本文将以大纲为准，逐层分析.</p>
</blockquote>
<h2 id="MVC-in-Ue-GamePlay"><a href="#MVC-in-Ue-GamePlay" class="headerlink" title="MVC in Ue_GamePlay"></a>MVC in Ue_GamePlay</h2><p><img src="/images/YumiImages/MVC_GamePlay.jpg" alt="MVC_GamePlay"></p>
<h2 id="Necessary-Class-in-Ue-GamePlay"><a href="#Necessary-Class-in-Ue-GamePlay" class="headerlink" title="Necessary Class in Ue_GamePlay"></a>Necessary Class in Ue_GamePlay</h2><p><img src="/images/YumiImages/Detailes.jpg" alt="Detailes"></p>
<h1 id="——-世界构建-表现——"><a href="#——-世界构建-表现——" class="headerlink" title="——-世界构建 - 表现——-"></a>——-世界构建 - 表现——-</h1><h1 id="UObject"><a href="#UObject" class="headerlink" title="UObject"></a>UObject</h1><blockquote>
<p>元数据，反射生成，GC垃圾回收，序列化，编辑器可见，Class Default Object.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class UObject ◇-&gt; UClass</span><br><span class="line">-------------</span><br><span class="line">GC &#x2F; 垃圾回收</span><br><span class="line">MetaData &#x2F; 元数据</span><br><span class="line">Reflection &#x2F; 生成</span><br><span class="line">Serialization &#x2F; 序列化</span><br><span class="line">Editable &#x2F; 编辑器可见</span><br><span class="line">Class Default Object</span><br><span class="line">-------------</span><br></pre></td></tr></table></figure>

<h1 id="Component-组件"><a href="#Component-组件" class="headerlink" title="Component / 组件"></a>Component / 组件</h1><blockquote>
<p>Ue 借鉴 Unity 的组件式构建对象的方法，通过 UActorComponent 的派生类来组装 Actor 的各项功能.</p>
</blockquote>
<h2 id="SceneComponent-场景组件"><a href="#SceneComponent-场景组件" class="headerlink" title="SceneComponent / 场景组件"></a>SceneComponent / 场景组件</h2><blockquote>
<p>Transform 变换仅存放于该组件中.</p>
<p>仅 SceneComponent 的组件之间可相互嵌套.</p>
<p><code>注意:</code></p>
<ol>
<li>AActor::AttachToComponent(…)，通过子组件完成组件父子层级的搭建.</li>
<li>一个 Actor 可能包含多个 SceneComponent 组件，需要通过参数指定具体应附加到哪一个插槽，跟随父 Actor 哪一个 SceneComponent 的变换，其本身变换通过在 Location,Roator,Scale上应用 Rule 来计算.</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class USceneComponent -&gt; UActorComponent</span><br><span class="line">-------------</span><br><span class="line">USceneComponent* AttachParent;</span><br><span class="line">TArray&lt;USceneComponent*&gt; AttachChildren;</span><br><span class="line">FTransform ComponentToWorld; &#x2F; 变换</span><br><span class="line">-------------</span><br></pre></td></tr></table></figure>

<h2 id="ActorComponent-Actor-组件"><a href="#ActorComponent-Actor-组件" class="headerlink" title="ActorComponent / Actor 组件"></a>ActorComponent / Actor 组件</h2><blockquote>
<p>ActorComponent 仅仅能附加于 Actor 对象下，不能够相互嵌套.</p>
<p><code>注意 : </code></p>
<ol>
<li>Ue 更推崇使组件功能单一，不希望出现大管家之类的组件.</li>
<li>Ue 仍不希望游戏逻辑代码出现在组件中，而 Unity 的脚本作组件挂载.</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class UActorComponent -&gt; UObject</span><br><span class="line">-------------</span><br><span class="line">void ReceiveTick(float DeltaSeconds); &#x2F; 组件 Tick&#x2F;心跳</span><br><span class="line">-------------</span><br><span class="line">AActor* OwnerPrivate; &#x2F; 唯一挂载的 Actor</span><br><span class="line">UWorld* WorldPrivate; &#x2F; 所处的 World</span><br></pre></td></tr></table></figure>

<h2 id="Actor-and-Component-关系"><a href="#Actor-and-Component-关系" class="headerlink" title="Actor and Component / 关系"></a>Actor and Component / 关系</h2><blockquote>
<p>TSet&lt;UActorComponent*&gt; OwnedComponents，Actor 通过集合保存着其在游戏 当前Level 下拥有的所有组件，其中一个组件作 RootComponent，一般为 SceneComponent.</p>
<p>TArray&lt;UActorComponent*&gt; InstanceComponents ，Actor 通过 TArray 保存着所有的实例化组件(创建蓝图类时定义的组件).</p>
</blockquote>
<h1 id="Actor"><a href="#Actor" class="headerlink" title="Actor"></a>Actor</h1><blockquote>
<p>Replication / 网络复制，Spwan / 创建销毁，Tick / 心跳.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class AActor -&gt; UObject</span><br><span class="line">-------------</span><br><span class="line">TArray&lt;AActor*&gt; Children; &#x2F; 父子嵌套</span><br><span class="line">void Tick(float DeltaSeconds); &#x2F; Tick 心跳</span><br><span class="line">-------------</span><br><span class="line">AActor* Owner;</span><br></pre></td></tr></table></figure>

<h2 id="Actor-Hierarchy-层级"><a href="#Actor-Hierarchy-层级" class="headerlink" title="Actor Hierarchy / 层级"></a>Actor Hierarchy / 层级</h2><blockquote>
<p>TArray&lt;AActor*&gt; Children，Actor 中存放了子 Actors 的数组.</p>
<p><code>注意:</code></p>
<ol>
<li>AActor::AttachToActor()，通过子 Actor 完成 Actor 父子关系的搭建.</li>
</ol>
</blockquote>
<h2 id="Tranform-变换"><a href="#Tranform-变换" class="headerlink" title="Tranform / 变换"></a>Tranform / 变换</h2><blockquote>
<p>在 Unity 中通过带 transform/变换 的 GameObject 来代表游戏中的对象.</p>
<p>Ue 中的 Actor 不仅仅是3D游戏对象的表述，而还可代表整个世界的运行规则等种种元素，其变换属性封装在 SceneComponent 中，即使是 Actor 的 GetActorLocation,SetActorLocation 等操作 transform 的方法，最终都是转发到 SceneComponent 下执行的.</p>
</blockquote>
<h1 id="Pawn-“MVC-V”"><a href="#Pawn-“MVC-V”" class="headerlink" title="Pawn “MVC - V”"></a>Pawn “MVC - V”</h1><blockquote>
<p>Pawn 强调可被控制的概念，提供了 可被 Controller 控制的接口，由于 Ue 做 Fps 起家，因此还给 Pawn 提供了物理碰撞，基本移动的接口.</p>
<p><code>注意:</code></p>
<ol>
<li>Pawn 仅表述了能走，但是怎么走由 Controller 控制，提线木偶的关系.</li>
<li>Actor 有 InputComponent，但不用于移动逻辑控制，仅用于响应输入，低阶逻辑控制由 Pawn 实现，更高级的由 Controller 实现.</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class APawn -&gt; AActor</span><br><span class="line">-------------</span><br><span class="line">TSubclassOf&lt;AController&gt; AIControllerClass;</span><br><span class="line">uint32 bInputEnabled;1;</span><br><span class="line">FVector ControlInputVector;</span><br><span class="line">-------------</span><br><span class="line">APlayerState* PlayerState;</span><br><span class="line">AController* Controller;</span><br></pre></td></tr></table></figure>

<h2 id="ADefaultPawn"><a href="#ADefaultPawn" class="headerlink" title="ADefaultPawn"></a>ADefaultPawn</h2><blockquote>
<p>携带基本逻辑控制能力的 Pawn.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class ADefaultPawn -&gt; APawn -&gt; AActor</span><br><span class="line">-------------</span><br><span class="line">USphereComponent* CollisionComponent; &#x2F; Pawn 物理碰撞</span><br><span class="line">UPawnMovementComponent* MovementComponent; &#x2F;Pawn 基本移动</span><br><span class="line">StaticMeshComponent* Mesh; &#x2F; Pawn显示</span><br><span class="line">-------------</span><br></pre></td></tr></table></figure>

<h2 id="ASpectatorPawn"><a href="#ASpectatorPawn" class="headerlink" title="ASpectatorPawn"></a>ASpectatorPawn</h2><blockquote>
<p>观战玩家也处于地图中，但无需表示，只需提供摄像机的控制能力.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class ASpectatorPawn -&gt; ADefaultPawn -&gt; APawn -&gt; AActor</span><br><span class="line">-------------</span><br><span class="line">USpectatorPawnMovement* MovementComponent; &#x2F; 无重力漫游</span><br><span class="line">-------------</span><br></pre></td></tr></table></figure>

<h2 id="ACharacter"><a href="#ACharacter" class="headerlink" title="ACharacter"></a>ACharacter</h2><blockquote>
<p>角色移动特化.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class ACharacter -&gt; APawn -&gt; AActor</span><br><span class="line">-------------</span><br><span class="line">USkeletalMeshComponent* Mesh; &#x2F; 骨架网格体</span><br><span class="line">CharacterMovementComponent* CharacterMovement; &#x2F; 角色特性移动组件</span><br><span class="line">CapsuleComponent*  CapsuleComponent; &#x2F; 胶囊体组件</span><br><span class="line">-------------</span><br></pre></td></tr></table></figure>

<h1 id="Level-关卡"><a href="#Level-关卡" class="headerlink" title="Level / 关卡"></a>Level / 关卡</h1><blockquote>
<p>Level 相当于 Actors 的容器.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class ULevel -&gt; UObject</span><br><span class="line">-------------</span><br><span class="line">TArray&lt;AActor*&gt; Actors; &#x2F; Level 下的所有 Actors</span><br><span class="line">ALevelScriptActor* LevelScriptActor; &#x2F; 关卡蓝图</span><br><span class="line">TArray&lt;UModelComponent*&gt; ModelComponents; &#x2F; Level 下的基元 BSP Geometry</span><br><span class="line">-------------</span><br><span class="line">AWorldSettings* WorldSettings(Actors[0]);</span><br></pre></td></tr></table></figure>

<h1 id="World-世界"><a href="#World-世界" class="headerlink" title="World / 世界"></a>World / 世界</h1><blockquote>
<p>对所有 Levels 的组装.</p>
<p><code>注意:</code></p>
<ol>
<li>可以以 SubLevel 方式进行组装，也可以以 WorldComposition 方式进行组装.</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class UWorld -&gt; UObject</span><br><span class="line">-------------</span><br><span class="line">TArray&lt;ULevel*&gt; Levels; &#x2F; World 下的所有 Levels</span><br><span class="line">AGameMode* AuthorityGameMode; &#x2F; 游戏模式</span><br><span class="line">AGameState* GameState; &#x2F; 游戏状态</span><br><span class="line">UWorldComposition* WorldComposition; &#x2F; Levels 组合</span><br><span class="line">FPhysScene* PhysicsScene; &#x2F; 各 Level 共享的全局物理</span><br><span class="line">-------------</span><br><span class="line">ULevel* PersistentLevel; &#x2F; 主关卡</span><br><span class="line">ULevel* CurrentLevel; &#x2F; 当前关卡</span><br><span class="line">TArray&lt;ULevelStreaming*&gt; StreamingLevels; &#x2F; 动态关卡流</span><br><span class="line">UGameInstance* OwningGameInstance; &#x2F; World 拥有的 GameInstance</span><br><span class="line">TArray&lt;TAutoWeakObjectPtr&lt;AController&gt;&gt; ControllerList;</span><br><span class="line">TArray&lt;TAutoWeakObjectPtr&lt;APlayerController&gt;&gt; PlayerControllerList;</span><br><span class="line">TArray&lt;TAutoWeakObjectPtr&lt;APawn&gt;&gt; PawnList;</span><br></pre></td></tr></table></figure>

<h2 id="PersistentLevel-主关卡"><a href="#PersistentLevel-主关卡" class="headerlink" title="PersistentLevel / 主关卡"></a>PersistentLevel / 主关卡</h2><blockquote>
<p>即 World 初始加载的默认关卡，每个关卡均有独立的 WorldSettings，而在 World 范围内起作用的配置项需要以 PersistentLevel / 主关卡 为主.</p>
</blockquote>
<h2 id="EWorldType-World-类型"><a href="#EWorldType-World-类型" class="headerlink" title="EWorldType / World 类型"></a>EWorldType / World 类型</h2><blockquote>
<p>World 不仅仅只有一种类型，一个世界也不仅仅只有一个World.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">namespace EWorldType</span><br><span class="line">&#123;</span><br><span class="line">	enum Type</span><br><span class="line">	&#123;</span><br><span class="line">		None,		&#x2F;&#x2F; An untyped world, in most cases this will be the vestigial worlds of streamed in sub-levels</span><br><span class="line">		Game,		&#x2F;&#x2F; The game world</span><br><span class="line">		Editor,		&#x2F;&#x2F; A world being edited in the editor</span><br><span class="line">		PIE,		&#x2F;&#x2F; A Play In Editor world</span><br><span class="line">		Preview,	&#x2F;&#x2F; A preview world for an editor tool</span><br><span class="line">		Inactive	&#x2F;&#x2F; An editor world that was loaded but not currently being edited in the level editor</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="GameInstance-Game-始末"><a href="#GameInstance-Game-始末" class="headerlink" title="GameInstance - Game 始末"></a>GameInstance - Game 始末</h1><blockquote>
<p>保存当前 World 的 WorldContext，以及其他整个游戏的信息.</p>
<p><code>注意:</code></p>
<ol>
<li>全局的唯一实例，代表着整个游戏的开始与结束.</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UGameInstance| -&gt; UClass | ◇-&gt; FWorldContext</span><br><span class="line">-------------</span><br><span class="line">ULocalPlayer* CreateLocalPlayer(...); &#x2F; 创建 Player</span><br><span class="line">AGameModeBase* CreateGameModeForURL(...); &#x2F; GameMode 的重载修改</span><br><span class="line">-------------</span><br><span class="line">FWorldContext* WorldContext;</span><br><span class="line">TArray&lt;ULocalPlayer*&gt; LocalPlayers; &#x2F; 管理本地 Player</span><br><span class="line">UOnlineSession* OnlineSession; &#x2F; 网络会话管理</span><br></pre></td></tr></table></figure>

<h1 id="Engine"><a href="#Engine" class="headerlink" title="Engine"></a>Engine</h1><blockquote>
<p>GEngine，源码开始的地方，其引用一个 UEngine.</p>
<p><code>注意:</code></p>
<ol>
<li>World 与 Level 的切换的实际发生地是 Engine.</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class UEngine</span><br><span class="line">-------------</span><br><span class="line">TIndirectArray&lt;FWorldContext&gt; WorldList; &#x2F; 所有 World</span><br><span class="line">-------------</span><br></pre></td></tr></table></figure>

<h2 id="UGameEngine"><a href="#UGameEngine" class="headerlink" title="UGameEngine"></a>UGameEngine</h2><blockquote>
<p>一般 GameEngine 下只有一个 WorldContext，直接通过 GameInstance 引用.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class UGameEngine -&gt; UEngine</span><br><span class="line">-------------</span><br><span class="line">UGameInstance* GameInstance;</span><br><span class="line">-------------</span><br></pre></td></tr></table></figure>



<h2 id="UEditorEngine"><a href="#UEditorEngine" class="headerlink" title="UEditorEngine"></a>UEditorEngine</h2><blockquote>
<p>一般有两个 WorldContext，一个用于 EditorWorld，一个用于 PlayWorld / PIE World，通过 WorldContext 下的 GameInstance 间接引用.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class UGameEngine -&gt; UEngine</span><br><span class="line">-------------</span><br><span class="line">UWorld* PlayWorld;</span><br><span class="line">UWorld* EditorWorld;</span><br><span class="line">TArray&lt;FEditorViewportClient*&gt; AllViewportClients;</span><br><span class="line">-------------</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="——-逻辑控制-逻辑——"><a href="#——-逻辑控制-逻辑——" class="headerlink" title="——-逻辑控制 - 逻辑——-"></a>——-逻辑控制 - 逻辑——-</h1><h1 id="WorldContext"><a href="#WorldContext" class="headerlink" title="WorldContext"></a>WorldContext</h1><blockquote>
<p>用于管理跟踪 World 的管理类.</p>
<p>可以保存切换 World 的过程信息，与目标 World 的上下文信息.</p>
<p>还保存着 World 下 Level 切换的上下文信息.</p>
<p><code>注意:</code></p>
<ol>
<li>WorldContext 可以管理 World 的更替，但是不应由外部直接操作，Ue内部负责.</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class FWorldContext ◇-&gt; UWorld</span><br><span class="line">-------------</span><br><span class="line">UGameInstance* OwningGameInstance; &#x2F; 向上的指针，获取所属的 GameInstance </span><br><span class="line">UWorld* ThisCurrentWorld; &#x2F; 当前 World 类型</span><br><span class="line">UGameViewportClient* GameViewport; &#x2F; 相机相关</span><br><span class="line">-------------</span><br><span class="line">FString TravelURL; &#x2F; 切换的下一目标 Level</span><br><span class="line">uint8 TravelType; &#x2F; 切换的下一目标 Level 类型</span><br></pre></td></tr></table></figure>

<h2 id="Level-Traveling-关卡切换"><a href="#Level-Traveling-关卡切换" class="headerlink" title="Level Traveling / 关卡切换"></a>Level Traveling / 关卡切换</h2><blockquote>
<p>OpenLevel : </p>
<p>先设置当前 World 的 WorldContext 中的 TravelURL，然后在 UEngine::TickWorldTravel 中判断 TravelURL 是否非空来真正执行 Level 的切换.</p>
<p><code>注意:</code></p>
<ol>
<li>关卡切换的信息不存放于 World 中，虽然 LoadStreamLevel 在切换时可以存放于 World 中，但是 World 的 PersistentLevel 在切换时，会将当前 World 释放.</li>
</ol>
</blockquote>
<h1 id="GameMode-游戏模式"><a href="#GameMode-游戏模式" class="headerlink" title="GameMode / 游戏模式"></a>GameMode / 游戏模式</h1><blockquote>
<p>World 下的唯一逻辑操纵者.</p>
<p>一个 World 下只会有一个 GameMode  实例，即PersistentLevel 下的 GameMode.  </p>
<p><code>注意:</code></p>
<ol>
<li>每个 Level 下也存着独立的 GameMode 实例.</li>
<li>World 下的 GameMode，将通过 Wolrd 的 PersistentLevel 的 AWorldSettings 上的配置生成.</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class AGameMode -&gt; AInfo -&gt; AActor</span><br><span class="line">-------------</span><br><span class="line">void InitGame(...); &#x2F; 初始化游戏</span><br><span class="line">void SetMatchState(...; &#x2F; 设置游戏运行状态</span><br><span class="line">-------------</span><br><span class="line">FName MatchState; &#x2F; 游戏运行状态</span><br><span class="line">AGameSession* GameSession; &#x2F; 游戏会话用于网络联机</span><br><span class="line">AGameState* GameState; &#x2F; 存储游戏状态</span><br><span class="line">uint32 bUseSeamlessTravel ：1; &#x2F; 启用无缝切换</span><br></pre></td></tr></table></figure>

<h2 id="Responsibility-职责"><a href="#Responsibility-职责" class="headerlink" title="Responsibility / 职责"></a>Responsibility / 职责</h2><ol>
<li><p>Class 登记</p>
<blockquote>
<p>记录基本的游戏类型信息，用于在需要时通过 UClass 反射可以自动 Spawn 出对象并添加至关卡中. </p>
</blockquote>
</li>
<li><p>控制游戏内实体的 Spawn</p>
<blockquote>
<p>包括 玩家，AI 的加载与释放，生成的位置，所处的状态，数目等等.</p>
</blockquote>
</li>
<li><p>Level 的无缝切换</p>
<blockquote>
<p>AGameModeBase::bUseSeamlessTravel = true 后可以实现无缝切换.</p>
<ol>
<li>标记出要在过渡关卡中存留的 Actors</li>
<li>转移至过渡关卡</li>
<li>标记出要在最终关卡中存留的 Actors</li>
<li>转移至最终关卡</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>为避免同时加载两个大地图，则需要引入很小的过渡关卡作中转，减少转换时的资源损耗.</li>
<li>若为设置过渡关卡，则默认创建一个空关卡.</li>
</ol>
</blockquote>
</li>
<li><p>多人游戏的同步</p>
<blockquote>
<p>标识整个游戏运行的状态.</p>
</blockquote>
</li>
</ol>
<h2 id="Travelling-GameMode-模式切换"><a href="#Travelling-GameMode-模式切换" class="headerlink" title="Travelling GameMode / 模式切换"></a>Travelling GameMode / 模式切换</h2><blockquote>
<p>在关卡切换时，World 下的 GameMode 也会发生变换.</p>
</blockquote>
<ul>
<li><p>非无缝切换</p>
<blockquote>
<p>AGameModeBase::bUseSeamlessTravel = false.</p>
<p>新的 World 加载时，当前的 GameMode 将被释放，根据新 World 的配置生成新的 GameMode.</p>
</blockquote>
</li>
<li><p>无缝切换</p>
<blockquote>
<p>AGameModeBase::bUseSeamlessTravel = true.</p>
<p>CurrentWorld -&gt; TransitionWorld : GameMode 也将被迁移，即 TransitionWorld 下保存着 CurrentWorld 的 GameMode.</p>
<p>TransitionWorld -&gt; NewWorld : 根据配置重新生成一个 GameMode.</p>
</blockquote>
</li>
</ul>
<h2 id="GameMode-and-LevelScriptActor"><a href="#GameMode-and-LevelScriptActor" class="headerlink" title="GameMode and LevelScriptActor"></a>GameMode and LevelScriptActor</h2><blockquote>
<p>GameMode 更注重整个 World 下，所有 Levels 的通用规则与逻辑，如胜利条件，怪物刷新等.</p>
<p>LevelScriptActor 更注重具体 Level 下表现行为.</p>
<p>GameMode 只在 Sever 中存在(单机游戏也是 Server)，因此对于 Client 的状态与逻辑，GameMode 无法控制，需要通过客户端具体关卡的 LevelScriptActor / 关卡蓝图 中的逻辑控制.</p>
</blockquote>
<h1 id="LevelScriptActor-关卡蓝图"><a href="#LevelScriptActor-关卡蓝图" class="headerlink" title="LevelScriptActor / 关卡蓝图"></a>LevelScriptActor / 关卡蓝图</h1><blockquote>
<p>关卡蓝图可包含此关卡下的一些运行规则，提供编写脚本的功能.</p>
<p><code>注意:</code></p>
<ol>
<li>Ue 不希望在 LevelScriptActor / 关卡蓝图 中出现太多逻辑代码.</li>
<li>LevelScriptActor 派生于 AActor，具备挂载组件的功能，但是不允许你挂载组件.</li>
</ol>
</blockquote>
<h1 id="Controller-“MVC-C”"><a href="#Controller-“MVC-C”" class="headerlink" title="Controller “MVC - C”"></a>Controller “MVC - C”</h1><blockquote>
<p>控制玩家Pawn的核心逻辑.</p>
<p><code>注意:</code></p>
<ol>
<li>Controller 不能够嵌套控制，即不应存在父子嵌套层级.</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class AController -&gt; AActor</span><br><span class="line">-------------</span><br><span class="line">void Possess(APawn* InPawn); &#x2F; 动态选择控制的 Pawn 实例</span><br><span class="line">void UnPossess(); &#x2F; 动态注销控制的 Pawn 实例</span><br><span class="line">void ChangeState(fName NewState); &#x2F; 改变 Controller 状态</span><br><span class="line">void InitPlayerState(); &#x2F; 保存玩家数据</span><br><span class="line">-------------</span><br><span class="line">APlayerState* PlayerState;</span><br><span class="line">uint32 bAttachToPawn;1; &#x2F; 附加到 Pawn</span><br><span class="line">APawn* Pawn;</span><br><span class="line">ACharacter* Character;</span><br><span class="line">USceneComponent* TransformComponent; &#x2F; 支持移动</span><br><span class="line">FRotator ControlRotation; &#x2F; 支持移动</span><br><span class="line">Fname StateName;</span><br></pre></td></tr></table></figure>

<h2 id="Responsibility-职责-1"><a href="#Responsibility-职责-1" class="headerlink" title="Responsibility / 职责"></a>Responsibility / 职责</h2><ul>
<li><p>关联并控制玩家Pawn</p>
<blockquote>
<p><code>注意:</code></p>
<ol>
<li>不能一个 Controller 同时控制多个 Pawn，只能运行时动态切换 Controller 与 Pawn 的1:1关联，因此即时策略类的游戏不太适合该框架，其需要同时控制多个玩家.</li>
</ol>
</blockquote>
</li>
<li><p>自身具备Spawn的能力</p>
<blockquote>
<p>由更高的逻辑控制层控制 Controller 的 Spawn.</p>
</blockquote>
</li>
<li><p>控制 Pawn 的 Spawn</p>
</li>
<li><p>保存数据状态</p>
</li>
<li><p>在世界中具备位置信息</p>
<blockquote>
<p>挂载 SceneComponent 组件.</p>
<p>Controller 具有位置信息的意义在于基于其本身的位置信息，可以更高的控制 Pawn 的位置与移动.</p>
<p><code>注意:</code></p>
<ol>
<li>但是 Controller 自身的位置信息不会自动更新，若需要自动更新，则需要设置 bAttachToPawn 为 true，将 Controller 附加到 Pawn 上，使其跟随 Pawn 的移动.</li>
</ol>
</blockquote>
</li>
<li><p>同步</p>
</li>
</ul>
<h2 id="APlayerController"><a href="#APlayerController" class="headerlink" title="APlayerController"></a>APlayerController</h2><blockquote>
<p>作为玩家控制的实体，具有与玩家相关的操作接口.</p>
<p>主要负责相机管理，输入逻辑控制，关联UPlayer，显示HUD，Voice语音，Level切换等职责.</p>
<p><code>注意:</code></p>
<ol>
<li>APlayerController 可以被替换，一般不同的关卡玩家会关联不同的 APlayerController，来实现不同的控制方式.</li>
<li>UPlayer : APlayerController : APawn : APlayerState = 1:1:1:1;可切换.</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class APlayerController -&gt; AController -&gt; AActor</span><br><span class="line">-------------</span><br><span class="line">void SetPlayer(Uplayer* InPlayer); &#x2F; 设置所控制的玩家</span><br><span class="line">-------------</span><br><span class="line">UPlayer* Player; &#x2F; 关联 Player</span><br><span class="line">AHUD* MyHUD; &#x2F; HUD显示</span><br><span class="line">APlayerCameraManager* PlayerCameraManager; &#x2F; 控制玩家视角</span><br><span class="line">UPlayerInput* PlayerInput; &#x2F; 输入处理</span><br><span class="line">APawn* AcknowledgedPawn;</span><br><span class="line">ASpectatorPawn* SpectatorPawn;</span><br></pre></td></tr></table></figure>



<h2 id="AAIController"><a href="#AAIController" class="headerlink" title="AAIController"></a>AAIController</h2><blockquote>
<p>AI 也可以算作一个 Player，只是无需接受玩家的控制，AAIController 为 AI 的控制实体.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class AAIController -&gt; AController -&gt; AActor</span><br><span class="line">-------------</span><br><span class="line">...</span><br><span class="line">剔除了APlayerController的基本组件，但新增了一些AI组件</span><br><span class="line">-------------</span><br></pre></td></tr></table></figure>

<h1 id="——-数据存储-数据——"><a href="#——-数据存储-数据——" class="headerlink" title="——-数据存储 - 数据——-"></a>——-数据存储 - 数据——-</h1><h1 id="SaveGame-游戏存档"><a href="#SaveGame-游戏存档" class="headerlink" title="SaveGame / 游戏存档"></a>SaveGame / 游戏存档</h1><blockquote>
<p>玩家存档.</p>
<p><code>注意:</code></p>
<ol>
<li>SaveGame 可以看作是一个全局持久的 数据 + 数据业务逻辑 类.</li>
<li>GameInstance 存临时数据，而 SaveGame 存持久性数据.</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class USaveGame -&gt; UObject</span><br></pre></td></tr></table></figure>

<h1 id="GameState-World-配置"><a href="#GameState-World-配置" class="headerlink" title="GameState / World 配置"></a>GameState / World 配置</h1><blockquote>
<p>保存游戏的状态数据，包含整个游戏的状态数据以及所有的 PlayerState.</p>
<p><code>注意:</code></p>
<ol>
<li>GameState 在客户端存在，GameMode 下的状态数据可通过 GameState 传递.</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class AGameState -&gt; AInfo -&gt; AActor</span><br><span class="line">-------------</span><br><span class="line">void SetMatchState(...); &#x2F; 同步游戏运行状态</span><br><span class="line">void AddPlayerState(...); &#x2F; 管理 World 下的 PlayerState</span><br><span class="line">-------------</span><br><span class="line">Fname MatchState;</span><br><span class="line">TArray&lt;class APlayerState*&gt; PlayerArray;</span><br></pre></td></tr></table></figure>

<h2 id="GameSession-游戏会话"><a href="#GameSession-游戏会话" class="headerlink" title="GameSession / 游戏会话"></a>GameSession / 游戏会话</h2><blockquote>
<p>针对网络 Session 的一个方便管理的类.</p>
</blockquote>
<h1 id="WorldSettings-关卡配置"><a href="#WorldSettings-关卡配置" class="headerlink" title="WorldSettings / 关卡配置"></a>WorldSettings / 关卡配置</h1><blockquote>
<p>存放着与关联 Level 相关的设置.</p>
<p><code>注意:</code></p>
<ol>
<li>若 WorldSettings 关联的 Level 为 World 的 PersistentLevel，则该 WorldSettings 将作为整个 World 的 WorldSettings.</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class AWorldSettings -&gt; AInfo -&gt; AActor</span><br><span class="line">-------------</span><br><span class="line">TSubclassOf&lt;class AGameMode&gt; DefaultGameMode; &#x2F; 用于生成所处 World 下的 GameMode</span><br><span class="line">-------------</span><br><span class="line">Other settings; &#x2F; 其他关卡下的设置</span><br></pre></td></tr></table></figure>

<h1 id="APlayerState-玩家配置”MVC-M”"><a href="#APlayerState-玩家配置”MVC-M”" class="headerlink" title="APlayerState / 玩家配置”MVC - M”"></a>APlayerState / 玩家配置”MVC - M”</h1><blockquote>
<p>存放关卡范围内的玩家的游玩数据.</p>
<p><code>注意:</code></p>
<ol>
<li>跨关卡的统计数据(SaveGame)，关卡内 Controller 的临时数据，关卡内的其他数据(GameState)，不应该由 APlayerState 保存.</li>
<li>APlayerState 只为真实的玩家 Player 存在，NPC可读取对应的 APlayerState 作决策，但自身不存在 APlayerState.</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class APlayerState -&gt; AInfo -&gt; AActor</span><br><span class="line">-------------</span><br><span class="line">float Score;</span><br><span class="line">int32 PlayerId;</span><br><span class="line">-------------</span><br></pre></td></tr></table></figure>

<h1 id="——-玩家接入——"><a href="#——-玩家接入——" class="headerlink" title="——-玩家接入——-"></a>——-玩家接入——-</h1><h1 id="Player-玩家接入点"><a href="#Player-玩家接入点" class="headerlink" title="Player - 玩家接入点"></a>Player - 玩家接入点</h1><blockquote>
<p>Ue 中 Player 是广泛的概念，本地玩家可以是 Player，联机时的网络连接也可以是 Player.</p>
<p><code>注意:</code></p>
<ol>
<li>Player 是比 World 更高一级的存在.</li>
<li>Ue 并不推荐直接在 Player 中编程，而是将其作为源头，作为玩家接入 World 的起点，构建 GamePlay 机制.</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class UPlayer -&gt; UObject</span><br><span class="line">-------------</span><br><span class="line">void SwitchController(APlayerController* PC);</span><br><span class="line">-------------</span><br><span class="line">APlayerController* PlayerController;</span><br><span class="line">int32 CurrentNetSpeed;</span><br></pre></td></tr></table></figure>

<h2 id="ULocalPlayer"><a href="#ULocalPlayer" class="headerlink" title="ULocalPlayer"></a>ULocalPlayer</h2><blockquote>
<p>本地玩家.</p>
<p>玩家对象的上层就是引擎，GameInstance 中保存着 LocalPlayer 列表.</p>
<p><code>注意:</code></p>
<ol>
<li>LocalPlayer 是 PlayerController 产生的源头.</li>
<li>GamePlay 框架下不写相关逻辑，拓展后可写玩家的相关逻辑.</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class ULocalPlayer -&gt; UPlayer -&gt; UObject</span><br><span class="line">-------------</span><br><span class="line">UWorld* GetWorld();</span><br><span class="line">bool SpawnPlayActor(...); &#x2F; 生成 PlayerController</span><br><span class="line">UGameInstance* GetGameInstance() const;</span><br><span class="line">-------------</span><br><span class="line">UGameViewportClient* ViewportClient;</span><br></pre></td></tr></table></figure>



<h2 id="UNetConnection"><a href="#UNetConnection" class="headerlink" title="UNetConnection"></a>UNetConnection</h2><blockquote>
<p>Ue 中一个网络连接也是一个 Player，可提供输入信号的都可以当做 Player.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class UNetConnection -&gt; UPlayer -&gt; UObject</span><br></pre></td></tr></table></figure>

<p>**Questions : **</p>
<ul>
<li><del>PlayerState : Player = 1:1 ？</del></li>
<li><del>整个框架的上下级管理关系需要梳理出来</del></li>
<li><del>BSP 基元组件 与 网格体组件关系？</del></li>
<li><del>PersistentLevel 与 CurrentLevel 有什么关系？</del></li>
<li><del>Level 下会有自己的 GameMode？？</del></li>
<li><del>对 World 的概念不是很理解</del></li>
<li><del>OpenLevel 是用于切换 Level ？还是 World ？</del></li>
<li><del>UGameViewportClient？？？</del></li>
<li><del>硬编码？</del></li>
<li>RPC调用？？</li>
</ul>
]]></content>
      <categories>
        <category>YumiGame</category>
      </categories>
      <tags>
        <tag>GamePlay</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity - 编程进阶</title>
    <url>/2022/03/22/Unity/Unity_%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Some-Keys-for-Programming-关键点"><a href="#Some-Keys-for-Programming-关键点" class="headerlink" title="Some Keys for Programming / 关键点"></a>Some Keys for Programming / 关键点</h1><hr>
<h1 id="The-Current-Progress-当前进度"><a href="#The-Current-Progress-当前进度" class="headerlink" title="The Current Progress / 当前进度"></a>The Current Progress / 当前进度</h1><ul>
<li>Unity初级编程 - 中级编程 / ing</li>
<li>动画系统demo实践 完成模型导入-&gt; 动画绑定 -&gt; 状态机组织动画</li>
<li>工具 fbx -&gt; motiondate -&gt; 中间数据</li>
<li>ue4状态机 + AI + 行为树</li>
<li>着手AIAnimation框架，着手动画系统的改写</li>
</ul>
<hr>
<h1 id="ForeachLoop-循环"><a href="#ForeachLoop-循环" class="headerlink" title="ForeachLoop / 循环"></a>ForeachLoop / 循环</h1><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ForeachLoop</span> : <span class="title">MonoBehaviour</span> </span><br><span class="line">&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span> (<span class="params"></span>) </span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="built_in">string</span>[] strings = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">3</span>];</span><br><span class="line">        </span><br><span class="line">        strings[<span class="number">0</span>] = <span class="string">&quot;First string&quot;</span>;</span><br><span class="line">        strings[<span class="number">1</span>] = <span class="string">&quot;Second string&quot;</span>;</span><br><span class="line">        strings[<span class="number">2</span>] = <span class="string">&quot;Third string&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">foreach</span>(<span class="built_in">string</span> item <span class="keyword">in</span> strings)</span><br><span class="line">        &#123;</span><br><span class="line">            print (item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Awake-and-Start-初始化方法"><a href="#Awake-and-Start-初始化方法" class="headerlink" title="Awake and Start / 初始化方法"></a>Awake and Start / 初始化方法</h1><blockquote>
<p>执行前提 : 必须将含该方法的脚本作为组件附加至游戏对象上，否则不会执行</p>
</blockquote>
<ul>
<li><p>Awake : 在加载场景时执行且仅执行一次，若该脚本组件已附加但是未被激活，仍将执行</p>
</li>
<li><p>Start : 在第一帧更新之前执行且仅执行一次，已附加的组件必须为激活态才会执行</p>
</li>
</ul>
<h1 id="FixUpdate-and-Update-更新方法"><a href="#FixUpdate-and-Update-更新方法" class="headerlink" title="FixUpdate and Update / 更新方法"></a>FixUpdate and Update / 更新方法</h1><ul>
<li>FixUpdate : 以固定时间间隔调用，每调用一次均完成一次物理计算，因此物理运动需要在此更新</li>
<li>Update : 下一帧执行前调用，但各帧的时间间隔不一，因此时间间隔不固定，一些简单非物理运动等可以在此更新</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">IUpdate</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FixedUpdate</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        print(<span class="string">&quot;FixedUpdate deltaTime : &quot;</span> + Time.deltaTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        print(<span class="string">&quot;Update deltaTime : &quot;</span> + Time.deltaTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Enabling-and-Disabling-Components-启用禁用组件"><a href="#Enabling-and-Disabling-Components-启用禁用组件" class="headerlink" title="Enabling and Disabling Components / 启用禁用组件"></a>Enabling and Disabling Components / 启用禁用组件</h1><ul>
<li><code>ComponentName.enabled</code>属性来启用或禁用组件</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Enabled</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        render = GetComponent&lt;MeshRenderer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyUp(KeyCode.Space)) &#123;</span><br><span class="line">            render.enabled = !render.enabled;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> MeshRenderer render;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Activating-GameObjects-激活游戏对象"><a href="#Activating-GameObjects-激活游戏对象" class="headerlink" title="Activating GameObjects / 激活游戏对象"></a>Activating GameObjects / 激活游戏对象</h1><ul>
<li>activeInHierarchy - 继承关系下孩子活跃状态的判断，当父对象设置为不活跃时，子对象仍活跃但是于Hierarchy为不活跃，即不会在场景中显示</li>
<li>activeSelf - 判断游戏对象的活跃状态</li>
<li>SetActive - 设置游戏对象的活跃状态</li>
</ul>
<h1 id="Translate-and-Rotate-func-变换与旋转方法"><a href="#Translate-and-Rotate-func-变换与旋转方法" class="headerlink" title="Translate and Rotate func / 变换与旋转方法"></a>Translate and Rotate func / 变换与旋转方法</h1><blockquote>
<p>transform 为 Transform 类的一个实例，可直接使用该实例下的变换方法 (不好意思，暂不深究，先笼统解释下=-=)</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Move</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetKey(KeyCode.UpArrow)) &#123;</span><br><span class="line">            <span class="comment">//给该对象一个向前的速度向量，参数结果仍然为一个Vector3向量</span></span><br><span class="line">            transform.Translate(Vector3.forward * moveSpeed * Time.deltaTime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetKey(KeyCode.LeftArrow))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//类似于给该对象绕up所在的轴一个转速</span></span><br><span class="line">            transform.Rotate(-Vector3.up, turnSpeed * Time.deltaTime);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetKey(KeyCode.RightArrow))</span><br><span class="line">        &#123;</span><br><span class="line">            transform.Rotate(Vector3.up, turnSpeed * Time.deltaTime);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetKey(KeyCode.DownArrow))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//给该对象一个向后的速度向量，参数结果仍然为一个Vector3向量</span></span><br><span class="line">            transform.Translate(-Vector3.forward * moveSpeed * Time.deltaTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> moveSpeed = <span class="number">10f</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> turnSpeed = <span class="number">50f</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Camera-LookAt-朝向"><a href="#Camera-LookAt-朝向" class="headerlink" title="Camera LookAt / 朝向"></a>Camera LookAt / 朝向</h1><blockquote>
<p>transform 实例下提供 LookAt 方法设置所附加对象的朝向，但是仅仅是朝向，不会跟随移动</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Look</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        transform.LookAt(target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Transform target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<hr>
<p>2022/1/5 21:50</p>
<h1 id="Linear-Interpolation-线性插值"><a href="#Linear-Interpolation-线性插值" class="headerlink" title="Linear Interpolation / 线性插值"></a>Linear Interpolation / 线性插值</h1><blockquote>
<p><code>U3D Document : Linearly interpolating is finding a value that is some percentage between two given values.</code></p>
<p>线性插值可以找到两个值之间的某个过渡值，该值在两者之间且满足一定的百分比</p>
<p><code>U3D Document : The third parameter in each case is still a float representing how much to interpolate.</code></p>
<p>第三个 Percentage 用于表示该如何插入</p>
<p><code>注意:</code></p>
<ol>
<li>lerp 函数仅仅是得到两值之间的某插值，注意是得到，若需要使用还需要将该函数返回值作为相应值类型变量进行处理，例如实现光照颜色随时间的平滑过渡，需要使用lerp得到过渡值并将该值赋值给光照颜色属性</li>
</ol>
</blockquote>
<ul>
<li><p>Mathf.Lerp (float From, float To, float Percentage);</p>
<blockquote>
<p>可用于两值之间的线性插值</p>
<p><code>U3D Document : Under some circumstances Lerp functions can be used to smooth a value over time.</code></p>
<p>该func有时还可以用于使某值/属性随时间平滑变化，即将From设置为该值/属性，To设置为期望不断逼近的某值，Percentage设置插入方式，若不想随帧率插入，可将该 Percentage*Time.deltaTime，使其随时间以s为单位平滑变化</p>
</blockquote>
</li>
<li><p>Vector3.Lerp (Vector3 From, Vector3 To, float Percentage);</p>
<blockquote>
<p>可用于两向量之间的线性插值</p>
</blockquote>
</li>
<li><p>Color.Lerp (Color From, Color To, float Percentage);</p>
<blockquote>
<p>可用于两颜色之间的线性插值</p>
</blockquote>
</li>
</ul>
<hr>
<p>**Questions: **</p>
<ul>
<li>Render 与 Renderer ？</li>
<li>GetKeyDown 与 GetKey ？</li>
</ul>
<hr>
<h1 id="Destroy-销毁"><a href="#Destroy-销毁" class="headerlink" title="Destroy / 销毁"></a>Destroy / 销毁</h1><blockquote>
<p><code>U3D Document : The Destory function can be used to remove game objects or components from game objects at run time.</code>s</p>
<p>Destroy 函数可以用于 运行时销毁 场景中的游戏对象或者游戏对象上的某组件，其第二个参数可以设置相应的延时</p>
<p><code>注意: </code></p>
<ol>
<li>销毁游戏对象的同时，其组件也将销毁</li>
<li>脚本可通过 gameObject 直接获取其所附加的游戏对象的引用</li>
</ol>
</blockquote>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DDestory</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//销毁本游戏对象</span></span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Space)) &#123;</span><br><span class="line">            Destroy(gameObject, <span class="number">1f</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//销毁其他游戏对象</span></span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.A))</span><br><span class="line">        &#123;</span><br><span class="line">            Destroy(other, <span class="number">1f</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//销毁组件</span></span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.B))</span><br><span class="line">        &#123;</span><br><span class="line">            Destroy(GetComponent&lt;Renderer&gt;(), <span class="number">1f</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> GameObject other;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="GetButton-和-GetKey-获取输入"><a href="#GetButton-和-GetKey-获取输入" class="headerlink" title="GetButton 和 GetKey / 获取输入"></a>GetButton 和 GetKey / 获取输入</h1><blockquote>
<p>Unity 的输入不预先设置轴映射和操作映射来区别按下与持续按下，而是通过三个函数判断输入状态，返回 true or false</p>
<p>Button 与 Key 的区别在于其使用方式，都可获取输入状态，但是 key 要求参数使用指定按键 KeyCode，而 button 可以通过 InputManager 自定义输入，参数使用 ButtonName 即可</p>
</blockquote>
<ul>
<li><p>GetKeyDown / GetButtonDown</p>
<blockquote>
<p>按下的那帧为true，其余为false</p>
</blockquote>
</li>
<li><p>GetKey / GetButton</p>
<blockquote>
<p>持续按下的所有帧均为true，包括按下那一帧</p>
</blockquote>
</li>
<li><p>GetKeyUp /GetButtonUp</p>
<blockquote>
<p>松开按键的那一帧为true，其余为false</p>
</blockquote>
</li>
</ul>
<h1 id="GetAxis-获取轴"><a href="#GetAxis-获取轴" class="headerlink" title="GetAxis / 获取轴"></a>GetAxis / 获取轴</h1><blockquote>
<p>类似于 GetButton/GetKey，但是其返回值不是 bool 类型而是介于[-1,1]之间的 float 类型，正向驱动轴的按钮按下将使轴趋向于1</p>
<p>即按下该轴绑定的按钮，该轴便会有值，并且能双向驱动，当松开时，该轴的值将恢复0</p>
</blockquote>
<ul>
<li>Gravity : 松开按钮时轴值恢复0的速度</li>
<li>Sensitivity : 按下轴时轴趋向 -1 or 1 的速度</li>
<li>Dead : 使用操作杆时设置，忽视某些细微操作导致的误触，可设置可忽略的范围</li>
<li>Snap : 若勾选，则按下对应反方向的按钮时，轴将重置为0，若未勾选，按下反方向的按钮时轴值从当前值开始变化</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Axis</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="built_in">float</span> axis = Input.GetAxis(<span class="string">&quot;Horizontal&quot;</span>);</span><br><span class="line">        transform.position = <span class="keyword">new</span> Vector3(axis, transform.position.y, transform.position.z);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="OnMouseDown-鼠标点击"><a href="#OnMouseDown-鼠标点击" class="headerlink" title="OnMouseDown / 鼠标点击"></a>OnMouseDown / 鼠标点击</h1><blockquote>
<p>OnMouseDown 函数用于处理于 GUI控件 或者碰撞体上的点击</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MouseClick</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnMouseDown</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        GetComponent&lt;Rigidbody&gt;().AddForce(-transform.forward * <span class="number">500f</span>);</span><br><span class="line">        GetComponent&lt;Rigidbody&gt;().useGravity = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="GetComponent-获取组件"><a href="#GetComponent-获取组件" class="headerlink" title="GetComponent / 获取组件"></a>GetComponent / 获取组件</h1><blockquote>
<p>可通过 GetComponent&lt;Type&gt; 函数获取某游戏对象上的组件并设置其属性</p>
<p><code>注意:</code></p>
<ol>
<li>若组件与获取组件的脚本附加于同一个游戏对象上，则可以直接 GetComponent&lt;Type&gt;</li>
<li>若需要获取的组件附加于其他游戏对象上，则需要先获取对应游戏对象，再通过该游戏对象调用 GetComponent&lt;Type&gt; 方法</li>
<li>GetComponent&lt;Type&gt; 方法很消耗性能，因此一般仅在初始化时调用一次获取组件，而不逐帧调用</li>
</ol>
</blockquote>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UsingOtherComponents</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> GameObject otherGameObject;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AnotherScript anotherScript;</span><br><span class="line">    <span class="keyword">private</span> YetAnotherScript yetAnotherScript;</span><br><span class="line">    <span class="keyword">private</span> BoxCollider boxCol;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        anotherScript = GetComponent&lt;AnotherScript&gt;();</span><br><span class="line">        yetAnotherScript = otherGameObject.GetComponent&lt;YetAnotherScript&gt;();</span><br><span class="line">        boxCol = otherGameObject.GetComponent&lt;BoxCollider&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        boxCol.size = <span class="keyword">new</span> Vector3(<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">        Debug.Log(<span class="string">&quot;The player&#x27;s score is &quot;</span> + anotherScript.playerScore);</span><br><span class="line">        Debug.Log(<span class="string">&quot;The player has died &quot;</span> + yetAnotherScript.numberOfPlayerDeaths + <span class="string">&quot; times&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="DeltaTime-时间增量"><a href="#DeltaTime-时间增量" class="headerlink" title="DeltaTime / 时间增量"></a>DeltaTime / 时间增量</h1><blockquote>
<p><code>U3D Document : The interval in seconds from the last frame to the current one (Read Only).</code></p>
<p>Time.deltaTime 为当前帧与上一帧的间隔时间，以秒/s为单位，只读不可修改 </p>
<p><code>U3D Document : An important thing to remember when handling time-based actions like this is that the game’s framerate is not constant and neither is the length of time between Update function calls.</code></p>
<p>以时间为基准的运动，不能逐帧实现，因为游戏帧率不是恒定的，即每一次 update 调用的时间间隔不是恒定的，逐帧实现的运动将导致运动不均匀</p>
<p><code>U3D Document : The solution is to scale the size of the movement by the frame time which you can read from the Time.deltaTime property.</code></p>
<p>能够使得运动更均匀顺滑的解决方案是通过 Time.deltaTime 属性值来缩放运动距离大小，随着帧率的变化，Time.deltaTime 也将随之变化，因此对象的移动速度将保持不变</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DeltaTime</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        transform.Translate(<span class="number">0</span>, <span class="number">0</span>, speed * Time.deltaTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> speed = <span class="number">0.0000000000005f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="Instantiate-运行时实例化"><a href="#Instantiate-运行时实例化" class="headerlink" title="Instantiate / 运行时实例化"></a>Instantiate / 运行时实例化</h1><blockquote>
<p>以发射器为例，可以完成运行时创建预制件的克隆体</p>
<p><code>注意:</code></p>
<ol>
<li>预制件创建的初始位置一般通过 barried 来设置，barried 为一个空游戏对象用于占位子弹发射位置</li>
<li>子弹的销毁不在if中完成，而是将销毁脚本附加于预制件上</li>
<li>可以使用 Launcher 空游戏对象用于在层级中管理枪支与barried，并将发射脚本置于 Launcher 上</li>
</ol>
</blockquote>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Shoot</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetButtonDown(<span class="string">&quot;Fire1&quot;</span>)) &#123;</span><br><span class="line">            Bullet = Instantiate(Bullet, barried.position, barried.rotation);</span><br><span class="line">            Bullet.AddForce(barried.up * <span class="number">500</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Rigidbody Bullet;</span><br><span class="line">    <span class="keyword">public</span> Transform barried;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Invoke-延时调用"><a href="#Invoke-延时调用" class="headerlink" title="Invoke / 延时调用"></a>Invoke / 延时调用</h1><blockquote>
<p>Invoke 可以完成某个方法的延时调用来完成对延时有要求的函数调用系统</p>
</blockquote>
<ul>
<li><p>Invoke(string FuncName,float DelayTime)</p>
<blockquote>
<p>可以完成 FuncName 的延时调用，以秒/s为单位，DelayTime秒后调用</p>
</blockquote>
</li>
<li><p>InvokeRepeating(string FuncName,float DelayTime,float IntervalTime)</p>
<blockquote>
<p>可以完成 FuncName 的延时调用，以秒/s为单位，DelayTime秒后调用，并且每隔IntervalTime秒重复调用</p>
</blockquote>
</li>
<li><p>CancelInvoke(string FuncName)</p>
<blockquote>
<p>可以关闭对 FuncName 延时重复调用</p>
</blockquote>
</li>
</ul>
<hr>
<p>2022/1/6 15:43</p>
<hr>
<h1 id="Properties-属性"><a href="#Properties-属性" class="headerlink" title="Properties / 属性"></a>Properties / 属性</h1><blockquote>
<p>通过属性访问器来访问成员而不是通过 public 来访问的优势在于</p>
<ol>
<li>可是使该成员 只读/只写，省去相应访问器即可</li>
<li>访问器中可添加一些方法</li>
</ol>
</blockquote>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Player</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//成员变量可以称为字段</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> experience;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Experience 是一个基本属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Experience</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//其他一些代码</span></span><br><span class="line">            <span class="keyword">return</span> experience;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//其他一些代码</span></span><br><span class="line">            experience = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h1 id="Generics-泛型"><a href="#Generics-泛型" class="headerlink" title="Generics / 泛型"></a>Generics / 泛型</h1><blockquote>
<p>where 关键字指定泛型类型约束</p>
</blockquote>
<ul>
<li><p>Generics  Class</p>
<blockquote>
<p>public class ClassName&lt;T&gt; {}</p>
</blockquote>
</li>
<li><p>Generics  Function</p>
<blockquote>
<p>public returnType FuncName&lt;T&gt; () {}</p>
</blockquote>
</li>
<li><p>Generics  Interface</p>
<blockquote>
<p>public interface InterfaceName&lt;T&gt; {}</p>
</blockquote>
</li>
<li><p>Generic Constraint / 泛型约束</p>
<blockquote>
<p>区别于c++，c++仅仅起暗示作用并不会实际约束，而c#会对期望的类型作出约束</p>
</blockquote>
<p>public class ClassName&lt;T&gt; where T : ConstraintList {}</p>
<p>public returnType FuncName&lt;T&gt; ()  where T : ConstraintList {}</p>
<p>public interface InterfaceName&lt;T&gt;  where T : ConstraintList {}</p>
<p>ConstraintList / 约束列表 : </p>
<ol>
<li>Struct T类型必须为值类型</li>
<li>new() T类型必须包含无参的公共构造函数，构造函数约束需要出现在约束列表的最后</li>
<li>class T类型必须为引用类型</li>
<li>ClassName T类型必须为 ClassName 类型或派生自 ClassName 基类类型</li>
<li>InterfaceName T类型必须已实现 InterfaceName 接口</li>
</ol>
</li>
</ul>
<h1 id="Member-Hiding-成员隐藏"><a href="#Member-Hiding-成员隐藏" class="headerlink" title="Member Hiding / 成员隐藏"></a>Member Hiding / 成员隐藏</h1><blockquote>
<p>在进行上转型时，为了能够调用父类的方法或属性，因此将子类的同名方法或属性前加 new 关键字进行隐藏，正常通过子类引用调用时并无影响，但是在上转型时，将隐藏子类的成员，而调用父类的成员</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Fasther</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> para = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SayHello</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;Hello! Father!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Childern</span> : <span class="title">Fasther</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SayHello</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;Hello! Children!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Inheritated</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Fasther father = <span class="keyword">new</span> Childern();</span><br><span class="line">        father.SayHello();</span><br><span class="line"></span><br><span class="line">        Childern children = <span class="keyword">new</span> Childern();</span><br><span class="line">        children.SayHello();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>Questions:</strong></p>
<ol>
<li>new 关键字隐藏的意义是什么？没有new在上转型时，不仍然会调用父类的方法吗，为何需要new呢？</li>
<li>virtual 需要搭配 override ，只有其中一个将表示什么意思</li>
</ol>
<hr>
<h1 id="Overriding-重写"><a href="#Overriding-重写" class="headerlink" title="Overriding / 重写"></a>Overriding / 重写</h1><blockquote>
<p>c#中重写需要将父类被重写的方法添加 virtual 关键字声明为虚函数，子类添加 override 关键字指明重写</p>
</blockquote>
<h1 id="Interface-接口"><a href="#Interface-接口" class="headerlink" title="Interface / 接口"></a>Interface / 接口</h1><blockquote>
<p>c#接口也有泛型，实现接口时使用 : + 接口 即可</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="comment">//This is a basic interface with a single required</span></span><br><span class="line"><span class="comment">//method.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IKillable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Kill</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//This is a generic interface where T is a placeholder</span></span><br><span class="line"><span class="comment">//for a data type that will be provided by the </span></span><br><span class="line"><span class="comment">//implementing class.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IDamageable</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Damage</span>(<span class="params">T damageTaken</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Extension-Methods-拓展方法"><a href="#Extension-Methods-拓展方法" class="headerlink" title="Extension Methods / 拓展方法"></a>Extension Methods / 拓展方法</h1><blockquote>
<p>Extension Methods 拓展方法可以不创建某个类的派生类，也不更改某个类，但是为该类”新增”了公用的方法</p>
<p><code>注意:</code></p>
<ol>
<li>拓展方法需要有一个静态类作容器</li>
<li>拓展方法本身也为静态方法，但是可以像实例方法一样调用</li>
<li>拓展方法的参数指定拓展的类型，前需要有关键字this</li>
<li>拓展方法仍不可访问拓展类的私有成员</li>
</ol>
</blockquote>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Extend</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Transform trans = GetComponent&lt;Transform&gt;();</span><br><span class="line">        trans.Logout();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Container</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Logout</span>(<span class="params"><span class="keyword">this</span> Transform trans</span>)</span> &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;Tranform 类中被\&quot;添加\&quot;了这个方法啦！&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Lists-and-Dictionaries-列表与字典"><a href="#Lists-and-Dictionaries-列表与字典" class="headerlink" title="Lists and Dictionaries / 列表与字典"></a>Lists and Dictionaries / 列表与字典</h1><blockquote>
<p>List 为动态数组，以泛型方式创建，并制定元素类型，提供Add，Remove，Sort，Clear等接口</p>
<p>Dictionarie 类似于map，以键值对形式存储元素</p>
<p><code>注意:</code></p>
<ol>
<li>需要先引用命名空间 System.Collections.Generic;</li>
</ol>
</blockquote>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// List</span></span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SomeClass</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span> (<span class="params"></span>) </span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//This is how you create a list. Notice how the type</span></span><br><span class="line">        <span class="comment">//is specified in the angle brackets (&lt; &gt;).</span></span><br><span class="line">        List&lt;BadGuy&gt; badguys = <span class="keyword">new</span> List&lt;BadGuy&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Here you add 3 BadGuys to the List</span></span><br><span class="line">        badguys.Add( <span class="keyword">new</span> BadGuy(<span class="string">&quot;Harvey&quot;</span>, <span class="number">50</span>));</span><br><span class="line">        badguys.Add( <span class="keyword">new</span> BadGuy(<span class="string">&quot;Magneto&quot;</span>, <span class="number">100</span>));</span><br><span class="line">        badguys.Add( <span class="keyword">new</span> BadGuy(<span class="string">&quot;Pip&quot;</span>, <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">        badguys.Sort();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span>(BadGuy guy <span class="keyword">in</span> badguys)</span><br><span class="line">        &#123;</span><br><span class="line">            print (guy.name + <span class="string">&quot; &quot;</span> + guy.power);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//This clears out the list so that it is</span></span><br><span class="line">        <span class="comment">//empty.</span></span><br><span class="line">        badguys.Clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dictionarie</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SomeOtherClass</span> : <span class="title">MonoBehaviour</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span> (<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//This is how you create a Dictionary. Notice how this takes</span></span><br><span class="line">        <span class="comment">//two generic terms. In this case you are using a string and a</span></span><br><span class="line">        <span class="comment">//BadGuy as your two values.</span></span><br><span class="line">        Dictionary&lt;<span class="built_in">string</span>, BadGuy&gt; badguys = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, BadGuy&gt;();</span><br><span class="line"></span><br><span class="line">        BadGuy bg1 = <span class="keyword">new</span> BadGuy(<span class="string">&quot;Harvey&quot;</span>, <span class="number">50</span>);</span><br><span class="line">        BadGuy bg2 = <span class="keyword">new</span> BadGuy(<span class="string">&quot;Magneto&quot;</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//You can place variables into the Dictionary with the</span></span><br><span class="line">        <span class="comment">//Add() method.</span></span><br><span class="line">        badguys.Add(<span class="string">&quot;gangster&quot;</span>, bg1);</span><br><span class="line">        badguys.Add(<span class="string">&quot;mutant&quot;</span>, bg2);</span><br><span class="line"></span><br><span class="line">        BadGuy magneto = badguys[<span class="string">&quot;mutant&quot;</span>];</span><br><span class="line"></span><br><span class="line">        BadGuy temp = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//This is a safer, but slow, method of accessing</span></span><br><span class="line">        <span class="comment">//values in a dictionary.</span></span><br><span class="line">        <span class="keyword">if</span>(badguys.TryGetValue(<span class="string">&quot;birds&quot;</span>, <span class="keyword">out</span> temp))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//success!</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//failure!</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<p>2022/1/6 21:48</p>
<h1 id="Coroutines-协程"><a href="#Coroutines-协程" class="headerlink" title="Coroutines / 协程"></a>Coroutines / 协程</h1><blockquote>
<p>协程本质上是一个用返回类型 IEnumerator 声明的函数，并在主体的某个位置包含 yield return 语句</p>
<p>yield return null; 是暂停执行下一帧恢复的调用点</p>
<p>要将协程设置为 运行/停止 态，需要使用 StartCoroutine()  / StopCoroutine() / StopAllCoroutines()</p>
</blockquote>
<ul>
<li><p>StartCoroutine(string name, object parameter = null)</p>
<blockquote>
<p>使用字符串类启动具有特定名称的协程并可以使用相应的 StopCoroutine() 来停止该协程的执行，同时可以指定参数 parameter </p>
</blockquote>
</li>
<li><p>StopCoroutine(string name)</p>
</li>
<li><p>StopAllCoroutines()</p>
<blockquote>
<p>停止该行为上运行的所有协程</p>
</blockquote>
</li>
<li><p>WaitForSeconds(float time)</p>
<blockquote>
<p>使用缩放时间来使协程暂停指定秒数</p>
<p><code>注意:</code></p>
<ol>
<li>实际暂停时间等于 给定时间 * Time.timeScale</li>
<li>其只能与 yield 语句结合使用，暂停时间过后，继续从当前位置执行</li>
</ol>
</blockquote>
</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Coroutines</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        StartCoroutine(<span class="string">&quot;MoveTo&quot;</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">IEnumerator <span class="title">MoveTo</span>(<span class="params">Transform target</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (Vector3.Distance(transform.position, target.position) &gt; <span class="number">1f</span>) &#123;</span><br><span class="line">            print(transform.position - target.position);</span><br><span class="line">            transform.position = Vector3.Lerp(transform.position, target.position, speed * Time.deltaTime);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        print(<span class="string">&quot;Reached the target.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">1f</span></span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Transform target;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> speed = <span class="number">1f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Quaternions-四元数"><a href="#Quaternions-四元数" class="headerlink" title="Quaternions / 四元数"></a>Quaternions / 四元数</h1><blockquote>
<p>Quaternions 用来管理旋转，不要轻易改变，但是可以通过unity提供的相应接口完成旋转管理</p>
</blockquote>
<ul>
<li><p>Quaternion.identity</p>
<blockquote>
<p><code>U3D Document : It Effectively set its Euler rotation to (0,0,0) or no rotation.</code></p>
<p>设置一个对象的 rotation 属性为 Quaternion.identity，即无旋转，欧拉角值为 (0,0,0)</p>
</blockquote>
</li>
<li><p>Quaternion.LookRotation (Vector3 forward, Vector3 upwards = Vector3.up)</p>
<blockquote>
<p><code>U3D Document : Creates a rotation with the specified </code>forward<code>and</code>upwards<code> directions.</code></p>
<p>暂略，有点懵</p>
</blockquote>
</li>
<li><p>Quaternion.Slerp (Quaternion a, Quaternion b, float t)</p>
<blockquote>
<p><code>U3D Document : Quaternion A quaternion spherically interpolated between quaternions a and b. The parameter t is clamped to the range [0, 1]，If the value of the parameter is close to 0, the output will be close to a, if it is close to 1, the output will be close to b.</code></p>
<p>非线性插值，可以按比例进行球形插值，t的范围为[0,1]，t越接近0，插值越接近a，t越接近1，插值越接近b</p>
</blockquote>
</li>
</ul>
<h1 id="Delegates-委托"><a href="#Delegates-委托" class="headerlink" title="Delegates / 委托"></a>Delegates / 委托</h1><blockquote>
<p>委托是存有对某个 方法 引用的引用类型变量</p>
</blockquote>
<h2 id="Declaration-声明"><a href="#Declaration-声明" class="headerlink" title="Declaration / 声明"></a>Declaration / 声明</h2><blockquote>
<p>delegate 关键字可以声明可由该委托引用的方法</p>
<p><code>注意:</code></p>
<ol>
<li>委托与其可引用的方法具有相同的函数签名</li>
</ol>
</blockquote>
<h2 id="Instantiation-实例化"><a href="#Instantiation-实例化" class="headerlink" title="Instantiation / 实例化"></a>Instantiation / 实例化</h2><blockquote>
<p>委托对象的实例化必须通过 new 创建，并且初始化时给定需要引用的方法名即可</p>
</blockquote>
<h2 id="Multicasting-of-a-Delegate-委托的多播"><a href="#Multicasting-of-a-Delegate-委托的多播" class="headerlink" title="Multicasting of a Delegate / 委托的多播"></a>Multicasting of a Delegate / 委托的多播</h2><blockquote>
<p>+ 可用于委托的合并，一个合并委托将调用它所合并的委托</p>
<p>- 可用于合并委托的移除</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Delegates</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Func</span>(<span class="params"><span class="built_in">int</span> param</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Func func1 = <span class="keyword">new</span> Func(printLog);</span><br><span class="line">        func1(<span class="number">1</span>);</span><br><span class="line">        func1 += printLoggg;</span><br><span class="line">        func1(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printLog</span>(<span class="params"><span class="built_in">int</span> param</span>)</span> &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;printLog() 被调用!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printLoggg</span>(<span class="params"><span class="built_in">int</span> param</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;printLoggg() 被调用!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Attributes-特性"><a href="#Attributes-特性" class="headerlink" title="Attributes / 特性"></a>Attributes / 特性</h1><blockquote>
<p><code>U3D Document : Attributes allow you to attach additional behavior to the methods and variables you create.</code></p>
<p>Attributes 允许你赋予创建的变量或者方法特别的行为</p>
<p><code>注意:</code></p>
<ol>
<li>特性书写形式为 []，若带参数则可以使用()指出</li>
</ol>
</blockquote>
<ul>
<li><p>Range</p>
<blockquote>
<p>[Range(min,max)] 可以在 inspectors 面板中显示可调整的滚动条来设置变量的大小0</p>
</blockquote>
</li>
<li><p>ExecuteInEditMode</p>
<blockquote>
<p>[ExecuteInEditMode] 可以使脚本在非运行模式下被执行</p>
<p><code>注意:</code></p>
<ol>
<li>执行结果将是不可逆转的永久性的，需要注意该特性的执行后果</li>
</ol>
</blockquote>
</li>
</ul>
<h1 id="Events-事件"><a href="#Events-事件" class="headerlink" title="Events / 事件"></a>Events / 事件</h1><blockquote>
<p>事件使用 Publisher / Subscriber 发布者/订阅者 机制，使得订阅了发布者的订阅者在发布者发生变动时，作出响应的事件处理</p>
<p>delegate 关键字完成委托的创建，event 关键字完成事件的创建</p>
</blockquote>
<h2 id="Publisher-发布者"><a href="#Publisher-发布者" class="headerlink" title="Publisher / 发布者"></a>Publisher / 发布者</h2><blockquote>
<p>创建事件处理任务的委托，并创建事件</p>
<p>设置相应的事件通知函数，完成对事件的调用，进而完成通知</p>
<p>作出改动时完成事件通知函数的调用</p>
<p><code>注意:</code></p>
<ol>
<li>事件一般设置为共有的静态成员</li>
</ol>
</blockquote>
<h2 id="Subscriber-订阅者"><a href="#Subscriber-订阅者" class="headerlink" title="Subscriber / 订阅者"></a>Subscriber / 订阅者</h2><blockquote>
<p>设置与委托相对应的事件处理函数</p>
<p>设置相应的接口完成对事件的订阅与取消订阅</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EventsPublisher</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//委托</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">EventDispose</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//事件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> EventDispose eventDispose;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//事件通知函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Notify</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (eventDispose != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//调用已订阅的类的相应事件处理函数</span></span><br><span class="line">            eventDispose();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span>(<span class="params"><span class="built_in">float</span> <span class="keyword">value</span></span>)</span> &#123;</span><br><span class="line">        elem = <span class="keyword">value</span>;</span><br><span class="line">        Notify();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start is called before the first frame update </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        EventSubscriber SubObj = <span class="keyword">new</span> EventSubscriber();</span><br><span class="line">        SubObj.Subscribe();</span><br><span class="line"></span><br><span class="line">        EventsPublisher PubObj = <span class="keyword">new</span> EventsPublisher();</span><br><span class="line">        PubObj.setValue(<span class="number">100f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> elem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EventSubscriber</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//订阅事件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Subscribe</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        EventsPublisher.eventDispose += <span class="keyword">new</span> EventsPublisher.EventDispose(Dispose);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取消订阅事件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CancelSubscribe</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        EventsPublisher.eventDispose -= <span class="keyword">new</span> EventsPublisher.EventDispose(Dispose);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//事件处理函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;事件被触发啦!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<p><strong>Question:</strong> </p>
<ul>
<li>Quaternions / 四元数 以后细锁</li>
</ul>
<hr>
<p>2022/1/7 15:00</p>
]]></content>
      <categories>
        <category>YumiGame</category>
      </categories>
      <tags>
        <tag>Unity - C#</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity - 编程基础</title>
    <url>/2022/03/22/Unity/Unity_%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="Unity-Basic-Unity-基础"><a href="#Unity-Basic-Unity-基础" class="headerlink" title="Unity Basic / Unity 基础"></a>Unity Basic / Unity 基础</h1><h2 id="初识问题汇总"><a href="#初识问题汇总" class="headerlink" title="初识问题汇总"></a>初识问题汇总</h2><ol>
<li><del>动画数据？</del></li>
<li><del>unity3D已有的内置算法已经可实现补间动画了吗？</del></li>
<li><del>IK系统？</del></li>
<li><del>fbx/animation 动画文件？ 模型文件</del></li>
<li>tensorflow算法训练 训练什么？输入输出？预期产出？</li>
<li>补间动画？ 动画融合与向量矫正？物理反馈？</li>
<li><del>Siggraph2019？</del></li>
</ol>
<h2 id="计划学习路线"><a href="#计划学习路线" class="headerlink" title="计划学习路线"></a>计划学习路线</h2><ul>
<li>Unity3D基础概念 / √</li>
<li>Unity3D动画系统概念初识 / √</li>
<li>Unity初级编程 - 中级编程 / ing</li>
<li>动画系统demo实践 完成模型导入-&gt; 动画绑定 -&gt; 状态机组织动画</li>
<li>着手AIAnimation框架，着手动画系统的改写</li>
</ul>
<h1 id="Unity3D-编辑器"><a href="#Unity3D-编辑器" class="headerlink" title="Unity3D 编辑器"></a>Unity3D 编辑器</h1><h2 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h2><blockquote>
<p>播放/暂停/步进</p>
</blockquote>
<h2 id="Scene-Camera"><a href="#Scene-Camera" class="headerlink" title="Scene / Camera"></a>Scene / Camera</h2><blockquote>
<p>显示视图</p>
</blockquote>
<h2 id="Project"><a href="#Project" class="headerlink" title="Project"></a>Project</h2><blockquote>
<p>资源库</p>
</blockquote>
<h2 id="Hierarchy"><a href="#Hierarchy" class="headerlink" title="Hierarchy"></a>Hierarchy</h2><blockquote>
<p>scene场景中的各对象的层级关系，注意存在属性继承</p>
</blockquote>
<h2 id="Inspector"><a href="#Inspector" class="headerlink" title="Inspector"></a>Inspector</h2><blockquote>
<p>属性</p>
</blockquote>
<h2 id="Status"><a href="#Status" class="headerlink" title="Status"></a>Status</h2><blockquote>
<p>Unity3D进程，输出，调试信息</p>
</blockquote>
<h1 id="Unity3D-基础概念"><a href="#Unity3D-基础概念" class="headerlink" title="Unity3D 基础概念"></a>Unity3D 基础概念</h1><h2 id="GameObjects-游戏对象"><a href="#GameObjects-游戏对象" class="headerlink" title="GameObjects / 游戏对象"></a>GameObjects / 游戏对象</h2><blockquote>
<p> <code>U3D Document : They do not accomplish much in themselves but they act as containers for Components, which implement the functionality.</code></p>
<p>GameObject是u3d中所有对象的实体容器，可以认为每一个对象(包括角色，场景，特效)均由一个GameObject形成</p>
<p>但是仅由GameObject无法使该对象具有相应的功能和属性，需要向该GameObject添加一系列组件来满足对特性行为/属性的需求</p>
<p>GameObject有一个默认的不可移除的组件为Transform组件，该组件使该GameObject具有了位置与方向的属性</p>
</blockquote>
<ul>
<li>activeInHierarchy - 继承关系下孩子活跃状态的判断，当父对象设置为不活跃时，子对象仍活跃但是于Hierarchy为不活跃</li>
<li>activeSelf - 判断游戏对象的活跃状态</li>
<li>SetActive - 设置游戏对象的活跃状态</li>
</ul>
<h2 id="Component-组件"><a href="#Component-组件" class="headerlink" title="Component / 组件"></a>Component / 组件</h2><blockquote>
<p><code>U3D Document : Components define the behaviour of that GameObject.</code></p>
<p>组件定义游戏对象的行为，即游戏对象的具体行为需要由相应的组件支持，包括属性</p>
</blockquote>
<h2 id="Scripts-C-脚本"><a href="#Scripts-C-脚本" class="headerlink" title="Scripts / C#脚本"></a>Scripts / C#脚本</h2><blockquote>
<p><code>U3D Document : In technical terms, any script you make compiles as a type of **component**, so the Unity Editor treats your script like a built-in component. You define the members of the script to be exposed in the Inspector, and the Editor executes whatever functionality you’ve written.</code></p>
<p>脚本可用来自动响应玩家的输入并控制场景中游戏对象的行为，游戏过程中的事件</p>
<p>资源库中创建的脚本被编译为组件，可以为某个游戏对象添加该组件，编译器将对该对象执行该脚本实现你脚本编写的行为</p>
</blockquote>
<h2 id="Tag-标签"><a href="#Tag-标签" class="headerlink" title="Tag / 标签"></a>Tag / 标签</h2><blockquote>
<p><code>U3D Document : Tags help you identify GameObjects for scripting purposes. They ensure you don’t need to manually add GameObjects to a script’s exposed properties using drag and drop, thereby saving time when you are using the same script code in multiple GameObjects.</code></p>
<p>将GameObject分组用于简化C#脚本操作，无需将具体对象引入到脚本的公共区域进行逻辑操作，仅需通过GameObject所属的标签来统一操作</p>
<p>GameObject.FindWithTag() 可按标签来查找对象</p>
</blockquote>
<h2 id="Layer-层"><a href="#Layer-层" class="headerlink" title="Layer / 层"></a>Layer / 层</h2><blockquote>
<p><code>U3D Document : Layers in Unity define which GameObjects can interact with different features and one another.</code></p>
<p>将GameObject分组用于各组件的相互交互</p>
<p>Camera : 仅渲染场景的一部分</p>
<p>Light : 仅照亮场景的某些部分</p>
<p>Collision : 使用 Layer Collision Matrix(层碰撞矩阵) 来管理游戏对象之间的碰撞</p>
</blockquote>
<h2 id="Rotation-and-Orientation-旋转与方向"><a href="#Rotation-and-Orientation-旋转与方向" class="headerlink" title="Rotation and Orientation / 旋转与方向"></a>Rotation and Orientation / 旋转与方向</h2><blockquote>
<p>欧拉角 + 四元数</p>
</blockquote>
<hr>
<p><strong>Questions :</strong></p>
<ul>
<li>欧拉角 + 四元数</li>
<li> 世界坐标与相对坐标？如何调整一个游戏对象的世界坐标</li>
<li>全局坐标/局部坐标？</li>
</ul>
<p>2021/12/22 - 2021/12/23 </p>
<hr>
<h1 id="Unity3D-Scripts-脚本"><a href="#Unity3D-Scripts-脚本" class="headerlink" title="Unity3D Scripts / 脚本"></a>Unity3D Scripts / 脚本</h1><h2 id="Basic-Code-Structure-初始结构"><a href="#Basic-Code-Structure-初始结构" class="headerlink" title="Basic Code Structure / 初始结构"></a>Basic Code Structure / 初始结构</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Class Name : 需要与脚本文件名相同否则该脚本无法作为组件附加到游戏对象中</span></span><br><span class="line"><span class="comment">    MonoBehaviour : 内置类，用于规范可附加到游戏对象中的组件类的行为标准</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    注意: </span></span><br><span class="line"><span class="comment">    	1.脚本对象的构造由编译器编译时完成，但是脚本文件类的构造函数为运行时构造，所以不要再为其设置构造函数进行初始化了 </span></span><br><span class="line"><span class="comment">    	2.当类继承自MonoBehaviour时使用构造函数会使构造函数在不需要的时间被调用，并且在许多情况下可能会导致 Unity 崩溃</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">QuickStart</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//进行所有成员初始化的理想位置</span></span><br><span class="line">        <span class="comment">//Start()函数于 before the first frame update 但是于运行时调用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//处理游戏对象的帧更新</span></span><br><span class="line">        <span class="comment">//响应事件，随时间推移需要处理的任何事件，任何行为</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> LookatMe; <span class="comment">//仅public成员再Inspector面板中可见且可操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Instantiating-Prefabs-at-run-time-运行时实例化预制件"><a href="#Instantiating-Prefabs-at-run-time-运行时实例化预制件" class="headerlink" title="Instantiating Prefabs at run time / 运行时实例化预制件"></a>Instantiating Prefabs at run time / 运行时实例化预制件</h2><blockquote>
<p>工厂模式来创建对象，通过Instantiate接口函数完成运行时对GameObject引用的赋值，即完成对象的创建</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Instantiate实例化</span></span><br><span class="line">TypeOfPrefeb reTurnReference = Instantiate(Prefeb, <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), Quaternion.identity);</span><br></pre></td></tr></table></figure>

<h3 id="First-Example-The-Wall"><a href="#First-Example-The-Wall" class="headerlink" title="First Example - The Wall"></a>First Example - The Wall</h3><p><strong>场景描述</strong></p>
<blockquote>
<p>需要使用基本预制件构造一堵墙，即通过基本mesh构件逐行循环构造形成一堵墙</p>
<p>但是mesh可以由不同的GameObject类型组成，如何做到不需要更改代码？随心所欲的更改该墙的基本构件的类型呢？</p>
<p>通过Instantiate接口函数使用PreFab引用创建对象，你需要做的便只需要运行时更替该引用的实际实体即可，该墙的脚本无需更改</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Wall</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> y = <span class="number">0</span>; y &lt; height; ++y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//固定height逐行构建</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> x = <span class="number">0</span>; x &lt; width; ++x)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//通过引用构建对象，引用实体于运行时给定</span></span><br><span class="line">                Instantiate(block, <span class="keyword">new</span> Vector3(x, y, <span class="number">0</span>), Quaternion.identity);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> GameObject block; <span class="comment">//墙基本构件的引用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> width = <span class="number">10</span>; <span class="comment">//墙宽</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> height = <span class="number">4</span>; <span class="comment">//墙高</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Second-Example-Fire"><a href="#Second-Example-Fire" class="headerlink" title="Second Example - Fire"></a>Second Example - Fire</h3><p><strong>场景描述:</strong></p>
<blockquote>
<p>欲实现开火效果</p>
<ul>
<li>子弹需要根据用户的的实际操作于运行时生成</li>
<li>子弹发生碰撞时的粒子效果需要于运行时生成</li>
<li>被子弹射中的对象需要由完美态到破损态，GameObject的实体替换需要由运行时完成</li>
</ul>
<p>通过Instantiate接口函数使用PreFab引用创建对象，你需要做的便只需要运行时指定/更替该引用的实际实体即可，无需对代码作出修改</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//子弹</span></span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FireProjectile</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// This script launches a projectile prefab by instantiating it at the position</span></span><br><span class="line">    <span class="comment">// of the GameObject on which it is placed, then then setting the velocity</span></span><br><span class="line">    <span class="comment">// in the forward direction of the same GameObject.    </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetButtonDown(<span class="string">&quot;Fire1&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//子弹对象的创建</span></span><br><span class="line">            Rigidbody p = Instantiate(projectile, transform.position, transform.rotation);</span><br><span class="line">            <span class="comment">//为子弹赋予一个速度向量</span></span><br><span class="line">            p.velocity = transform.forward * speed;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Rigidbody projectile; <span class="comment">//设置为刚体防止赋予实体时类型错误</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> speed = <span class="number">4</span>; <span class="comment">//速率</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//完美态 -&gt; 破损态</span></span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WreckOnCollision</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnCollisionEnter</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Destroy(gameObject);</span><br><span class="line">        <span class="comment">//wreckedVersion需要指定为一个破损态的GameObject</span></span><br><span class="line">        Instantiate(wreckedVersion,transform.position,transform.rotation);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> GameObject wreckedVersion;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Event-Functions-事件函数"><a href="#Event-Functions-事件函数" class="headerlink" title="Event Functions / 事件函数"></a>Event Functions / 事件函数</h2><blockquote>
<p><code>U3D Document : These functions are known as event functions since they are activated by Unity in response to events that occur during gameplay.</code></p>
<p>脚本区别于程序，程序会一直持续执行直到其执行完毕，但是脚本不是，脚本依附于其包含的事件函数，当特定的事件发生时，会由相应的事件函数作出响应处理，这是u3d会暂时将控制权转交给相应的脚本，当该事件处理完毕，脚本将马上交还控制权</p>
</blockquote>
<h3 id="Regular-Update-Events"><a href="#Regular-Update-Events" class="headerlink" title="Regular Update Events"></a>Regular Update Events</h3><blockquote>
<p><code>U3D Document : A key concept in games programming is that of making changes to position, state and behavior of objects in the game just before each frame is rendered.</code></p>
<p>游戏类似于动画，需要逐帧渲染，这要求在下一帧渲染前对游戏对象的位置,状态,行为等属性作出改变</p>
</blockquote>
<h4 id="Update"><a href="#Update" class="headerlink" title="Update()"></a>Update()</h4><blockquote>
<p><code>U3D Document : Update is called before the frame is rendered and also before animations are calculated.</code></p>
<ol>
<li>before the frame is rendered. 在下一帧被渲染之前被调用</li>
<li>before animations are calculated. 在计算动画之前</li>
</ol>
</blockquote>
<h4 id="FixedUpdate"><a href="#FixedUpdate" class="headerlink" title="FixedUpdate()"></a>FixedUpdate()</h4><blockquote>
<p><code>U3D Document : FixedUpdate is called just before each physics update. Since the physics updates and frame updates do not occur with the same frequency, you will get more accurate results from physics code if you place it in the FixedUpdate function rather than Update.</code></p>
<ol>
<li>before each physics update. u3d物理系统的更新类似于帧更新，均为离散逐步更新，但是物理帧更新与帧更新的频率不同，FixedUpdate()对物理的更新更准确</li>
</ol>
</blockquote>
<h4 id="LateUpdate"><a href="#LateUpdate" class="headerlink" title="LateUpdate()"></a>LateUpdate()</h4><blockquote>
<p><code>U3D Document : LateUpdate function can be used for the situation that to be able to make additional changes at a point after the Update and FixedUpdate functions have been called for all objects in the scene and after all animations have been calculated. </code></p>
<ol>
<li>after the Update and FixedUpdate functions have been called. 在Update()和FixedUpdate()被调用之后，作出额外的操作</li>
<li>after all animations have been calculated. 在所有动画计算完毕之后作出额外的操作</li>
</ol>
<p>例如相机需要实时朝向目标对象，但是相机方向的调整必须在目标对象位置作出变动之后，即update()之后，再进行调整，也就是说相机必须实时朝向目标对象改动后的位置</p>
</blockquote>
<h3 id="Initialization-Events"><a href="#Initialization-Events" class="headerlink" title="Initialization Events"></a>Initialization Events</h3><h4 id="Awake"><a href="#Awake" class="headerlink" title="Awake()"></a>Awake()</h4><blockquote>
<p><code>U3D Document : The Awake function is called for each object in the scene at the time when the scene loads</code></p>
<ol>
<li>when the scene loads. 在场景加载时，为场景中的每个对象调用Awake()使其能够初始化</li>
</ol>
</blockquote>
<h4 id="Start"><a href="#Start" class="headerlink" title="Start()"></a>Start()</h4><blockquote>
<p><code>U3D Document : The Start function is called before the first frame or physics update on an object.</code></p>
<ol>
<li>before the first frame or physics update on an object. 在对象首次执行帧更新or物理更新之前需要被调用进行的初始化</li>
</ol>
</blockquote>
<p><code>注意:</code></p>
<ol>
<li><p><code>all the Awakes will have finished before the first Start is called.</code></p>
<blockquote>
<p>所有的Awakes初始化均会在第一个start之前，注意一些重复初始化问题，而且Start可借助Awake完成一些初始化</p>
</blockquote>
</li>
<li><p><code>Using the constructor when the class inherits from MonoBehaviour will make the constructor to be called at unwanted times and in many cases might cause Unity to crash.</code></p>
<blockquote>
<p>脚本的构造函数可能会在你不期望的时机被调用，甚至导致unity崩溃，所有尽量不要使用构造函数完成初始化</p>
</blockquote>
</li>
</ol>
<h3 id="GUI-events"><a href="#GUI-events" class="headerlink" title="GUI events"></a>GUI events</h3><blockquote>
<p>GUI控件上发生的相应事件，与帧更新的处理方式不同</p>
</blockquote>
<h4 id="OnGUI"><a href="#OnGUI" class="headerlink" title="OnGUI()"></a>OnGUI()</h4><blockquote>
<p><code>U3D Document : Unity has a system for rendering GUI controls over the main action in the scene and responding to clicks on these controls. This code is handled somewhat differently from the normal frame update and so it should be placed in the OnGUI function, which will be called periodically.</code></p>
<p>用于GUI控件的渲染以及发生在其上的点击事件的响应</p>
</blockquote>
<h3 id="Physics-events"><a href="#Physics-events" class="headerlink" title="Physics events"></a>Physics events</h3><blockquote>
<p><code>U3D Document : The physics engine will report collisions against an object by calling event functions on that object’s script.</code></p>
<p>U3D使用脚本中的事件函数来处理发生在对象上的碰撞</p>
</blockquote>
<p><strong>Collider / Trigger</strong></p>
<blockquote>
<p>Collider 可以认为是记录对象空间占位信息的组件，只有具有 Collider 组件的对象，才会由物理系统去计算发生在该对象上的碰撞</p>
<p>若仅仅想检测碰撞，但是却不希望影响该对象的移动，而可以在inspector面板中将 Collider 勾选配置为 Trigger，可以仅检测碰撞而不产生碰撞效果，具体响应可在下面事件中作出</p>
</blockquote>
<h4 id="OnCollisionEnter-OnTriggerEnter"><a href="#OnCollisionEnter-OnTriggerEnter" class="headerlink" title="OnCollisionEnter() / OnTriggerEnter()"></a>OnCollisionEnter() / OnTriggerEnter()</h4><h4 id="OnCollisionStay-OnTriggerStay"><a href="#OnCollisionStay-OnTriggerStay" class="headerlink" title="OnCollisionStay() / OnTriggerStay()"></a>OnCollisionStay() / OnTriggerStay()</h4><h4 id="OnCollisionExit-OnTriggerExit"><a href="#OnCollisionExit-OnTriggerExit" class="headerlink" title="OnCollisionExit() / OnTriggerExit()"></a>OnCollisionExit() / OnTriggerExit()</h4><h2 id="Order-of-execution-for-event-functions-事件的执行顺序"><a href="#Order-of-execution-for-event-functions-事件的执行顺序" class="headerlink" title="Order of execution for event functions / 事件的执行顺序"></a>Order of execution for event functions / 事件的执行顺序</h2><blockquote>
<p><code>U3D Document : Unity orders and repeats event functions over a script’s lifetime.</code></p>
<p>在一个脚本的生命周期内，例如场景加载时，帧更新时，修改对象属性时等等会 包含/触发 一系列的u3d事件函数</p>
<p>具体需要时参考U3D Document</p>
</blockquote>
<h3 id="Script-lifecycle-overview-脚本的生命周期概述"><a href="#Script-lifecycle-overview-脚本的生命周期概述" class="headerlink" title="Script lifecycle overview / 脚本的生命周期概述"></a>Script lifecycle overview / 脚本的生命周期概述</h3><ul>
<li>First Scene Load / 场景第一次加载时</li>
<li>Editor / 编辑属性时</li>
<li>Before the first frame update / 第一次帧更新前</li>
<li>In between frames / 帧之间</li>
<li>Update order / 更新时</li>
<li>Animation update loop / 动画更新循环时</li>
<li>Rendering / 渲染时</li>
<li>Coroutines / 协程相关</li>
<li>When the object is destroyed / 对象销毁时</li>
<li>When quitting / 退出时</li>
</ul>
<h2 id="Coroutines-协程"><a href="#Coroutines-协程" class="headerlink" title="Coroutines / 协程"></a>Coroutines / 协程</h2><blockquote>
<p><code>U3D Document : A coroutine allows you to spread tasks across several frames. In Unity, a coroutine is a method that can pause execution and return control to Unity but then continue where it left off on the following frame.</code></p>
<p>一个脚本中的普通事件函数只能在一帧完成，如果需要有一定的过渡效果，就必须将该事件函数处理的任务分散在多个帧中逐步完成，协程允许将一个任务分散在多个帧中执行，它可以在某一帧中停止执行，将控制权返还给unity，随后在下一帧继续执行因暂停而未完成的任务</p>
</blockquote>
<h2 id="Attributes-特性"><a href="#Attributes-特性" class="headerlink" title="Attributes  / 特性"></a>Attributes  / 特性</h2><blockquote>
<p><code>U3D Document : Attributes are markers that can be placed above a class, property or function in a script to indicate special behaviour.</code></p>
<p>类似于ue4的uproprety宏定义，用于表明某些属性，方法，类的特殊行为，例如是否在的inspectors窗口中显示public属性</p>
</blockquote>
<h2 id="Important-Class-内置类"><a href="#Important-Class-内置类" class="headerlink" title="Important Class / 内置类"></a>Important Class / 内置类</h2><blockquote>
<p>目前版本暂时略，需要时自查文档即可</p>
</blockquote>
<hr>
<p>**Questions : **</p>
<ul>
<li>UEGamePlay框架</li>
<li>prefab is instantiated / 预制件的实例化，在什么情景下算实例化成功？资产中的预制件算不算？场景中的预制件算不算？脚本属性中的预制件引用对应的实体算不算？</li>
<li>MonoBehaviour instance is created？ GameObject with the script component is instantiated</li>
<li><del>collider and Trigger</del></li>
<li><del>刚体与碰撞体</del></li>
</ul>
<hr>
<p>2021/12/24 - 2021/12/25</p>
<hr>
<h1 id="Unity3D-Animation-动画"><a href="#Unity3D-Animation-动画" class="headerlink" title="Unity3D Animation / 动画"></a>Unity3D Animation / 动画</h1><blockquote>
<p><code>U3D Document :Unity’s Animation features include retargetable animations, full control of animation weights at runtime, event calling from within the animation playback, sophisticated state machine hierarchies and transitions, blend shapes for facial animations, and much more.</code></p>
<p>动画系统包括 动画重定向，运行时动画权重的控制，动画播放时事件的回调，复杂状态机管理下的动画与过渡，混合树等</p>
</blockquote>
<h2 id="Animation-Workflow-动画流程"><a href="#Animation-Workflow-动画流程" class="headerlink" title="Animation Workflow / 动画流程"></a>Animation Workflow / 动画流程</h2><ol>
<li>Animation clips are imported from an external source or created within Unity. In this example, they are imported motion captured humanoid animations.</li>
<li>The animation clips are placed and arranged in an Animator Controller. This shows a view of an Animator Controller in the Animator window. The  States (which may represent animations or nested sub-state machines) appear as nodes connected by lines. This Animator Controller exists as an asset in the Project window.</li>
<li>The rigged character model (in this case, the astronaut “Astrella”) has a specific configuration of bones which are mapped to Unity’s common Avatar format. This mapping is stored as an Avatar asset as part of the imported character model, and also appears in the Project window as shown.</li>
<li>When animating the character model, it has an Animator component attached. In the Inspector view shown above, you can see the Animator Component which has both the Animator Controller and the Avatar assigned. The animator uses these together to animate the model. The Avatar reference is only necessary when animating a humanoid character. For other types of animation, only an Animator Controller is required.</li>
</ol>
<h2 id="Animation-Window-动画窗口"><a href="#Animation-Window-动画窗口" class="headerlink" title="Animation Window / 动画窗口"></a>Animation Window / 动画窗口</h2><blockquote>
<p><code>U3D Document : The Animation Window in Unity allows you to create and modify Animation Clips directly inside Unity, the Animation window shows the timeline and keyframes of the Animation for the currently selected GameObject or Animation Clip Asset.</code></p>
<p>用于对动画切片进行编辑的工具，该窗口展示了选中游戏对象上动画的时间轴与关键帧</p>
<p>操作详情略，忘记时文档自寻</p>
</blockquote>
<h3 id="Windows-Interface-界面布局"><a href="#Windows-Interface-界面布局" class="headerlink" title="Windows Interface / 界面布局"></a>Windows Interface / 界面布局</h3><h4 id="Playback-and-frame-navigation-controls-回放与帧导航控制"><a href="#Playback-and-frame-navigation-controls-回放与帧导航控制" class="headerlink" title="Playback and frame navigation controls / 回放与帧导航控制"></a>Playback and frame navigation controls / 回放与帧导航控制</h4><ul>
<li><p>Record Mode for Playback / 录制模式</p>
<blockquote>
<p>录制模式下，对游戏可动画化属性的任何更改，都会在该时间轴位置处添加关键帧</p>
</blockquote>
</li>
<li><p>Preview Mode for Playback / 预览模式</p>
<blockquote>
<p>预览模式下，若不是通过属性列表修改的属性，均不会自动创建关键帧，需要手动添加关键帧</p>
<ol>
<li>shift + k 为更改属性/所选属性添加关键帧</li>
<li>k 为当前属性列表中的所有属性添加关键帧</li>
<li>inspector视图中对相应属性右键添加关键帧</li>
<li>属性列表为指定属性添加关键帧</li>
</ol>
</blockquote>
</li>
<li><p>Frame Navigation Controls / 帧导航控制</p>
</li>
</ul>
<blockquote>
<p>alt + &gt; 下一关键帧 / alt + &lt; 上一关键帧</p>
<p>&gt; 下一帧 / &lt; 上一帧</p>
<p>空格 暂停</p>
</blockquote>
<h4 id="The-Animated-Properties-list-已动画化的属性列表"><a href="#The-Animated-Properties-list-已动画化的属性列表" class="headerlink" title="The Animated Properties list / 已动画化的属性列表"></a>The Animated Properties list / 已动画化的属性列表</h4><blockquote>
<p>该列表将显示选定动画化的游戏对象的已动画化的属性，可以添加其余可动画化属性来完成更多动画效果</p>
</blockquote>
<h4 id="The-Animation-Timeline-动画时间轴"><a href="#The-Animation-Timeline-动画时间轴" class="headerlink" title="The Animation Timeline / 动画时间轴"></a>The Animation Timeline / 动画时间轴</h4><blockquote>
<p>可以使用该时间轴，在某个时间点设置期望属性值后插入关键帧，完成动画效果</p>
<p>该时间轴的单位为 秒:帧</p>
</blockquote>
<ul>
<li><p>Dopesheet timeline mode / 关键帧清单模式</p>
<blockquote>
<p>详细操作见文档</p>
</blockquote>
</li>
<li><p>Curves timeline mode / 曲线时间轴模式</p>
<blockquote>
<p>详细操作见文档</p>
</blockquote>
<h3 id="Rotation-Interpolation-Types-旋转插值类型"><a href="#Rotation-Interpolation-Types-旋转插值类型" class="headerlink" title="Rotation Interpolation Types / 旋转插值类型"></a>Rotation Interpolation Types / 旋转插值类型</h3></li>
<li><p>Quaternion Interpolation  / 四元数插值</p>
<blockquote>
<p>两个旋转之间的最短路径进行平滑插值</p>
<p>不能表示大于180°的旋转</p>
<p>对xyz任意一条曲线的更改，其余曲线均可能被影响，对任意一条曲线的插入关键帧，其余曲线都插入</p>
</blockquote>
</li>
<li><p> Euler Angles Interpolation / 欧拉角插值</p>
</li>
</ul>
<blockquote>
<p>可以表示任意角度的旋转</p>
<p>xyz三条曲线相互独立</p>
<p>围绕多个轴进行旋转时，可能导致插值瑕疵，如万向锁</p>
</blockquote>
<h2 id="Animation-Clips-动画切片"><a href="#Animation-Clips-动画切片" class="headerlink" title="Animation Clips / 动画切片"></a>Animation Clips / 动画切片</h2><blockquote>
<p><code>U3D Document : Unity’s animation system is based on the concept of Animation Clips, which contain information about how certain objects should change their position, rotation, or other properties over time. Each clip can be thought of as a single linear recording. Unity supports importing animation from external sources, and offers the ability to create animation clips.</code></p>
<p>动画切片可以理解为一个线性录制，它包含了某个对象的可动画化属性如何随时间变化而变化</p>
<p>u3d中的动画切片可从外部导入也可自行创建</p>
</blockquote>
<h3 id="Animation-from-External-Sources-由外部源导入"><a href="#Animation-from-External-Sources-由外部源导入" class="headerlink" title="Animation from External Sources / 由外部源导入"></a>Animation from External Sources / 由外部源导入</h3><blockquote>
<p><code>U3D Document : These External files can contain animation data in the form of a linear recording of the movements of objects within the file.</code></p>
<p>这些外部源文件可以通过 线性记录文件中对象移动 的方式存储动画数据</p>
<p>详细略，此前为略读了解概念版本</p>
</blockquote>
<ul>
<li><p>Humanoid animations captured at a motion capture studio</p>
<blockquote>
<p>可导入来自动作捕捉的动画</p>
</blockquote>
</li>
<li><p>Animations created from scratch by an artist in an external 3D application (such as Autodesk® 3ds Max® or Autodesk® Maya®)</p>
<blockquote>
<p>可导入外部3D软件创建的动画</p>
</blockquote>
</li>
<li><p>Animation sets from 3rd-party libraries (eg, from Unity’s asset store)</p>
<blockquote>
<p>可导入第三方库中的动画集</p>
</blockquote>
</li>
<li><p>Multiple clips cut and sliced from a single imported timeline.</p>
<blockquote>
<p>也可是单个时间轴切割形成的多个动画切片</p>
</blockquote>
</li>
</ul>
<h3 id="Animation-Created-and-Edited-Within-Unity-由Unity创建并编辑"><a href="#Animation-Created-and-Edited-Within-Unity-由Unity创建并编辑" class="headerlink" title="Animation Created and Edited Within Unity /  由Unity创建并编辑"></a>Animation Created and Edited Within Unity /  由Unity创建并编辑</h3><ul>
<li><p>The position, rotation and scale of GameObjects</p>
<blockquote>
<p>可以由游戏对象的位置，旋转，缩放形成</p>
</blockquote>
</li>
<li><p>Component properties such as material color, the intensity of a light, the volume of a sound </p>
<blockquote>
<p>可以由组件的属性形成，例如材质颜色变化，光照强度变化，声音强弱变化</p>
<ul>
<li>Float</li>
<li>Color</li>
<li>Vector2</li>
<li>Vector3</li>
<li>Vector4</li>
<li>Quaternion / 四元数</li>
<li>Boolean</li>
</ul>
</blockquote>
</li>
<li><p>Properties within your own scripts including float, integer, enum, vector and Boolean variables</p>
<blockquote>
<p>脚本中的属性成员</p>
</blockquote>
</li>
<li><p>The timing of calling functions within your own scripts </p>
<blockquote>
<p>脚本中函数的调用时机</p>
</blockquote>
</li>
</ul>
<h3 id="Animation-Events-动画事件"><a href="#Animation-Events-动画事件" class="headerlink" title="Animation Events / 动画事件"></a>Animation Events / 动画事件</h3><blockquote>
<p><code>U3D Document : You can increase the usefulness of Animation clips by using Animation Events, which allow you to call functions in the object’s script at specified points in the timeline.</code></p>
<p>可以将动画化对象脚本中的某些函数作为事件添加至动画切片中时间轴中某个时间点上，作为动画事件增加动画切片的用途</p>
<p><code>注意:</code></p>
<ol>
<li>在时间轴的某个时间点添加事件后，需要将其与对应对象脚本的函数建立绑定，若该函数带有参数，还必须指定参数</li>
<li>该事件需要作为该动画作用对象的组件进行附加</li>
</ol>
</blockquote>
<h2 id="Animation-Controller-动画控制器"><a href="#Animation-Controller-动画控制器" class="headerlink" title="Animation Controller / 动画控制器"></a>Animation Controller / 动画控制器</h2><blockquote>
<p><code>U3D Document : The Animator Controller acts as a “State Machine” which keeps track of which clip should currently be playing, and when the animations should change or blend together.</code></p>
<p>Controller 用于跟踪当前状态需要播放哪一个动画切片，并管理各切片应何时改变或何时混合</p>
<p><code>U3D Document : An Animator Controller allows you to arrange and maintain a set of animations for a character or other animated Game Object.The controller has references to the animation clips used within it, and manages the various animation states and the transitions between them using a so-called State Machine.</code></p>
<p>Controller 包含对动画切片的引用，通过状态机，Controller 可以管理各动画状态与状态之间的转换</p>
<p><code>U3D Document : However even if you just have a single animation clip you still need to place it into an animator controller to use it on a Game Object.</code></p>
<p>动画切片若想作用于游戏对象，需要通过 Animation Controller 附加到游戏对象上，因此即使只有一个动画切片，也需要由 Animation Controller 控制管理</p>
</blockquote>
<h4 id="Layer-动画层"><a href="#Layer-动画层" class="headerlink" title="Layer / 动画层"></a>Layer / 动画层</h4><blockquote>
<p><code>U3D Document : This allows you to have multiple layers of animation within a single animation controller working at the same time, each controlled by a separate state machine. A common use of this is to have a separate layer playing upper-body animations over a base layer that controls the general movement animations for a character.</code></p>
<p>关键词 : at the same time ，a single animation controller，multiple layers of animation</p>
<p>在一个controller下，同一时刻可以有多种动画同时播放，每个动画分别由独立的状态机控制，例如为了使人物移动更自然，在整体move的base动画层播放时，仍可添加一个上身动画层同时播放以时该动作更自然</p>
<p><code>U3D Document : Unity uses Animation Layers for managing complex state machines for different body parts. </code></p>
<p>动画层可用来处理不同身体部位的复杂状态机，即同时处理不同身体部位的动画，各个部位使用单独的状态机</p>
</blockquote>
<p><strong>Mask / 遮罩</strong></p>
<blockquote>
<p><code>U3D Document : The mask specifies the body parts on which to apply the animation. </code></p>
<p>遮罩用来具化动画应该应用在哪一个身体部位上</p>
</blockquote>
<p><strong>Blending Type / 混合类型</strong></p>
<blockquote>
<p><code>U3D Document : The Blending type specifies how the animation is applied.</code></p>
<p>混合类型用来规范各动画层应如何工作</p>
</blockquote>
<ul>
<li><p>Override / 覆盖 : to use the animation on this layer, replacing the animation on previous layers.</p>
</li>
<li><p>Additive / 附加 : to add the animation on this layer on top of the animation from previous layers.</p>
<p>For additive blending to be successful, the animation on the additive layer must contain the same properties as the previous layers.</p>
</li>
</ul>
<h3 id="Parameters-动画参数"><a href="#Parameters-动画参数" class="headerlink" title="Parameters / 动画参数"></a>Parameters / 动画参数</h3><blockquote>
<p><code>U3D Document : Examples of what the Parameter data can be used for include: </code><br><code>1. Defining Transition conditions</code><br><code>2. Controlling state properties</code><br><code>3. Controlling Blend Trees</code></p>
<p>动画参数可以用于定义转换条件，控制状态的属性，控制混合树</p>
</blockquote>
<ul>
<li><p>Floats</p>
</li>
<li><p>Integers</p>
</li>
<li><p>Booleans</p>
</li>
<li><p>Triggers / 触发器类型</p>
<blockquote>
<p><code>U3D Document : Trigger Parameters are exclusively used to start Transitions. </code></p>
<p>触发器参数专门用于启动某种过渡</p>
</blockquote>
</li>
</ul>
<h3 id="Animation-State-Machines-动画状态机"><a href="#Animation-State-Machines-动画状态机" class="headerlink" title="Animation State Machines / 动画状态机"></a>Animation State Machines / 动画状态机</h3><blockquote>
<p><code>U3D Document : It is common for a character or other animated Game Object to have several different animations that correspond to different actions it can perform in the game.State machine enable you to control and sequence the animation clips that you want to use on your character or object.</code></p>
<p>动画状态机允许你控制动画切片，在游戏对象发生某些行为时，可以播放你想与之对应的动画</p>
<p><code>U3D Document : Taken together, the set of states, the set of transitions and the variable to remember the current state form a state machine.</code></p>
<p>状态集合，状态过渡集合，以及标识记录当前状态的变量形成了状态机</p>
</blockquote>
<h4 id="State-状态"><a href="#State-状态" class="headerlink" title="State / 状态"></a>State / 状态</h4><blockquote>
<p><code>U3D Document : Each state has a Motion associated with it that will play whenever the machine is in that state.</code></p>
<p>在 Animation Controller 中以被线条连接的结点表示，它可以是某个clip动画，也可以是一个子状态机</p>
<p>每种状态对应一种行为，只要在该状态下，就会一直执行该行为直至该状态结束</p>
</blockquote>
<h4 id="State-Machine-Transitions-状态过渡"><a href="#State-Machine-Transitions-状态过渡" class="headerlink" title="State Machine Transitions / 状态过渡"></a>State Machine Transitions / 状态过渡</h4><blockquote>
<p><code>U3D Document : The options for the next state that a character can enter from its current state are referred to as state transitions. </code></p>
<p>从当前状态到下一可进入状态的这些选择被称为状态过渡</p>
<p><code>U3D Document : Each view in the animator window has an Entry and Exit node. These are used during State Machine Transitions.</code></p>
<p><code>The Entry node is used when transitioning into a state machine. </code></p>
<p><code>The Exit node is used to indicate that a state machine should exit.</code></p>
<p>状态机中的开始与退出结点用于过渡</p>
<p><code>U3D Document : It is possible to mix state machine transitions with regular state transtitions, so it is possible to transition from state to state, from a state to a statemachine, and from one statemachine directly to another statemachine.</code></p>
<p>状态机可支持状态机过渡与常规过渡的混合，状态机 &lt;-&gt; 状态机 &lt;-&gt; 状态 &lt;-&gt; 状态 均可支持 </p>
</blockquote>
<h4 id="State-Machine-Behaviours-状态机行为"><a href="#State-Machine-Behaviours-状态机行为" class="headerlink" title="State Machine Behaviours / 状态机行为"></a>State Machine Behaviours / 状态机行为</h4><blockquote>
<p><code>U3D Document : State Machine BehavioursA State Machine Behaviour is a special class of script. In a similar way to attaching regular Unity scripts(MonoBehaviours) to individual GameObjects, you can attach a StateMachineBehaviour script to an individual state within a state machine. This allows you to write code that will execute when the state machine enters, exits or remains within a particular state.</code></p>
<p>状态机行为是特殊的用于状态机的脚本，该脚本可以附加于状态机的某种状态下，可以在该状态进入，更新，退出，移动等等时机调用</p>
<p>该脚本包含的类继承自 StateMachineBehaviour 类</p>
</blockquote>
<ul>
<li>State Machine Behaviours / 状态机行为</li>
<li>State Behaviours / 状态行为</li>
</ul>
<h4 id="Target-Matching-目标匹配"><a href="#Target-Matching-目标匹配" class="headerlink" title="Target Matching / 目标匹配"></a>Target Matching / 目标匹配</h4><blockquote>
<p><code>U3D Document : Often in games, a situation arises where a character must move in such a way that a hand or foot lands at a certain place at a certain time.</code></p>
<p>角色的移动有时需要在动画结束后使得某个身体部位固定到某一个位置，可以在正确点调用 animator.MatchTarget() 函数完成部位结束位置的固定</p>
<p>前提 : </p>
<ol>
<li>需匹配部位在动画发生时的位置</li>
<li>需匹配部位在动画结束时的位置</li>
</ol>
</blockquote>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line">[<span class="meta">RequireComponent(typeof(Animator))</span>] </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TargetCtrl</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Animator animator;    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//the platform object in the scene</span></span><br><span class="line">    <span class="keyword">public</span> Transform jumpTarget = <span class="literal">null</span>; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span> (<span class="params"></span>)</span> &#123;</span><br><span class="line">        animator = GetComponent&lt;Animator&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span> (<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(animator) &#123;</span><br><span class="line">            <span class="keyword">if</span>(Input.GetButton(<span class="string">&quot;Fire1&quot;</span>))         </span><br><span class="line">                animator.MatchTarget(jumpTarget.position, jumpTarget.rotation, AvatarTarget.LeftFoot, </span><br><span class="line">                                                       <span class="keyword">new</span> MatchTargetWeightMask(Vector3.one, <span class="number">1f</span>), <span class="number">0.141f</span>, <span class="number">0.78f</span>);</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Forward-Kinematics-FK正向运动学"><a href="#Forward-Kinematics-FK正向运动学" class="headerlink" title="Forward Kinematics / FK正向运动学 :"></a>Forward Kinematics / FK正向运动学 :</h4><blockquote>
<p><code>U3D Document : Most animation is produced by rotating the angles of joints in a skeleton to predetermined values. The position of a child joint changes according to the rotation of its parent and so the end point of a chain of joints can be determined from the angles and relative positions of the individual joints it contains. This method of posing a skeleton is known as forward kinematics.</code></p>
<p>将关节旋转至预定义的旋转角度可形成动画，子关节的旋转随其父节点的旋转的改变而改变，因此一条关节链的终点可以由该链所包含的关节的角度与相对位置来确定，这种构建骨架的方式称为正向运动学</p>
<p>简言之，即根据父关节的旋转来计算得出每个子关节的位置</p>
</blockquote>
<ul>
<li><p>自带运动曲线，自然</p>
<blockquote>
<p>由父关节带动子关节的运动，因此动画更自然，走路，投弧线更自然一些 </p>
</blockquote>
</li>
<li><p>存在万向锁问题</p>
</li>
</ul>
<h4 id="Inverse-Kinematics-IK逆向运动学"><a href="#Inverse-Kinematics-IK逆向运动学" class="headerlink" title="Inverse Kinematics / IK逆向运动学"></a>Inverse Kinematics / IK逆向运动学</h4><blockquote>
<p><code>U3D Document : Given a chosen position in space, work backwards and find a valid way of orienting the joints so that the end point lands at that position. This approach is known as Inverse Kinematics (IK) and is supported in Mecanim for any humanoid character with a correctly configured Avatar.</code></p>
<p>预先给定的不是该关节的旋转角度，而是空间中的位置，在逆向找到关节定位的方式，最终使得关节链的终点位于该位置</p>
<p>简言之，由末端子关节的位置移动来得出每个父关节的旋转</p>
</blockquote>
<ul>
<li><p>当末端控制器收到物体或空间限制时，IK更方便</p>
<blockquote>
<p>动画涉及牵引，推拉，支撑等可能导致父关节随之变动的动画，IK更方便一些</p>
</blockquote>
</li>
</ul>
<h4 id="Root-Motion-根运动"><a href="#Root-Motion-根运动" class="headerlink" title="Root Motion / 根运动"></a>Root Motion / 根运动</h4><blockquote>
<p>暂略</p>
</blockquote>
<h2 id="Avatar-for-Humanoid-Animation-Avatar系统"><a href="#Avatar-for-Humanoid-Animation-Avatar系统" class="headerlink" title="Avatar for Humanoid Animation / Avatar系统"></a>Avatar for Humanoid Animation / Avatar系统</h2><blockquote>
<p><code>U3D Document : Unity’s Animation system also has numerous special features for handling humanoid characters which give you the ability to retarget humanoid animation from any source (for example: motion capture; the Asset Store; or some other third-party animation library) to your own character model, as well as adjusting muscle definitions. These special features are enabled by Unity’s Avatar system, where humanoid characters are mapped to a common internal format.</code></p>
<p>Avatar系统主要用于处理人形角色动画，它允许我们将任何源中的人形动画重定向到我们的场景人物模型中，使其具有相同动画，并且我们可以重新调整肌肉定义</p>
</blockquote>
<h2 id="Animationtor-Component-动画组件"><a href="#Animationtor-Component-动画组件" class="headerlink" title="Animationtor Component / 动画组件"></a>Animationtor Component / 动画组件</h2><blockquote>
<p><code>U3D Document : Each of these pieces - the Animation Clips, the Animator Controller, and the Avatar, are brought together on a GameObject via the Animator Component. This component has a reference to an Animator Controller, and (if required) the Avatar for this model. The Animator Controller, in turn, contains the references to the Animation Clips it uses.</code></p>
<p>动画需要应用到场景中的游戏对象上，而GameObject的属性行为由组件赋予，因此无论 Animation Clips，Animation Controller or Avatar 均需要通过  Animationtor 组件附加到场景中的游戏对象上，仅当对象为人形角色时才会附加Avatar资源的引用</p>
</blockquote>
<hr>
<p>**Questions : **</p>
<ul>
<li><p><del>the object to be animated</del></p>
</li>
<li><p><del>the animations</del></p>
</li>
<li><p><del>The timing of calling functions within your own scripts</del></p>
<blockquote>
<p><del>脚本中函数的调用时机</del></p>
</blockquote>
</li>
<li><p><del>动画剪辑的关键帧和曲线</del></p>
</li>
<li><p><del>Animation Events 动画事件</del></p>
<blockquote>
<p><del>functions that are called at specified points along the timeline.</del></p>
<p><del>这些函数将在时间轴上的指定点被调用</del></p>
</blockquote>
</li>
<li><p><del>Animation view</del></p>
</li>
<li><p><del>创建动画切片时该动画切片应应用于哪一个游戏对象是否可选定？创建动画切片的正确方式时什么？需要先确定动画化对象再去创建其相应的切片吗？</del></p>
</li>
<li><p><del>如何为指定游戏对象创建动画切片？</del></p>
</li>
<li><p><del>State Machines consist of <strong>States</strong>, <strong>Transitions</strong> and Events 事件怎么体现</del></p>
</li>
<li><p>骨骼</p>
</li>
<li><p>where humanoid characters are mapped to a common internal format.？？？映射为一种什么样的内部格式</p>
</li>
<li><p>Multiple clips cut and sliced from a single imported timeline. ？？？</p>
</li>
<li><p>曲线的关键点？曲线的关键点一旦添加，关键帧清单模式下也会给相应位置添加关键帧，那这个关键点为什么要和关键帧的概念区分开？</p>
</li>
<li><p>万向锁？？？</p>
</li>
<li><p>旋转插值类型？？？</p>
</li>
<li><p>character 是什么概念？？人形角色？</p>
</li>
<li><p>Controllor 状态机的输入参数概念？？该参数的意图在于什么？</p>
</li>
<li><p>状态机的各个状态为什么会自动循环？</p>
</li>
<li><p>transition设置了切换的条件为什么会无效？使用的是默认的参数作比较</p>
</li>
<li><p>状态的进入明白，状态机何时进入？为什么设置了相应的进入行为但是却没有被调用？</p>
</li>
<li><p>标识当前状态的变量？？？？ the variable to remember the current state？？？？</p>
</li>
<li><p>动画层的顺序会有先后显示的含义吗？比如在上面的动画会覆盖下面的动画</p>
</li>
<li><p>动画层mask怎么用？</p>
</li>
<li><p>Animation Layer syncing 动画层同步？？</p>
</li>
</ul>
<hr>
<p>2021/12/27 - 2021/12/30</p>
<hr>
<h2 id="Blend-Trees-混合树"><a href="#Blend-Trees-混合树" class="headerlink" title="Blend Trees / 混合树"></a>Blend Trees / 混合树</h2><blockquote>
<p> <code>U3D Document : Blend Trees are a special type of state in an Animation State Machine.</code></p>
<p>混合树是状态机中一种特殊的状态</p>
<p><code>U3D Document : A common task in game animation is to blend between two or more similar motions. </code></p>
<p>其可以混合多种类似的动画</p>
<p><code>U3D Document : The amount that each of the motions contributes to the final effect is controlled using a blending parameter, which is just one of the numeric animation parameters associated with the Animator Controller.</code></p>
<p>多种动画对最终效果的影响通过 blending parameter 控制，该参数为动画参数之一</p>
<p><code>U3D Document : In order for the blended motion to make sense, the motions that are blended must be of similar nature and timing. </code></p>
<p>被混合的动画需要具有相似的性质与时机，以时混合动画更合理</p>
</blockquote>
<hr>
<p><strong>Questions :</strong> </p>
<ul>
<li>Blend Trees 混合多种动画切片为一个混合动画切片？</li>
<li>Input Manager</li>
<li>动画模型的导入格式</li>
</ul>
<hr>
<p>2021/12/30 16:50</p>
<hr>
<h1 id="Unity3D-Input-Manager-输入"><a href="#Unity3D-Input-Manager-输入" class="headerlink" title="Unity3D Input Manager / 输入"></a>Unity3D Input Manager / 输入</h1><blockquote>
<p> <code>U3D Document : The Input Manager window allows you to define input axes and their associated actions for your Project. </code></p>
<p> 在 Input Manager 完成输入轴的定义与响应操作的关联/绑定</p>
</blockquote>
<h2 id="Input-Type-输入类型"><a href="#Input-Type-输入类型" class="headerlink" title="Input Type / 输入类型"></a>Input Type / 输入类型</h2><blockquote>
<p><code>U3D Document : The type of input that controls the axis.</code></p>
<p>控制虚拟轴的输入类型</p>
</blockquote>
<ul>
<li>Key or Mouse Button / 鼠标/键盘的按钮</li>
<li>Mouse Movement / 鼠标移动</li>
<li>JoyStick Axis / 鼠标杆轴</li>
</ul>
<h2 id="Controls-控件"><a href="#Controls-控件" class="headerlink" title="Controls / 控件"></a>Controls / 控件</h2><ul>
<li><p>Key</p>
<blockquote>
<p><code>U3D Document : refers to any key on a physical keyboard, such as W, Shift, or the space bar.</code></p>
<p>physical keyboard，物理键盘的输入</p>
</blockquote>
</li>
<li><p>Button</p>
<blockquote>
<p><code>U3D Document : refers to any button on a physical controller (for example, gamepads), such as the X button on an Xbox One controller.</code></p>
<p>physical controller，游戏控制器的输入，例如手柄</p>
</blockquote>
</li>
</ul>
<p><code>注意:</code></p>
<ol>
<li>区分控件类型与输入类型，关系为用户的输入操作将激活相应的控件</li>
</ol>
<h2 id="Virtual-Axis-plural-Axes-虚拟轴"><a href="#Virtual-Axis-plural-Axes-虚拟轴" class="headerlink" title="Virtual Axis (plural : Axes) / 虚拟轴"></a>Virtual Axis (plural : Axes) / 虚拟轴</h2><blockquote>
<p><code>U3D Document : Every Project you create has a number of input axes created by default. These axes enable you to use keyboard, mouse, and joystick input in your Project straight away.</code></p>
<p>虚拟轴可以在用户执行输入操作时，接受[-1,1]之间的某个值，该值可用于脚本，从而处理该输入操作将触发的事件</p>
</blockquote>
<h3 id="Properties-轴属性"><a href="#Properties-轴属性" class="headerlink" title="Properties / 轴属性"></a>Properties / 轴属性</h3><table>
<thead>
<tr>
<th align="left"><strong>属性</strong></th>
<th align="left"><strong>功能</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Name</strong></td>
<td align="left">轴名称。使用此名称可以通过脚本来访问轴。</td>
</tr>
<tr>
<td align="left"><strong>Descriptive Name, Descriptive Negative Name</strong></td>
<td align="left">这些值已弃用，不起作用。以前在启动时会在 Rebind Controls 屏幕上为用户显示这些值，但该屏幕也已弃用。</td>
</tr>
<tr>
<td align="left"><strong>Negative Button, Positive Button</strong></td>
<td align="left">用于分别沿负向和正向推动轴的控件。这些控件可以是键盘上的键，也可以是游戏杆或鼠标上的按钮。</td>
</tr>
<tr>
<td align="left"><strong>Alt Negative Button, Alt Positive Button</strong></td>
<td align="left">用于分别沿负向和正向推动轴的备用控件。</td>
</tr>
<tr>
<td align="left"><strong>Gravity</strong></td>
<td align="left">不存在输入时，轴下降到中性点的速度（以单位/秒表示）。</td>
</tr>
<tr>
<td align="left"><strong>Dead</strong></td>
<td align="left">在应用程序对移动操作进行记录之前，用户需要移动模拟摇杆的距离。在运行时，所有模拟设备在该范围内的输入将被视为 null。</td>
</tr>
<tr>
<td align="left"><strong>Sensitivity</strong></td>
<td align="left">轴向目标值移动的速度（以单位/秒表示）。仅用于数字设备。</td>
</tr>
<tr>
<td align="left"><strong>Snap</strong></td>
<td align="left">如果启用此属性，按下对应于反方向的按钮时，轴值将重置为零。</td>
</tr>
<tr>
<td align="left"><strong>Type</strong></td>
<td align="left">这是控制此轴的输入类型。从以下值中进行选择： 键或鼠标按钮 (Key or Mouse button) 鼠标移动 (Mouse Movement) 游戏杆轴 (Joystick Axis)</td>
</tr>
<tr>
<td align="left"><strong>Axis</strong></td>
<td align="left">这是用于控制此轴的连接设备的轴。</td>
</tr>
<tr>
<td align="left"><strong>JoyNum</strong></td>
<td align="left">这是控制此轴的连接游戏杆。可以选择特定游戏杆，或查询所有游戏杆的输入。</td>
</tr>
</tbody></table>
<h2 id="Map-映射"><a href="#Map-映射" class="headerlink" title="Map / 映射"></a>Map / 映射</h2><blockquote>
<p><code>U3D Document : A virtual axis (plural: axes) is mapped to a control, such as a button or a key. When the user activates the control, the axis receives a value in the range of [–1..1]. You can use this value in your scripts.</code></p>
<p>用户的输入操作 -&gt; 激活相应的控件 -&gt; 该控件映射到的轴可以接受相应的[-1,1]之间的某个值 -&gt; 从而脚本获取该值</p>
<p><code>U3D Document : To map a key or button to an axis, enter its name in the Positive Button or Negative Button property in the Input Manager.</code></p>
<p>建立控件与虚拟轴的映射的方式即为设置虚拟轴的 Positive Button 属性 or Negative Button 属性，建立虚拟轴与控件的绑定</p>
</blockquote>
<h2 id="Using-virtual-axes-in-scripts-脚本中使用虚拟轴"><a href="#Using-virtual-axes-in-scripts-脚本中使用虚拟轴" class="headerlink" title="Using virtual axes in scripts / 脚本中使用虚拟轴"></a>Using virtual axes in scripts / 脚本中使用虚拟轴</h2><blockquote>
<p><code>U3D Document : To access virtual axes from scripts, you can use the axis name.</code></p>
<p>使用虚拟轴的名称便可以在脚本中获取轴的值</p>
</blockquote>
<ul>
<li>Input.GetAxis(“AxisName”) 获取 AxisName 轴的值</li>
<li>Input.GetButtonDown(“AxisName”) 对于非移动操作的轴，类比ue4操作映射，应使用该函数获取轴值</li>
</ul>
<h1 id="Unity3D-Models-模型"><a href="#Unity3D-Models-模型" class="headerlink" title="Unity3D Models / 模型"></a>Unity3D Models / 模型</h1><blockquote>
<p><code>U3D Document : Models are files that contain data about the shape and appearance of 3D objects, such as characters, terrain, or environment objects.Model files can contain a variety of data, including meshes, materials, and textures. They can also contain animation data, for animated characters.</code></p>
<p>模型是包含3D对象形状和外观数据的文件，例如角色，地形，或环境对象</p>
<p>模型还可以包含动画数据，若对象为动画化的对象，还可以包含网格体，材质以及纹理等</p>
</blockquote>
<hr>
<p><strong>Questions :</strong> </p>
<ul>
<li>轴的值时干啥用的？</li>
<li>输入类型与控件类型的关系模糊？</li>
<li>人物移动的话应该算key类型的控件，长按如何处理的？如何通过轴的值去处理长按操作的？</li>
<li>是否非移动型的操作映射都可以使用GetButtonDown来接受轴值呢？</li>
</ul>
<hr>
<p>2021/12/30 21:00</p>
]]></content>
      <categories>
        <category>YumiGame</category>
      </categories>
      <tags>
        <tag>Unity - C#</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity - Animation Systems</title>
    <url>/2022/03/22/Unity/Unity_%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="Unity-Animation-Systems-Unity-动画系统"><a href="#Unity-Animation-Systems-Unity-动画系统" class="headerlink" title="Unity Animation Systems / Unity 动画系统"></a>Unity Animation Systems / Unity 动画系统</h1><h1 id="The-Current-Progress-当前进度"><a href="#The-Current-Progress-当前进度" class="headerlink" title="The Current Progress / 当前进度"></a>The Current Progress / 当前进度</h1><ul>
<li>Unity初级编程 - 中级编程 / √</li>
<li>动画系统demo实践 完成模型导入-&gt; 动画绑定 -&gt; 状态机组织动画 / ing</li>
<li>工具 fbx -&gt; motiondate -&gt; 中间数据</li>
<li>ue4状态机 + AI + 行为树</li>
<li>着手AIAnimation框架，着手动画系统的改写</li>
</ul>
<h1 id="Animation-Data-动画数据"><a href="#Animation-Data-动画数据" class="headerlink" title="Animation Data / 动画数据"></a>Animation Data / 动画数据</h1><blockquote>
<p><code>U3D Document : Animation data is stored as an asset called an Animation Clip.</code></p>
<p><code>An Animation Clip can store any GameObject animation.</code></p>
<p><code>Animation Clips are the fundamental building blocks of Unity’s animation systems. </code></p>
<p>动画数据被存储为动画切片，动画切片为动画系统的基本构件</p>
</blockquote>
<h2 id="Animation-Clip-动画切片"><a href="#Animation-Clip-动画切片" class="headerlink" title="Animation Clip / 动画切片"></a>Animation Clip / 动画切片</h2><h4 id="Values-值"><a href="#Values-值" class="headerlink" title="Values / 值"></a>Values / 值</h4><blockquote>
<p><code>U3D Document : The values of an Animation Clip are usually, but not always, represented by Animation Curves.</code></p>
<p>值数据总是以曲线的形式体现</p>
<p> <code>Animation Curves contain information about the way the GameObject you’re animating changes. </code></p>
<p>动画曲线包含了游戏对象动画化的方式信息</p>
</blockquote>
<h4 id="Bindings-绑定"><a href="#Bindings-绑定" class="headerlink" title="Bindings / 绑定"></a>Bindings / 绑定</h4><blockquote>
<p><code>U3D Document : The bindings of an Animation Clip are a way of connecting the values to a particular field of a GameObject or component.</code></p>
<p>绑定 : 将值与游戏对象或组件的具体字段建立关联</p>
<p><code>1. The path through the Hierarchy to the GameObject’s Transform component</code></p>
<p>先将值与游戏对象的相应组件建立关联</p>
<p><code>2. The path from that Transform component to a particular field</code></p>
<p>再将值与相应组件的具体字段建立关联</p>
<p><code>注意:</code></p>
<ol>
<li>每个值都具有其意义，其意义取决于与其一对一绑定的特定字段</li>
</ol>
</blockquote>
<h2 id="Binding-System-绑定系统"><a href="#Binding-System-绑定系统" class="headerlink" title="Binding System / 绑定系统"></a>Binding System / 绑定系统</h2><blockquote>
<p><code>U3D Document : Bindings have two parts ：A Transform path，A Property name.</code></p>
<p>动画窗口中的绑定包含两部分，一个是索引到层级结构中的游戏对象的路径，一个是动画化字段的具体属性名称</p>
<p><code>U3D Document : The Transform path is a string that includes: </code></p>
<p><code>1. The names of the Transforms in the hierarchy that must be traversed to get to the GameObject.</code></p>
<p><code>2. The component and property that is to be animated. </code></p>
<p>转换路径仍为字符串，该字符串格式为 : [ 能在层级结构中索引到存在游戏对象的层级名称 - 动画化的字段名称 ]</p>
<p><code>U3D Document : Any properties on the same GameObject as the Animator component have a blank path, as no Transforms need to be traversed to get to that property. Any properties on a direct child of the GameObject with the Animator component have a Transform path of just that child’s name. This continues down the hierarchy for other GameObjects. </code></p>
<p>Animator 组件所附加上的游戏对象的属性具有默认空白路径，其直接子对象也具有子对象名称起始的默认路径</p>
<p><code>U3D Document : It’s important to remember that this pattern for bindings means that only properties on the same GameObject as the Animator component and below it in the hierarchy can have their properties controlled by the Animator.</code></p>
<p>这种绑定模式意味着 Animator 只能向下控制游戏对象即子游戏对象的动画化属性</p>
</blockquote>
<h3 id="Animation-Mode-动画化方式"><a href="#Animation-Mode-动画化方式" class="headerlink" title="Animation Mode / 动画化方式"></a>Animation Mode / 动画化方式</h3><blockquote>
<p><code>U3D Document : When an animation is playing, the current time for its Animation Clip changes. At any given time, the values for all the bindings are being checked and the fields that those bindings correspond to have their values set.</code></p>
<p>动画一旦开始播放，其时间轴上的时间也将变化，进而完成动画化</p>
<ol>
<li>任意一个时间点，该时间点下的所有绑定对应的值都将被检查</li>
<li>并且与该值也将被设置到其绑定的字段上</li>
</ol>
</blockquote>
<h1 id="Animation-Blending-动画混合"><a href="#Animation-Blending-动画混合" class="headerlink" title="Animation Blending / 动画混合"></a>Animation Blending / 动画混合</h1><blockquote>
<p><code>U3D Document : Sometimes when a GameObject is playing an animation, you’ll want to change which animation is playing or play another animation at the same time. When multiple animations are played at the same time and through the same GameObject hierarchy, the animations are doing what is called blending. </code></p>
<p>动画混合的使用场景为你期望改变游戏对象正在播放的动画或者同时播放多个动画在同一个游戏对象上</p>
<p><code>U3D Document : When you play more than one Animation Clip at the same time, Unity blends them together. The result of the blend is then applied to the bindings. </code></p>
<p>当播放超过一个的动画切片时，Unity会将这些动画混合后应用于绑定</p>
<p><code>U3D Document : To blend Animation Clips, each animation has a relative weight. These weights are used to calculate how much influence each individual Animation Clip has on the final animation. </code></p>
<p>动画权重的意义在于指出被混合的每一个动画切片对最终动画的影响</p>
</blockquote>
<h2 id="Blending-Algorithms-混合算法"><a href="#Blending-Algorithms-混合算法" class="headerlink" title="Blending Algorithms / 混合算法"></a>Blending Algorithms / 混合算法</h2><blockquote>
<p><code>U3D Document : All the algorithms follow the same overall process: </code></p>
<p><code>Each animation is given a weight. This weight represents how much the animation affects the result of the blend.</code></p>
<p>首先，每个混合的动画切片将具有其混合权重</p>
<p><code>Higher weights mean the animation will have more of an effect and lower weights mean the animation will have less of an effect. </code></p>
<p>该混合权重用于表示该动画切片对混合结果动画的影响，权重值越高，意味着影响越大，混合结果与该动画越接近</p>
<p><code>Typically, weights are normalized. This means that the sum of the weights for all the animations being blended equals one. </code></p>
<p>并且该权重值时规范化的，意味着所有动画切片的权重值之和为1</p>
</blockquote>
<ul>
<li><p>Weighted Sum / 加权平均</p>
<blockquote>
<p>遍历所有混合切片的绑定，将某时刻下每个动画切片的绑定值与对应切片的动画权重相乘后累加作为该时刻下的混合结果，并将该结果写入到绑定</p>
</blockquote>
</li>
</ul>
<h2 id="Features-Using-Blending-混合应用"><a href="#Features-Using-Blending-混合应用" class="headerlink" title="Features Using Blending / 混合应用"></a>Features Using Blending / 混合应用</h2><ul>
<li><p>Transitions / 过渡</p>
<blockquote>
<p><code>U3D Document : As the Transition continues, the weight of it increases, while the weight of the previous state decreases.</code></p>
<p>当过渡发生时，过渡前的状态权重降低，过渡后的状态权重增加</p>
</blockquote>
</li>
<li><p>Blending Trees / 混合树</p>
<blockquote>
<p><code>U3D Document : Blend Trees are used in place of a single Animation Clip in a state. They blend the multiple Animation Clips they contain. </code></p>
<p>混合树可以混合多种动画并作为一种状态参与过渡</p>
</blockquote>
</li>
<li><p>Layer / 动画层</p>
<blockquote>
<p><code>U3D Document : Blending in Layers works slightly differently than with Transitions and Blend Trees. All the animation in a Layer is completely evaluated before it’s then blended with the next Layer. The result of this blend is then evaluated before it is blended with subsequent Layers, and so on. </code></p>
<p>动画层的混合，在该层与下一动画层混合前，会评估该层的所有动画</p>
</blockquote>
</li>
</ul>
<h2 id="Nested-Blending-混合嵌套"><a href="#Nested-Blending-混合嵌套" class="headerlink" title="Nested Blending / 混合嵌套"></a>Nested Blending / 混合嵌套</h2><blockquote>
<p><code>U3D Document : Animation blending can be nested. Weighting happens multiplicatively, so each Animation Clip has its weight calculated before the final result is calculated. </code></p>
<p>动画混合可以被嵌套，在最终结果被计算之前，每个动画切片将计算其自身权重</p>
</blockquote>
<h2 id="Animator-Controller-动画控制器"><a href="#Animator-Controller-动画控制器" class="headerlink" title="Animator Controller / 动画控制器"></a>Animator Controller / 动画控制器</h2><blockquote>
<p><code>U3D Document : An Animator Controller is a way of controlling when an Animation Clip starts playing and how it’s blended with other Animation Clips. </code></p>
<p>动画控制器用于控制动画切片的播放时机以及动画切片之间的混合方式</p>
<p><code>U3D Document : They are a collection of logical States, containing one or more Animation Clips. </code></p>
<p>动画控制器是一组逻辑状态的集合，包含一个或多个动画切片</p>
<p><code>U3D Document : The Animator Controller takes a path between these States, evaluating the Animation Clip(s) in the State currently being played. </code></p>
<p>控制器将选取状态之间的一条路径来评估当前状态下应播放的动画切片</p>
<p><code>U3D Document : The States are connected by Transitions, which blend the Animation Clips of the States they connect together. </code></p>
<p>状态通过 transition 来完成过渡混合</p>
</blockquote>
<h3 id="Animator-Transition-状态过渡"><a href="#Animator-Transition-状态过渡" class="headerlink" title="Animator Transition / 状态过渡"></a>Animator Transition / 状态过渡</h3><blockquote>
<p><code>U3D Document : Transitions are used to blend two animations together. </code></p>
<p>Transitions 被用于状态之间的过渡混合</p>
<p><code>U3D Document : Transitions are a blend between one Animator State and another. </code></p>
<p>过渡是状态之间的混合</p>
<p><code>注意:</code></p>
<ol>
<li>默认 Entry 下的过渡是不可预览的，即没有以下各 Settings</li>
</ol>
</blockquote>
<h4 id="Current-and-Next-States-当前与下一状态"><a href="#Current-and-Next-States-当前与下一状态" class="headerlink" title="Current and Next States / 当前与下一状态"></a>Current and Next States / 当前与下一状态</h4><blockquote>
<p><code>U3D Document : When a Transition starts, the Animator State that is being Transitioned to (which is called the **next State**) starts playing. </code></p>
<p>当过渡发生时，Next State 开始播放</p>
<p><code>U3D Document : At this point, the next State has a weight of 0 and the Animation State that is being transitioned from (which is called the current State) has a Weight of 1. </code></p>
<p>当过渡发生时，Next State 将获得0的权重，Current State (过渡发生的状态) 将获得1的权重</p>
<p><code>U3D Document : As the Transition continues, both Animation States continue to play and the Weight of the current State starts reducing as the next State increases linearly. When the Weight of the current State reaches **0** (which will happen at the end of the Transition), it stops playing and the next State becomes the new current State. </code></p>
<p>当过渡持续进行时，Current State 的权重不断变小，同时 Next State 的权重线性增加，直至 Current State 权重减小至0，Next State 成为 Current State</p>
</blockquote>
<h4 id="Transition-Settings-过渡设置"><a href="#Transition-Settings-过渡设置" class="headerlink" title="Transition Settings / 过渡设置"></a>Transition Settings / 过渡设置</h4><ul>
<li><p>Multiple Transitions / 多重过渡</p>
<blockquote>
<p>可在两个过渡之间重复添加多个过渡，多重过渡具有三个箭头</p>
</blockquote>
</li>
<li><p>Conditions / 条件</p>
<blockquote>
<p>条件依附于动画参数而存在，根据判断动画参数的状态的来设置过渡条件</p>
<p><code>U3D Document : When these statements are satisfied, the Transition will start. </code></p>
<p>当所有条件均满足时才会发生过渡，并且可以设置条件判断的优先级</p>
</blockquote>
</li>
<li><p>Exit Time / 退出时间</p>
<blockquote>
<p>float 类型，表明当前状态播放百分之 n(n为退出时间 * 100) 后开始过渡，若想当前状态至少播放一次完毕后再过渡，该值需要大于1</p>
<p><code>U3D Document : Exit Time is the time at which a Transition starts. This is measured in the Normalized Time of the current state. </code></p>
<p>Exit Time 可控制 Current State 发生过渡的时机，该值通过归一化时间来衡量</p>
<p><code>The Normalized Time on the previous frame is less than the Exit Time.</code></p>
<p><code>The Normalized Time on the current frame is greater than the Exit Time.</code></p>
<p>只有在上一帧状态的归一化时间小于 Exit Time，当前帧的归一化时间大于 Exit Time 时，过渡才会发生</p>
</blockquote>
</li>
<li><p>Transition Duration / 持续时间</p>
<blockquote>
<p><code>U3D Document : To control the length of time a Transition takes.</code></p>
<p><code>U3D Document : seconds, if Fixed Duration is enabled</code></p>
<p><code>U3D Document : Normalized Time of the current State, if Fixed Duration is disabled </code></p>
<p>控制过渡持续的时间，可以秒/s或者归一化时间来衡量，取决于 Fixed Duration 是否被选中</p>
<p><code>U3D Document : Transition duration in normalized time from current state</code></p>
<p>若使用归一化时间，则表示相对于 Current State 的时间</p>
</blockquote>
</li>
<li><p>Transition Offset / 过渡偏移</p>
<blockquote>
<p><code>U3D Document : You want the animations you’re blending to do so smoothly, so it’s important for the animations to be in phase like they were when you were manually adjusting the weights of the Circle and Square Animation Clips. </code></p>
<p>动画混合时为了使混合更自然，因此被混合的动画应该处于相位态，即上一个动画从50%结束时，下一个动画不能从头开始而应该也从50%处开始播放，这样才能在调整权重之后动画过渡更自然</p>
<p><code>U3D Document : The offset is the Normalized Time of the next State at which the State will start playing when the Transition occurs. </code></p>
<p>过渡偏移是相对于 Next State 的归一化时间，用于设置过渡发生时 Next State 的播放内容，或者说过渡发生时，Next State 的播放起始点</p>
<p><code>注意:</code></p>
<ol>
<li>偏移时间应该根据退出时间而定，自上一动画的退出时间点来设置下一动画的偏移量</li>
</ol>
</blockquote>
</li>
<li><p>Transition Interruption / 过渡中断</p>
<blockquote>
<p><code>U3D Document : Transitions can be interrupted by other Transitions. When this happens, the values for the animation at the current frame of the Transition are stored and act as the current State for the interrupting Transition.</code></p>
<p>当前过渡可以被其他过渡中断，当中断过渡发生时，将保存当前帧下属性在当前过渡下的值，并作为中断过渡的 Current State</p>
<p><code>U3D Document : This means that the blend for the interrupting Transition happens between a single time on the original Transition and the interrupting Transition’s next State. </code></p>
<p>这意味着中断类型的过渡发生于 Current Transition 的中断点 与 Interrupting Transition 的 Next State 之间，而不是 Current State 与 Next State 之间</p>
<p><code>注意:</code></p>
<ol>
<li>默认情况下过渡在发生时是不允许中断的，需要通过下列设置手动触发该机制</li>
</ol>
</blockquote>
</li>
<li><p>Interruption Source / 中断源</p>
<blockquote>
<p><code>U3D Document : Animator Controllers maintain a list of Transitions that can currently be taken for each Animation Layer. These Transitions have their Conditions and Exit Time checked each frame. By default, this list only contains Transitions from the Any State followed by the current State’s Transition list.</code></p>
<p>Animator Controllers 将维护一个 Transitions 列表，区别于每个状态下的 Orderable Transitions 列表，该列表每一帧都会检查列表下所有过渡的条件与退出时间，以便可作为源进行 Transition Interruption，该列表默认情况下仅包含任何状态的转换与当前状态下的转换</p>
<p><code>U3D Document : However, when an Animation Layer is transitioning, this list of Transitions is replaced by the Transitions from the Any State and whatever additional Transitions are defined by the Interruption Source of the current Transition. </code></p>
<p>Transitions 列表中的过渡发生时，其可以被其他过渡所取代，这取决于 Interruption Source 选中的源，非 None 的情况下会将选中源的 Orderable Transitions 添加至 Transitions 列表中，用于 Transition Interruption</p>
</blockquote>
</li>
<li><p>Ordered Interruption / 有序中断</p>
<blockquote>
<p><code>U3D Document : Ordered Interruption controls whether Transitions of lower priority on the current State can interrupt the Transition. If this property is enabled, Transitions of lower priority on the current State cannot interrupt the Transition because of their lower order.</code></p>
<p>该选项用于控制低优先级的过渡是否可以中断 Current Transition ，若被选中，则低优先级的不允许中断 Current Transition</p>
</blockquote>
</li>
<li><p>Any State / 任何状态</p>
<blockquote>
<p><code>U3D Document : Each layer in an Animator Controller has a special node called Any State. This node allows Transitions to be made from it but not to it, so that no matter what State is currently playing, a Transition can happen. </code></p>
<p>Animator Controller 的每一动画层下均有一个 Any State 状态，该状态可以过渡至任何状态，但是不允许其他状态过渡至该状态，Any State 状态即使未播放，其下的过渡仍可以发生</p>
<p><code>U3D Document : The Any State node appears in all State machines for convenience, but it only has a single list of Transitions. Each instance of the Any State node in an Animation Layer is the same one.</code></p>
<p>每个状态机下均存在 Any State，但是 Any State 仅会有一个实例，即每个动画层下的 Any State 使用同一个 Transitions List</p>
<p><code>U3D Document : In each frame, the Animator Controller checks a list of Transitions to see whether any of them should start. It checks them in order, starting with all the Transitions from the Any State node and then all the Transitions from the current State. </code></p>
<p>Animator Controller 每一帧均会检查该 Transitions List，检查该列表下的所有过渡是否应该发生，先检查源为 Any State 的过渡，然后是源为 Current State 的过渡</p>
<p><code>注意:</code></p>
<ol>
<li>Any State 下的过渡是逐帧检查的，使用时需要注意该条件</li>
</ol>
</blockquote>
</li>
</ul>
<h3 id="State-Machines-状态机"><a href="#State-Machines-状态机" class="headerlink" title="State Machines / 状态机"></a>State Machines / 状态机</h3><blockquote>
<p><code>U3D Document : State Machines are purely an organisational tool. State Machines allow you to group States and Transitions together</code></p>
<p>状态机仅仅是一种状态与过渡组织管理工具，处理复杂动画时很有用</p>
<p><code>U3D Document : Each Animator Controller has one or more Animator Layers (or Layers), and each Animator Layer contains a State Machine. However, any State Machine may also have additional State Machines nested within it. </code></p>
<p>每个 Animator Controller 将有一个或多个 Layers，而每个动画层将包含一个状态机，状态机还可以有附加的子状态机</p>
</blockquote>
<h4 id="State-Machine-Transitions-状态机过渡"><a href="#State-Machine-Transitions-状态机过渡" class="headerlink" title="State Machine Transitions / 状态机过渡"></a>State Machine Transitions / 状态机过渡</h4><blockquote>
<p>可以由外部状态 &lt;-&gt; 状态机，也可以外部状态 &lt;-&gt;状态机内部状态，还可以状态机内部状态 &lt;-&gt; 状态机</p>
</blockquote>
<ul>
<li><p>Entry Node and Exit Node / 进入与退出状态</p>
<blockquote>
<p><code>U3D Document : The Entry and Exit nodes are used for Transitions to/from the State Machine itself. </code></p>
<p>仅用于进入与退出子状态机状态本身</p>
</blockquote>
</li>
<li><p>Up Node / Up状态</p>
<blockquote>
<p><code>U3D Document : The Up node represents a direct Transition between the internal and external nodes. </code></p>
<p>Up Node 用于子状态机内部与外部状态的直接转换</p>
</blockquote>
</li>
</ul>
<h3 id="Animator-Layers-动画层"><a href="#Animator-Layers-动画层" class="headerlink" title="Animator Layers / 动画层"></a>Animator Layers / 动画层</h3><blockquote>
<p><code>U3D Document : Animator Layers are a way of playing multiple animations at the same time and blending the result.</code></p>
<p>动画层也是一种同时播放多种动画并混合结果的一种方式</p>
<p><code>1. The blending overrides what’s happening on other Animator Layers.</code></p>
<p>一种混合方式是覆盖至其他动画层播放的动画上</p>
<p><code>2. The blending adds to what is happening on other Animator Layers.</code></p>
<p>一种混合方式是附加到其他动画层播放的动画上</p>
</blockquote>
<ul>
<li><p>Animator Layer indices / 索引</p>
<blockquote>
<p><code>U3D Document : The base Layer has an index of 0 and all subsequent Layers have indices incrementing from there.</code></p>
<p>Base Layer 使用0索引，其余动画层以此递增</p>
<p><code>U3D Document : Animator Layers are evaluated in ascending index order, starting with 0.</code></p>
<p>动画层将按索引顺序被计算/评估，自0索引开始计算</p>
</blockquote>
</li>
<li><p>Animator Layer weights / 权重</p>
<blockquote>
<p><code>U3D Document : Each Animator Layer has a weight that determines its contribution to the final result. </code></p>
<p>每个动画层均具有权重用于表示其对混合结果的影响程度</p>
</blockquote>
</li>
</ul>
<h4 id="Animator-Layer-Blending-Layer-混合"><a href="#Animator-Layer-Blending-Layer-混合" class="headerlink" title="Animator Layer Blending / Layer 混合"></a>Animator Layer Blending / Layer 混合</h4><blockquote>
<p>动画层的计算将按索引顺序计算评估，因此会先计算 Layer0 的动画，之后计算 Layer1 的动画并与 Layer0 混合</p>
<p>混合方式 : 1. 计算当前动画层的动画 2. 与之前 Layer 动画混合结果进行混合</p>
</blockquote>
<ul>
<li><p>Mask / 遮罩</p>
<blockquote>
<p><code>U3D Document : When you’re working on a transform animation or humanoid animation, it can often be useful to only animate part of a skeleton at once.</code></p>
<p>一般使用人形动画时可能会使用遮罩，使得某些骨骼不受某些动画的影响，该动画控制的绑定将不会写入到设定的骨骼中，骨骼设定取决于 Avatar Mask</p>
</blockquote>
</li>
<li><p>Override Blending / 覆盖</p>
<blockquote>
<p><code>U3D Document : Override blending is similar to the blending used by Transitions and 1D Blend Trees. As the contribution from the next Animator Layer increases, the contribution from the previous  Animator Layers decreases. </code></p>
<p>覆盖混合类型类似于过渡混合于1D混合树混合，当前动画层权重增加时，之前混合结果的权重将降低</p>
<p><code>U3D Document : The weight of the previous Animator Layers is equal to the inverse of the overriding (next) Animator Layer.</code></p>
<p>当前动画层权重与之前混合动画结果权重的关系 : 相加为1</p>
</blockquote>
</li>
<li><p>Additive Blending / 附加</p>
<blockquote>
<p><code>U3D Document : This is used to support additive animation. Additive animation is when the animation itself is stored as a delta (or change) from a reference pose.</code></p>
<p>附加动画将以相对于参考姿势的增量形式存储</p>
<p><code>U3D Document : When you use Additive blending, the already evaluated Animator Layers always have an effective weight of 1. Any animation from the Additive Animator Layer is added to the contribution from those Layers. The animation data is taken as a delta (or change) between a default value and its current value to calculate the weighted contribution. </code></p>
<p>当使用附加绑定类型时，已评估的混合结果将始终具有1的权重，而任何来自 Additive Layer 层的动画数据将以增量形式存储并附加于之前的混合动画中</p>
<p><code>注意:</code></p>
<ol>
<li>若将未设置附加动画参考姿势的切片所在的 Layer 设置为使用附加绑定类型，则可能导致不期望的结果</li>
</ol>
</blockquote>
</li>
</ul>
<h4 id="Sync-and-IK-Pass-同步与IK"><a href="#Sync-and-IK-Pass-同步与IK" class="headerlink" title="Sync and IK Pass / 同步与IK"></a>Sync and IK Pass / 同步与IK</h4><ul>
<li><p>Sync / 同步</p>
<blockquote>
<p><code>U3D Document : This will create an identical State Machine to the one on the source Animator Layer. </code></p>
<p>同步将创建一个与源动画层完全相同的状态机</p>
<p><code>U3D Document : By default, the State Machine will match the timing of the source State Machine. This means that when Transitions happen in the source Animator Layer, they will also happen in the synced Animator Layer. </code></p>
<p>默认情况下，同步层与原动画层的状态机时间将匹配，即状态机管理下的过渡发生时机将相同</p>
<p><code>U3D Document : However, if Timing is enabled, State durations will be an interpolation of the source Animator Layer’s Animation Clip length and the synced Animator Layer’s Animation Clip length. They will be based on the weight of the synced Animator Layer. </code></p>
<p>若选中 Timing，则状态的持续时间将不再与原动画层状态相同，而是根据同步层的权重，对源动画层切片持续时间与同步层切片持续时间进行插值，使用此插值作为同步层切片持续时间</p>
</blockquote>
</li>
<li><p>IK Pass</p>
<blockquote>
<p><code>U3D Document : This setting is just for humanoid animation. </code></p>
<p>仅适用于具有IK系统的人形动画</p>
<p><code>U3D Document : If it’s enabled, it will cause methods for evaluating IK to be called on MonoBehaviours on the same GameObject as the Animator component, as well in State Machine behaviours for this Animator Layer. </code></p>
<p>若其被选中，则造成 MonoBehaviours 脚本与 State Machine behaviours 状态机行为中的IK评估方法被调用</p>
</blockquote>
</li>
</ul>
<hr>
<p>**Questions: **</p>
<ul>
<li><del>动画切片的组成 - 绑定是什么概念？一对一绑定是什么东西？</del></li>
<li>Multiple Transitions / 多重过渡 时所有条件均满足？还是满足其一？</li>
<li><del>多个过渡条件时全部满足时才发生过渡？</del></li>
<li> <del>Current Transition 是用来指定中断过渡的源的？</del></li>
<li>状态机之间的过渡，是如何混合的？？</li>
</ul>
<hr>
<p>2022/1/7 21:42 - 2022/1/10 17:52</p>
<h1 id="Model-Specific-Animation-模型动画"><a href="#Model-Specific-Animation-模型动画" class="headerlink" title="Model-Specific Animation / 模型动画"></a>Model-Specific Animation / 模型动画</h1><h2 id="Fundamentals-基础"><a href="#Fundamentals-基础" class="headerlink" title="Fundamentals / 基础"></a>Fundamentals / 基础</h2><blockquote>
<p><code>U3D Document : Models in Unity are represented by a Mesh of triangles. When you want to animate a model, the Mesh must be deformed so that its triangles change position and shape. </code></p>
<p>模型是由三角形组成的网格体表示的，当动画化模型时，其网格体需要作出改变，以便其三角形改变位置与形状</p>
<p><code>U3D Document : Models can contain too many triangles for each of them to be moved individually. The higher the definition of a model, the greater the number of triangles. </code></p>
<p>但是模型越复杂，其所包含的三角形越多，因此当改变网格体时，手动逐个操作具体的三角形是不现实的</p>
<p><code>U3D Document : Instead of moving each triangle individually during animation, models are skinned before they are animated.</code></p>
<p>取而代之的是在动画化模型之前，先对模型进行蒙皮</p>
<p><code>U3D Document : Skinning gives each of the vertices making up the triangles a dependence on a bone. This bone is then moved using animation data and the associated vertices work out where they should be based on the bone’s position and rotation.</code></p>
<p>蒙皮使模型的三角形顶点依附于骨骼而运动，形成动画数据控制骨骼的移动，骨骼带动绑定到其上的三角形顶点的运动</p>
<p><code>U3D Document : Bone hierarchies and the way they affect meshes are part of Rigs.</code></p>
<p>骨骼影响网格体运动的方式由 Rigs 决定</p>
<p><code>U3D Document : In Unity, bones are represented by Transforms.</code></p>
<p>在Unity中，骨骼由 Transforms 表示</p>
</blockquote>
<h3 id="Triangle-Mesh-三角网格"><a href="#Triangle-Mesh-三角网格" class="headerlink" title="Triangle Mesh / 三角网格"></a>Triangle Mesh / 三角网格</h3><blockquote>
<p><code>U3D Document : Generally, animated models have a skinned mesh. </code></p>
<p>动画化的模型一般都会有一个蒙皮网格体</p>
<p><code>U3D Document : Skinning is the process of connecting each vertex of a mesh to one or multiple bones and then giving those bones a weight to affect that vertex. </code></p>
<p>而蒙皮使模型每个网格体的顶点会关联到一个或多个骨骼，这些骨骼被赋予了权重来决定对顶点移动的影响程度</p>
<p><code>U3D Document : In Unity, bones are represented by the Transforms of a model，which are part of GameObjects, so each vertex moves with a weighted combination of the Transforms it is skinned to. </code></p>
<p>在Unity中，骨骼通过模型的 Transforms 来表示，即游戏对象上的 transform 组件，所以网格体顶点的移动将跟随其附加到的所有 Transforms 权重组合的变化而变化 </p>
<p><code>注意:</code></p>
<ol>
<li>一个模型可能有多个游戏对象用以表示多个骨骼</li>
</ol>
</blockquote>
<h3 id="Forward-Kinematics-FK正向动力学"><a href="#Forward-Kinematics-FK正向动力学" class="headerlink" title="Forward Kinematics / FK正向动力学"></a>Forward Kinematics / FK正向动力学</h3><blockquote>
<p><code>U3D Document : This means that child Transforms move relative to their parents.</code></p>
<p>子变换依赖于父变换，由父变换带动子变换</p>
</blockquote>
<h3 id="Inverse-Kinematics-IK逆向动力学"><a href="#Inverse-Kinematics-IK逆向动力学" class="headerlink" title="Inverse Kinematics / IK逆向动力学"></a>Inverse Kinematics / IK逆向动力学</h3><blockquote>
<p><code>U3D Document : This is where the end of a chain of bones has its position or rotation set, and then the positions and rotations of bones further up the chain are set via an algorithm to accommodate the end bone’s position and rotation.</code></p>
<p>IK中，骨骼链的末端骨骼有其位置与旋转集，骨骼链更深层次的骨骼运动将由算法计算，来适应末端骨骼的位置与旋转</p>
</blockquote>
<h2 id="Model-Specific-Import-Settings-模型导入设置"><a href="#Model-Specific-Import-Settings-模型导入设置" class="headerlink" title="Model-Specific Import Settings / 模型导入设置"></a>Model-Specific Import Settings / 模型导入设置</h2><blockquote>
<p><code>U3D Document : When models are imported from digital content creation (DCC) programs, they have animation settings that are split into two sections: </code></p>
<p><code>1. Model-specific settings, which affect all animations imported with that model.</code></p>
<p><code>2. Animation-specific settings, which affect individual animations imported with that model.</code></p>
<p>当模型是由GCC程序集导入时，其动画设置具有针对于整个动画模型的设置，也具有针对于某个具体动画切片的设置，以下为部分 Model-specific settings</p>
</blockquote>
<ul>
<li><p>Import Constraints</p>
<blockquote>
<p>是否导入相应的关节约束</p>
</blockquote>
</li>
<li><p>Import Animation</p>
<blockquote>
<p>是否将模型对应的动画导入，若不勾选则无其余动画设置</p>
</blockquote>
</li>
<li><p>Baking animations / 烘焙动画</p>
<blockquote>
<p><code>U3D Document : This determines whether animations imported as inverse kinematics (IK) or simulation data should be converted into forward kinematics (FK) through a process called baking. </code></p>
<p>该设置表明以 IK 或 仿真数据 导入的动画，是否应该被转换为 FK 数据，烘焙后将以 FK 格式存储动画数据</p>
</blockquote>
</li>
<li><p>Resampling Animation Curves / 重新采样</p>
<blockquote>
<p><code>U3D Document : This setting determines whether animations imported with euler angles for their rotations should have these converted to quaternion angles instead. </code></p>
<p>该设置表明是否应该将以欧拉角定义旋转的数据应转换为以四元数定义</p>
<p><code>注意: </code></p>
<ol>
<li>this option is only available for models with generic rigs, as humanoid rigs are automatically resampled. </li>
<li>if an animation makes a rotation greater than 180 degrees between frames.  注意是否存在180°旋转</li>
</ol>
</blockquote>
</li>
<li><p>Animation Compression / 动画压缩优化</p>
<blockquote>
<p><code>The Animation Compression setting refers to how the animation’s size, both on disk and in memory, can be reduced by making approximations from the original imported file. </code></p>
<p>该设置可以选择 对原始动画的近似方式 来减少动画数据在内存以及硬盘中所占的大小</p>
<ol>
<li>off / 不压缩</li>
<li>Keyframe Reduction / 减少关键帧</li>
<li>Optimal / 最优</li>
</ol>
</blockquote>
</li>
<li><p>Custom Properties / 定制属性</p>
</li>
</ul>
<h2 id="Animation-Specific-Import-Settings-切片导入设置"><a href="#Animation-Specific-Import-Settings-切片导入设置" class="headerlink" title="Animation-Specific Import Settings / 切片导入设置"></a>Animation-Specific Import Settings / 切片导入设置</h2><h3 id="Cutting-Imported-Animation-Clips-剪切动画切片"><a href="#Cutting-Imported-Animation-Clips-剪切动画切片" class="headerlink" title="Cutting Imported Animation Clips / 剪切动画切片"></a>Cutting Imported Animation Clips / 剪切动画切片</h3><blockquote>
<p><code>U3D Document : You’ll use animation-specific settings to cut an imported Animation Clip. One of the most common uses for cutting animation is using motion capture (or mocap) data, but it can be used to adjust any imported animation. </code></p>
<p>使用 animation-specific 针对动画切片的设置完成对导入动画的剪切</p>
</blockquote>
<h3 id="Timeline-时间轴"><a href="#Timeline-时间轴" class="headerlink" title="Timeline / 时间轴"></a>Timeline / 时间轴</h3><blockquote>
<p><code>U3D Document : The animation timeline shows all of the animation data for the current Animation Clip</code></p>
<p>时间轴显示了当前选中动画切片的动画数据</p>
<p><code>U3D Document : There are handles you can drag to set the start and end of the Animation Clip to cut the take.</code></p>
<p>通过拖拽切片来对动画切片进行剪切，也可通过 Start 与 End 完成对剪切点的选择</p>
</blockquote>
<h3 id="Timeline-Settings-时间轴设置"><a href="#Timeline-Settings-时间轴设置" class="headerlink" title="Timeline Settings / 时间轴设置"></a>Timeline Settings / 时间轴设置</h3><ul>
<li><p>Loop Time / 循环时间</p>
<blockquote>
<p><code>U3D Document : If the Loop Time setting is enabled, the animation will begin again at the start once it finishes. </code></p>
<p>只有选中了 Loop Time 选项，动画才会循环播放</p>
</blockquote>
</li>
<li><p>Loop Pose / 循环姿势</p>
<blockquote>
<p><code>U3D Document : The Loop Pose setting changes the values of the keyframes in the Animation Clip so that they match at the start and end. </code></p>
<p>选中 Loop Pose 会改变关键帧的值以便该动画切片的关键帧在 start 与 end 处可匹配关联，使其不会在循环时发生突变，循环更自然</p>
</blockquote>
</li>
<li><p>Cycle Offset / 周期偏移</p>
<blockquote>
<p><code>U3D Document : Cycle Offset adjusts when the Animation Clip actually starts in the frame range you have selected. </code></p>
<p>Cycle Offset 可用于调整剪切后的该动画真正开始的时间，相对于选中 start 的偏移量</p>
<p><code>U3D Document : It is measured in Normalized Time, which means that a value of 0.2 would start the Animation Clip 20% of the way into the selected frame range.</code></p>
<p>该值若为0.2，则代表由剪切后切片的20%处开始播放，注意此时 Plane 预览面板的动画时间初始值也随之变化</p>
<p><code>U3D Document : When blending similar animations, it makes sense for them to be in phase. </code></p>
<p>该设置在混合动画时很有用，被混合的动画切片可能需要具备相应的条件，比如设置标准化的起始姿势</p>
</blockquote>
</li>
</ul>
<h3 id="Root-Motion-根运动"><a href="#Root-Motion-根运动" class="headerlink" title="Root Motion / 根运动"></a>Root Motion / 根运动</h3><blockquote>
<p><code>U3D Document : Root nodes are used to define Root Motion in animations. Root Motion is when an animation causes GameObjects to offset from their previous position, rather than just moving in absolute terms.This means you can make movements look a lot more realistic, as they can be based on the animation itself and not simply scripted. </code></p>
<p>根运动是指一个动画导致游戏对象的位置发生变动，而不是通过绝对值移动，这意味着你可以作出更自然的移动，因为这些移动将基于动画本身</p>
<p><code>U3D Document : For example, if a GameObject is animated to move forward on its z-axis, then with Root Motion, the GameObject would continue to move further and further along the z-axis as the animation loops. Without Root Motion, whenever the animation loops, the GameObject would return to where it started and then move forward in its z-axis again. </code></p>
<p>例如动画中游戏对象将沿z轴移动，那么场景中随着动画的循环播放，游戏对象将一直沿z轴移动，但是如果没有根运动，那么场景中游戏对象只会随动画循环播放而不断地从初始位置移动，再恢复，再移动</p>
<p><code>U3D Document : You can fix these things by baking some elements of the Root Motion into the pose. This means they won’t affect the Root Motion at all.</code></p>
<p>可以将切片的 Root Motion 中某些元素 bake into the pose 来使这些元素不会影响根运动</p>
</blockquote>
<ul>
<li><p>Root Node / 根节点</p>
<blockquote>
<p><code>U3D Document : The Root node is used as a reference for this Motion.</code></p>
<p>根节点用作根运动的参考</p>
</blockquote>
</li>
</ul>
<h3 id="Additional-Settings-其他设置"><a href="#Additional-Settings-其他设置" class="headerlink" title="Additional Settings / 其他设置"></a>Additional Settings / 其他设置</h3><h4 id="Mirror-Setting-镜像设置"><a href="#Mirror-Setting-镜像设置" class="headerlink" title="Mirror Setting / 镜像设置"></a>Mirror Setting / 镜像设置</h4><blockquote>
<p><code>U3D Document : This particular setting is exclusively for humanoid rigged animation.</code></p>
<p>镜像设置针对于人形动画</p>
<p><code>U3D Document : When enabled, the Mirror setting flips the animation on the YZ plane down the character’s middle. Since this flips both the pose and the Root Motion, you can use it for making a left turn into a right turn, for example.</code></p>
<p>勾选镜像设置后，模型YZ平面将以人物中心为轴翻转</p>
<p><code>注意:</code></p>
<ol>
<li>翻转后根运动也将受影响</li>
</ol>
</blockquote>
<h4 id="Additive-Reference-Pose-Setting-附加引用姿势"><a href="#Additive-Reference-Pose-Setting-附加引用姿势" class="headerlink" title="Additive Reference Pose Setting / 附加引用姿势"></a>Additive Reference Pose Setting / 附加引用姿势</h4><blockquote>
<p><code>U3D Document : By using Additive Animation, you can build on and make alterations to any existing animation. </code></p>
<p>该设置可以以已存在的动画为基础，并在此基础上作出更改，更改将覆盖原绑定的值</p>
<p><code>U3D Document : Since Additive Animation is added to an existing animation, it’s stored as deltas from a Reference Pose. Deltas are small differences or changes.</code></p>
<p>因为附加动画已被附加至已存在的动画，所以附加动画以针对于参考/原动画姿势的增量形式存储</p>
<p><code>U3D Document : Make an animation be treated as Additive Animation :</code></p>
<p><code>1. In the Inspector, enable Additive Reference Pose</code></p>
<p><code>2. Select the frame number that should serve as the reference pose.</code></p>
<p>创建 Additive Animation 的方式是先勾选附加选项，然后选择作为参考姿势的帧，该帧上的值将被作为默认值，之后附加的动画将以此为参考进行增量式存储</p>
</blockquote>
<h4 id="Curves-曲线"><a href="#Curves-曲线" class="headerlink" title="Curves / 曲线"></a>Curves / 曲线</h4><blockquote>
<p><code>U3D Document : When Animation Clips are imported, their curves are locked and will appear as read-only. However, as part of the import process, more curves can be added so you can edit them. These curves can be used to store data that can vary over the course of the animation and should not be confused with the standard Animation Curves you have used when creating and editing Animation Clips.  </code></p>
<p>此曲线区别于动画曲线，该曲线用于存储动画播放过程中随之改变的数据，用于编辑</p>
<ol>
<li> Select the Add (+) button under the Curves foldout. </li>
<li> Name the curve, so its value can be found at runtime. </li>
<li> Make sure the associated Animator Controller has a parameter with the same name as your curve. </li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>确保该曲线名称与该动画切片附加到的控制器某参数具有相同的名称</li>
</ol>
</blockquote>
<h4 id="Events-事件"><a href="#Events-事件" class="headerlink" title="Events / 事件"></a>Events / 事件</h4><blockquote>
<p><code>U3D Document : In the Animation Importer, where there is an option for the Animation Clip to have an Animation Event added.</code></p>
<p>导入动画模型时，可以为动画切片在没有具体游戏对象上下文的情况下添加事件</p>
<p><code>注意:</code></p>
<ol>
<li>注意添加事件调用方法名需要与之后将调用的方法一致</li>
</ol>
</blockquote>
<hr>
<p><strong>Questions:</strong> </p>
<ul>
<li>simulation data 仿真是个什么样的动画数据？</li>
<li><del>rather than just moving in absolute terms 什么意思？</del></li>
<li><del>Root Motion / 根运动</del></li>
<li><del>Curves / 曲线 曲线的名称和某控制器参数要相同？为什么要相同，是因为这个曲线控制的就是该参数嘛？</del></li>
</ul>
<hr>
<p>2022/1/11 15:42 - 2022/1/11 21:35</p>
<hr>
<h1 id="Model-Rig-模型Rig"><a href="#Model-Rig-模型Rig" class="headerlink" title="Model Rig /  模型Rig"></a>Model Rig /  模型Rig</h1><blockquote>
<p><code>U3D Document : Rigs are a way of defining the structure of the model being imported and are used to define how animations play.</code></p>
<p>Rig 定义了模型导入时的结构以及其所有附加动画的播放方式</p>
</blockquote>
<h2 id="Configuring-Generic-Rigs-配置-Generic-Rig"><a href="#Configuring-Generic-Rigs-配置-Generic-Rig" class="headerlink" title="Configuring Generic Rigs / 配置 Generic Rig"></a>Configuring Generic Rigs / 配置 Generic Rig</h2><ul>
<li><p>Animation Type setting / 动画类型设置</p>
<blockquote>
<ol>
<li>None</li>
<li>Legacy</li>
<li>Generic</li>
<li>Humaniod</li>
</ol>
</blockquote>
<p><strong>Humaniod Animation Type / 人形动画类型</strong></p>
<blockquote>
<p><code>1. The model has animations that are intended to be played through another Humanoid model with a different hierarchical structure.</code></p>
<p>当本模型动画的用途为被不同层级结构下的人形模型使用时，需要将模型动画类型设置为 Humaniod</p>
<p><code>2. You’re using the model to play animations that are from Humanoid models with a different hierarchical structure.</code></p>
<p>当本模型的动画使用的是不同层级结构下其他模型的动画时，需要将模型动画类型设置为 Humaniod</p>
<p><code>3. You want to use the built-in Humanoid features, such as arm and leg IK or target matching.</code></p>
<p>当使用内置人形功能时，需要将模型动画类型设置为 Humaniod</p>
</blockquote>
</li>
<li><p>Avatar Definition / Avatar 定义</p>
<blockquote>
<p><code>U3D Document : Avatars are an asset representation of the model’s Rig. They take different forms depending on whether the Rig is Generic or Humanoid.</code></p>
<p>Avatar 是资产，在 Project 窗口可见，代表了模型的 Rig，Avatar 类型由模型 Rig 类型决定</p>
</blockquote>
</li>
<li><p>Root Node / 根节点设置</p>
</li>
<li><p>Skin Weights / 蒙皮权重</p>
<blockquote>
<p><code>U3D Document : The Skin Weights setting allows you to adjust how many bones a vertex can be skinned to. </code></p>
<p>可以设置一个网格体顶点可以附加多少骨骼，默认为4个</p>
</blockquote>
</li>
<li><p>Optimize Game Objects / 优化游戏对象</p>
<blockquote>
<p><code>U3D Document : Models can have very complicated hierarchies. This can result in having many GameObjects that are there simply to define the positions of the vertices of a skinned mesh. </code></p>
<p>模型可能有复杂的层级结构，这将导致其附加有多个游戏对象仅用于表示蒙皮网格体的顶点位置</p>
<p><code>U3D Document : If Optimize GameObjects is enabled, all GameObjects that have no components on them are removed. The Skinned Mesh is then moved directly by the animation. </code></p>
<p>启用该设置将使模型上所有没有其他组件的游戏对象被移除，蒙皮骨骼的运动将由动画驱使</p>
<p><code>U3D Document : To keep the GameObject(s), you need to use the Expose Extra Transforms settings. </code></p>
<p>通过 Expose Extra Transforms 选项可以选择保留某些游戏对象而不被优化移除</p>
</blockquote>
</li>
<li><p>Generic Avatar Masks / Avatar 遮罩</p>
<blockquote>
<p><code>U3D Document : Avatar Masks are a way of preventing animation data from being written to its binding. </code></p>
<p>Avatar Masks 可以用于防止动画数据的值被写入到绑定</p>
<p><code>U3D Document : Transform data is not used from sources that have been masked.</code></p>
<p>变换数据将不会被写入到被遮罩的源</p>
<p><code>注意:</code></p>
<ol>
<li>It’s important to remember that Avatar Masks only mask Transform data. They do not mask data on the same GameObject as a masked Transform.</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Configuring-Humaniod-Rigs-配置-Humaniod-Rig"><a href="#Configuring-Humaniod-Rigs-配置-Humaniod-Rig" class="headerlink" title="Configuring Humaniod Rigs / 配置 Humaniod Rig"></a>Configuring Humaniod Rigs / 配置 Humaniod Rig</h2><blockquote>
<p><code>U3D Document : The core difference between Generic Rigs and Humanoid Rigs is their Avatars. Humanoid Rigs require Avatars to play their animations, which is not the case for Generic Rigs. This is because Humanoids are a special case; their Transform hierarchy is mapped to the bones of a human-like shape.</code></p>
<p>Humanoid Rigs 区别于 Generic Rigs 的点就是 Humanoid Avatars，Humanoid Rigs 要求由 Humanoid Avatars 播放动画，人形模型的 Transform 被映射到 human-like shape 上的骨骼</p>
</blockquote>
<h3 id="Animation-Playback-Process-人形动画播放过程"><a href="#Animation-Playback-Process-人形动画播放过程" class="headerlink" title="Animation Playback Process / 人形动画播放过程"></a>Animation Playback Process / 人形动画播放过程</h3><blockquote>
<p><code>U3D Document : Under normal circumstances, in order for an animation to be shared among multiple targets, each target must have an identical hierarchy with identical names to those on the Animation Clip. This is because the names of Transforms are used to construct the bindings of an Animation Clip. If the hierarchy through which an Animation Clip is being played doesn’t have a specific binding, the binding is just ignored. This means that if the names don’t match, the animation won’t play.</code></p>
<p>标准绑定方式 : 要实现动画切片在不同对象下的共享，需要使播放该切片的游戏对象群具有与动画切片相同的名称层级结构 (因为切片就是通过名称来建立的绑定)，即需要具有动画切片绑定要求的字段，如果没有该字段，绑定无法建立，则动画播放时将忽略这些绑定</p>
<p><code>U3D Document : When an imported model is a Humanoid, its Animation Clips are no longer played using just standard bindings. Instead, the parts of the Animation Clips that match the Humanoid definition are played through the Avatar. </code></p>
<p>Humanoid 动画绑定 : 当导入的模型为 Humanoid 时，将不再使用标准建立切片名称与对象动画化字段的直接绑定，而是先建立与 Avatar 的 Mapping/绑定，最后由 Avatar 将值写入到对象的字段上，完成动画的播放</p>
<p><code>U3D Document : At import time, Animation Clips from Humanoid models are converted from writing to Transforms directly to writing to Muscles instead. These are called Muscle Clips. At runtime, Muscle Clips are converted back to write to Transforms. </code></p>
<p>Humanoid 动画绑定 : 在导入时，会将人形模型的动画切片作转换，使绑定由 与对象字段的直接绑定 转换为 与肌肉 的绑定，转换后形成 Muscle Clips，再将值 写入到 / 绑定 到对象的动画化字段上</p>
<p><code>U3D Document : Because all humanoids have this mapping, any Humanoid Animation Clip can be played through any Humanoid model.</code></p>
<p>所有 humanoids 具有该映射(肌肉绑定)，因此该动画切片可以被所有人形模型共享</p>
</blockquote>
<p>On import : Animation Clip with Transform bindings → Humanoid Avatar → Muscle Clip</p>
<p>At runtime : Muscle Clip → Humanoid Avatar → set Transform properties</p>
<h3 id="Avatar-configuration-Avatar-配置"><a href="#Avatar-configuration-Avatar-配置" class="headerlink" title="Avatar configuration / Avatar 配置"></a>Avatar configuration / Avatar 配置</h3><h4 id="Mapping-绑定"><a href="#Mapping-绑定" class="headerlink" title="Mapping / 绑定"></a>Mapping / 绑定</h4><blockquote>
<p><code>U3D Document : The mapping defines exactly which of the model’s Transforms is linked to which of the pre-defined Humanoid bones.</code></p>
<p>定义模型的 Transforms 具体绑定到 Avatar 哪一个预定义的人形骨骼上</p>
<p><code>U3D Document : Each dot on the diagram refers to a bone. If the dot has a solid outline then the bone is required in order for the mapping to work. If the dot has a dotted outline, the bone is optional. The more optional bones you map, the higher the quality of the retargeting.</code></p>
<p>human-like shape 上的每一个点代表骨骼，实心代表必须建立人形模型与该骨骼的映射，非实心表示可选，可选骨骼越多，重定向质量越高</p>
</blockquote>
<ul>
<li><p>Automap 自动完成骨骼的映射</p>
</li>
<li><p>Animation Pose / 标准姿势</p>
<blockquote>
<p><code>U3D Document : They form a reference pose from which animations are measured. Each rotation and translation in an animation is compared to this reference pose when it’s converted to and from a Muscle Clip. Because this pose is so important, Unity uses a standard animation pose as the target all humanoid models should aim for: the T-pose.</code></p>
<p>Avatar 中每个 Transforms 将具有旋转与位置属性，他们将形成一个参考姿势，这些属性在进行 Avatar &lt;–&gt; Muscle Clip 之间的转换时会被参考，因此 Unity 使用 T-pose 作为默认参考姿势，建议在 Mapping 时将 pose 强制为 T-pose</p>
</blockquote>
</li>
</ul>
<h4 id="Muscles-amp-Settings-肌肉设置"><a href="#Muscles-amp-Settings-肌肉设置" class="headerlink" title="Muscles &amp; Settings / 肌肉设置"></a>Muscles &amp; Settings / 肌肉设置</h4><blockquote>
<p><code>U3D Document : Muscle definitions exist as a range within or beyond which a bone is expected to rotate on a given axis. </code></p>
<p>肌肉以范围的形式存在，代表骨骼绕指定轴可旋转的范围</p>
</blockquote>
<ul>
<li><p>Normalised Range / 统一化范围</p>
<blockquote>
<p><code>U3D Document : This range is normalised, which means that rotations at one end of the range would have a value of 0 and rotations at the other end of the range would have a value of 1.</code></p>
<p>标准的范围为 [0,1]</p>
<p><code>U3D Document : Transform rotations are converted into these normalised rotation ranges at import time. The normalised rotation ranges are then converted back into Transform rotations at runtime.</code></p>
<p>Muscle 将于 导入时 转换为 Normalised Range 统一范围，运行时再进一步根据具体 Muscle 范围定义转换为 Transform rotations 具体旋转，这样可以方便于重定向，因为不同人形模型的 Muscle 范围定义可能不同，当动画某一帧要求旋转指定角度时，需要先参照 Avatar 的 Muscle 的标准范围，再进一步转换为实际 Transform rotations</p>
</blockquote>
</li>
</ul>
<h4 id="Humanoid-Avatar-Masks-Avatar-遮罩"><a href="#Humanoid-Avatar-Masks-Avatar-遮罩" class="headerlink" title="Humanoid Avatar Masks / Avatar 遮罩"></a>Humanoid Avatar Masks / Avatar 遮罩</h4><blockquote>
<p><code>U3D Document : Avatar Masks are a way of preventing animation data from being written to its binding. </code></p>
<p>Avatar Masks 可以用于防止动画数据的值被写入到绑定</p>
<p><code>U3D Document : Transform data is not used from sources that have been masked.</code></p>
<p>变换数据将不会被写入到被遮罩的源</p>
<p><code>注意:</code></p>
<ol>
<li>It’s important to remember that Avatar Masks only mask Transform data. They do not mask data on the same GameObject as a masked Transform.</li>
</ol>
</blockquote>
<h1 id="Animation-Windows-动画窗口"><a href="#Animation-Windows-动画窗口" class="headerlink" title="Animation Windows / 动画窗口"></a>Animation Windows / 动画窗口</h1><h2 id="Keyframes-关键帧"><a href="#Keyframes-关键帧" class="headerlink" title="Keyframes / 关键帧"></a>Keyframes / 关键帧</h2><blockquote>
<p><code>U3D Document : These keyframes hold information on the value of the Animation Curve at a specific time, as well as how to interpolate the values in-between.</code></p>
<p>关键帧记录有曲线在特定时间下的特定值，以及在两值之间插值的方式</p>
</blockquote>
<h2 id="Keyframes-Tangents-关键帧切线"><a href="#Keyframes-Tangents-关键帧切线" class="headerlink" title="Keyframes Tangents / 关键帧切线"></a>Keyframes Tangents / 关键帧切线</h2><blockquote>
<p><code>U3D Document : The value of an Animation Curve at any given time is the interpolation between the previous and next Keyframe. The exact value of this interpolation is calculated using the tangents of the Keyframes.</code></p>
<p>关键帧切线可以用于计算两关键帧之间任意时刻的插值</p>
<p><code>U3D Document : Each Keyframe has two tangents: An in-tangent (on the left), An out-tangent (on the right)</code></p>
<p>每个关键帧有两个切线，一个为内切线(左侧)，一个为外切线(右侧)</p>
<p><code>U3D Document : The exceptions to this are the first and last keyframes: the in- and out-tangents of the first and last Keyframes are connected to each other for the purposes of editing looped animation.</code></p>
<p>但是第一个关键帧与最后一个关键帧的切线相互连接，便于编辑循环动画</p>
</blockquote>
<h2 id="Animation-Events-动画事件"><a href="#Animation-Events-动画事件" class="headerlink" title="Animation Events / 动画事件"></a>Animation Events / 动画事件</h2><blockquote>
<p><code>U3D Document : Animation Events call methods in MonoBehaviour scripts. In order for an Animation Event to call a method from a script, the script must be attached to the same GameObject as the Animator component through which the Animation Clip is playing.</code></p>
<p>动画事件调用 MonoBehaviour 脚本下的方法，为了保证事件能够调用到脚本中的方法，该方法必须被附加同一个游戏对象上</p>
</blockquote>
<h1 id="Animator-Component-动画器组件"><a href="#Animator-Component-动画器组件" class="headerlink" title="Animator Component / 动画器组件"></a>Animator Component / 动画器组件</h1><h2 id="Animator-Parameters-动画参数"><a href="#Animator-Parameters-动画参数" class="headerlink" title="Animator Parameters / 动画参数"></a>Animator Parameters / 动画参数</h2><blockquote>
<p><code>U3D Document : Examples of what the Parameter data can be used for include: </code><br><code>1. Defining Transition conditions</code><br><code>2. Controlling state properties</code><br><code>3. Controlling Blend Trees</code></p>
<p>动画参数可以用于定义转换条件，控制状态的属性，控制混合树</p>
</blockquote>
<ul>
<li><p>Floats</p>
</li>
<li><p>Integers</p>
</li>
<li><p>Booleans</p>
</li>
<li><p>Triggers / 触发器类型</p>
<blockquote>
<p><code>U3D Document : Trigger Parameters are exclusively used to start Transitions. </code></p>
<p>触发器参数专门用于启动某种过渡</p>
</blockquote>
</li>
</ul>
<h2 id="Animator-Component-Properties-Animator-属性"><a href="#Animator-Component-Properties-Animator-属性" class="headerlink" title="Animator Component Properties / Animator 属性"></a>Animator Component Properties / Animator 属性</h2><ul>
<li><p>Avatar Setting</p>
<blockquote>
<p><code>U3D Document : The Avatar setting of the Animator component is optional, unless you’re animating a character with a Humanoid rig.</code></p>
<p>只有具有 humaniod rig 的角色需要设置 Avatar </p>
</blockquote>
</li>
<li><p>Apply Root Motion</p>
<blockquote>
<p><code>U3D Document : The Apply Root Motion setting determines whether or not any change to the Position or Rotation of the Root node will be applied.</code></p>
<p>该设置在于动画中对根节点位置与旋转的更改是否应用到场景中</p>
</blockquote>
</li>
<li><p>Update Mode / 更新模式</p>
<blockquote>
<p><code>U3D Document : The Update Mode of an Animator component affects when the code of the Animator is executed to update the properties it controls.  </code></p>
<p>该模式在于控制 更新其控制的动画化属性的时机</p>
<ol>
<li>Normal (In time with the render system between the Update and LateUpdate method calls. )</li>
<li>Animate Physics (In time with the physics system after the FixedUpdate method call. )</li>
<li>Unscaled Time (In time with the render system, but is not affected by Time.timeScale. This means that the speed of the animation will not change. )</li>
</ol>
</blockquote>
</li>
<li><p>Culling Mode / 剔除模式</p>
<blockquote>
<p><code>U3D Document : This setting affects what can cause the Animator to pause its updates for efficiency.  </code></p>
<p>剔除模式控制为效率而暂停动画的方式</p>
<ol>
<li>Always Animate 不剔除</li>
<li>Cull Update Transforms 只要 Animator 下的渲染器边界位于摄像机视椎体之外，则停止该Animator的动画，但是仍保留根运动</li>
<li>Cull Completely 只要 Animator 下的渲染器边界位于摄像机视椎体之外，则停止该Animator的动画以及根运动</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Animator-State-Settings-状态设置"><a href="#Animator-State-Settings-状态设置" class="headerlink" title="Animator State Settings / 状态设置"></a>Animator State Settings / 状态设置</h2><ul>
<li><p>Name and Tag / 名称与标签</p>
<blockquote>
<p><code> U3D Document : These are both strings that are purely used for identification.</code></p>
<p>字符串类型用于标识状态身份</p>
<p><code>U3D Document : the Name must be unique but the Tag doesn’t need to be.</code></p>
<p>Name 字符串需要唯一，Tag 字符串不需要唯一</p>
</blockquote>
</li>
<li><p>Motion / 运动</p>
<blockquote>
<p>可以为动画切片或者混合树</p>
</blockquote>
</li>
<li><p>Speed and Multiplier / 速度与乘数</p>
<blockquote>
<p><code>U3D Document : You can use the next group of settings to manipulate how the Motion is played. </code></p>
<p>用于操纵 Motion 的播放速度，Multiplier 可成倍变化，可设置初始值后通过参数调整</p>
</blockquote>
</li>
<li><p>Motion/Normalized Time / 归一化时间</p>
<blockquote>
<p><code>U3D Document : Another way to control how an Animator State plays is by directly controlling its Normalized Time. </code></p>
<p>Normalized Time 仍用于控制状态的播放方式</p>
<p><code>U3D Document : Normalized Time is the concept of having the current time of the Motion being measured between 0 and 1.</code></p>
<p>归一化时间使用[0,1]来表示播放状态，0时开始播放，1时播放完毕</p>
</blockquote>
</li>
<li><p>Cycle Offset / 周期偏移</p>
<blockquote>
<p><code>U3D Document : This setting works alongside Normalized Time, in that it sets the Normalized Time the State will start playing at. If you want to change this, you can set it to a Float or have it controlled by a Float Parameter.</code></p>
<p>配合 Motion Time 使用，使用浮点数参数来控制偏移量</p>
</blockquote>
</li>
<li><p>Humanoid Settings - Mirror / 镜像</p>
<blockquote>
<p><code>U3D Document : Mirror reflects an animation from left to right. </code></p>
</blockquote>
</li>
<li><p>Humanoid Settings - Foot IK / 足部IK</p>
<blockquote>
<p><code>U3D Document : Foot IK uses the Muscle Clip data to estimate when each foot is supposed to be planted on the ground. When using Foot IK, the foot’s position is locked. </code></p>
<p>Foot Ik 用于判定何时哪只脚固定到地面上，此时足部的位置将被锁定，一般用于防止应处于固定态的足部运动</p>
</blockquote>
</li>
<li><p>Additional Settings - Write Defaults / 写入默认值</p>
<blockquote>
<p><code>U3D Document : An Animator gathers all the bindings from all the Animation Clips it contains and writes to each of them every frame.</code></p>
<p>一个 Animator 将聚集所有动画切片的所有绑定，并且每帧将绑定的值写入对应属性</p>
<p><code>U3D Document : When the Motion of an Animator State doesn’t write to a particular binding, If you enable Write Defaults, the default value of that binding is written to it. If you disable it the binding is not written to, and therefore keeps its previous value.</code></p>
<p>但是 Animator 状态的绑定未写入时，若勾选该设置，则使用默认值写入绑定，否则，不写入绑定保持原值</p>
</blockquote>
</li>
<li><p>Additional Settings - List of Transitions / 优先级</p>
<blockquote>
<p><code>U3D Document : The list is the priority order for the Transitions, meaning that their conditions will be checked in the order that’s shown on the list.</code></p>
<p>可以用于设置状态机中状态过渡的优先级</p>
</blockquote>
</li>
</ul>
<h2 id="State-Transitions-Settings-状态过渡设置"><a href="#State-Transitions-Settings-状态过渡设置" class="headerlink" title="State Transitions Settings / 状态过渡设置"></a>State Transitions Settings / 状态过渡设置</h2><hr>
<p><strong>Questions :</strong> </p>
<ul>
<li><del>Avatar Masks 的具体设置不是很理解</del></li>
<li><del>Normalised Range 与 Transform rotations 的转换</del></li>
<li>You want to use the built-in Humanoid features, such as arm and leg IK or target matching. 谁使用内置人形功能？人形功能是什么样的功能？</li>
<li>Controlling state properties 参数的用途2，3</li>
<li>Unscaled Time 更新模式 没概念</li>
<li>Layer / 动画层 动画层的混合权重应用 没概念</li>
<li>Nested Blending / 绑定嵌套 没概念</li>
<li>过渡完成时 Current State 是否具有1的权重，当下一过渡发生时，才会具有1的权重？</li>
</ul>
<hr>
<p>2022/1/12 15:51</p>
<hr>
<h1 id="General-Animation-Scripting-通用动画脚本"><a href="#General-Animation-Scripting-通用动画脚本" class="headerlink" title="General Animation Scripting / 通用动画脚本"></a>General Animation Scripting / 通用动画脚本</h1><blockquote>
<p><code>U3D Document : Most of the scripting discussed here is for methods found on the Animator component. Finding a reference to the Animator component is an assumed step before using any of these methods.</code></p>
<p>动画脚本基于 Animator 组件，因此在获取 Animator 属性前，需要先获取 Animator 组件的引用</p>
</blockquote>
<h3 id="Controlling-Animator-Parameter-Values-控制动画参数值"><a href="#Controlling-Animator-Parameter-Values-控制动画参数值" class="headerlink" title="Controlling Animator Parameter Values / 控制动画参数值"></a>Controlling Animator Parameter Values / 控制动画参数值</h3><blockquote>
<p><code>U3D Document : One of the most common reasons you might need to get the value of an Animator parameter is if it’s not being set by script but instead by an imported animation.</code></p>
<p>一般获取动画参数的原因不在于获取通过脚本设置的参数值，而是通过导入模型设置的参数值</p>
<p><code>U3D Document : Imported animations have the option to use additional Animation Curves, and each of these additional Animation Curves must have a name. If this name is the same as a float Animator Parameter, then while the animation is being evaluated the parameter will have its value set to that of the Animation Curve. </code></p>
<p>因为导入模型附加有动画曲线，该曲线仍具有名称，若该名称与动画参数同名，那么参数的值该跟随曲线而变化</p>
<p><code>U3D Document : These Animation Curves are subject to weighting, so if two animations are being blended, the value of the Animator Parameter will be a blend between its values for each animation.</code></p>
<p>由于动画曲线具有混合权重，因此混合时动画参数也将被混合</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SetParametersExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span> Animator animator;</span><br><span class="line">   <span class="comment">// 一般使用动画参数名称的哈希值来作函数参数，防止同名混淆</span></span><br><span class="line">   <span class="comment">// Animator.StringToHash(string) 获取string的哈希值</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">int</span> speedParameterHash = Animator.StringToHash(<span class="string">&quot;Speed&quot;</span>);</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>   &#123;</span><br><span class="line">       <span class="comment">//animator.SetBool(string name, Bool value) / animator.GetBool(string name)</span></span><br><span class="line">	<span class="comment">//animator.SetFloat(...) / animator.GetFloat(...)</span></span><br><span class="line">	   <span class="comment">//animator.SetInteger(...) / animator.GetInteger(...)</span></span><br><span class="line">	<span class="comment">//animator.SetTrigger(...) / animator.GetTrigger(...)</span></span><br><span class="line">       <span class="comment">//string 参数可使用 int 类型的哈希值代替</span></span><br><span class="line">       animator.SetFloat(speedParameterHash, <span class="number">5f</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Controlling-Animator-Layer-Weights-控制动画层权重"><a href="#Controlling-Animator-Layer-Weights-控制动画层权重" class="headerlink" title="Controlling Animator Layer Weights / 控制动画层权重"></a>Controlling Animator Layer Weights / 控制动画层权重</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">animator.SetLayerWeight()</span><br><span class="line"><span class="built_in">float</span> shootingLayerWeight = animator.GetLayerWeight (<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Flow-Control-流程控制"><a href="#Flow-Control-流程控制" class="headerlink" title="Flow Control / 流程控制"></a>Flow Control / 流程控制</h3><blockquote>
<p><code>U3D Document : Although one of the main jobs of Animator Parameters is to control Transitions, sometimes you might prefer to take control of the flow of animations that play more individually.</code></p>
<p>较于通过动画参数控制过渡，可以通过某些方法直接控制播放的动画</p>
</blockquote>
<ul>
<li><p>Play and PlayInFixedTime</p>
<blockquote>
<p><code>U3D Document : Play a State of a given name. They just do it slightly differently. </code></p>
<p>播放指定名称下的状态</p>
<p><code>注意:</code></p>
<ol>
<li>两者区别仅在于第三个参数，Play 为归一化的时间，PlayInFixedTime 为秒</li>
</ol>
</blockquote>
</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FlowControlExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Animator animator;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">int</span> shootStateHash = Animator.StringToHash(<span class="string">&quot;Shoot&quot;</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">int</span> walkStateHash = Animator.StringToHash(<span class="string">&quot;Walk&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        animator.Play(<span class="string">&quot;Run&quot;</span>, <span class="number">0</span>, <span class="number">0.1f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            Parameters:</span></span><br><span class="line"><span class="comment">                string/int : 指定待播放状态的名称/名称哈希值</span></span><br><span class="line"><span class="comment">                int : 指定待播放状态所在动画层的索引</span></span><br><span class="line"><span class="comment">                float : 指定待播放状态的播放时机，以 Current 状态为基准</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(Input.GetKeyDown(KeyCode.Space))</span><br><span class="line">            animator.PlayInFixedTime(shootStateHash, <span class="number">1</span>, <span class="number">0f</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(Input.GetKeyDown(KeyCode.LeftShift))</span><br><span class="line">            animator.Play(walkStateHash, <span class="number">0.5f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>CrossFade and CrossFadeInFixedTime</p>
<blockquote>
<p><code>U3D Document : It works more like Transitions.</code></p>
<p>目前认为该方法用于创建无条件临时过渡</p>
</blockquote>
</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FlowControlExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Animator animator;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">int</span> shootStateHash = Animator.StringToHash(<span class="string">&quot;Shoot&quot;</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">int</span> walkStateHash = Animator.StringToHash(<span class="string">&quot;Walk&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        animator.Play(<span class="string">&quot;Run&quot;</span>, <span class="number">0</span>, <span class="number">0.1f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            Parameters:</span></span><br><span class="line"><span class="comment">                string / int : The name of the State to be cross faded to (as either a string or a hash of the State’s name)</span></span><br><span class="line"><span class="comment">                float : How long the fade should take / 过渡持续时间</span></span><br><span class="line"><span class="comment">                int : The index of the Layer of the State being cross-faded to / 动画层索引</span></span><br><span class="line"><span class="comment">                float : The offset through the State being transitioned to / Next 状态的偏移量</span></span><br><span class="line"><span class="comment">                float : The time through the fade to start at / 此参数必须为归一化时间</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.LeftShift))</span><br><span class="line">            animator.CrossFade(walkStateHash, <span class="number">1f</span>, <span class="number">0</span>, <span class="number">0.1f</span>, <span class="number">0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="MonoBehaviour-Messages-消息"><a href="#MonoBehaviour-Messages-消息" class="headerlink" title="MonoBehaviour Messages / 消息"></a>MonoBehaviour Messages / 消息</h3><ul>
<li><p>OnAnimatorMove()</p>
<blockquote>
<p><code>U3D Document : However, if a MonoBehaviour calls the OnAnimatorMove method, then it controls the Root Motion. </code></p>
<p>OnAnimatorMove 可以用于控制根运动，可以调用 animator.deltaPosition，animator.deltaRotation 来完成对根运动的设置</p>
<p><code>U3D Document : An empty OnAnimatorMove method will make an Animator behave as though it has no Root Motion. </code></p>
<p>若该方法为空，则 Animator 无根运动</p>
</blockquote>
</li>
<li><p>Update Mode / 更新模式</p>
<blockquote>
<p>Normal : Update() -&gt; OnAnimatorMove() -&gt; OnAnimatorIK() -&gt; LateUpdate()</p>
<p>Animate Physics : FixedUpdate() -&gt; OnAnimatorMove() -&gt; Internal Update(物理系统内置更新用于检测碰撞) -&gt; OnAnimatorIK()</p>
</blockquote>
</li>
</ul>
<h3 id="State-and-Animation-Clip-Information-获取状态与切片信息"><a href="#State-and-Animation-Clip-Information-获取状态与切片信息" class="headerlink" title="State and Animation Clip Information / 获取状态与切片信息"></a>State and Animation Clip Information / 获取状态与切片信息</h3><ul>
<li><p>animator.IsInTransition(…)</p>
<blockquote>
<p>可获取某一动画层是否处于过渡状态</p>
</blockquote>
</li>
<li><p>animator.GetCurrentAnimatorStateInfo(…) / animator.GetNextAnimatorStateInfo(…)</p>
<blockquote>
<p>可获取某动画层当前状态以及下一状态的信息，若无下一状态，则返回默认值</p>
</blockquote>
</li>
<li><p>AnimatorStateInfo 结构</p>
<blockquote>
<p><code>U3D Document : It contains concise information about the State such as: Length，Hashes for the name and tag，Speed.&quot; </code></p>
<p>其包含状态的某些信息，如状态长度，名称的哈希值，播放速度等</p>
</blockquote>
</li>
<li><p>animator.GetCurrentAnimatorClipInfo(…) / animator.GetNextAnimatorClipInfo(…)</p>
<blockquote>
<p><code>U3D Document : They both have an index parameter for the Animator Layer, but instead return an array of AnimatorClipInfos. </code></p>
<p>获取某动画层的所有状态信息，返回 AnimatorClipInfos 数组</p>
</blockquote>
</li>
<li><p>AnimatorClipInfos 结构</p>
<blockquote>
<p><code>U3D Document : These are structs with a reference to the Animation Clip being played and its Weight. This Weight is the blending weight, meaning it takes both Blend Trees and Transitions into account. It does not take the weights of Animator Layers into account.</code></p>
<p>AnimatorClipInfos 结构存放着动画切片的引用以及其权重，同时考虑了混合树与过渡的权重，但是 Layer 权重不考虑在内</p>
</blockquote>
</li>
</ul>
<h1 id="Humanoid-Specific-Animation-Scripting-人形动画脚本"><a href="#Humanoid-Specific-Animation-Scripting-人形动画脚本" class="headerlink" title="Humanoid-Specific Animation Scripting / 人形动画脚本"></a>Humanoid-Specific Animation Scripting / 人形动画脚本</h1><h2 id="Target-Matching-and-IK-目标匹配与IK"><a href="#Target-Matching-and-IK-目标匹配与IK" class="headerlink" title="Target Matching and IK / 目标匹配与IK"></a>Target Matching and IK / 目标匹配与IK</h2><blockquote>
<p><code>U3D Document : However, sometimes you might want to set the position or rotation of a bone near the bottom of the hierarchy (called the effector) separately. In this case, the rest of the hierarchy needs to change to accommodate the effector’s position or rotation. </code></p>
<p>可以通过目标匹配或IK，完成更改效应器(骨骼链末端骨骼)的位置与旋转，进而更新骨骼链其余上级骨骼来适应效应器的变换</p>
</blockquote>
<h3 id="Target-Matching-目标匹配"><a href="#Target-Matching-目标匹配" class="headerlink" title="Target Matching / 目标匹配"></a>Target Matching / 目标匹配</h3><blockquote>
<p><code>U3D Document : Target matching moves the root of the hierarchy so that the effector is in the correct position or rotation without changing the rest of the hierarchy. </code></p>
<p>目标匹配仅改变骨骼层级中根节点的位置与旋转来使效应器处于正确的位置与旋转，而不改变其余骨骼的位置与旋转</p>
</blockquote>
<ul>
<li><p>animator.MatchTarget(…)</p>
<blockquote>
<p><code>U3D Document : Target matching is done using the MatchTarget method of the Animator Controller. The method should be called once during the State where you wish to target-match at any time before you want the matching to start. </code></p>
<p>目标匹配通过 Animator 组件的 MatchTarget 方法完成，需要在某一状态播放下的某个时间点调用 MatchTarget 方法，启动匹配</p>
<p><code>U3D Document : The parameters for the MatchTarget method can be split into three groups, with two parameters each.</code></p>
<p>该方法有三组参数，分别为 Target Information ，Effector Information ，Information about when the target matching should happen.</p>
</blockquote>
</li>
<li><p>Target Information / 目标信息</p>
<blockquote>
<p><code>U3D Document : The target information parameters are simply the world-space position to be matched and the world space rotation to be matched.</code></p>
<p>匹配目标的全局位置与全局旋转</p>
</blockquote>
</li>
<li><p>Effector Information / 效应器信息</p>
<p><strong>AvatarTarget</strong></p>
<blockquote>
<p><code>U3D Document : The first of the effector information parameters is an enumeration to determine which body part is the effector. </code></p>
<p>AvatarTarget 用来定义 Humaniod Avatar 哪一个身体部位用作效应器进行匹配，为枚举类型(Root，Body，LeftFoot，RightFoot，LeftHand，RightHand)</p>
</blockquote>
<p><strong>MatchTargetWeightMask</strong></p>
<blockquote>
<p><code>U3D Document : The second of the effector information parameters is a struct called MatchTargetWeightMask. It determines what balance of the original position and the target position the effector should take. </code></p>
<p>MatchTargetWeightMask 为一种结构体，定义了原始位置与目标位置应该采取的平衡，其构造函数需要具有两个参数</p>
<p>MatchTargetWeightMask(Vector3 _1,float _2) </p>
<p>_1 : The positional weight (called positionXYZWeight) is a Vector3 that should have a value between 0 and 1 for each axis to control how much the effector should use that axis of the target position. / 浮点值类型用于规定效应器应使用多少目标位置的轴</p>
<p>_2 : The rotational weight (called rotationWeight) is a float allowing for linear interpolation between the original rotation and the target rotation. / 原始旋转与目标旋转的插值</p>
<p>注意:</p>
<ol>
<li>Root 枚举代表身体的质心</li>
</ol>
</blockquote>
</li>
<li><p>Information about when the target matching should happen / 时间参数</p>
<blockquote>
<p><code>U3D Document : The final two parameters are floats giving the Normalized Time of the State. They are when the target matching should start and when it should reach the target.</code></p>
<p>归一化的时间类型，表示发生目标匹配的时间与其匹配到目标的时间</p>
</blockquote>
</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">VaultTargetMatching</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Animator animator;</span><br><span class="line">    <span class="keyword">public</span> Transform wallHandPosition;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> takeOffTime = <span class="number">0.027f</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> handDownTime = <span class="number">0.371f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (animator.GetCurrentAnimatorStateInfo(<span class="number">0</span>).IsName(<span class="string">&quot;Vault&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            MatchTargetWeightMask mask = <span class="keyword">new</span> MatchTargetWeightMask(Vector3.one, <span class="number">0f</span>);</span><br><span class="line">            animator.MatchTarget(wallHandPosition.position, wallHandPosition.rotation, AvatarTarget.LeftHand, mask, takeOffTime, handDownTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Inverse-Kinematics-IK"><a href="#Inverse-Kinematics-IK" class="headerlink" title="Inverse Kinematics / IK"></a>Inverse Kinematics / IK</h2><blockquote>
<p><code>U3D Document : IK doesn’t move the root of the hierarchy, but it does change the pose of the character. There are many different algorithms used for IK, but what they all have in common is that they set the position or rotation of bones further up the hierarchy so that the effector is at its desired position or rotation. </code></p>
<p>IK 不同于目标匹配，IK 不改变根节点的位置与旋转，而是设置层级中上一骨骼的以便效应器能处于期望的位置与旋转</p>
<p><code>U3D Document : There are three important variables that are used with the two-bone inverse kinematics (IK) algorithm that the animator uses: The target position，The target rotation，The hint position.</code></p>
<p>双关节IK算法需要知道三个重要参数 The target position，The target rotation，The hint position.</p>
<p><code>U3D Document : The target position and rotation are the position and rotation that the hand or foot will try to reach. The hint position is the position that the elbow or knee for that limb will try to reach. </code></p>
<p>目标位置与目标旋转为手或者足部想要到达的位置和旋转，提示位置为肘或膝盖想要到达的位置</p>
<p><code>注意:</code></p>
<ol>
<li>The target position，The target rotation，The hint position 均有其权重，可以获取并设置 IK 相应状态与权重</li>
</ol>
</blockquote>
<h2 id="MonoBehaviour-Messages-消息-1"><a href="#MonoBehaviour-Messages-消息-1" class="headerlink" title="MonoBehaviour Messages / 消息"></a>MonoBehaviour Messages / 消息</h2><ul>
<li> OnAnimatorIK(…)</li>
</ul>
<blockquote>
<p><code>U3D Document : OnAnimatorIK is called once per update for every Animator Layer which has its IK Pass enabled. Each call has the Layer’s index passed as a parameter. This means you can deal with various uses of IK separately. </code></p>
<p>OnAnimatorIK 将在动画层 IK Pass 选中的情况下，每更新一次调用一次</p>
</blockquote>
<ul>
<li><p>Update Mode / 更新模式</p>
<blockquote>
<p>Normal : Update() -&gt; OnAnimatorMove() -&gt; OnAnimatorIK() -&gt; LateUpdate()</p>
<p>Animate Physics : FixedUpdate() -&gt; OnAnimatorMove() -&gt; Internal Update(物理系统内置更新用于检测碰撞) -&gt; OnAnimatorIK()</p>
</blockquote>
</li>
</ul>
<hr>
<p><strong>Questions :</strong> </p>
<ul>
<li>Play and PlayInFixedTime 执行时是不是强制需要具有当前状态到某个状态的过渡？</li>
<li>CrossFade 不就相当于设置了一个过渡？</li>
<li>Information about when the target matching should happen / 时间参数 到达目标的时间？是怎么界定的？</li>
<li>MatchTargetWeightMask 结构构造函数不清楚</li>
</ul>
<hr>
<p>2022/1/17 21:36</p>
]]></content>
      <categories>
        <category>YumiGame</category>
      </categories>
      <tags>
        <tag>Animation Systems</tag>
      </tags>
  </entry>
  <entry>
    <title>Matlab 入门</title>
    <url>/2023/02/27/Matlab/Matlab/</url>
    <content><![CDATA[<h1 id="Matlab-Authority"><a href="#Matlab-Authority" class="headerlink" title="Matlab - Authority"></a>Matlab - Authority</h1><blockquote>
<p>Matlab 全称 Matrix Laboratory.</p>
<p>专用于处理矩阵与数组数据.</p>
</blockquote>
<h2 id="Variables-变量"><a href="#Variables-变量" class="headerlink" title="Variables / 变量"></a>Variables / 变量</h2><ul>
<li><p>Matlab 中的变量都是多维数组，与数据类型无关.</p>
<blockquote>
<p>矩阵其实本身就是用于线代数据处理的多维数组.</p>
</blockquote>
</li>
<li><p>Matlab中对数字的处理与保存方式是以 long 浮点值的形式存储.</p>
<blockquote>
<p>可以使用 format 来指定显示的小数位数，而不影响存储方式.</p>
</blockquote>
</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">format long</span><br><span class="line">format short</span><br></pre></td></tr></table></figure>

<ul>
<li><p>特殊常量值.</p>
<blockquote>
<p>NaN 非数字</p>
<p>Pi π</p>
<p>Inf 无穷</p>
</blockquote>
</li>
</ul>
<h2 id="Array-creation-数组创建"><a href="#Array-creation-数组创建" class="headerlink" title="Array creation / 数组创建"></a>Array creation / 数组创建</h2><ul>
<li><p>行向量的创建</p>
<blockquote>
<p>[1 2 3] </p>
<p>[]为串联运算符，可用于创建数组，<strong>逗号或者空格</strong> 用于分割各个元素</p>
</blockquote>
</li>
<li><p>多行矩阵的创建</p>
<blockquote>
<p>[1 2 3;4 5 6;7 8 9] </p>
<p>; 用于分割各行元素</p>
</blockquote>
</li>
<li><p>基于函数创建矩阵</p>
<blockquote>
<p>ones，zeros，rand来直接生成指定大小与维度的矩阵</p>
</blockquote>
</li>
</ul>
<h2 id="Array-Operation-数组运算"><a href="#Array-Operation-数组运算" class="headerlink" title="Array Operation / 数组运算"></a>Array Operation / 数组运算</h2><ul>
<li><p>矩阵运算符</p>
<blockquote>
<p>针对于矩阵性质的运算.</p>
</blockquote>
<p><img src="/images/Matlab/image-20230105112837600.png" alt="image-20230105112837600"></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">% &#39; 转置运算  </span><br><span class="line">a &#x3D; [1,3,5;2,4,6;7,8,10]</span><br><span class="line">b &#x3D; a&#39;</span><br><span class="line">% 标准矩阵乘法 - *</span><br><span class="line">c &#x3D; a * b</span><br></pre></td></tr></table></figure>

<ul>
<li><p>数组运算符 / 元素级运算</p>
<blockquote>
<p>对矩阵中各元素逐个进行运算.<br><code>注意:</code></p>
<ol>
<li>数组运算符 .^ 若改变运算变量前后次序，结果不相同.</li>
</ol>
</blockquote>
<p><img src="/images/Matlab/image-20230105112821337.png" alt="image-20230105112821337"></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 使用单个运算符，逐元素执行运算符运算</span></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>;<span class="number">7</span>,<span class="number">8</span>,<span class="number">10</span>]</span><br><span class="line">a + <span class="number">10</span></span><br><span class="line"><span class="comment">% 标准矩阵运算符(乘，除，幂)前加.即可表示为对逐元素的运算</span></span><br><span class="line"><span class="comment">% .* ./ .^</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Index-of-Array-数组索引"><a href="#Index-of-Array-数组索引" class="headerlink" title="Index of Array / 数组索引"></a>Index of Array / 数组索引</h2><blockquote>
<p>访问数组特定元素.</p>
</blockquote>
<ul>
<li><p>指定行列下标</p>
<blockquote>
<p>通过 变量名(行，列) 的方式进行索引.</p>
<p>若作右值，则索引不能越界.</p>
<p>若作左值，索引可以越界，编译器会自动扩大数组来容纳新的元素.</p>
<p><code>注意:</code></p>
<ol>
<li>关键字 end 表示维度下最后一个元素.</li>
</ol>
</blockquote>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">7</span>;<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>;<span class="number">5</span>,<span class="number">6</span>,<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">b = a(<span class="number">3</span>,<span class="number">3</span>); <span class="comment">% b = 10.</span></span><br><span class="line">b = a(<span class="number">3</span>,<span class="number">4</span>); <span class="comment">% 报错.</span></span><br><span class="line">a(<span class="number">3</span>,<span class="number">4</span>) = <span class="number">11</span>; <span class="comment">% 扩容.</span></span><br></pre></td></tr></table></figure></li>
<li><p>线性索引</p>
<blockquote>
<p>直接指定一个下标 i .</p>
<p>线性索引的情况下，数组被认为是一个长列向量(由各个列拼接而成的长列向量).</p>
</blockquote>
</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">7</span>;<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>;<span class="number">5</span>,<span class="number">6</span>,<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">c = a(<span class="number">9</span>); <span class="comment">% c = 10.</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>多个元素的索引</p>
<blockquote>
<p>使用 : 运算符指定多个元素.</p>
<p><code>注意:</code></p>
<ol>
<li>start : end 将生成一个指定范围的行向量.</li>
<li>可以通过 [] 进行索引.</li>
</ol>
</blockquote>
</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% start : end 格式. 指定由 start 到 end 范围且步长为1的所有元素.</span></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">7</span>;<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>;<span class="number">5</span>,<span class="number">6</span>,<span class="number">10</span>];</span><br><span class="line">b = a(<span class="number">1</span>:<span class="number">3</span>,<span class="number">2</span>) <span class="comment">% b为a矩阵第1-3行，第二列的所有元素.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% : 省略 start 与 end. 指定该维度的所有元素.</span></span><br><span class="line">b = a(:,<span class="number">2</span>) <span class="comment">% b为a矩阵第二列的所有元素.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% start : step : end 通用格式. 指定步长，范围由 start - end.</span></span><br><span class="line">b = a(<span class="number">1</span>:<span class="number">2</span>:<span class="number">3</span>,<span class="number">2</span>) <span class="comment">% b为a矩阵第二列中第一行以及第三行的元素.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% [] 作为索引进行元素提取</span></span><br><span class="line">x = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>; <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span>;<span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span>;<span class="number">16</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span> <span class="number">20</span>]</span><br><span class="line">x = x([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]) <span class="comment">% 长向量下取前5个元素.</span></span><br><span class="line">x = x([<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>],:) <span class="comment">% 提取所有行，但是按 1 4 2 3 的顺序.</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>逻辑索引</p>
<blockquote>
<p>x(l) 指定 x 中的满足条件的元素，生成一个列向量.</p>
<p>x 为数组，l 为与 x 同等大小的数组，l 元素非零.</p>
<p><code>注意:</code></p>
<ol>
<li>逻辑索引取 x 满足条件的元素时，将 x 视为长列向量，逐个元素的进行判断提取.</li>
</ol>
</blockquote>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 取 x 中非 NaN 元素.</span></span><br><span class="line">x = x(<span class="built_in">isfinite</span>(x))</span><br><span class="line"><span class="comment">% 取 x 中满足条件的元素.</span></span><br><span class="line">x = x(x &lt;= <span class="number">10</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>find 函数</p>
<blockquote>
<p>确定与指定逻辑条件相符的数组元素的索引，生成一个列向量.</p>
<p><code>注意:</code></p>
<ol>
<li>原理同 [] 以列向量逐个元素索引相同.</li>
</ol>
</blockquote>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">x = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>; <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span>;<span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span>;<span class="number">16</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span> <span class="number">20</span>]</span><br><span class="line">a = <span class="built_in">find</span>(x&lt;=<span class="number">10</span>)</span><br><span class="line">x(a) = <span class="number">0</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="In-series-串联"><a href="#In-series-串联" class="headerlink" title="In series / 串联"></a>In series / 串联</h2><ul>
<li><p>[] 为串联运算符</p>
<blockquote>
<p>可串联各个元素形成数组，也可串联数组形成更大数组.</p>
<p>以逗号或者空格分割表示横向串联.</p>
<p>以分号分割表示纵向串联.</p>
</blockquote>
</li>
</ul>
<h2 id="WorkSpace-Variables-工作区变量"><a href="#WorkSpace-Variables-工作区变量" class="headerlink" title="WorkSpace Variables / 工作区变量"></a>WorkSpace Variables / 工作区变量</h2><blockquote>
<p>从Matlab创建或者导入的变量将被包含在工作区.</p>
</blockquote>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 保存工作区变量. 工作区变量不会自动保存</span></span><br><span class="line">save filename.mat;</span><br><span class="line"><span class="comment">% 加载.mat中的变量到工作区.</span></span><br><span class="line">load filename.mat;</span><br><span class="line"><span class="comment">% 命令行查看工作区变量.</span></span><br><span class="line">whos</span><br></pre></td></tr></table></figure>

<h2 id="String-字符串数组"><a href="#String-字符串数组" class="headerlink" title="String / 字符串数组"></a>String / 字符串数组</h2><blockquote>
<p>a = “…”  a为字符串数组.</p>
<p>a只有一个元素.</p>
</blockquote>
<ul>
<li><p>若””中想包含””，不再使用转义字符，而是使用双””…””来表示.</p>
</li>
<li><p>拼接运算符</p>
<blockquote>
<p>可以使用+进行字符串数组内容的的首尾拼接.</p>
</blockquote>
</li>
<li><p>[] - 字符串数组的串联</p>
<blockquote>
<p>字符串数组的串联将等同于一般元素的串联，将构成多行多列的矩形数组.</p>
<p>并且可以通过 strlength(A) 求得各个元素的字符串长度，以矩阵形式输出.</p>
</blockquote>
</li>
</ul>
<h2 id="Char-字符数组"><a href="#Char-字符数组" class="headerlink" title="Char / 字符数组"></a>Char / 字符数组</h2><blockquote>
<p>a = ‘…’  a为字符数组.</p>
</blockquote>
<ul>
<li>字符在内部以数字存储，对应可使用的 ASCLL 值.、</li>
</ul>
<h3 id="单行字符数组"><a href="#单行字符数组" class="headerlink" title="单行字符数组"></a>单行字符数组</h3><ul>
<li><p>字符数组每个字符为独立的元素，可以通过索引进行存取.</p>
</li>
<li><p>拼接运算符.</p>
<blockquote>
<p>+不再适用于字符数组，可以相加，但是字符数组内容变为两者ASCLL的值和.</p>
</blockquote>
</li>
<li><p>[] - 字符数组的串联.</p>
<blockquote>
<p>字符数组的串联将对字符数组进行首尾拼接，得到一个新的字符数组.</p>
</blockquote>
</li>
<li><p>char 函数.</p>
<blockquote>
<p>可以通过 double(字符 / 字符数组)，char(数字 / 数值数组) 进行转换.</p>
<p><code>注意:</code></p>
<ol>
<li>此转换不仅仅为单个字符的转换，数组也能进行转换.</li>
</ol>
</blockquote>
</li>
</ul>
<h3 id="多行字符数组"><a href="#多行字符数组" class="headerlink" title="多行字符数组"></a>多行字符数组</h3><blockquote>
<p>多行字符数组必须满足各行字符数组长度一致，因此不足长度的需要后置位补空格.</p>
</blockquote>
<ul>
<li><p>char 函数.</p>
<blockquote>
<p>通过 char 可以将不等长的单行字符数组按行进行串联，后置位自动补足.</p>
<p><code>注意:</code></p>
<ol>
<li>不等长的字符数组不能按行进行串联.</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Function-call-函数调用"><a href="#Function-call-函数调用" class="headerlink" title="Function call - 函数调用"></a>Function call - 函数调用</h2><blockquote>
<p>函数名(参数列表).</p>
</blockquote>
<ul>
<li><p>多参数逗号分隔，无参数不需要括号.</p>
</li>
<li><p>多个返回值.</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">[a,b] = fuc(...);</span><br><span class="line"><span class="comment">% a = ..., b = ...;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Map-drawing-绘制图"><a href="#Map-drawing-绘制图" class="headerlink" title="Map drawing / 绘制图"></a>Map drawing / 绘制图</h2><ul>
<li><p>二维图</p>
<blockquote>
<p>给定自变量的范围.</p>
<p>给定自变量与因变量之间的关系(函数).</p>
<p>plot(x,y). 绘制二线线图.</p>
</blockquote>
</li>
<li><p>三维图</p>
<blockquote>
<p>给定自变量的范围.</p>
<p>给定</p>
<p>surf(x,y,z). 绘制三维曲面图.</p>
</blockquote>
</li>
<li><p>标签绘制</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">xlabel(<span class="string">&quot;x&quot;</span>) <span class="comment">% x标签.</span></span><br><span class="line">ylabel(<span class="string">&quot;y&quot;</span>) <span class="comment">% y标签.</span></span><br><span class="line">title(<span class="string">&quot;title&quot;</span>) <span class="comment">% 标题标签.</span></span><br></pre></td></tr></table></figure></li>
<li><p>多曲线绘制</p>
<blockquote>
<p>图窗窗口中在绘制一条新的曲线时会抹除原先的曲线.</p>
<p>可以通过将当前曲线添加到图窗中完成同时显示.</p>
</blockquote>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">x = <span class="built_in">linspace</span>(<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>)</span><br><span class="line">y = <span class="built_in">sin</span>(x)</span><br><span class="line"><span class="built_in">plot</span>(x,y) <span class="comment">% 第一条曲线.</span></span><br><span class="line"></span><br><span class="line">xlabel(<span class="string">&quot;x&quot;</span>)</span><br><span class="line">ylabel(<span class="string">&quot;y&quot;</span>)</span><br><span class="line">title(<span class="string">&quot;title&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 通过 hold on - hold off 完成第二条曲线的添加.</span></span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"></span><br><span class="line">y2 = <span class="built_in">cos</span>(x);</span><br><span class="line"><span class="built_in">plot</span>(x,y2,<span class="string">&quot;:&quot;</span>)</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&quot;sin&quot;</span>,<span class="string">&quot;cos&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">hold</span> off</span><br></pre></td></tr></table></figure></li>
<li><p>多图绘制</p>
<blockquote>
<p>允许一个图窗中显示多个图.</p>
</blockquote>
</li>
</ul>
<h2 id="Script-脚本"><a href="#Script-脚本" class="headerlink" title="Script / 脚本"></a>Script / 脚本</h2><ul>
<li>普通脚本</li>
</ul>
<blockquote>
<p>.m 文件为普通脚本文件.</p>
<p><code>注意:</code></p>
<ol>
<li>matlab 可用 … 表明长语句在下一行执行.</li>
</ol>
</blockquote>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">edit filename <span class="comment">% 编辑.m脚本文件，若默认搜索路径中不存在，则会在bin目录下创建.</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>实时脚本</p>
<blockquote>
<p>.mlx 文件为实时脚本文件.</p>
</blockquote>
</li>
<li><p>循环语句</p>
<blockquote>
<p>for or while.</p>
<p>continue or break or return.    </p>
</blockquote>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">starts = <span class="number">1</span></span><br><span class="line">ends = <span class="number">100</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = starts : ends</span><br><span class="line">   f(<span class="built_in">i</span>) = <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li>
<li><p>条件语句</p>
<blockquote>
<p>if elseif else end.</p>
<p>switch case otherwise.</p>
<p><code>注意:</code></p>
<ol>
<li> == 若对于数组而言，不会返回 true / false，而是返回一个矩阵.</li>
<li>因此使用函数来进行逻辑判断 isequal isempty all any.</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Help-帮助文档"><a href="#Help-帮助文档" class="headerlink" title="Help / 帮助文档"></a>Help / 帮助文档</h2><ul>
<li><p>doc fucname.</p>
<blockquote>
<p>以文档形式打开函数文档.</p>
</blockquote>
</li>
<li><p>funcame(</p>
<blockquote>
<p>填充式提示函数参数.</p>
</blockquote>
</li>
<li><p>help fucname.</p>
<blockquote>
<p>命令行显示函数简明文档.</p>
</blockquote>
</li>
</ul>
<h2 id="Matrix-矩阵"><a href="#Matrix-矩阵" class="headerlink" title="Matrix / 矩阵"></a>Matrix / 矩阵</h2><blockquote>
<p>Matlab 中矩阵为值为数值的矩形数组.</p>
<p><code>注意:</code></p>
<p>Matlab处理矩阵时会优先处理矩阵的列.</p>
</blockquote>
<h3 id="Matrix-Creation-矩阵创建"><a href="#Matrix-Creation-矩阵创建" class="headerlink" title="Matrix Creation / 矩阵创建"></a>Matrix Creation / 矩阵创建</h3><ul>
<li><p>指定明确列表创建.</p>
<blockquote>
<p>使用空格或逗号分隔行的元素。</p>
<p>使用分号 ; 表示每行末尾。</p>
<p>使用方括号 [ ] 将整个元素列表括起来。</p>
</blockquote>
</li>
<li><p>内置函数生成.</p>
<blockquote>
<p>zeros - 1</p>
<p>ones - 0</p>
<p>rand - (0,1] 均匀分布随机数</p>
<p>randn (0,1] 正态分布随机数</p>
</blockquote>
</li>
<li><p>表达式创建.</p>
<blockquote>
<p>matrix = (0:9).</p>
<p>创建由 0 - 9 构成的行向量.</p>
</blockquote>
</li>
<li><p>外部文件导入.</p>
</li>
</ul>
<h3 id="Matrix-Operation-矩阵操作"><a href="#Matrix-Operation-矩阵操作" class="headerlink" title="Matrix Operation / 矩阵操作"></a>Matrix Operation / 矩阵操作</h3><ul>
<li><p>sum 求指定行列的和.</p>
<blockquote>
<p>sum(A) 默认求 A 矩阵列元素总和，结果为行向量.</p>
<p>sum(A’)’ 可求 A 矩阵行元素总和，结果为列向量.</p>
<p>sum(A,2) 第二个参数指定维度，1为按列求和，2位按行求和.</p>
</blockquote>
</li>
<li><p>子矩阵.</p>
<blockquote>
<p>A(x,y) 取 A 的子矩阵.</p>
<p>x 从行的维度设置提取的内容，y 从列的维度设置提取的内容.</p>
<ol>
<li>数值 - 提取指定行.</li>
<li>: - 提取整个维度.</li>
<li>start : end - 提取指定范围的内容.  提取由 start 到 end 范围且步长为1的所有元素.</li>
<li>[1,3,2] 按指定顺序提取相应 行/列 号的内容.</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>上述四种方式一定明确在何种维度下，行，列或者长列向量.</li>
</ol>
</blockquote>
</li>
<li><p>删除行列元素.</p>
<blockquote>
<p>将指定元素设置为 [].</p>
<p><code>注意:</code></p>
<ol>
<li>删除元素和指定范围元素为特定值不一样，删除元素可能会导致矩阵长度不一，而发生错误.</li>
<li>可以通过单一下标删除一个或多个指定元素，但是其余元素将被重构为<strong>行向量</strong>.</li>
</ol>
</blockquote>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 删除 x 第二列的所有元素.</span></span><br><span class="line">X(:,<span class="number">2</span>) = []</span><br><span class="line"><span class="comment">% 结果不再为矩阵，报错.</span></span><br><span class="line">X(<span class="number">1</span>,<span class="number">2</span>) = []</span><br><span class="line"><span class="comment">% 结果为删除 2 4 6 8 10 索引元素后重构的行向量.</span></span><br><span class="line">X(<span class="number">2</span>:<span class="number">2</span>:<span class="number">10</span>) = []</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Cell-元胞数组"><a href="#Cell-元胞数组" class="headerlink" title="Cell / 元胞数组"></a>Cell / 元胞数组</h2><blockquote>
<p>包含其他数组副本的多维数组.</p>
</blockquote>
<ul>
<li><p>副本而非指针.</p>
<blockquote>
<p>即操作元胞数组元素不会对原始数组产生影响.</p>
</blockquote>
</li>
<li><p>使用 {} 进行创建和索引.</p>
<blockquote>
<p>{} 创建.</p>
<p>{} + 下标 索引.</p>
</blockquote>
</li>
</ul>
<h2 id="Struct-结构体"><a href="#Struct-结构体" class="headerlink" title="Struct / 结构体"></a>Struct / 结构体</h2><blockquote>
<p>数组元素为含字段结构体的多维数组.</p>
</blockquote>
<ul>
<li><p>结构体的创建.</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">S.name = <span class="string">&#x27;Ed Plum&#x27;</span>;</span><br><span class="line">S.score = <span class="number">83</span>;</span><br><span class="line">S.grade = <span class="string">&#x27;B+&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>结构体的赋值.</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">S(<span class="number">2</span>).name = <span class="string">&#x27;Toni Miller&#x27;</span>;</span><br><span class="line">S(<span class="number">2</span>).score = <span class="number">91</span>;</span><br><span class="line">S(<span class="number">2</span>).grade = <span class="string">&#x27;A-&#x27;</span>;</span><br><span class="line"></span><br><span class="line">S(<span class="number">3</span>) = struct(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;Jerry Garcia&#x27;</span>,... </span><br><span class="line">               <span class="string">&#x27;score&#x27;</span>,<span class="number">70</span>,<span class="string">&#x27;grade&#x27;</span>,<span class="string">&#x27;C&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Function-函数"><a href="#Function-函数" class="headerlink" title="Function / 函数"></a>Function / 函数</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">r</span> = <span class="title">rank</span><span class="params">(A,tol)</span></span></span><br><span class="line"><span class="comment">% 注释</span></span><br><span class="line"><span class="comment">% 注释</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>function 关键字用于定义函数.</p>
<p>r - 返回值.</p>
<p>rank - 函数名称.</p>
<p>(arg) - 参数列表.</p>
<p>% - 第一行注释为 H1 标题行，help 时显示.</p>
</blockquote>
<ul>
<li><p>匿名函数</p>
<blockquote>
<p>匿名函数可以不创建文件快速创建简单函数.</p>
</blockquote>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% fun = @(arg)exp;</span></span><br><span class="line">sqr = @(x) x.^<span class="number">2</span>;</span><br><span class="line">a = sqr(<span class="number">5</span>); <span class="comment">% res = 25.</span></span><br></pre></td></tr></table></figure></li>
<li><p>一般函数</p>
<blockquote>
<p>任何非匿名函数都必须在文件中定义，且主函数与文件名相同.</p>
<p>主函数 : 可供其他文件调用，最先定义.</p>
<p>局部函数 : 仅供所处文件下的其他函数调用，主函数之后定义.</p>
</blockquote>
</li>
<li><p>私有函数</p>
<blockquote>
<p>私有函数位于名为 private 的文件夹中，仅供父文件夹中的函数使用.</p>
<p><code>注意:</code></p>
<ol>
<li>与私有函数同名的其他函数，在父文件夹中调用时优先搜索私有函数，以此创建特定版本的函数.</li>
</ol>
</blockquote>
</li>
<li><p>全局变量</p>
<blockquote>
<p>通过 global 关键字进行声明的变量，可被多个函数共享.</p>
<p><code>注意:</code></p>
<ol>
<li>一般全局变量使用大写字符用于区分.</li>
</ol>
</blockquote>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">global</span> VAR;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="Matlab-Bilibili-快速入门汇总"><a href="#Matlab-Bilibili-快速入门汇总" class="headerlink" title="Matlab - Bilibili 快速入门汇总"></a>Matlab - Bilibili 快速入门汇总</h1><blockquote>
<p>clc 清除命令行中所有命令</p>
<p>clear all 清除工作区中的所有变量</p>
<p>单行注释 % - %%</p>
<p>多行注释  %{ … %}</p>
</blockquote>
<h2 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h2><blockquote>
<p>区分大小写，字母开头完事</p>
</blockquote>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li><p>数字</p>
</li>
<li><p>字符与字符串</p>
<blockquote>
<p>‘ ‘单引号括起来的为字符串</p>
</blockquote>
</li>
<li><p>矩阵</p>
<blockquote>
<p>A = [1 2 3;4 5 6;7 8 9]<br>% 转置<br>B = A’<br>% 竖着拉伸 以列为基准转换为列向量<br>C = A(:)<br>% 求逆矩阵 方阵<br>D = inv(A)<br>% 生成全是0的矩阵 （行数，列数，维度）<br>E = zeros(10,5,3)<br>% rand(0-1之间，随机均匀分布,m<em>n的随机矩阵),randn(0-1之间，正态分布,m</em>n的随机矩阵) randi(iMax,[m,n]) {(0,IMax]之间左开右闭，m*x随机整数矩阵}<br>E(:,:,1) = rand(10,5)<br>E(:,:,2) = randn(10,5)<br>E(:,:,3) = randi(5,10,5)</p>
</blockquote>
</li>
<li><p>元胞数组</p>
<blockquote>
<p>cell(行数,列数)</p>
<p>从1开始索引</p>
<p>类似于数组，内部元素可以属于不同的数据类型.</p>
</blockquote>
</li>
<li><p>结构体</p>
<blockquote>
<p>struct(键，值…)</p>
<p>以键值对的方式来存数据，仍需要通过键来取值</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>Matlab</category>
      </categories>
      <tags>
        <tag>Matlab</tag>
      </tags>
  </entry>
</search>

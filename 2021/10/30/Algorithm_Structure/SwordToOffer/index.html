<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>剑指Offer-一刷 | YunDid's Blog</title><meta name="keywords" content="Algorithm and DataStruture"><meta name="author" content="YunDid"><meta name="copyright" content="YunDid"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="DataStruct and Algorithm1 赋值运算符函数 为类型CMyString的声明添加赋值运算符函数  Testing case 一个CMyString实例赋予另外一个实例 一个CMyString实例赋值给它自己 连续赋值  Key 考虑测试用例，是否传入参数是对象本身  若传入参数为自身，则释放原有内存后将无法继续赋值，因为参数内存也被释放   考虑函数返回值是否为引用，并相应的">
<meta property="og:type" content="article">
<meta property="og:title" content="剑指Offer-一刷">
<meta property="og:url" content="http://example.com/2021/10/30/Algorithm_Structure/SwordToOffer/index.html">
<meta property="og:site_name" content="YunDid&#39;s Blog">
<meta property="og:description" content="DataStruct and Algorithm1 赋值运算符函数 为类型CMyString的声明添加赋值运算符函数  Testing case 一个CMyString实例赋予另外一个实例 一个CMyString实例赋值给它自己 连续赋值  Key 考虑测试用例，是否传入参数是对象本身  若传入参数为自身，则释放原有内存后将无法继续赋值，因为参数内存也被释放   考虑函数返回值是否为引用，并相应的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/ma3.jpg">
<meta property="article:published_time" content="2021-10-30T05:00:00.000Z">
<meta property="article:modified_time" content="2021-10-30T05:00:51.702Z">
<meta property="article:author" content="YunDid">
<meta property="article:tag" content="Algorithm and DataStruture">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/ma3.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/10/30/Algorithm_Structure/SwordToOffer/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: YunDid","link":"链接: ","source":"来源: YunDid's Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-10-30 13:00:51'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">46</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/ma3.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">YunDid's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">剑指Offer-一刷</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-10-30T05:00:00.000Z" title="发表于 2021-10-30 13:00:00">2021-10-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-10-30T05:00:51.702Z" title="更新于 2021-10-30 13:00:51">2021-10-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Algorithm-and-DataStruture/">Algorithm and DataStruture</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="剑指Offer-一刷"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2021/10/30/Algorithm_Structure/SwordToOffer/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2021/10/30/Algorithm_Structure/SwordToOffer/" itemprop="commentCount"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="DataStruct-and-Algorithm"><a href="#DataStruct-and-Algorithm" class="headerlink" title="DataStruct and Algorithm"></a>DataStruct and Algorithm</h1><h1 id="1-赋值运算符函数"><a href="#1-赋值运算符函数" class="headerlink" title="1 赋值运算符函数"></a>1 赋值运算符函数</h1><blockquote>
<p>为类型CMyString的声明添加赋值运算符函数</p>
</blockquote>
<h2 id="Testing-case"><a href="#Testing-case" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>一个CMyString实例赋予另外一个实例</li>
<li>一个CMyString实例赋值给它自己</li>
<li>连续赋值</li>
</ul>
<h2 id="Key"><a href="#Key" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>考虑测试用例，是否传入参数是对象本身</p>
<blockquote>
<p>若传入参数为自身，则释放原有内存后将无法继续赋值，因为参数内存也被释放</p>
</blockquote>
</li>
<li><p>考虑函数返回值是否为引用，并相应的返回引用</p>
<blockquote>
<p>引用作函数返回值使=运算符可连=</p>
</blockquote>
</li>
<li><p>函数参数是否为常引用</p>
<blockquote>
<p>传入参数类型为引用将避免无谓的消耗，常引用则不希望影响原对象</p>
<p>传值时会调用拷贝构造，降低效率</p>
</blockquote>
</li>
<li><p>为已存在指针创建新的内存前是否释放原内存并置空</p>
<blockquote>
<p>若为释放原内存则会造成内存泄漏</p>
<p>若释放后未置空，则导致野指针出现</p>
</blockquote>
</li>
</ul>
<h2 id="Answer"><a href="#Answer" class="headerlink" title="Answer"></a>Answer</h2><h3 id="经典解法"><a href="#经典解法" class="headerlink" title="经典解法"></a>经典解法</h3><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyString</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CMyString</span>(<span class="keyword">char</span>* pData = <span class="literal">nullptr</span>);</span><br><span class="line">	<span class="built_in">CMyString</span>(<span class="keyword">const</span> CMyString&amp; str);</span><br><span class="line">	~<span class="built_in">CMyString</span>(<span class="keyword">void</span>);</span><br><span class="line">	<span class="comment">//12</span></span><br><span class="line">	CMyString&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> CMyString&amp; str) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//3</span></span><br><span class="line">		<span class="keyword">if</span> (&amp;str == <span class="keyword">this</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//4</span></span><br><span class="line">		<span class="keyword">delete</span>[]m_pData;</span><br><span class="line">		m_pData = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//5</span></span><br><span class="line">		<span class="keyword">char</span>* m_pData = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str.m_pData) + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">		<span class="built_in">strcpy</span>(m_pData, str.m_pData);</span><br><span class="line">		<span class="comment">//copy时包括终止符&#x27;\0&#x27;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//6</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">char</span>* m_pData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="考虑异常安全性"><a href="#考虑异常安全性" class="headerlink" title="考虑异常安全性"></a>考虑异常安全性</h3><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//考虑异常安全性 -先new后delete</span></span><br><span class="line">CMyString&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> CMyString&amp; str) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (&amp;str == <span class="keyword">this</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span>* _m_pData = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str.m_pData) + <span class="number">1</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(_m_pData, str.m_pData);</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">delete</span>[]m_pData;</span><br><span class="line">	m_pData = _m_pData;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//考虑异常安全性 -临时对象交换</span></span><br><span class="line">CMyString&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> CMyString&amp; str) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (&amp;str == <span class="keyword">this</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function">CMyString <span class="title">temp</span><span class="params">(str)</span></span>;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">char</span>* p = temp.m_pData;</span><br><span class="line">	temp.m_pData = m_pData;</span><br><span class="line">	m_pData = p;</span><br><span class="line">    </span><br><span class="line">	p = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>临时指针</p>
<blockquote>
<p>完成copy操作，这样即使new时内存不足导致异常也不会影响原m_pData状态，不至于为nullptr</p>
</blockquote>
</li>
<li><p>临时对象</p>
<blockquote>
<p>该临时对象为传入对象的copy</p>
<p>将该对象与原对象的成员<strong>进行交换</strong>，在跳出临时对象作用域时，其内存会被自动释放</p>
<p>若不交换仍会导致内存泄漏，交换的目的就在于使用作用域机制，让系统自动释放内存</p>
</blockquote>
</li>
</ul>
<h1 id="2-1-数组中重复的数字"><a href="#2-1-数组中重复的数字" class="headerlink" title="2.1 数组中重复的数字"></a>2.1 数组中重复的数字</h1><blockquote>
<p>在一个长度为n的数组里的所有数字都在0~n-1的范围内。数组中某些数字是重复的,但不知道有几个数字重复了,也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如,如果输入长度为7的数组(2, 3, 1,0, 2, 5, 3,那么对应的输出是重复的数字2或者3.</p>
</blockquote>
<h2 id="Testing-case-1"><a href="#Testing-case-1" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>长度为n的数组里包含一个或多个重复数字</li>
<li>数组不包含重复的数字</li>
<li>无效输入(空指针;0~n-1范围之外的数字)</li>
</ul>
<h2 id="Key-1"><a href="#Key-1" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>数组可支持O(1)的随机访问，可使用该性质结合哈希表实现时间复杂度为O(n)，空间复杂度为O(n)的算法</p>
<blockquote>
<p>创建一个等大的数组，遍历原数组，从头开始将每一个元素模n，得到对应的索引位置(角标)</p>
<p>若角标处无元素，则存入，若有元素则为重复数字</p>
</blockquote>
</li>
<li><p>基于原数组，结合哈希表实现时间复杂度为O(n)，空间复杂度为O(1)的算法</p>
<blockquote>
<ol>
<li><p>从头遍历原数组，判断索引值与元素值是否相等</p>
</li>
<li><p>相等，则说明该元素位置正确</p>
</li>
<li><p>不相等，则将该元素置于其值对应的索引处，若对应索引处元素值与该元素相等，则重复，否则交换元素，重复1</p>
</li>
</ol>
<p>当遍历完原数组后，则无重复且元素排列有序(元素均位于”正确”的位置)或者找出重复</p>
</blockquote>
</li>
</ul>
<h2 id="Answer-1"><a href="#Answer-1" class="headerlink" title="Answer"></a>Answer</h2><h3 id="哈希表-T-n-O-n-S-n-O-n"><a href="#哈希表-T-n-O-n-S-n-O-n" class="headerlink" title="哈希表 T(n)=O(n) S(n)=O(n)"></a>哈希表 T(n)=O(n) S(n)=O(n)</h3><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">repeat</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (arr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span>* temp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line">		<span class="comment">//初始化哈希表值为-1，表示位置为空</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			temp[i] = <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//遍历原数组</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[i] &gt; n - <span class="number">1</span> || arr[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;存在无效数字&quot;</span> &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (temp[arr[i] % n] == arr[i]) &#123;</span><br><span class="line">				cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				temp[arr[i] % n] = arr[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="归位法-T-n-O-n-S-n-O-1"><a href="#归位法-T-n-O-n-S-n-O-1" class="headerlink" title="归位法 T(n)=O(n) S(n)=O(1)"></a>归位法 T(n)=O(n) S(n)=O(1)</h3><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">repeat</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> re = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="literal">nullptr</span> || n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (arr[i] &gt; n - <span class="number">1</span> || arr[i] &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (i != arr[i]) &#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[i] == arr[arr[i]]) &#123;</span><br><span class="line">				cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">				re = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">int</span> t = arr[i];</span><br><span class="line">				arr[i] = arr[arr[i]];</span><br><span class="line">				arr[arr[i]] = t;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="2-2-数组中的重复数字"><a href="#2-2-数组中的重复数字" class="headerlink" title="2.2 数组中的重复数字"></a>2.2 数组中的重复数字</h1><blockquote>
<p>在一个长度为n+1的数组里的所有数字都在1~n的范围内,所以数组中至少有一个数字是重复的。请找出数组中<strong>任意一个</strong>重复的数字,但<strong>不能修改输入的数组</strong>。例如,如果输入长度为8的数组(2, 3, 5, 4, 3, 2, 6,7,那么对应的输出是重复的数字2或者3</p>
</blockquote>
<h2 id="Testing-case-2"><a href="#Testing-case-2" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>长度为n的数组里包含一个重复数字</li>
<li>长度为n的数组里包含多个重复数字</li>
<li>无效输入(空指针;1~n范围之外的数字)</li>
</ul>
<h2 id="Key-2"><a href="#Key-2" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>哈希法 T(n)=O(n) S(n)=O(n) </p>
<ul>
<li>二分法 T(n)=O(nlogn) S(n)=O(1) </li>
</ul>
<blockquote>
<p>在一个长度为n+1的数组里的所有数字都在1~n的范围内,所以数组中至少有一个数字是重复的。</p>
<ol>
<li>将1<del>n范围内的数字分两部分，1</del>n/2  -  n/2+1~n，若1-2/n中的数字出现个数大于n/2，则认为这个范围内的数字存在重复数字，否则另一部分存在重复</li>
<li>重复数字部分重复步骤1</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li><p>不更改原数组，原数组仅用于遍历判断范围内的数字出现的次数</p>
</li>
<li><p>若出现个数与范围n同，则不能保证没有重复数字，精度有些问题</p>
</li>
<li><p>仅能找出一个重复数字</p>
</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-2"><a href="#Answer-2" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">repeat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="literal">nullptr</span> || n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (arr[i] &gt; n - <span class="number">1</span> || arr[i] &lt; <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//确定有重复数字的范围</span></span><br><span class="line">	<span class="keyword">int</span> low = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> high = n - <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//在该范围内进行二分，缩小重复数字的范围</span></span><br><span class="line">	<span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> mid = (high + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">int</span> nums = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//遍历数组判断指定范围内 (1 - mid) 的数字出现的次数</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (arr[i] &lt;= mid &amp;&amp; arr[i] &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">				nums++;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//得到该数字范围的长度</span></span><br><span class="line">		<span class="keyword">int</span> count = mid - low + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//若数组中数字出现次数大于该数字范围的长度，说明该数字范围内存在重复数字</span></span><br><span class="line">		<span class="keyword">if</span> (nums &gt; count) &#123;</span><br><span class="line">			high = mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			low = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; arr[high];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</blockquote>
<h1 id="4-二维数组中的查找"><a href="#4-二维数组中的查找" class="headerlink" title="4 二维数组中的查找"></a>4 二维数组中的查找</h1><blockquote>
<p>在一个二维数组中,每一行都按照从左到右递增的顺序排序,每一列都按照从上到下递增的顺序排序。请完成一个函数,输入这样的一个二维数组和一个整数,判断数组中是否含有该整数。</p>
</blockquote>
<h2 id="Testing-case-3"><a href="#Testing-case-3" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>二维数组中存在/不存在该整数</li>
</ul>
<h2 id="Key-3"><a href="#Key-3" class="headerlink" title="Key"></a>Key</h2><ul>
<li>选取右上角或者左下角开始作比较，每比较一次可缩减一次查找范围，直到找到或者不存在该整数</li>
</ul>
<h2 id="Answer-3"><a href="#Answer-3" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">int</span> rows,<span class="keyword">int</span> cols, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//锁定右上角位置</span></span><br><span class="line">	<span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> col = cols - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//直到越界结束查找</span></span><br><span class="line">	<span class="keyword">while</span> (row &lt; rows &amp;&amp; col &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n &gt; arr[row*cols + col]) &#123;</span><br><span class="line">			<span class="comment">//剔除一行</span></span><br><span class="line">			row++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (n == arr[row*cols + col]) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//剔除一列</span></span><br><span class="line">			col--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="5-1-替换空格"><a href="#5-1-替换空格" class="headerlink" title="5.1 替换空格"></a>5.1 替换空格</h1><blockquote>
<p>请实现一个函数,把字符串中的每个空格替换成”%20”。例如,输入”We are happy.”,则输出 “We%20are%20happy.”</p>
</blockquote>
<h2 id="Testing-case-4"><a href="#Testing-case-4" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>字符串中含有空格(空格位于字符串前面，后面，中间)，含有连续空格</li>
<li>字符串无空格</li>
<li>输入无效字符(空字符串，空指针)</li>
</ul>
<h2 id="Key-4"><a href="#Key-4" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>注意字符串变长导致的内存覆盖</p>
</li>
<li><p>从前往后替换空格 T(n)=O(n2)</p>
<blockquote>
<p>前向遍历字符数组，只要含有空格就将空格之后的字符后移两位并替换空格</p>
<p>缺点是每含一个空格就需要进行一次整体移位，含多次重复操作</p>
</blockquote>
</li>
<li><p>从后往前替换空格 T(n)=O(n)</p>
<blockquote>
<p>反向遍历字符数组，设置两个指针，一个指向原字符串末尾，一个指向将所有空格替换后(增长后)的末尾</p>
<ol>
<li>对于接受到的数组，遍历数组的同时记录空格数(<strong>每替换一个空格字符串长度加2</strong>)，进而定位两个指针的位置</li>
<li>循环开始，若p指向的元素不是空格，则将该元素转到q指向的位置，并前移1位</li>
<li>若p指向的元素是空格，则将q指向的位置使用%20替代空格，并p前移1位，q前移三位</li>
<li>直至p==q，循环终止，空格均替代完毕</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-4"><a href="#Answer-4" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replace</span><span class="params">(<span class="keyword">char</span>* arr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="literal">nullptr</span> || <span class="built_in">strlen</span>(arr) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">char</span>* p = arr;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//定位p指针位置并计数空格数，进而定位q指针位置</span></span><br><span class="line">	<span class="keyword">int</span> nums = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (; *p != <span class="string">&#x27;\0&#x27;</span>; p++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (*p == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">			nums++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span>* q = p + nums * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (p != q) &#123;</span><br><span class="line">		<span class="keyword">if</span> (*p != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">			*q = *p;</span><br><span class="line">			p--;</span><br><span class="line">			q--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			</span><br><span class="line">			p--;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">				<span class="keyword">if</span> (i == <span class="number">0</span>) &#123;		</span><br><span class="line">					*q = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">					q--;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">					*q = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">					q--;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					*q = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">					q--;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="5-2-合并两个有序数组"><a href="#5-2-合并两个有序数组" class="headerlink" title="5.2 合并两个有序数组"></a>5.2 合并两个有序数组</h1><blockquote>
<p>有两个排序的数组A1和A2,内存在<strong>A1的末尾有足够多的空余空间容纳A2</strong>,请实现一个函数,把A2中的所有数字插入A1中,并且所有的数字是排序的。</p>
</blockquote>
<h2 id="Testing-case-5"><a href="#Testing-case-5" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>长度相等/不等的升序数组合并</li>
<li>无效数组输入</li>
</ul>
<h2 id="Key-5"><a href="#Key-5" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>从后往前合并有序数组 T(n)=O(n + m)</p>
<blockquote>
<p>反向遍历两个数组，并于A1数组设置三个指针，一个p1指向A1元素末尾，一个p2指向A2元素末尾，一个q指向A1数组合并后预留位置后的末尾</p>
<ol>
<li>通过比较p1与p2指向的元素大小决定q指向的元素内容，合并元素后移动相应指针</li>
<li>直至有一个数组元素全部合并完毕后，将另一个数组未合并完成的数组元素按序填充至A1剩余空位处</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-5"><a href="#Answer-5" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="function"><span class="keyword">void</span> <span class="title">combine</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; v1,<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp;v2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (v1.<span class="built_in">size</span>() == <span class="number">0</span> &amp;&amp; v2.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//vector扩容后为重新申请了一块两倍大小内存，注意获取迭代器的时机</span></span><br><span class="line">		v1.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>() + v2.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">	<span class="comment">//定位迭代器指向</span></span><br><span class="line">	<span class="keyword">auto</span> p1 = v1.<span class="built_in">end</span>() - <span class="number">1</span> - v2.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">auto</span> p2 = v2.<span class="built_in">end</span>() - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">auto</span> q = p1 + v2.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//合并数组</span></span><br><span class="line">	<span class="keyword">while</span> (q != v1.<span class="built_in">begin</span>() &amp;&amp; p1 &gt;= v1.<span class="built_in">begin</span>() &amp;&amp; p2 &gt;= v2.<span class="built_in">begin</span>()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (*p1 &gt;= *p2) &#123;			</span><br><span class="line">			*q = *p1;</span><br><span class="line">			q--;</span><br><span class="line">			<span class="keyword">if</span> (p1 == v1.<span class="built_in">begin</span>()) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			p1--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;	</span><br><span class="line">			*q = *p2;</span><br><span class="line">			q--;</span><br><span class="line">			<span class="keyword">if</span> (p2 == v2.<span class="built_in">begin</span>()) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			p2--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将剩余未合并元素有序合并</span></span><br><span class="line">	<span class="keyword">if</span> (p1 == v1.<span class="built_in">begin</span>() &amp;&amp; p2 != v2.<span class="built_in">begin</span>()) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">auto</span> re = v2.<span class="built_in">begin</span>();</span><br><span class="line">		<span class="keyword">while</span> (re &lt;= p2) &#123;</span><br><span class="line">			*p1 = *re;</span><br><span class="line">			re++;</span><br><span class="line">			p1++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</blockquote>
<h1 id="6-从尾到头打印链表"><a href="#6-从尾到头打印链表" class="headerlink" title="6 从尾到头打印链表"></a>6 从尾到头打印链表</h1><blockquote>
<p>输入一个链表的头节点,<strong>从尾到头</strong>反过来打印出每个节点的值。链表节点定义如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> m_nKey;</span><br><span class="line">    ListNode* m_pNext;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Testing-case-6"><a href="#Testing-case-6" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>输入的链表有多个结点</li>
<li>输入的链表只有一个结点</li>
<li>链表的头结点指针为nullptr</li>
</ul>
<h2 id="Key-6"><a href="#Key-6" class="headerlink" title="Key"></a>Key</h2><ul>
<li>正向遍历，压栈输出</li>
<li>正向遍历，递归输出</li>
</ul>
<h2 id="Answer-6"><a href="#Answer-6" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//压栈输出</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reprint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ListNode* q = head-&gt;m_pNext;</span><br><span class="line">	stack&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">	<span class="keyword">while</span> (q != <span class="literal">nullptr</span>) &#123;	</span><br><span class="line">		st.<span class="built_in">push</span>(q-&gt;m_nKey);</span><br><span class="line">		q = q-&gt;m_pNext;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		cout &lt;&lt; st.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		st.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rreprint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (head-&gt;m_pNext != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="built_in">reprint</span>(head-&gt;m_pNext);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; head-&gt;m_nKey &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="7-重建二叉树"><a href="#7-重建二叉树" class="headerlink" title="7 重建二叉树"></a>7 重建二叉树</h1><blockquote>
<p>输入某二又树的前序遍历和中序遍历的结果,请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
</blockquote>
<h2 id="Testing-case-7"><a href="#Testing-case-7" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>完全二叉树，非完全二叉树</li>
<li>特殊二叉树(无左子树，无右子树)</li>
<li>头结点为nullptr，两个遍历序列不匹配</li>
</ul>
<h2 id="Key-7"><a href="#Key-7" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>两者结合，相辅相成</p>
<blockquote>
<ol>
<li><p>前序遍历序列先出现的为根节点，可先于前序遍历序列中找到根节点</p>
</li>
<li><p>再于中序遍历序列中确定该根节点的左右子树，中序遍历序列中其左边结点属于左子树</p>
</li>
<li><p>递归再使用同样的方法在左子树中去前序遍历序列中找寻根节点，确定根节点后再回到中序遍历序列确定左右子树范围</p>
</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-7"><a href="#Answer-7" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinaryTreeNode* <span class="title">constructBTreeCore</span><span class="params">(<span class="keyword">int</span>* stp, <span class="keyword">int</span>*sep, <span class="keyword">int</span>*itp, <span class="keyword">int</span>*iep)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//于先序遍历序列中找到根节点</span></span><br><span class="line">	<span class="keyword">int</span> rootValue = stp[<span class="number">0</span>];</span><br><span class="line">	<span class="comment">//创建根节点</span></span><br><span class="line">	BinaryTreeNode* root = <span class="keyword">new</span> <span class="built_in">BinaryTreeNode</span>();</span><br><span class="line">	root-&gt;m_nValue = rootValue;</span><br><span class="line">	root-&gt;m_pLeft = root-&gt;m_pRight = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置递归终止条件并判断异常</span></span><br><span class="line">	<span class="keyword">if</span> (stp == sep) &#123;</span><br><span class="line">		<span class="keyword">if</span> (itp == iep &amp;&amp; *stp == *itp) &#123;</span><br><span class="line">			<span class="keyword">return</span> root;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建左右子树</span></span><br><span class="line">	<span class="keyword">int</span> *Iroot = itp;</span><br><span class="line">	<span class="keyword">while</span> (Iroot != iep &amp;&amp; *Iroot != rootValue) &#123;</span><br><span class="line">		Iroot++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//异常处理</span></span><br><span class="line">	<span class="keyword">if</span> (Iroot == iep &amp;&amp; *Iroot != rootValue) &#123;</span><br><span class="line">		<span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//确定左右子树范围</span></span><br><span class="line">	<span class="keyword">int</span> leftlen = Iroot - itp;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//构建左子树</span></span><br><span class="line">	<span class="keyword">if</span> (leftlen &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		root-&gt;m_pLeft = <span class="built_in">constructBTreeCore</span>(stp + <span class="number">1</span>, stp + leftlen, itp, Iroot - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//构建右子树 - 若仅有左子树则无需构建</span></span><br><span class="line">	<span class="keyword">if</span> (leftlen &lt; iep - itp) &#123;</span><br><span class="line">		root-&gt;m_pRight = <span class="built_in">constructBTreeCore</span>(stp + leftlen + <span class="number">1</span>, sep, Iroot + <span class="number">1</span>, iep);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="8-二叉树的下一个结点"><a href="#8-二叉树的下一个结点" class="headerlink" title="8 二叉树的下一个结点"></a>8 二叉树的下一个结点</h1><blockquote>
<p>给定一棵二叉树和其中的一个节点,如何找出中序遍历序列的下一个节点?</p>
<p>树中的节点除了有两个分别指向左、右子节点的指针,还有一个指向父节点的指针</p>
</blockquote>
<h2 id="Testing-case-8"><a href="#Testing-case-8" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>普通二叉树(完全二叉树，不完全二叉树)</li>
<li>特殊二叉树(所有结点都没有右节点，所有结点都没有左子节点，只有一个结点，根节点为nullptr)</li>
<li>不同位置结点的下一个结点(下一个结点为当前结点的右子结点，右子结点的最左子节点，父结点，跨层的父结点等，或当前结点没有下一个结点)</li>
</ul>
<h2 id="Key-8"><a href="#Key-8" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>区分求结点下一结点的两种情况</p>
<blockquote>
<ol>
<li>该结点存在右子树，则该节点的下一个结点为右子树的最左结点</li>
<li>该节点不存在右子树，但是该节点存在父结点，则向上遍历，直至找到其及其上层子结点是其上层父结点的左子树，则该父结点为其下一个结点</li>
<li>该节点不存在右子树，且不存在父结点，则无下一个结点</li>
<li>该节点不存在右子树，存在父结点，但是不存在2的情况，则无下一个结点</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-8"><a href="#Answer-8" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinaryTreeNode* <span class="title">GetNext</span><span class="params">(BinaryTreeNode* pNode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (pNode == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	BinaryTreeNode* pNext = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pNode-&gt;m_pRight != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		</span><br><span class="line">		BinaryTreeNode* pCurrent = pNode-&gt;m_pRight;</span><br><span class="line">		<span class="keyword">while</span> (pCurrent-&gt;m_pLeft != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			pCurrent = pCurrent-&gt;m_pLeft;</span><br><span class="line">		&#125;</span><br><span class="line">		pNext = pCurrent;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pNode-&gt;m_pParent != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		</span><br><span class="line">		BinaryTreeNode* pCurrent = pNode;</span><br><span class="line">		BinaryTreeNode* pParent = pNode-&gt;m_pParent;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (pParent-&gt;m_pParent != <span class="literal">nullptr</span> &amp;&amp; pCurrent == pParent-&gt;m_pRight) &#123;</span><br><span class="line">			pCurrent = pParent;</span><br><span class="line">			pParent = pParent-&gt;m_pParent;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (pCurrent == pParent-&gt;m_pLeft) &#123;</span><br><span class="line">			pNext = pParent;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pNext;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="9-用两个栈实现队列"><a href="#9-用两个栈实现队列" class="headerlink" title="9 用两个栈实现队列"></a>9 用两个栈实现队列</h1><blockquote>
<p>用两个栈实现一个队列,队列的声明如下,请实现它的两个函数appendTail和deleteHead,分别完成在队列尾部插入节点和在队列头部删除节点的功能。</p>
</blockquote>
<h2 id="Testing-case-9"><a href="#Testing-case-9" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>往空的队列中添加，删除元素</li>
<li>往非空的队列中添加，删除元素</li>
<li>连续删除元素直至队列为空</li>
</ul>
<h2 id="Key-9"><a href="#Key-9" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>熟悉栈与队列的特性</p>
<blockquote>
<p>队列先进先出，栈后进先出</p>
</blockquote>
</li>
<li><p>appendTail队尾插入</p>
<blockquote>
<p>插入的元素均置于stack1中</p>
</blockquote>
</li>
<li><p>deleteHead队头删除</p>
<blockquote>
<p>删除结点时，为保证删除结点的顺序，因此需要</p>
<ol>
<li>判断stack2是否为空，若不为空，则直接于stack2中弹出</li>
<li>若为空，则先将stack1中的元素全部弹出并插入到stack2中，再于stack2中弹出</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-9"><a href="#Answer-9" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> CQueue&lt;T&gt;::<span class="built_in">appendTail</span>(<span class="keyword">const</span> T&amp;node) &#123;</span><br><span class="line">	stack1.<span class="built_in">push</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T CQueue&lt;T&gt;::<span class="built_in">deleteHead</span>() &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (stack2.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (stack1.<span class="built_in">size</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">			stack2.<span class="built_in">push</span>(stack1.<span class="built_in">top</span>());</span><br><span class="line">			stack1.<span class="built_in">pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (stack2.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">exception</span>(<span class="string">&quot;stack2 is empty!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	T head = stack2.<span class="built_in">top</span>();</span><br><span class="line">	stack2.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="10-用两个队列实现栈"><a href="#10-用两个队列实现栈" class="headerlink" title="10 用两个队列实现栈"></a>10 用两个队列实现栈</h1><blockquote>
<p>用两个队列实现一个栈,栈的声明如下,请实现它的两个函数appendTail和deleteHead的功能。</p>
</blockquote>
<h2 id="Testing-case-10"><a href="#Testing-case-10" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>往空的栈中添加，删除元素</li>
<li>往非空的栈中添加，删除元素</li>
<li>连续删除元素直至栈为空</li>
</ul>
<h2 id="Key-10"><a href="#Key-10" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>熟悉栈与队列的特性</p>
<blockquote>
<p>队列先进先出，栈后进先出</p>
</blockquote>
</li>
<li><p>appendTail 栈顶插入</p>
<blockquote>
<ol>
<li>若插入元素时两个队列均为空，则随意，指定为queue1</li>
<li>若插入元素时含不为空的队列，则插入到不为空的队列中去</li>
</ol>
</blockquote>
</li>
<li><p>deleteHead 栈顶弹出</p>
<blockquote>
<p>删除结点时，为保证删除结点的顺序，因此需要</p>
<ol>
<li>先将不为空的队列的元素除最后插入的元素以外全部弹出并压入到空的队里中去</li>
<li>将该队列最后插入元素于队列中弹出</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-10"><a href="#Answer-10" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> CStack&lt;T&gt;::<span class="built_in">appendTail</span>(<span class="keyword">const</span> T&amp;node) &#123;</span><br><span class="line">	<span class="keyword">if</span> (queue1.<span class="built_in">size</span>() == <span class="number">0</span> &amp;&amp; queue2.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">		queue1.<span class="built_in">push</span>(node);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (queue1.<span class="built_in">size</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">		queue1.<span class="built_in">push</span>(node);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		queue2.<span class="built_in">push</span>(node);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T CStack&lt;T&gt;::<span class="built_in">deleteHead</span>() &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (queue2.<span class="built_in">size</span>() == <span class="number">0</span> &amp;&amp; queue1.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">exception</span>(<span class="string">&quot;queue is empty!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (queue2.<span class="built_in">size</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">while</span> (queue2.<span class="built_in">size</span>() != <span class="number">1</span>) &#123;</span><br><span class="line">			</span><br><span class="line">			queue1.<span class="built_in">push</span>(queue2.<span class="built_in">front</span>());</span><br><span class="line">			queue2.<span class="built_in">pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		T head = queue2.<span class="built_in">front</span>();</span><br><span class="line">		queue2.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">while</span> (queue1.<span class="built_in">size</span>() != <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">			queue2.<span class="built_in">push</span>(queue1.<span class="built_in">front</span>());</span><br><span class="line">			queue1.<span class="built_in">pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		T head = queue1.<span class="built_in">front</span>();</span><br><span class="line">		queue1.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</blockquote>
<h1 id="11-斐波那契数列"><a href="#11-斐波那契数列" class="headerlink" title="11 斐波那契数列"></a>11 斐波那契数列</h1><blockquote>
<p>求斐波那契数列的第n项。写一个函数,输入n,求斐波那契(Fibonacci)数列的第n项。</p>
</blockquote>
<h2 id="Testing-case-11"><a href="#Testing-case-11" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(3,5,10)</li>
<li>边界测试(0,1,2)</li>
<li>性能测试(40,50,100)</li>
</ul>
<h2 id="Key-11"><a href="#Key-11" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>T(n) = O(2^n) S(n) = O(n)</p>
<blockquote>
<p>自上而下回溯递归，按条件形式递归</p>
<p>缺陷:</p>
<ol>
<li>每次递归需要存放函数返回地址，临时变量等，占用栈空间</li>
<li>每次递归调用时栈的弹出，压入需要耗费时间</li>
<li>每个进程的栈空间有限，可能存在栈溢出问题</li>
</ol>
</blockquote>
</li>
<li><p>T(n) = O(n) S(n) = O(1)</p>
<blockquote>
<p>自下而上循环累加代替自上而下的回溯递归</p>
</blockquote>
</li>
</ul>
<h2 id="Answer-T-n-O-n"><a href="#Answer-T-n-O-n" class="headerlink" title="Answer - T(n) = O(n)"></a>Answer - T(n) = O(n)</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">Fibonaci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">long</span> one = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">long</span> two = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">long</span> FN = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			FN = one + two;</span><br><span class="line">			one = two;</span><br><span class="line">			two = FN;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> FN;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="11-1-青蛙跳台阶"><a href="#11-1-青蛙跳台阶" class="headerlink" title="11.1 青蛙跳台阶"></a>11.1 青蛙跳台阶</h1><blockquote>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p>
</blockquote>
<h2 id="Testing-case-12"><a href="#Testing-case-12" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(3,5,10)</li>
<li>边界测试(0,1,2)</li>
<li>性能测试(40,50,100)</li>
</ul>
<h2 id="Key-12"><a href="#Key-12" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>数学建模能力</p>
<blockquote>
<p>青蛙跳上一级台阶有一种跳法，青蛙跳上二级台阶有两种跳法，当N&gt;2时，的跳法总数可经过分析得为f(n) = f(n-1)+f(n-2)</p>
<p>分析:</p>
<p>青蛙第一跳可以选择跳一级台阶也可以选择跳两级台阶，总跳法取决于含第一跳的剩余台阶的跳法</p>
<ul>
<li><p>若选择跳一级台阶，则剩下n-1个台阶共含有f(n-1)种跳法</p>
</li>
<li><p>若选择跳二级台阶，则剩下n-2个台阶共含有f(n-2)种跳法</p>
</li>
</ul>
<p>因此f(n) = f(n-1) + f(n-2)</p>
</blockquote>
</li>
</ul>
<h2 id="Answer-11"><a href="#Answer-11" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">Fibonaci_F</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">long</span> one = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">long</span> two = <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">long</span> FN = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">			FN = one + two;</span><br><span class="line">			one = two;</span><br><span class="line">			two = FN;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> FN;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="11-2-青蛙变态跳台阶"><a href="#11-2-青蛙变态跳台阶" class="headerlink" title="11.2 青蛙变态跳台阶"></a>11.2 青蛙变态跳台阶</h1><blockquote>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶，也可以一次跳上n级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p>
</blockquote>
<h2 id="Testing-case-13"><a href="#Testing-case-13" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(3,5,10)</li>
<li>边界测试(0,1,2)</li>
<li>性能测试(40,50,100)</li>
</ul>
<h2 id="Key-13"><a href="#Key-13" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>数学建模能力</p>
<blockquote>
<ol>
<li><p>青蛙跳上最后一级台阶的跳法有，从n-1层台阶跳一级，或者从n-2级台阶跳二级…从1级台阶跳n级，所以f(n) = f(n-1) + f(n-2)+ … + f(1)</p>
</li>
<li><p>青蛙跳上n-1级台阶的跳法有 f(n-1) = f(n-2) + … + f(1)</p>
</li>
<li><p>所以f(n) = 2f(n-1) = 4f(n-2) = 2^(n-1) * f(1) =  2^(n-1)</p>
</li>
</ol>
</blockquote>
</li>
</ul>
<h1 id="—-快速排序算法-—"><a href="#—-快速排序算法-—" class="headerlink" title="—- 快速排序算法 —-"></a>—- 快速排序算法 —-</h1><h2 id="Testing-case-14"><a href="#Testing-case-14" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试</li>
<li>边界测试(nullptr)</li>
<li>性能测试</li>
</ul>
<h2 id="Key-14"><a href="#Key-14" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>随机基数分治法</p>
<blockquote>
<p>随机选择数组中的一个元素作为基数pivot，将比基数小的元素移动到基数左边，比基数大的元素移动到基数右边，递归对基数左右的元素再进行基数分治，直至范围长度为1</p>
</blockquote>
</li>
<li><p>随机基数分治法 - 双指针交替</p>
<blockquote>
<p>使用left,right指针与index指针三个指针实现</p>
<p>left: 时刻应指向比基数小的元素</p>
<p>right:时刻应指向不比基数小的元素</p>
<p>index:指向基数应存放的位置，在该位置未被赋予key值前，该位置均认为为空，原元素可被覆盖，暂存left或者right不应指向的元素</p>
<ol>
<li>从左开始，left指针指向的元素与基数比较，若比基数小，left指针后移，否则，将该元素赋值到index处，并将index设置到left当前指向</li>
<li>从right开始交替判断，若right指向的元素不比基数小，right指针前移，否则，将该元素赋值到index处，并将index设置到right当前指向</li>
<li>1,2往复交替，直至left==right，该位置为key值应存位置</li>
</ol>
</blockquote>
</li>
<li><p>随机基数分治法 - 单指针交换</p>
<blockquote>
<p>使用small指针单指针实现</p>
<p>small:small时刻指向当前最后一个比基数小的元素</p>
<ol>
<li>随机获取关键字索引，并于数组末暂存key，对key前元素进行排序</li>
<li>遍历数组，若元素比基数小，small++，使small指向比基数小的元素，否则，small不自增，继续向下遍历数组</li>
<li>直至再次遇到比基数小的元素，small自增，将该元素与small当前指向元素进行交换</li>
<li>重复3，直至遍历完数组，数组当前状态为small指向最后一个比基数小的元素，基数存放于数组末</li>
<li>将基数归位，与(++small)位置处的比基数大的元素进行交换</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-12"><a href="#Answer-12" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<p>1</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普遍方法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Position</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> len, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span> || start &lt; <span class="number">0</span> || end &gt;= len) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">exception</span>(<span class="string">&quot;数组异常&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//随机获取关键字索引</span></span><br><span class="line"> <span class="comment">//index必须使用范围内随机数或者首尾，不能使用常数，因为每次递归常量index可能会导致越界</span></span><br><span class="line">	<span class="keyword">int</span> index = start;</span><br><span class="line">	<span class="keyword">int</span> key = arr[index];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">		<span class="keyword">while</span> (start &lt; end &amp;&amp;arr[start] &lt; key) &#123;</span><br><span class="line">			start++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//移动元素时必须每次判断是否满足循环条件，否则将导致越界访问</span></span><br><span class="line">		<span class="keyword">if</span> (arr[start] &gt;= key) &#123;</span><br><span class="line">			arr[index] = arr[start];</span><br><span class="line">			index = start;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//移动元素时必须每次判断是否满足循环条件，否则将导致越界访问</span></span><br><span class="line">		<span class="keyword">while</span> (start &lt; end &amp;&amp;arr[end] &gt;= key) &#123;</span><br><span class="line">			end--;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (arr[end] &lt; arr[index]) &#123;</span><br><span class="line">			arr[index] = arr[end];</span><br><span class="line">			index = end;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	arr[index] = key;</span><br><span class="line">	<span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> len, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取关键字位置</span></span><br><span class="line">	<span class="keyword">int</span> index = <span class="built_in">Position</span>(arr, len, start, end);</span><br><span class="line">	<span class="comment">//递归快排index左边的数据</span></span><br><span class="line">	<span class="keyword">if</span> (index &gt; start)</span><br><span class="line">		<span class="built_in">QuickSort</span>(arr, len, start, index - <span class="number">1</span>);</span><br><span class="line">	<span class="comment">//递归快排index右边的数据</span></span><br><span class="line">	<span class="keyword">if</span> (index &lt; end)</span><br><span class="line">		<span class="built_in">QuickSort</span>(arr, len, index + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> length, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (data == <span class="literal">NULL</span> || length &lt;= <span class="number">0</span> || start &lt; <span class="number">0</span> || end &gt;= length)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;error1!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> index = <span class="built_in">RandomInRange</span>(start, end);</span><br><span class="line">	<span class="comment">//在数组末尾暂存基数，对基数前面的数据进行移动</span></span><br><span class="line">	<span class="built_in">swap_element</span>(&amp;data[index], &amp;data[end]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置small指针，时刻指向当前最后一个比基数小的元素</span></span><br><span class="line">	<span class="keyword">int</span> small = start - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历数组，移动small指针，最终使small指向当前最后一个比基数小的元素</span></span><br><span class="line">	<span class="keyword">for</span> (index = start; index &lt; end; index++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (data[index] &lt; data[end]) &#123;</span><br><span class="line">			small++;</span><br><span class="line">			<span class="keyword">if</span> (small != index) &#123;</span><br><span class="line">				<span class="built_in">swap_element</span>(&amp;data[index], &amp;data[small]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//移动small指针，使其指向基数应在的位置，但是当前存放着比基数大的元素</span></span><br><span class="line">	small++;</span><br><span class="line">	<span class="comment">//将末尾暂存的基数归位</span></span><br><span class="line">	<span class="built_in">swap_element</span>(&amp;data[end], &amp;data[small]);</span><br><span class="line">	<span class="keyword">return</span> small;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Quicksort</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> length, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (start == end)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> index = <span class="built_in">Partition</span>(data, length, start, end);</span><br><span class="line">	<span class="keyword">if</span> (index &gt; start)</span><br><span class="line">		<span class="built_in">Quicksort</span>(data, length, start, index - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (index &lt; end)</span><br><span class="line">		<span class="built_in">Quicksort</span>(data, length, index + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RandomInRange</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (end &gt; start)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));<span class="comment">//srand函数是随机数发生器的初始化函数,使得随机数种子随时间的变化而变化</span></span><br><span class="line">		<span class="keyword">return</span> start + <span class="built_in">rand</span>() % ((end - start));<span class="comment">//产生start~end之间的随机数</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_element</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp;</span><br><span class="line">	temp = *a;</span><br><span class="line">	*a = *b;</span><br><span class="line">	*b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</blockquote>
<h1 id="12-旋转数组最小数字"><a href="#12-旋转数组最小数字" class="headerlink" title="12 旋转数组最小数字"></a>12 旋转数组最小数字</h1><blockquote>
<p>把一个数组最开始的若干个元素搬到数组的末尾,我们称之为数组的旋转。</p>
<p>输入一个递增有序数组的一个旋转,输出旋转数组的最小元素。例如,数组(3,4,5,1,2}为{1,2,3,4,5}的一个旋转,该数组的最小值为1</p>
</blockquote>
<h2 id="Testing-case-15"><a href="#Testing-case-15" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(输入的数组是升序数组的一个旋转，有重复数字或无重复数字)</li>
<li>边界测试(仅含有一个元素的数组)</li>
<li>性能测试(nullptr)</li>
</ul>
<h2 id="Key-15"><a href="#Key-15" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>二分思维(缩小查找范围)</p>
<blockquote>
<p> 将整个旋转数组看做两个递增序列，且第一个递增序列的值始终大于等于第二个递增序列的值，且最小的元素位于两个递增序列的边界</p>
<ol>
<li>设置两个指针分别指向整个序列的首尾，选取两指针范围内的元素与两端进行比较，判断该元素位于哪一个递增序列中</li>
<li>若该元素位于左边递增序列中，则移动left指针至该元素处，否则，移动right指针至该元素处</li>
<li>直至left与right相差1，此时right指向最小的元素</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li><p>2中若左右两端元素相等且中间元素值也与端值相等，则无法判断该元素位于哪一个序列，需要顺序查找</p>
<p>10111 - 11101 无法判断1位于哪一个递增序列中</p>
</li>
<li><p>若旋转数组旋转尺度为0，则不存在两个序列，直接返回首元素即可</p>
</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-13"><a href="#Answer-13" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常处理</span></span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="literal">nullptr</span> || length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">exception</span>(<span class="string">&quot;数组异常！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//指针初始化</span></span><br><span class="line">	<span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> right = length - <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//考虑到旋转数组旋转尺度为0时，即整个数组递增有序时的情况，返回首元素</span></span><br><span class="line">	<span class="keyword">int</span> mid = left;</span><br><span class="line">	<span class="comment">/*int mid = left;*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (arr[left] &gt;= arr[right]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (right - left == <span class="number">1</span>) &#123;</span><br><span class="line">			mid = right;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//取范围内的一个数</span></span><br><span class="line">		mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (arr[left] == arr[right] &amp;&amp; arr[mid] == arr[left]) &#123;</span><br><span class="line">			<span class="comment">//指定范围内顺序查找</span></span><br><span class="line">			_getMin(arr, left, right);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (arr[mid] &gt;= arr[left]) &#123;</span><br><span class="line">			left = mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt;= arr[right]) &#123;</span><br><span class="line">			right = mid;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arr[mid];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _getMin(<span class="keyword">int</span> *arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right) &#123;</span><br><span class="line">	<span class="keyword">int</span> min = arr[left];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt;= right; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (arr[i] &lt;= min) &#123;</span><br><span class="line">			min = arr[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="—-Exhaustive-Search-穷举搜索-—"><a href="#—-Exhaustive-Search-穷举搜索-—" class="headerlink" title="—- Exhaustive Search 穷举搜索 —-"></a>—- Exhaustive Search 穷举搜索 —-</h1><h2 id="Pattern-决策树下的递归"><a href="#Pattern-决策树下的递归" class="headerlink" title="Pattern - 决策树下的递归"></a>Pattern - 决策树下的递归</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">explore</span><span class="params">(options, soFar)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (no more decisions to make) &#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// recursive case, we have a decision to make</span></span><br><span class="line">        <span class="keyword">for</span> (each available option) &#123;</span><br><span class="line">            <span class="built_in">choose</span> (update options/sofar)</span><br><span class="line">            <span class="built_in">explore</span> (recur on updated options/sofar)</span><br><span class="line">            [<span class="built_in">backtracking</span> (undo changes to options/sofar)] <span class="comment">//chooseable</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>base case 递归终止条件</li>
<li>make decisions 作决策</li>
<li>explore -递归处理该决策下的决策</li>
<li>backtracking 决策失败后的回溯</li>
</ul>
<h1 id="13-矩阵中的路径"><a href="#13-矩阵中的路径" class="headerlink" title="13 矩阵中的路径"></a>13 矩阵中的路径</h1><blockquote>
<p>请设计一个函数,用来判断在一个矩阵中是否存在一条包含某字符串<strong>所有字符的路径</strong>。路径可以从矩阵中的任意一格开始,每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格,那么该路径<strong>不能再次进入</strong>该格子。例如,在下面的3x4的矩阵中包含一条字符串”bfce”的路径(路径中的字母用下画线标出)。但矩阵中不包含字符串”abtb”的路径,因为字符串的第一个字符b占据了矩阵中的第一行第三个格子之后,路径不能再次进入这个格子。</p>
</blockquote>
<h2 id="Testing-case-16"><a href="#Testing-case-16" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(多行多列的矩阵中存在/不存在路径)</li>
<li>边界测试(矩阵只有一行/一列，矩阵中所有字符相同)</li>
<li>性能测试(nullptr)</li>
</ul>
<h2 id="Key-16"><a href="#Key-16" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>递归回溯-穷举法</p>
<blockquote>
<ol>
<li><p>对于给定的矩阵进行遍历，与给定字符串中的元素进行匹配</p>
</li>
<li><p>每匹配到一个元素，便对其相邻元素进行递归查找，若相邻元素无匹配项，则回溯到上一个元素</p>
<p><code>注意:</code>由于每个格子仅能访问一次，因此需要为每个格子设置访问标识</p>
</li>
</ol>
</blockquote>
</li>
<li><p>递归模式</p>
<ol>
<li>base case 递归终止的条件</li>
<li>对匹配元素的四周递归搜索</li>
<li>若四周无匹配元素，回溯回退到上一格</li>
</ol>
</li>
</ul>
<h2 id="Answer-14"><a href="#Answer-14" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>* arr, <span class="keyword">int</span> cols, <span class="keyword">int</span> rows, string str)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常处理</span></span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="literal">nullptr</span> || cols &lt; <span class="number">1</span> || rows &lt; <span class="number">1</span> || str.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">exception</span>(<span class="string">&quot;异常!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置访问标识数组</span></span><br><span class="line">	<span class="keyword">bool</span>* visited = <span class="keyword">new</span> <span class="keyword">bool</span>[cols*rows];</span><br><span class="line">	<span class="comment">//初始化</span></span><br><span class="line">	<span class="built_in">memset</span>(visited, <span class="number">0</span>, cols*rows);</span><br><span class="line">	<span class="comment">//设置路径状态变量，用于标识路径搜索状态，str中字符匹配位置状态</span></span><br><span class="line">	<span class="keyword">int</span> pathLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历矩阵每一个元素进行路径搜索</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; cols; col++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; rows; row++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">hasPathCore</span>(arr, cols, col, rows, row, pathLength, str, visited)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span> []visited;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasPathCore</span><span class="params">(<span class="keyword">char</span>* arr, <span class="keyword">int</span> cols, <span class="keyword">int</span> col, <span class="keyword">int</span> rows, <span class="keyword">int</span> row, <span class="keyword">int</span>&amp; pathLength,string str, <span class="keyword">bool</span>*&amp;visited)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//base case</span></span><br><span class="line">	<span class="keyword">if</span> (str[pathLength] == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//设置返回值</span></span><br><span class="line">	<span class="keyword">bool</span> hasPath = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (col &gt;= <span class="number">0</span> &amp;&amp; col &lt; cols&amp;&amp;row&gt;=<span class="number">0</span> &amp;&amp; row &lt; rows&amp;&amp;arr[row*cols + col] == str[pathLength] &amp;&amp; visited[row*cols + col] != <span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="comment">//找到匹配路径元素，查找下一个匹配的路径元素</span></span><br><span class="line">		pathLength++;</span><br><span class="line">		<span class="comment">//设置访问状态</span></span><br><span class="line">		visited[row*cols + col] == <span class="literal">true</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//查找该元素的相邻元素</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">hasPathCore</span>(arr, cols, col + <span class="number">1</span>, rows, row, pathLength, str, visited)</span><br><span class="line">			|| <span class="built_in">hasPathCore</span>(arr, cols, col, rows, row + <span class="number">1</span>, pathLength, str, visited)</span><br><span class="line">			|| <span class="built_in">hasPathCore</span>(arr, cols, col - <span class="number">1</span>, rows, row, pathLength, str, visited)</span><br><span class="line">			|| <span class="built_in">hasPathCore</span>(arr, cols, col, rows, row - <span class="number">1</span>, pathLength, str, visited)) &#123;</span><br><span class="line">			hasPath = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//若未找到下一个匹配元素，需要回溯到上一个元素</span></span><br><span class="line">		<span class="keyword">if</span> (!hasPath) &#123;</span><br><span class="line">			pathLength--;</span><br><span class="line">			visited[row*cols + col] == <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> hasPath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="14-机器人的运动范围"><a href="#14-机器人的运动范围" class="headerlink" title="14 机器人的运动范围"></a>14 机器人的运动范围</h1><blockquote>
<p>地上有一个m行n列的方格。一个机器人从坐标(0, 0)的格子开始移动,它每次可以向左、右、上、下移动一格,但不能进入行坐标和列坐标的数位之和大于k的格子。</p>
<p>例如,当k为18时,机器人能够进入方格(35, 37),因为3+5+3+7-18,但它不能进入方格(35, 38),因为3+5+3+8-19,请问该机器人能够到达多少个格子?</p>
</blockquote>
<h2 id="Testing-case-17"><a href="#Testing-case-17" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(矩阵为多行多列，k为正数)</li>
<li>边界测试(矩阵为一行一列，k为0)</li>
<li>性能测试(k为负数)</li>
</ul>
<h2 id="Key-17"><a href="#Key-17" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>递归</p>
<blockquote>
<ol>
<li>从矩阵左上角首元素开始，若元素所在行列不满足阈值条件，则直接返回0，表示从该元素开始的运动范围为0</li>
<li>若满足阈值条件，则从该元素位置开始计数，并对其四周进行递归计数，最终将该计数总和返回即可得到可抵达的所有范围</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-15"><a href="#Answer-15" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isOK</span><span class="params">(<span class="keyword">int</span> cols, <span class="keyword">int</span> rows, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (cols != <span class="number">0</span>) &#123;</span><br><span class="line">		sum += cols % <span class="number">10</span>;</span><br><span class="line">		cols /= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (rows != <span class="number">0</span>) &#123;</span><br><span class="line">		sum += rows % <span class="number">10</span>;</span><br><span class="line">		rows /= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sum &gt; k) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNum</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常处理</span></span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="literal">nullptr</span> || cols &lt; <span class="number">1</span> || rows &lt; <span class="number">1</span> || k &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">exception</span>(<span class="string">&quot;异常!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置访问标识数组</span></span><br><span class="line">	<span class="keyword">bool</span>* visited = <span class="keyword">new</span> <span class="keyword">bool</span>[cols*rows];</span><br><span class="line">	<span class="comment">//初始化</span></span><br><span class="line">	<span class="built_in">memset</span>(visited, <span class="number">0</span>, cols*rows);</span><br><span class="line">	<span class="comment">//设置出发点</span></span><br><span class="line">	<span class="keyword">int</span> col = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> num = <span class="built_in">getNumCore</span>(arr, row, rows, col, cols, k, visited);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//回收内存</span></span><br><span class="line">	<span class="keyword">delete</span>[] visited;</span><br><span class="line">	<span class="keyword">return</span> num;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNumCore</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">int</span> row, <span class="keyword">int</span> rows,<span class="keyword">int</span> col, <span class="keyword">int</span> cols, <span class="keyword">int</span> k, <span class="keyword">bool</span>*visited)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//base case</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">isOK</span>(cols, rows, k)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (!visited[row*cols + col]) &#123;</span><br><span class="line">			num++;</span><br><span class="line">			visited[row*cols + col] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">			num += <span class="built_in">getNumCore</span>(arr, row - <span class="number">1</span>, rows, col, cols, k, visited);</span><br><span class="line">			num += <span class="built_in">getNumCore</span>(arr, row + <span class="number">1</span>, rows, col, cols, k, visited);</span><br><span class="line">			num += <span class="built_in">getNumCore</span>(arr, row, rows, col - <span class="number">1</span>, cols, k, visited);</span><br><span class="line">			num += <span class="built_in">getNumCore</span>(arr, row, rows, col + <span class="number">1</span>, cols, k, visited);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> num;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="15-剪绳子"><a href="#15-剪绳子" class="headerlink" title="15 剪绳子"></a>15 剪绳子</h1><blockquote>
<p>给你一根长度为n的绳子,请把绳子剪成m段(m、n都是整数,n1并且m&gt;1),每段绳子的长度记为A[0].A[1]..A[m]</p>
<p>请问k[0]×…×k[m]可能的最大乘积是多少?例如,当绳子的长度是8时,我们把它剪成长度分别为2,3,3的三段,此时得到的最大乘积是18</p>
</blockquote>
<h2 id="Testing-case-18"><a href="#Testing-case-18" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(初始长度大于5)</li>
<li>边界测试(边界值1,2,3,4)</li>
</ul>
<h2 id="Key-18"><a href="#Key-18" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>动态规划 T(n)=O(n2) S(n)=O(n)</p>
<blockquote>
<p>自下而上的迭代计算代替自顶向下的递归计算，减少重复计算</p>
<ol>
<li>自顶向下分析可得，剪得的最后一次的绳子段长度可能为 1,2…n-1，共n-1种可能将0绳子分为两部分，所以最大乘积 f(n)=max{f(i)*f(n-i)}，最大乘积为最后两部分相应乘积最大值的乘积，max{f(i)*f(n-i)} =&gt;max{f(i)} × max{f(n-i)} ,而max{f(i)}仍可拆解为两段分析</li>
<li>自下向上迭代计算剩余长度为0,1…n的部分的最大乘积，并使用数组顺序存放每部分的最大乘积值</li>
</ol>
</blockquote>
</li>
<li><p>贪心算法 T(n)=O(1) S(n)=O(1)</p>
<blockquote>
<p>当n&gt;=5时，剪得的绳子段长度为3的数目越多越好，其中两段长度分别为3和1的需要用两段长度为2和2的绳子段代替，因为3×1 &lt; 2×2</p>
<ol>
<li>计算绳子最多可容纳的长度为3的绳子段的个数</li>
<li>计算是否存在长度为1的绳子段，若存在，则有一段长度为3的绳子段不可用，需用长度为2的代替</li>
<li>计算剩余长度可容纳的长度为2的绳子段的个数</li>
<li>返回乘积结果</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-16"><a href="#Answer-16" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<p>1</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//对输入长度作初始判断</span></span><br><span class="line">	<span class="keyword">if</span> (length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="comment">//没办法砍</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (length == <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="comment">//只能砍一刀</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (length == <span class="number">3</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//使用数组暂存自下向上的各长度的最大乘积值</span></span><br><span class="line">	<span class="keyword">int</span>* temp = <span class="keyword">new</span> <span class="keyword">int</span>[length + <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">		temp[i] = i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置记录长度为n时的乘积max变量</span></span><br><span class="line">	<span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//计算其余长度的最大乘积值</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= length; i++) &#123;</span><br><span class="line">		max = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//使用已记录的值迭代进行计算，防止重复计算乘积值，设置终止条件为i/2</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i / <span class="number">2</span>; j++) &#123;</span><br><span class="line">			max = temp[j] * temp[i - j];</span><br><span class="line">			<span class="keyword">if</span> (max &gt;= temp[i]) &#123;</span><br><span class="line">				temp[i] = max;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	max = temp[length];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//防止内存泄漏</span></span><br><span class="line">	<span class="keyword">delete</span>[] temp;</span><br><span class="line">	<span class="keyword">return</span> max;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaxx</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//对输入长度作初始判断</span></span><br><span class="line">	<span class="keyword">if</span> (length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="comment">//没办法砍</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (length == <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="comment">//只能砍一刀</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (length == <span class="number">3</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//记录绳子可剪为长度为3的绳子段的个数与长度为2的绳子段的个数</span></span><br><span class="line">	<span class="keyword">int</span> threeTimes = length / <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">int</span> twoTimes = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//记录是否存在裁剪为3*1的情况，需使用2*2替代</span></span><br><span class="line">	<span class="keyword">if</span> (length - <span class="number">3</span> * threeTimes == <span class="number">1</span>) &#123;</span><br><span class="line">		threeTimes -= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	twoTimes = (length - <span class="number">3</span> * threeTimes) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">2</span>, twoTimes) * <span class="built_in">pow</span>(<span class="number">3</span>, threeTimes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="16-二进制中1的个数"><a href="#16-二进制中1的个数" class="headerlink" title="16 二进制中1的个数"></a>16 二进制中1的个数</h1><blockquote>
<p>请实现一个函数,输入一个整数,输出该数二进制表示中1的个数。</p>
<p>例如,把9表示成二进制是1001,有2位是1。因此,如果输入9,则该函数输出2</p>
</blockquote>
<h2 id="Testing-case-19"><a href="#Testing-case-19" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>正数(边界值 1,0x7fffffff)</li>
<li>负数(0x80000000,0xffffffff)</li>
<li>0</li>
</ul>
<h2 id="Key-19"><a href="#Key-19" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>右移整数</p>
<blockquote>
<p>从低位开始判断是否为1，为1则右移一位继续判断次低位，直至整数为0</p>
<p>判断是否为1可与1作&amp;运算</p>
<p><code>注意:</code>若输入负数将引起死循环，负数右移左补1，不会使原数至0</p>
</blockquote>
</li>
<li><p>左移标志数</p>
<blockquote>
<p>从低位开始判断是否为1，为1则标志数左移一位继续判断整数的次低位，直至标志数为0</p>
<p>判断次低位是否为1可与10作&amp;运算，次次低位…</p>
<p>操作次数与整数二进制位数相同</p>
</blockquote>
</li>
<li><p>消除二进制中的所有1</p>
<blockquote>
<p>只要整数不为0，则其二进制中必含1，从低位开始将整数二进制中的1置为0，直至整数为0时的置0操作次数即为0的个数</p>
<p>将整数减去1后与自身作与运算即可消去低位的1</p>
<p>操作次数与整数二进制中1的个数相同</p>
</blockquote>
</li>
</ul>
<h2 id="Answer-17"><a href="#Answer-17" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<p>1</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNOne1</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> nums = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">			nums++;</span><br><span class="line">		&#125;</span><br><span class="line">		n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNOne2</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> nums = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (flag) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n &amp; flag) &#123;</span><br><span class="line">			nums++;</span><br><span class="line">		&#125;</span><br><span class="line">		flag &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNOne3</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> nums = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (n) &#123;</span><br><span class="line">		nums++;</span><br><span class="line">		n = (n - <span class="number">1</span>)&amp;n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="17-数值的整数次方"><a href="#17-数值的整数次方" class="headerlink" title="17 数值的整数次方"></a>17 数值的整数次方</h1><blockquote>
<p>实现函数double Power(double base, int exponent),求base的exponent次方。</p>
<p>不得使用库函数,同时不需要考虑大数问题。</p>
</blockquote>
<h2 id="Testing-case-20"><a href="#Testing-case-20" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(正数负数的任意整数次幂)</li>
<li>边界测试(0的负数次幂)</li>
</ul>
<h2 id="Key-20"><a href="#Key-20" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>考虑边界值的处理</p>
</li>
<li><p>考虑指数为负数时的倒数处理</p>
</li>
<li><p>考虑错误处理的方式 - 返回值，全局变量，异常</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="center">方式</th>
<th align="center">优缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="left">返回值</td>
<td align="center">返回0表示调用成功，否则调用失败</td>
<td align="center">与系统API一致但是执行结果不便于操作</td>
</tr>
<tr>
<td align="left">全局变量</td>
<td align="center">通过全局变量的值的情况反应函数是否调用成功</td>
<td align="center">便于操作计算结果但是容易忘记处理失败调用</td>
</tr>
<tr>
<td align="left">异常</td>
<td align="center">通过抛出异常的类型对不同类型的异常作不同的处理</td>
<td align="center">方便处理异常但是有性能开销，有的语言不支持异常</td>
</tr>
</tbody></table>
</li>
<li><p>累乘法</p>
<blockquote>
<p>累乘的次数与指数的大小相同</p>
</blockquote>
</li>
<li><p>递归法</p>
<blockquote>
<ol>
<li>若指数为偶数，则|index|整数次方可以由 |index/2| 的乘积得出</li>
<li>若指数为奇数，则|index|整数次方可以由 |index/2| 的乘积 × n 得出</li>
<li>由此可递归计算n的|index|整数次幂</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>使用右移一位操作代替除以2</li>
<li>使用&amp;0x1操作代替%2，可提高性能执行效率</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-18"><a href="#Answer-18" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<p>1.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置用于检查调用是否成功的全局变量</span></span><br><span class="line"><span class="keyword">bool</span> failed = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getPow</span><span class="params">(<span class="keyword">double</span> n, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//考虑n为0时index为负数的情况，无法求倒数</span></span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0.0</span>&amp;index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		failed = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//无论指数正负，先求指数求绝对值后的次方结果</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> absIndex;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		absIndex = -index;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		absIndex = index;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">double</span> result = <span class="built_in">getAbsPow</span>(n, absIndex);</span><br><span class="line">	<span class="comment">//对指数为负数的情况求倒数</span></span><br><span class="line">	<span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		result = <span class="number">1.0</span> / result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getAbsPow</span><span class="params">(<span class="keyword">double</span> n, <span class="keyword">unsigned</span> <span class="keyword">int</span> absIndex)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">double</span> sum = <span class="number">1.0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1.0</span>; i &lt;= absIndex; i++) &#123;</span><br><span class="line">		sum *= n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getAbsPow2</span><span class="params">(<span class="keyword">double</span> n, <span class="keyword">unsigned</span> <span class="keyword">int</span> absIndex)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//basecase</span></span><br><span class="line">	<span class="keyword">if</span> (absIndex == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (absIndex == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">double</span> pow = <span class="built_in">getAbsPow2</span>(n, absIndex &gt;&gt; <span class="number">1</span>);</span><br><span class="line">		pow *= pow;</span><br><span class="line">		<span class="keyword">if</span> (absIndex &amp; <span class="number">0x1</span> == <span class="number">1</span>) &#123;</span><br><span class="line">			pow *= n;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> pow;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</blockquote>
<h1 id="18-打印从1到最大的n位数"><a href="#18-打印从1到最大的n位数" class="headerlink" title="18 打印从1到最大的n位数"></a>18 打印从1到最大的n位数</h1><blockquote>
<p>输入数字n,按顺序打印出从1到最大的n位十进制数。</p>
<p>比如输入3,则打印出1,2,3一直到最大的3位数999</p>
</blockquote>
<h2 id="Testing-case-21"><a href="#Testing-case-21" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(1,2,3)</li>
<li>边界测试(0,-1)</li>
</ul>
<h2 id="Key-21"><a href="#Key-21" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>大数问题</p>
<blockquote>
<p>当n过大，无论是int还是long长整型均会溢出，因此无法预先算出max(n)后顺序输出</p>
</blockquote>
</li>
<li><p>字符串模拟</p>
<blockquote>
<p>使用字符串来存放数字并模拟数字加法，最终将字符串表达的数字输出</p>
<ol>
<li>设置字符串的长度为n+1,使用’\0’初始化而非0，并将末尾值为空操作符</li>
<li>在字符串上模拟对数字的加法，设置进位标志，先取出对应位上的数字(-‘\0’)，进行加法运算后覆盖置回</li>
<li>输出数字时从字符串第一个非零的数字字符开始输出</li>
<li>若进位产生于字符串第一个位置，则已到达最大数位，不再输出</li>
</ol>
</blockquote>
</li>
<li><p>全排列递归</p>
<blockquote>
<p>将1到最大n位数的所有数当做0-9的全排列问题</p>
<ol>
<li>从首位开始递归排列直至到达最后一位进行回溯顺序输出</li>
</ol>
</blockquote>
</li>
<li><p>Bitmap算法</p>
<blockquote>
<p>使用bit作存储单元，使用更贴合计算机底层的运算，性能与内存使用效率都很高</p>
<p>bitmap中0表示无意义，1表示存放了索引对应的数据</p>
</blockquote>
</li>
</ul>
<h2 id="Answer-19"><a href="#Answer-19" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<p>1.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常处理</span></span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		xfailed = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//考虑大数问题，设置字符串或者数组来存放数字(此处选择字符串)</span></span><br><span class="line">	<span class="keyword">char</span>* str = <span class="keyword">new</span> <span class="keyword">char</span>[n + <span class="number">1</span>];</span><br><span class="line">	<span class="built_in">memset</span>(str, <span class="string">&#x27;0&#x27;</span>, n);</span><br><span class="line">	str[n] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">increment</span>(str)) &#123;</span><br><span class="line">		<span class="built_in">printNumCore</span>(str);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//防止内存泄漏</span></span><br><span class="line">	<span class="keyword">delete</span>[] str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对字符串模拟加1</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">increment</span><span class="params">(<span class="keyword">char</span>* str)</span></span>&#123;</span><br><span class="line">	<span class="comment">//记录字符串长度</span></span><br><span class="line">	<span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">	<span class="comment">//设置进位值</span></span><br><span class="line">	<span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//设置返回值判断是否至最大数进位</span></span><br><span class="line">	<span class="keyword">bool</span> arrive = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="comment">//设置模拟加法的临时数字变量</span></span><br><span class="line">		<span class="keyword">int</span> num = str[i] - <span class="string">&#x27;0&#x27;</span> + carry;</span><br><span class="line">		<span class="comment">//若为个位，则直接进行加1即可</span></span><br><span class="line">		<span class="keyword">if</span> (i == len - <span class="number">1</span>) &#123;</span><br><span class="line">			num++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (num &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">				arrive = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">//设置进位后，将本位设置为0后写回</span></span><br><span class="line">				num -= <span class="number">10</span>;</span><br><span class="line">				str[i] = num + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">				carry = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//直接写回</span></span><br><span class="line">			str[i] = num + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">			<span class="comment">//break作用为:所有的直接加一运算仅作用于个位，其余位的加1运算均来自carry的进位</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> arrive;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNumCore</span><span class="params">(<span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//设置判断是否为第一个非零数的变量</span></span><br><span class="line">	<span class="keyword">bool</span> first = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len; i++) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!first&amp;&amp;str[i] != <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">			first = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (first)</span><br><span class="line">			cout &lt;&lt; str[i];</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNum2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常处理</span></span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		xxfailed = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//考虑大数问题，设置字符串或者数组来存放数字(此处选择字符串)</span></span><br><span class="line">	<span class="keyword">char</span>* str = <span class="keyword">new</span> <span class="keyword">char</span>[n + <span class="number">1</span>];</span><br><span class="line">	<span class="built_in">memset</span>(str, <span class="string">&#x27;0&#x27;</span>, n);</span><br><span class="line">	str[n] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从第一位开始递归排列</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		str[<span class="number">0</span>] = i + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		<span class="built_in">permutation</span>(str, n, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//防止内存泄漏</span></span><br><span class="line">	<span class="keyword">delete</span>[] str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">permutation</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">int</span> length, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//base case</span></span><br><span class="line">	<span class="keyword">if</span> (index == length - <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="built_in">printNumCore2</span>(str);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		str[index + <span class="number">1</span>] = i + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		<span class="built_in">permutation</span>(str, length, index + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNumCore2</span><span class="params">(<span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//设置判断是否为第一个非零数的变量</span></span><br><span class="line">	<span class="keyword">bool</span> first = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len; i++) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!first&amp;&amp;str[i] != <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">			first = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (first)</span><br><span class="line">			cout &lt;&lt; str[i];</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="19-1-删除链表的结点"><a href="#19-1-删除链表的结点" class="headerlink" title="19.1 删除链表的结点"></a>19.1 删除链表的结点</h1><blockquote>
<p>在0(1)时间内删除链表节点</p>
<p>给定单向链表的头指针和一个节点指针,定义一个函数在O(1)时间内删除该节点</p>
<p>假设待删除的结点位于链表中</p>
</blockquote>
<h2 id="Testing-case-22"><a href="#Testing-case-22" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(要删除的结点在首尾结点之间，删除首元结点，删除尾元结点)</li>
<li>边界测试(nullpter)</li>
</ul>
<h2 id="Key-22"><a href="#Key-22" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>顺序删除 T(n)=O(n)</p>
<blockquote>
<p>从头结点开始顺序遍历至待删除结点的前一个结点进行删除</p>
</blockquote>
</li>
<li><p>伪删除 T(n)=O(1)</p>
<blockquote>
<ol>
<li>使用待删除结点的后一个结点值赋值替代待删除结点的值，待删除结点”伪装”为后一个结点</li>
<li>将待删除结点的next指针指向后一个 结点的next指向</li>
<li>删除后一个结点即可</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-20"><a href="#Answer-20" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> &#123;</span></span><br><span class="line">	LinkNode* pNext;</span><br><span class="line">	<span class="keyword">int</span> pValue;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(LinkNode** pHead, LinkNode* dNode)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断异常</span></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span> || dNode == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		doFalse = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dNode == *pHead) &#123;</span><br><span class="line">		<span class="comment">//删除的结点为头结点</span></span><br><span class="line">		<span class="keyword">delete</span> dNode;</span><br><span class="line">		dNode = <span class="literal">nullptr</span>;</span><br><span class="line">		*pHead = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (dNode-&gt;pNext != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="comment">//删除的结点为首尾结点之间的结点</span></span><br><span class="line">		LinkNode* ppNext = dNode-&gt;pNext;</span><br><span class="line">		dNode-&gt;pValue = ppNext-&gt;pValue;</span><br><span class="line">		dNode-&gt;pNext = ppNext-&gt;pNext;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">delete</span> ppNext;</span><br><span class="line">		ppNext = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//删除的结点为尾元结点</span></span><br><span class="line">		LinkNode* pPre = (*pHead)-&gt;pNext;</span><br><span class="line">		<span class="comment">//遍历至待删除结点的前一个结点</span></span><br><span class="line">		<span class="keyword">while</span> (pPre-&gt;pNext != dNode) &#123;</span><br><span class="line">			pPre = pPre-&gt;pNext;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		pPre-&gt;pNext = <span class="literal">nullptr</span>;</span><br><span class="line">		<span class="keyword">delete</span> dNode;</span><br><span class="line">		dNode = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="19-2-删除链表中的重复连续结点"><a href="#19-2-删除链表中的重复连续结点" class="headerlink" title="19.2 删除链表中的重复连续结点"></a>19.2 删除链表中的重复连续结点</h1><blockquote>
<p>删除链表中重复连续的节点</p>
<p>重复结点指连续的值相同的结点</p>
</blockquote>
<h2 id="Testing-case-23"><a href="#Testing-case-23" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(要删除的结点在首尾结点之间，首元结点，尾元结点)</li>
<li>边界测试(nullpter)</li>
</ul>
<h2 id="Key-23"><a href="#Key-23" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>顺序删除</p>
<blockquote>
<ol>
<li><p>顺序遍历整个链表，从第一个结点开始查找，是否存在连续的相同的结点</p>
</li>
<li><p>若存在，则需要删除当前连续结点，且判断其后续结点是否仍然连续</p>
</li>
<li><p>若不存在，则向后遍历，直至遍历完所有结点</p>
</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>为了保证链表连续，需要时刻记录当前遍历结点的前一个结点，在进行删除操作后，将前一个结点的pNext更新，保持链表连续</li>
<li>使用一个ppNext时刻指针指向preNode的下一个结点</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-21"><a href="#Answer-21" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteNode2</span><span class="params">(LinkNode** PHead)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断异常</span></span><br><span class="line">	<span class="keyword">if</span> (PHead == <span class="literal">nullptr</span> || *PHead== <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="comment">/*doFalse = true;*/</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//为保证连续性需要每次记录当前未被删除结点的上一个结点</span></span><br><span class="line">	LinkNode* preNode = <span class="literal">nullptr</span>;</span><br><span class="line">	LinkNode* pNode = *PHead;</span><br><span class="line">	<span class="comment">//遍历链表找寻重复结点</span></span><br><span class="line">	<span class="keyword">while</span> (pNode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="comment">//设置结点是否需要删除的标志</span></span><br><span class="line">		<span class="keyword">bool</span> deleteY = <span class="literal">false</span>;</span><br><span class="line">		<span class="comment">//设置指向当前结点下一结点的指针</span></span><br><span class="line">		LinkNode* ppNext = pNode-&gt;pNext;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//判断当前结点是否需要删除</span></span><br><span class="line">		<span class="keyword">if</span> (ppNext != <span class="literal">nullptr</span> &amp;&amp; ppNext-&gt;pValue == pNode-&gt;pValue) &#123;</span><br><span class="line">			deleteY = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//若不要删除则继续向下遍历</span></span><br><span class="line">		<span class="keyword">if</span> (!deleteY) &#123;</span><br><span class="line">			preNode = pNode;</span><br><span class="line">			pNode = pNode-&gt;pNext;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//记录当前需要删除的结点</span></span><br><span class="line">			LinkNode* DeleteNeed = pNode;</span><br><span class="line">			<span class="comment">//记录重复的元素值</span></span><br><span class="line">			<span class="keyword">int</span> value = DeleteNeed-&gt;pValue;</span><br><span class="line">			<span class="comment">//若当前结点需要删除，继续循环判断当前结点的下一个是否需要删除，判断结束后再进行删除</span></span><br><span class="line">			ppNext = DeleteNeed-&gt;pNext;</span><br><span class="line">			<span class="comment">//删除当前结点</span></span><br><span class="line">			<span class="keyword">delete</span> DeleteNeed;</span><br><span class="line">			DeleteNeed = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">while</span> (ppNext != <span class="literal">nullptr</span>&amp;&amp;ppNext-&gt;pValue == value) &#123;																		<span class="comment">//设置当前结点为需要删除的结点，注意顺序，不可和下面调换</span></span><br><span class="line">				DeleteNeed = ppNext;																									<span class="comment">//继续判断下一结点是否需要删除</span></span><br><span class="line">				ppNext = ppNext-&gt;pNext;																					</span><br><span class="line">				<span class="comment">//删除结点</span></span><br><span class="line">				<span class="keyword">delete</span> DeleteNeed;</span><br><span class="line">				DeleteNeed = <span class="literal">nullptr</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (preNode == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">				*PHead = ppNext;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				preNode-&gt;pNext = ppNext;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			pNode = ppNext;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</blockquote>
<h1 id="20-正则表达式匹配"><a href="#20-正则表达式匹配" class="headerlink" title="20 正则表达式匹配"></a>20 正则表达式匹配</h1><blockquote>
<p>请实现一个函数用来匹配包含‘.’和‘*’的正则表达式。模式中的字符’.’表示任意一个字符,而’米’表示它前面的字符可以出现任意次(含0次)。</p>
<p>在本题中,匹配是指字符串的所有字符匹配整个模式。例如,字符串”aa”与模式”a.a”和”ab米ac米a”匹配,但与”aa.a”和”ab*a”均不匹配。</p>
</blockquote>
<h2 id="Testing-case-24"><a href="#Testing-case-24" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(模式与输入字符串匹配或不匹配，模式字符串中含有普通字符,’.’,’*’，输入字符串为空字符串)</li>
<li>边界测试(nullptr)</li>
</ul>
<h2 id="Key-24"><a href="#Key-24" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>分治递归</p>
<blockquote>
<ol>
<li>在考虑当前字符是否匹配之前，先进行判断当前字符的下一个模式字符是否 ‘*’</li>
<li>若不是，则直接判断当前字符是否匹配，不匹配直接返回false，若匹配，移动指针，递归判断子字符串是否匹配</li>
<li>若是，则分三种情况讨论，当前字符出现0次，当前字符出现1次，当前字符出现多次</li>
<li>直至模式字符串匹配完成</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>‘*’ 可以忽略前一个字符(出现0次)，但是’.’不可以忽略，该字符必须参与比较</li>
<li>防止*(pattern + 1)越界，所以basecase使用pattern到末尾做基准</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-22"><a href="#Answer-22" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">char</span>* pattern)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (str == <span class="literal">nullptr</span> || pattern == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		isfalse = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">matchCore</span>(str, pattern);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">matchCore</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">char</span>* pattern)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//base case</span></span><br><span class="line">	<span class="keyword">if</span> (*str == <span class="string">&#x27;\0&#x27;</span>&amp;&amp;*pattern == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (*str != <span class="string">&#x27;\0&#x27;</span>&amp;&amp;*pattern == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//首先判断当前判定模式字符的下一位是否为*</span></span><br><span class="line">	<span class="keyword">if</span> (*(pattern + <span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (*str == *pattern || *pattern == <span class="string">&#x27;.&#x27;</span>&amp;&amp;*str != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">matchCore</span>(str, pattern + <span class="number">2</span>) || <span class="built_in">matchCore</span>(str + <span class="number">1</span>, pattern + <span class="number">2</span>) || <span class="built_in">matchCore</span>(str + <span class="number">1</span>, pattern);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">matchCore</span>(str, pattern + <span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (*str == *pattern || *pattern == <span class="string">&#x27;.&#x27;</span>&amp;&amp;*str != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">			<span class="comment">//第一个字符匹配,两个匹配字符串指针均后移一位</span></span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">matchCore</span>(str + <span class="number">1</span>, pattern + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="21-表示数值的字符串"><a href="#21-表示数值的字符串" class="headerlink" title="21 表示数值的字符串"></a>21 表示数值的字符串</h1><blockquote>
<p>请实现一个函数用来判断字符串是否表示数值(包括整数和小数)。例如,字符串”+100”，”5e2”，”-123”，”3.1416”及”-1E-16”都表示数值,但”12e”，”1a3.14”，”1.2.3”，”+-5”及”12e+5.4”都不是。</p>
</blockquote>
<h2 id="Testing-case-25"><a href="#Testing-case-25" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(有无整数部分，有无小数部分，有无指数部分，正数负数，含其他字符)</li>
<li>边界测试(nullptr，字符串为空)</li>
</ul>
<h2 id="Key-25"><a href="#Key-25" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>模式有序分析</p>
<blockquote>
<p>若一个字符串是数值字符串，则其满足[A][.B][e|EC],即A整数部分，B小数部分，C指数部分</p>
<ol>
<li>先判断整数部分，最大努力寻找整数，直至遇到’’.’或者’e|E’或其他字符停止或至末尾</li>
<li>再判断小数部分，若遇到’.’，则再向后最大努力寻找整数，直至遇到’e|E’或其他字符停止或至末尾</li>
<li>最后判断指数部分，若遇到’e|E’，则再向后最大努力寻找整数，直至遇到其他字符停止或至末尾</li>
<li>若三部分判断完毕且字符串也遍历完毕则为数值字符串</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>判断小数部分时使用 || 的原因为考虑无整数部分的小数也满足条件，无小数部分的整数也满足条件</li>
<li> 判断指数部分时使用 &amp;&amp; 的原因为考虑若含指数部分，则e之前至少含小数或整数，不可为空，e之后必含整数不可为空</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-23"><a href="#Answer-23" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isNum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (str == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//首先判断A整数部分是否满足条件</span></span><br><span class="line">	<span class="keyword">bool</span> numric = <span class="built_in">isInteger</span>(&amp;str);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断B小数部分是否满足条件</span></span><br><span class="line">	<span class="keyword">if</span> (*str == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">		str++;</span><br><span class="line"></span><br><span class="line">		numric = <span class="built_in">isUInteger</span>(&amp;str) || numric;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断C指数部分是否满足条件</span></span><br><span class="line">	<span class="keyword">if</span> (*str == <span class="string">&#x27;e&#x27;</span> || *str == <span class="string">&#x27;E&#x27;</span>) &#123;</span><br><span class="line">		str++;</span><br><span class="line">		numric = <span class="built_in">isInteger</span>(&amp;str) &amp;&amp; numric;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断字符串是否还有剩余的其他字符</span></span><br><span class="line"></span><br><span class="line">	numric = numric &amp;&amp; *str == <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> numric;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isUInteger</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>** str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *temp = *str;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (**str != <span class="string">&#x27;\0&#x27;</span> &amp;&amp; **str &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; **str &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">		(*str)++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//只要*str移动了则一定含有数字字符，一定大于temp，temp始终指向字符首部不变</span></span><br><span class="line">	<span class="keyword">return</span> *str &gt; temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isInteger</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>** str)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (**str == <span class="string">&#x27;+&#x27;</span> || **str == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">		(*str)++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">isUInteger</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="22-调整数组顺序使奇数位于偶数前面"><a href="#22-调整数组顺序使奇数位于偶数前面" class="headerlink" title="22 调整数组顺序使奇数位于偶数前面"></a>22 调整数组顺序使奇数位于偶数前面</h1><blockquote>
<p>输入一个整数数组,实现一个函数来调整该数组中数字的顺序使得所有奇数位于数组的前半部分,所有偶数位于数组的后半部分。</p>
</blockquote>
<h2 id="Testing-case-26"><a href="#Testing-case-26" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(数组奇数偶数交替，所有偶数在奇数前面，所有奇数在偶数前面)</li>
<li>边界测试(nullptr，仅含一个数字)</li>
</ul>
<h2 id="Key-26"><a href="#Key-26" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>双指针交换</p>
<blockquote>
<ol>
<li>设置两个指针分别为指向奇数的指针p1初始指向首元素，指向偶数的指针p2初始指向尾元素</li>
<li>移动两个指针，直至p1指向偶数，p2指向奇数，若p1&lt;=p2，表明存在一个偶数在奇数之前，交换其位置</li>
<li>当p1&gt;p2后，数组遍历完成，交换完成</li>
</ol>
</blockquote>
</li>
<li><p>考虑拓展性</p>
<blockquote>
<p>将性质判断从交换元素中解耦出来，使用函数指针指明判断方法即可</p>
</blockquote>
</li>
</ul>
<h2 id="Answer-24"><a href="#Answer-24" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Move</span><span class="params">(<span class="keyword">int</span>* base, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (base == <span class="literal">nullptr</span> || length &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置指针</span></span><br><span class="line">	<span class="keyword">int</span>* pOdd = base;</span><br><span class="line">	<span class="keyword">int</span>* pEven = base + length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过交换移动奇数于偶数之前</span></span><br><span class="line">	<span class="keyword">while</span> (pOdd &lt;= pEven) &#123;</span><br><span class="line">		<span class="keyword">while</span> (pOdd &lt;= pEven &amp;&amp; (*pOdd &amp; <span class="number">0x1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">			pOdd++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (pOdd &lt;= pEven &amp;&amp; (*pEven &amp; <span class="number">0x1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">			pEven--;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (pOdd &lt;= pEven) &#123;</span><br><span class="line">			<span class="keyword">int</span> temp;</span><br><span class="line">			temp = *pOdd; *pOdd = *pEven; *pEven = temp;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//考虑拓展性</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">standard</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (n &amp; <span class="number">0x1</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Move</span><span class="params">(<span class="keyword">int</span>* base, <span class="keyword">int</span> length, <span class="keyword">bool</span>(*func)(<span class="keyword">int</span>))</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (base == <span class="literal">nullptr</span> || length &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置指针</span></span><br><span class="line">	<span class="keyword">int</span>* pOdd = base;</span><br><span class="line">	<span class="keyword">int</span>* pEven = base + length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过交换移动奇数于偶数之前</span></span><br><span class="line">	<span class="keyword">while</span> (pOdd &lt;= pEven) &#123;</span><br><span class="line">		<span class="keyword">while</span> (pOdd &lt;= pEven &amp;&amp; !<span class="built_in">func</span>((*pOdd))) &#123;</span><br><span class="line">			pOdd++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (pOdd &lt;= pEven &amp;&amp; <span class="built_in">func</span>((*pEven))) &#123;</span><br><span class="line">			pEven--;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (pOdd &lt;= pEven) &#123;</span><br><span class="line">			<span class="keyword">int</span> temp;</span><br><span class="line">			temp = *pOdd; *pOdd = *pEven; *pEven = temp;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="23-1-链表中倒数第k个结点"><a href="#23-1-链表中倒数第k个结点" class="headerlink" title="23.1 链表中倒数第k个结点"></a>23.1 链表中倒数第k个结点</h1><blockquote>
<p>输入一个链表,输出该链表中倒数第k个节点。</p>
<p>为了符合大多数人的习惯,本题从1开始计数,即链表的尾节点是倒数第1个节点。</p>
<p>例如,一个链表有6个节点,从头节点开始,它们的值依次是1.2.3.4.5.6,这个链表的倒数第3个节点是值为4的节点。</p>
</blockquote>
<h2 id="Testing-case-27"><a href="#Testing-case-27" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(倒数第k个结点为首结点，尾结点，中间结点)</li>
<li>边界测试(nullptr，链表结点数小于k)</li>
</ul>
<h2 id="Key-27"><a href="#Key-27" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>遍历两次链表</p>
<blockquote>
<p>第一次从头遍历链表获取链表长度，第二次直接移动至 n-k+1 个结点处，即为倒数第k个结点</p>
</blockquote>
</li>
<li><p>遍历一次链表</p>
<blockquote>
<p>使用范围指针对，指针对始终相差k-1，当范围指针对右边界指针移动至链表尾部时，左边界指向的结点即为倒数第k个结点</p>
<ol>
<li>首先定位左右指针的边界，初始左边界为链表头，右边界为首部右移 k-1 次后的结点</li>
<li>移动该范围指针对，直至右边界指针指向尾部元素</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>注意代码的鲁棒性，对输入参数进行鲁棒性校验</li>
<li>在移动范围指针对时，注意k的取值是否会导致指针指向越界</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-25"><a href="#Answer-25" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> pValue;</span><br><span class="line">	ListNode* pNext;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">LastK</span><span class="params">(ListNode* pHead, <span class="keyword">unsigned</span> <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span> || k &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置范围指针对</span></span><br><span class="line">	ListNode* pRight = pHead;</span><br><span class="line">	<span class="comment">//设置范围指针对的左起始边界</span></span><br><span class="line">	ListNode* pLeft = pHead;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置范围指针对的右起始边界</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (pRight-&gt;pNext == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		pRight = pRight-&gt;pNext;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//移动范围指针对，直至右边界指针至尾结点</span></span><br><span class="line">	<span class="keyword">while</span> (pRight-&gt;pNext != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		pRight = pRight-&gt;pNext;</span><br><span class="line">		pLeft = pLeft-&gt;pNext;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pLeft;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="23-2-求链表的中间结点"><a href="#23-2-求链表的中间结点" class="headerlink" title="23.2 求链表的中间结点"></a>23.2 求链表的中间结点</h1><blockquote>
<p>求链表的中间节点</p>
<p>如果链表中的节点总数为奇数,则返回中间节点;如果节点总数是偶数,则返回中间两个节点的任意一个</p>
</blockquote>
<h2 id="Testing-case-28"><a href="#Testing-case-28" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(链表结点个数为奇数，为偶数，结点长度为1)</li>
<li>边界测试(nullptr，结点长度为0)</li>
</ul>
<h2 id="Key-28"><a href="#Key-28" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>遍历两次链表</p>
<blockquote>
<p>第一次从头遍历链表获取链表长度，根据长度奇偶性决定第二次移动的次数</p>
</blockquote>
</li>
<li><p>遍历一次链表</p>
<blockquote>
<p>使用两个指针，一个faster指针一次移动2单位，一个slower指针一次移动一单位</p>
<ol>
<li>设置两个指针的起始位置均为头结点，则faster指针移动至尾结点时，slower指针指向即为中间结点</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>faster指针在移动时只能一次一次移动，第二次移动时需要判断是否为nullptr，防止越界</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-26"><a href="#Answer-26" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> pValue;</span><br><span class="line">	ListNode* pNext;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">Middle</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断异常</span></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置遍历指针与定位指针</span></span><br><span class="line">	ListNode* faster = pHead;</span><br><span class="line">	ListNode* slower = pHead;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (faster-&gt;pNext != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		faster = faster-&gt;pNext;</span><br><span class="line">		<span class="keyword">if</span> (faster-&gt;pNext != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			faster = faster-&gt;pNext;</span><br><span class="line">		&#125;</span><br><span class="line">		slower = slower-&gt;pNext;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> slower;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="24-链表中环的入口结点"><a href="#24-链表中环的入口结点" class="headerlink" title="24 链表中环的入口结点"></a>24 链表中环的入口结点</h1><blockquote>
<p>如果一个链表中包含环,如何找出环的入口节点?</p>
</blockquote>
<h2 id="Testing-case-29"><a href="#Testing-case-29" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(链表有无环，链表中仅有一个结点)</li>
<li>边界测试(nullptr)</li>
</ul>
<h2 id="Key-29"><a href="#Key-29" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>顺序求解</p>
<blockquote>
<ol>
<li>首先判断链表中是否有环</li>
<li>若链表中有环，则进而判断环中结点的个数</li>
<li>进而求得环的入口结点</li>
</ol>
</blockquote>
</li>
<li><p>双指针</p>
<blockquote>
<ol>
<li>设置两个速度不同的指针，若某一时刻快的指针追赶到慢的指针，说明有环，若快的指针遍历完链表后为nullptr，则说明无环</li>
<li>若链表中有环，则1中两个指针相遇的结点必定在环中，只需设置一个指针从该结点开始向后移动，同时计数，回到该结点的计数值即为环中结点数</li>
<li>使用范围指针对，范围长度为n+1，n为环中结点数，初始左边界为首部结点，右边界向右移动n个单位，向后移动，两个指针相遇的结点即为环入口</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>范围指针对长度为n+1的原因为当右边界到达环末尾时，左边界将位于入口前一个结点，范围长度只会在 n+1 - 0 两值之间反复横跳</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-27"><a href="#Answer-27" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">getMeetNode</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//若仅有一个结点则无环，无相遇结点可</span></span><br><span class="line">	<span class="keyword">if</span> (pHead-&gt;pNext == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置快慢指针</span></span><br><span class="line">	ListNode* faster = pHead;</span><br><span class="line">	ListNode* slower = pHead;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (faster != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		faster = faster-&gt;pNext;</span><br><span class="line">		<span class="keyword">if</span> (faster != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			faster = faster-&gt;pNext;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		slower = slower-&gt;pNext;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (faster == slower) &#123;</span><br><span class="line">			<span class="keyword">return</span> faster;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//若无环，返回nullptr</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">getEntryPoint</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function">	ListNode* pMeetNode </span>= <span class="built_in">getMeetNode</span>(pH</span><br><span class="line">	<span class="keyword">if</span> (pMeetNode == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//若存在环，则计算环中结点个数</span></span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">	ListNode* p = pMeetNode;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (p-&gt;pNext != pMeetNode) &#123;</span><br><span class="line">		p = p-&gt;pNext;</span><br><span class="line">		num++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置范围指针对，并设置初始位置</span></span><br><span class="line">	ListNode* pRight = pHead;</span><br><span class="line">	ListNode* pLeft= pHead;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">		pRight = pRight-&gt;pNext;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//移动范围指针对找寻入口点</span></span><br><span class="line">	<span class="keyword">while</span> (pRight != pLeft) &#123;</span><br><span class="line">		pRight = pRight-&gt;pNext;</span><br><span class="line">		pLeft = pLeft-&gt;pNext;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pLeft;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="25-反转链表"><a href="#25-反转链表" class="headerlink" title="25 反转链表"></a>25 反转链表</h1><blockquote>
<p>定义一个函数,输入一个链表的头节点,反转该链表并输出反转后链表的头节点</p>
</blockquote>
<h2 id="Testing-case-30"><a href="#Testing-case-30" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(链表有一个或者多个结点)</li>
<li>边界测试(nullptr)</li>
</ul>
<h2 id="Key-30"><a href="#Key-30" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>遍历逐元素反转</p>
<blockquote>
<p>从头至尾遍历链表，将每个元素的pNext均置为前一个元素，首结点置为nullptr</p>
<ol>
<li>设置两个指针，一个pPre指向当前结点的前一个结点，一个pNode指向当前结点，初始首结点的pPre置为nullptr</li>
<li>开始向后遍历，每次遍历到下一个元素时马上通过ppNext记录其下一个结点，并使用pPre指向设置其pNext指向，使当前结点指向其前一个结点</li>
<li>反转当前结点后，更新下一个结点的pPre指向</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>由于单向链表向后遍历时，一个指针只能获得当前结点的状态，因此到下一个结点之前，需要使用pPre记录当前结点，使得设置下一个结点的pNext时可以获得前一个结点的状态</li>
<li>由于单向链表在反转某个结点时，会导致其与原本之后的结点断裂，导致无法向下遍历，因此在反转当前结点之前先记录当前结点的pNext值，反转之后，将该值赋值给pNode继续向下遍历</li>
</ol>
</blockquote>
</li>
<li><p>递归</p>
<blockquote>
<ol>
<li>从首节点开始，递归求得除当前结点外，其后剩余结点的反转链表</li>
<li>将当前结点作为其后反转链表的新尾部结点</li>
<li>直至当前结点为尾元结点</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>当前结点其后剩余结点的反转链表的尾元结点为当前结点的下一个结点，该结点由剩余结点的头结点反转后成为尾元结点</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-28"><a href="#Answer-28" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<p>1.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">Reverse</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//设置状态保存变量</span></span><br><span class="line">	ListNode* pPre = <span class="literal">nullptr</span>;</span><br><span class="line">	ListNode* pNode = pHead;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历链表并设置每一个结点的pNext为前一个结点</span></span><br><span class="line">	<span class="keyword">while</span> (pNode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="comment">//保存下一个结点，防止链表断裂后无法遍历</span></span><br><span class="line">		ListNode* ppNext = pNode-&gt;pNext;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//设置当前结点的pNext为s前一个结点</span></span><br><span class="line">		pNode-&gt;pNext = pPre;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//更新状态保存变量值对应于下一个结点</span></span><br><span class="line">		pPre = pNode;</span><br><span class="line">		pNode = ppNext;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pPre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">RReverseCore</span><span class="params">(ListNode* pNowHead)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//basecase</span></span><br><span class="line">	<span class="keyword">if</span> (pNowHead-&gt;pNext == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> pNowHead;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//记录分治后的尾元结点即当前结点的下一个结点</span></span><br><span class="line">	ListNode* LastTail = pNowHead-&gt;pNext;</span><br><span class="line">	<span class="comment">//递归返回分治后新的首结点</span></span><br><span class="line">	ListNode* NewHead = <span class="built_in">RReverseCore</span>(pNowHead-&gt;pNext);</span><br><span class="line">	<span class="comment">//将当前结点与已&quot;反转&quot;的后半部分的尾元结点连接</span></span><br><span class="line">	LastTail-&gt;pNext = pNowHead;</span><br><span class="line">	<span class="comment">//当前结点成为新的尾元结点</span></span><br><span class="line">	pNowHead-&gt;pNext = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> NewHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">RReverse</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">RReverseCore</span>(pHead);		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="26-合并两个排序的链表"><a href="#26-合并两个排序的链表" class="headerlink" title="26 合并两个排序的链表"></a>26 合并两个排序的链表</h1><blockquote>
<p>输入两个递增排序的链表,合并这两个链表并使新链表中的节点仍然是递增排序的</p>
</blockquote>
<h2 id="Testing-case-31"><a href="#Testing-case-31" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(两个链表均为长度不为0排序的链表)</li>
<li>边界测试(两个链表有一个为nullptr，两个链表均为nullptr)</li>
</ul>
<h2 id="Key-31"><a href="#Key-31" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>递归</p>
<blockquote>
<ol>
<li>比较两个链表的首元结点的值的大小，选取小的结点作为当前合并后的首元结点</li>
<li>选取除1中结点两个链表中较小的首元结点作剩余结点合并后的首节点，作1中结点的下一个结点</li>
<li>直至有一个链表选取完全，首元结点为nullptr，则选取另一个链表的首元结点作剩余结点的首元结点</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>鲁棒性的校验于basecase中完成，即使传入nullptr仍可作处理</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-29"><a href="#Answer-29" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">Merge</span><span class="params">(ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//basecase</span></span><br><span class="line">	<span class="keyword">if</span> (pHead1 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> pHead2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pHead2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> pHead1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置指向合并后首结点的指针</span></span><br><span class="line">	ListNode* MergedHead = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pHead1-&gt;pValue &lt;= pHead2-&gt;pValue) &#123;</span><br><span class="line">		MergedHead = pHead1;</span><br><span class="line">		MergedHead-&gt;pNext = <span class="built_in">Merge</span>(pHead1-&gt;pNext, pHead2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		MergedHead = pHead2;</span><br><span class="line">		MergedHead-&gt;pNext = <span class="built_in">Merge</span>(pHead1, pHead2-&gt;pNext);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> MergedHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="27-树的子结构"><a href="#27-树的子结构" class="headerlink" title="27 树的子结构"></a>27 树的子结构</h1><blockquote>
<p>输入两棵二叉树A和B,判断B是不是A的子结构</p>
</blockquote>
<h2 id="Testing-case-32"><a href="#Testing-case-32" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(AB均为普通二叉树，树B 是/不是 A的子结构)</li>
<li>边界测试(AB至少有一棵为空，二叉树仅有左子树，仅有右子树)</li>
</ul>
<h2 id="Key-32"><a href="#Key-32" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>穷举递归</p>
<blockquote>
<p>A树的每一个结点都有可能作B子结构的根节点(匹配)，因此需要穷举遍历A中所有结点</p>
<ol>
<li>选择A树的当前根节点与当前正匹配的B的根节点作比较</li>
<li>若相等，则进而判断该A中该根节点的左右子树是否与B中当前正匹配的根节点相等</li>
<li>若左右子树均匹配，则返回true，否则返回false</li>
<li>若不相等，则选择A中下一个结点作匹配的根节点</li>
<li>直至当前匹配的B中根结点为nullptr，即匹配完成</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>double类型数据在判断是否相等时需要考虑精度问题，即 |x-y| 的绝对值在某个精度内方可判断x,y是否相等</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-30"><a href="#Answer-30" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasSubTree</span><span class="params">(TreeNode* pHead, TreeNode* pSHead)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断异常</span></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span> || pSHead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//设置返回值</span></span><br><span class="line">	<span class="keyword">bool</span> result = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断是否是否含有与sub根结点相同的结点</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">Equal</span>(pHead-&gt;pValue, pSHead-&gt;pValue)) &#123;</span><br><span class="line">		<span class="comment">//若根结点相同则继续判断是否含有sub子树</span></span><br><span class="line">		result = <span class="built_in">hasSubTreeCore</span>(pHead, pSHead);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//若该根结点与sub子树根结点不同，或该根结点下的子树与sub子树结构不同，则向下遍历</span></span><br><span class="line">	<span class="keyword">if</span> (!result) &#123;</span><br><span class="line">		result = <span class="built_in">hasSubTreeCore</span>(pHead-&gt;pLeft, pSHead);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!result) &#123;</span><br><span class="line">		result = <span class="built_in">hasSubTreeCore</span>(pHead-&gt;pRight, pSHead);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasSubTreeCore</span><span class="params">(TreeNode* pHead, TreeNode* pSHead)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//base case</span></span><br><span class="line">	<span class="keyword">if</span> (pSHead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//判断当前结点是否相同</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">Equal</span>(pHead-&gt;pValue, pSHead-&gt;pValue)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//递归判断左右子树是否结构相同</span></span><br><span class="line">	<span class="keyword">bool</span> hasLeftSub = <span class="built_in">hasSubTreeCore</span>(pHead-&gt;pLeft, pSHead-&gt;pLeft);</span><br><span class="line">	<span class="keyword">bool</span> hasRightSub = <span class="built_in">hasSubTreeCore</span>(pHead-&gt;pRight, pSHead-&gt;pRight);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> hasLeftSub &amp;&amp; hasRightSub;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Equal</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (x - y &gt;= <span class="number">-0.001</span>) &amp;&amp; (x - y &lt;= <span class="number">0.001</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="28-二叉树的镜像"><a href="#28-二叉树的镜像" class="headerlink" title="28 二叉树的镜像"></a>28 二叉树的镜像</h1><blockquote>
<p>请完成一个函数,输入一棵二叉树,该函数输出它的镜像</p>
</blockquote>
<h2 id="Testing-case-33"><a href="#Testing-case-33" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(普通二叉树，仅有一个结点的二叉树，仅有左/右子树的二叉树)</li>
<li>边界测试(nullptr)</li>
</ul>
<h2 id="Key-33"><a href="#Key-33" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>递归交换</p>
<blockquote>
<ol>
<li>先序遍历一颗二叉树</li>
<li>每到根节点时交换根节点的左右子树，递归向下继续遍历</li>
<li>直至根节点为nullptr</li>
</ol>
</blockquote>
</li>
<li><p>层次遍历</p>
<blockquote>
<ol>
<li>使用队列进行层次遍历</li>
<li>每遍历到一个结点，将其左右子树交换后再重新压入队列</li>
<li>直至队列为空，即遍历完成</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-31"><a href="#Answer-31" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<p>1.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TreeMirro</span><span class="params">(TreeNode* pHead)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//base case</span></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//先根遍历的同时交换左右子结点，由根开始</span></span><br><span class="line">	TreeNode* pTemp = pHead-&gt;pLeft;</span><br><span class="line">	pHead-&gt;pLeft = pHead-&gt;pRight;</span><br><span class="line">	pHead-&gt;pRight = pTemp;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; pHead-&gt;pValue &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//左子树</span></span><br><span class="line">	<span class="keyword">if</span> (pHead-&gt;pLeft) &#123;</span><br><span class="line">		<span class="built_in">TreeMirro</span>(pHead-&gt;pLeft);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pHead-&gt;pRight) &#123;</span><br><span class="line">		<span class="built_in">TreeMirro</span>(pHead-&gt;pRight);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Non_RecursiveTreeMirro</span><span class="params">(TreeNode* pHead)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断异常</span></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//使用队列完成非递归遍历</span></span><br><span class="line">	queue&lt;TreeNode*&gt; Tqueue;</span><br><span class="line">	Tqueue.<span class="built_in">push</span>(pHead);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//层次遍历</span></span><br><span class="line">	<span class="keyword">while</span> (!Tqueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//弹出根结点</span></span><br><span class="line">		TreeNode* pTempHead = Tqueue.<span class="built_in">front</span>();</span><br><span class="line">		Tqueue.<span class="built_in">pop</span>();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//交换根节点的左右子树</span></span><br><span class="line">		TreeNode* pTemp = pTempHead-&gt;pLeft;</span><br><span class="line">		pTempHead-&gt;pLeft = pTempHead-&gt;pRight;</span><br><span class="line">		pTempHead-&gt;pRight = pTemp;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; pTempHead-&gt;pValue &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将交换后的左右子树压入队列遍历交换</span></span><br><span class="line">		<span class="keyword">if</span> (pTempHead-&gt;pLeft) &#123;</span><br><span class="line">			Tqueue.<span class="built_in">push</span>(pTempHead-&gt;pLeft);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        		<span class="keyword">if</span> (pTempHead-&gt;pRight) &#123;</span><br><span class="line">        			Tqueue.<span class="built_in">push</span>(pTempHead-&gt;pRight);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="29-对称的二叉树"><a href="#29-对称的二叉树" class="headerlink" title="29 对称的二叉树"></a>29 对称的二叉树</h1><blockquote>
<p>请实现一个函数,用来判断一棵二叉树是不是对称的</p>
<p>如果一棵二叉树和它的镜像一样,那么它是对称的</p>
</blockquote>
<h2 id="Testing-case-34"><a href="#Testing-case-34" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(对称/部队称的二叉树)</li>
<li>边界测试(nullptr，只有一个结点的二叉树，所有结点值相同的二叉树)</li>
</ul>
<h2 id="Key-34"><a href="#Key-34" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>对称前序遍历</p>
<blockquote>
<p>使用一个递归同时完成前序遍历与对称前序遍历，对称前序遍历为根右左</p>
<ol>
<li>设置递归的参数结点为两个，一个为前序遍历的结点，一个为对称前序遍历的结点</li>
<li>判断当前前序与对称前序遍历的结点的值是否相等，相等继续判断之后遍历结点的值是否相等(根左右-根右左)，若不相等则不对称</li>
<li>直至两种遍历次序下的结点同时为空，若不同时为空，表明不对称</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>对称为结构对称与值对称，若各结点值均相等，则需要将nullptr的孩子结点考虑在内，进而判断结构是否对称</li>
<li>通过设置两个参数同时完成两种遍历次序的递归，进而同时完成对称结点的相等判断</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-32"><a href="#Answer-32" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetry</span><span class="params">(TreeNode* pHead)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断异常</span></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">isSymmetryCore</span>(pHead, pHead);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetryCore</span><span class="params">(TreeNode* pHead, TreeNode* pSHead)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//base case</span></span><br><span class="line">	<span class="comment">//若前序遍历与对称前序遍历的头结点同时为空，满足对称条件</span></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span> &amp;&amp; pSHead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//若前序遍历与对称前序遍历的头结点不同时为空，则不满足对称条件</span></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span> || pSHead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(pHead-&gt;pValue == pSHead-&gt;pValue)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//递归判断前序遍历与对称前序遍历的结点</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">isSymmetryCore</span>(pHead-&gt;pLeft, pSHead-&gt;pRight) &amp;&amp; <span class="built_in">isSymmetryCore</span>(pHead-&gt;pRight, pSHead-&gt;pLeft);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="30-顺时针打印矩阵"><a href="#30-顺时针打印矩阵" class="headerlink" title="30 顺时针打印矩阵"></a>30 顺时针打印矩阵</h1><blockquote>
<p>输入一个矩阵,按照从外向里以顺时针的顺序依次打印出每一个数字</p>
</blockquote>
<h2 id="Testing-case-35"><a href="#Testing-case-35" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(数组具有多行多列，数组只有一行/一列)</li>
<li>边界测试(nullptr)</li>
</ul>
<h2 id="Key-35"><a href="#Key-35" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>逐圈输出</p>
<blockquote>
<ol>
<li>每次循环从圈的起点 (start,start) [start取值0,1…k] 开始顺时针输出</li>
<li>记录圈右边界与下边界，先从起始行开始输出至右边界</li>
<li>若起始行下界仍有未输出元素，则从当前列开始，起始行下一行向下输出该列元素，至下界</li>
<li>若右边界列左边仍有未输出元素，则从当前行开始，右边界列的前一行开始向左(前)输出该行元素，至左界</li>
<li>若左边界列的上边仍有未输出元素，则从当前列开始，下边界的上一行开始向上输出该列元素，至起始行的下一行</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>因为矩阵不是方阵，因此循环次数判断时需要行列分别判断是否大于 2 * start</li>
<li>将通过二级指针参数传递二维数组时，可以动态创建一个一级指针数组，使用二级指针指向，并使用已创建的二维数组的各行为其初始化后再传递该二级指针</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-33"><a href="#Answer-33" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sprint</span><span class="params">(<span class="keyword">int</span>** arr, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="literal">nullptr</span> || rows &lt;= <span class="number">0</span> || cols &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		hasException = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断循环输出圈的次数</span></span><br><span class="line">	<span class="keyword">while</span> (rows &gt; <span class="number">2</span> * start &amp;&amp; cols &gt; <span class="number">2</span> * start) &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">SprintCore</span>(arr, rows, cols, start);</span><br><span class="line">		start++;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SprintCore</span><span class="params">(<span class="keyword">int</span>** arr, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//当前坐上结点的坐标为 (start,start)</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//记录当前待输出圈的边界</span></span><br><span class="line">	<span class="keyword">int</span> endX = cols - <span class="number">1</span> - start;</span><br><span class="line">	<span class="keyword">int</span> endY = rows - <span class="number">1</span> - start;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//输出圈的上半部分</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= endX; i++) &#123;</span><br><span class="line">		cout &lt;&lt; arr[start][i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//判断圈是否需要继续向下输出右半部分</span></span><br><span class="line">	<span class="keyword">if</span> (endY &gt; start) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= endY; i++) &#123;</span><br><span class="line">			cout &lt;&lt; arr[i][endX] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//判断圈是否需要继续向左输出下半部分</span></span><br><span class="line">	<span class="keyword">if</span> (endY &gt; start &amp;&amp; endX &gt; start) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = endX - <span class="number">1</span>; i &gt;= start; i--) &#123;</span><br><span class="line">			cout &lt;&lt; arr[endY][i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//判断圈是否需要继续向上输出左半部分</span></span><br><span class="line">	<span class="keyword">if</span> (endY - <span class="number">1</span> &gt; start &amp;&amp; endX &gt; start) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = endY - <span class="number">1</span>; i &gt; start; i--) &#123;</span><br><span class="line">			cout &lt;&lt; arr[i][start] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="31-包含min函数的栈"><a href="#31-包含min函数的栈" class="headerlink" title="31 包含min函数的栈"></a>31 包含min函数的栈</h1><blockquote>
<p>定义栈的数据结构,请在该类型中实现一个能够得到栈的最小元素的min函数</p>
<p>在该栈中,调用min,push及pop的时间复杂度都是O(1)</p>
</blockquote>
<h2 id="Testing-case-36"><a href="#Testing-case-36" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>新压入的元素比数据栈中元素小</li>
<li>新压入的元素比数据栈中元素大</li>
<li>新弹出的元素是最小元素</li>
<li>新弹出的元素不是最小元素</li>
</ul>
<h2 id="Key-36"><a href="#Key-36" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>辅助栈记录数据栈的最小值状态</p>
<blockquote>
<ol>
<li>压入元素于数据栈，判断当前压入的元素与min栈栈顶元素的大小</li>
<li>若min栈为空，表示当前数据栈无元素，直接压入即可</li>
<li>否则将小的元素再次压入min栈，作为当前数据栈的最小元素，位于min栈栈顶</li>
<li>弹出时，若栈非空，则同时弹出数据栈，min栈的栈顶</li>
<li>取数据栈当前的最小元素直接取当前min栈的栈顶即可</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>为了保证O(1)的复杂度，因此必须在数据栈元素全部压入前进行最小值状态记录，否则压入后记录只能从栈顶取出</li>
<li>为保证min栈的每个元素均对应数据栈每一种状态下的最小值，需要保证两栈元素个数相同，即使压入的元素与当前最小值相同，仍需再次压入min栈</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-34"><a href="#Answer-34" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackWithMin</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">StackWithMin</span>() = <span class="keyword">default</span>;</span><br><span class="line">	~<span class="built_in">StackWithMin</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//压入元素</span></span><br><span class="line">		m_data.<span class="built_in">push</span>(value);</span><br><span class="line">		<span class="comment">//更新min栈的栈顶元素</span></span><br><span class="line">		<span class="keyword">if</span> (m_min.<span class="built_in">size</span>() == <span class="number">0</span> || value &lt;= m_min.<span class="built_in">top</span>()) &#123;</span><br><span class="line">			<span class="comment">//若min栈为空或者压入的元素为最小元素，即小于等于min栈栈顶元素</span></span><br><span class="line">			m_min.<span class="built_in">push</span>(value);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//保持两栈元素个数相等，保证min栈的每个栈顶元素均对应data栈不同状态下的最小值</span></span><br><span class="line">			m_min.<span class="built_in">push</span>(m_min.<span class="built_in">top</span>());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (m_data.<span class="built_in">size</span>() != <span class="number">0</span> &amp;&amp; m_min.<span class="built_in">size</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">			m_data.<span class="built_in">pop</span>();</span><br><span class="line">			m_min.<span class="built_in">pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">const</span> T&amp; <span class="title">getMin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (m_min.<span class="built_in">size</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> m_min.<span class="built_in">top</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	stack&lt;T&gt; m_data;</span><br><span class="line">	stack&lt;T&gt; m_min;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="32-栈的压入-弹出序列"><a href="#32-栈的压入-弹出序列" class="headerlink" title="32 栈的压入,弹出序列"></a>32 栈的压入,弹出序列</h1><blockquote>
<p>输入两个整数序列,第一个序列表示栈的压入顺序,请判断第二个序列是否为该栈的弹出顺序,假设压入栈的所有数字均不相等</p>
</blockquote>
<h2 id="Testing-case-37"><a href="#Testing-case-37" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(输入的数组有两个数字，一个数字，第二个序列是/不是第一个序列的输出序列)</li>
<li>边界测试(nullptr)</li>
</ul>
<h2 id="Key-37"><a href="#Key-37" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>辅助栈模拟序列的输入输出</p>
<blockquote>
<ol>
<li>从输出队列入手，遍历输出队列的每一个元素，判断当前输出队列元素是否与辅助栈中栈顶元素匹配</li>
<li>若匹配，将栈顶元素弹出，输出队列指针后移判断下一个元素是否匹配</li>
<li>若不匹配或者栈为空，则判断输入队列的元素是否已全部入栈，若未全部入栈，则将输入队列的中的一个元素压栈，进而继续1中判断</li>
<li>若输入队列的元素已全部入栈，且输出队列未遍历完毕，则不是匹配序列，退出遍历</li>
<li>若输出队列元素已全部匹配且栈为空，则是匹配队列</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-35"><a href="#Answer-35" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isIOMatch</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* pInput, <span class="keyword">const</span> <span class="keyword">int</span>* pOutput, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//设置返回值</span></span><br><span class="line">	<span class="keyword">bool</span> imatch = <span class="literal">false</span>;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (pInput == <span class="literal">nullptr</span> || pOutput == <span class="literal">nullptr</span> || length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		isException = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> imatch;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建辅助栈</span></span><br><span class="line">	stack&lt;<span class="keyword">int</span>&gt; helperStack;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置临时指针</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span>* tInput = pInput;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span>* tOutput = pOutput;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//逐个判断输出队列中的各元素是否匹配</span></span><br><span class="line">	<span class="keyword">while</span> (tOutput - pOutput != length) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//若栈中无元素或者当前栈顶元素与输出指针指向的元素不匹配，则将输入队列的元素压入栈</span></span><br><span class="line">		<span class="keyword">if</span> (helperStack.<span class="built_in">size</span>() == <span class="number">0</span> || helperStack.<span class="built_in">top</span>() != *tOutput) &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (tInput - pInput == length) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			helperStack.<span class="built_in">push</span>(*tInput);</span><br><span class="line">			tInput++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//若当前栈顶元素与当前输出指针指向的元素，则将栈顶元素弹出，判断当前栈顶与输出指针的下一个指向是否匹配</span></span><br><span class="line">		<span class="keyword">if</span> (helperStack.<span class="built_in">top</span>() == *tOutput) &#123;</span><br><span class="line">			helperStack.<span class="built_in">pop</span>();</span><br><span class="line">			tOutput++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//若输出队列遍历完毕且辅助栈为空，则表示匹配</span></span><br><span class="line">	<span class="keyword">if</span> (helperStack.<span class="built_in">size</span>() == <span class="number">0</span> &amp;&amp; tOutput - pOutput == length) &#123;</span><br><span class="line">		imatch = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> imatch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="33-1-从上到下打印二叉树"><a href="#33-1-从上到下打印二叉树" class="headerlink" title="33.1 从上到下打印二叉树"></a>33.1 从上到下打印二叉树</h1><blockquote>
<p>不分行</p>
<p>从上到下打印二叉树从上到下打印出二叉树的每个节点,同一层的节点按照从左到右的顺序打印</p>
</blockquote>
<h2 id="Testing-case-38"><a href="#Testing-case-38" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(完全二叉树,只有左/右子树的二叉树)</li>
<li>边界测试(nullptr,只有一个结点的二叉树)</li>
</ul>
<h2 id="Key-38"><a href="#Key-38" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>辅助队列存储当前遍历结点的左右子结点</p>
<blockquote>
<ol>
<li>将根节点压入队列</li>
<li>遍历队列的队首节点，并弹出队列</li>
<li>若当前遍历节点含有左右子结点，则从左至右将左右子节点压入队列尾部，否则结束本次循环</li>
<li>重复步骤2，直至队列为空</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-36"><a href="#Answer-36" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printTree</span><span class="params">(TreeNode* pHead)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置辅助队列</span></span><br><span class="line">	deque&lt;TreeNode*&gt; deque;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//首先将根节点压入队列</span></span><br><span class="line">	deque.<span class="built_in">push_back</span>(pHead);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历</span></span><br><span class="line">	<span class="keyword">while</span> (deque.<span class="built_in">size</span>() != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//取出当前队列中的头元素</span></span><br><span class="line">		TreeNode* pTemp = deque.<span class="built_in">front</span>();</span><br><span class="line">		deque.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//输出元素</span></span><br><span class="line">		cout &lt;&lt; pTemp-&gt;pValue &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//若取出的结点含左右子树，则重新压入队列</span></span><br><span class="line">		<span class="keyword">if</span> (pTemp-&gt;pLeft)</span><br><span class="line">			deque.<span class="built_in">push_back</span>(pTemp-&gt;pLeft);</span><br><span class="line">		<span class="keyword">if</span> (pTemp-&gt;pRight)</span><br><span class="line">			deque.<span class="built_in">push_back</span>(pTemp-&gt;pRight);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="33-2-从上到下打印二叉树"><a href="#33-2-从上到下打印二叉树" class="headerlink" title="33.2 从上到下打印二叉树"></a>33.2 从上到下打印二叉树</h1><blockquote>
<p>分行</p>
<p>从上到下打印二叉树从上到下打印出二叉树的每个节点,同一层的节点按照从左到右的顺序打印</p>
</blockquote>
<h2 id="Testing-case-39"><a href="#Testing-case-39" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(完全二叉树,只有左/右子树的二叉树)</li>
<li>边界测试(nullptr,只有一个结点的二叉树)</li>
</ul>
<h2 id="Key-39"><a href="#Key-39" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>辅助队列存储当前遍历结点的左右子结点</p>
<blockquote>
<ol>
<li>将根节点压入队列</li>
<li>遍历队列的队首节点，并弹出队列</li>
<li>若当前遍历节点含有左右子结点，则从左至右将左右子节点压入队列尾部，否则结束本次循环</li>
<li>重复步骤2，直至队列为空</li>
</ol>
</blockquote>
</li>
<li><p>状态记录变量</p>
<blockquote>
<ol>
<li>设置记录当前层仍未输出的节点数的变量 toBePrinted</li>
<li>设置记录下一层节点数的累加计数变量 numNextLayer</li>
<li>每遍历一个节点，toBePrinted减1，若减为0，则表示本层节点输出完毕，应换行</li>
<li>每将一个节点压入队列，numNextLayer增1，记录下一层的节点数，直至toBePrinted为0(本层节点输出完毕)时，使用numNextLayer更新toBePrinted，并将自身重置为0，进行下一层节点的输出</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-37"><a href="#Answer-37" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lprintTree</span><span class="params">(TreeNode* pHead)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置辅助队列</span></span><br><span class="line">	deque&lt;TreeNode*&gt; deque;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//首先将根节点压入队列</span></span><br><span class="line">	deque.<span class="built_in">push_back</span>(pHead);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置状态记录变量</span></span><br><span class="line">	<span class="comment">//记录下一层的节点个数</span></span><br><span class="line">	<span class="keyword">int</span> NextLayer = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//记录本层仍未输出的节点个数</span></span><br><span class="line">	<span class="keyword">int</span> toBePrinted = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历</span></span><br><span class="line">	<span class="keyword">while</span> (deque.<span class="built_in">size</span>() != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//取出当前队列中的头元素</span></span><br><span class="line">		TreeNode* pTemp = deque.<span class="built_in">front</span>();</span><br><span class="line">		deque.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//输出元素</span></span><br><span class="line">		cout &lt;&lt; pTemp-&gt;pValue &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		toBePrinted--;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//若取出的结点含左右子树，则重新压入队列</span></span><br><span class="line">		<span class="keyword">if</span> (pTemp-&gt;pLeft) &#123;</span><br><span class="line">			deque.<span class="built_in">push_back</span>(pTemp-&gt;pLeft);</span><br><span class="line">			NextLayer++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (pTemp-&gt;pRight) &#123;</span><br><span class="line">			deque.<span class="built_in">push_back</span>(pTemp-&gt;pRight);</span><br><span class="line">			NextLayer++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (toBePrinted == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">//本层的元素输出完毕，换行，进行下一行元素的输出</span></span><br><span class="line">			cout &lt;&lt; endl;</span><br><span class="line">			<span class="comment">//更新toBePrinted为下一层应输出的节点数</span></span><br><span class="line">			toBePrinted = NextLayer;</span><br><span class="line">			<span class="comment">//重置NextLayer，记录下一层的下一层节点数</span></span><br><span class="line">			NextLayer = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="33-3-从上到下打印二叉树"><a href="#33-3-从上到下打印二叉树" class="headerlink" title="33.3 从上到下打印二叉树"></a>33.3 从上到下打印二叉树</h1><blockquote>
<p>之字形打印二叉树</p>
<p>请实现一个函数按照之字形顺序打印二叉树,即第一行按照从左到右的顺序打印,第二层按照从右到左的顺序打印,第三行再按照从左到右的顺序打印,其他行以此类推</p>
</blockquote>
<h2 id="Testing-case-40"><a href="#Testing-case-40" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(完全二叉树,只有左/右子树的二叉树)</li>
<li>边界测试(nullptr,只有一个结点的二叉树)</li>
</ul>
<h2 id="Key-40"><a href="#Key-40" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>双栈完成之字形输出更替</p>
<blockquote>
<ol>
<li>将根节点压入栈1</li>
<li>遍历栈1元素，逐个将栈1中的元素弹出，并将弹出的每个元素的左右节点按自左向右的顺序压入栈2，直至栈1为空，并输出换行</li>
<li>遍历栈2元素，逐个将栈2中的元素弹出，并将弹出的每个元素的左右节点按自右向左的顺序压入栈1，直至栈2为空，并输出换行</li>
<li>重复2,3直至栈2与栈3均为空</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-38"><a href="#Answer-38" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SprintTree</span><span class="params">(TreeNode* pHead)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置两个辅助栈</span></span><br><span class="line">	deque&lt;TreeNode*&gt; deque1;</span><br><span class="line">	deque&lt;TreeNode*&gt; deque2;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//首先将根节点压入栈1</span></span><br><span class="line">	deque1.<span class="built_in">push_back</span>(pHead);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历</span></span><br><span class="line">	<span class="keyword">while</span> (deque1.<span class="built_in">size</span>() != <span class="number">0</span> || deque1.<span class="built_in">size</span>() != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//取出并遍历栈1中的元素</span></span><br><span class="line">		<span class="keyword">while</span> (deque1.<span class="built_in">size</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">			TreeNode* pTemp = deque1.<span class="built_in">back</span>();</span><br><span class="line">			deque1.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">			<span class="comment">//输出元素</span></span><br><span class="line">			cout &lt;&lt; pTemp-&gt;pValue &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//若取出的结点含左右子树，则自左向右压入栈2</span></span><br><span class="line">			<span class="keyword">if</span> (pTemp-&gt;pLeft) &#123;</span><br><span class="line">				deque2.<span class="built_in">push_back</span>(pTemp-&gt;pLeft);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (pTemp-&gt;pRight) &#123;</span><br><span class="line">				deque2.<span class="built_in">push_back</span>(pTemp-&gt;pRight);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//取出并遍历栈2中的元素</span></span><br><span class="line">		<span class="keyword">while</span> (deque2.<span class="built_in">size</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">			TreeNode* pTemp2 = deque2.<span class="built_in">back</span>();</span><br><span class="line">			deque2.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">			<span class="comment">//输出元素</span></span><br><span class="line">			cout &lt;&lt; pTemp2-&gt;pValue &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//若取出的结点含左右子树，则自右向左压入栈1</span></span><br><span class="line">			<span class="keyword">if</span> (pTemp2-&gt;pRight) &#123;</span><br><span class="line">				deque1.<span class="built_in">push_back</span>(pTemp2-&gt;pRight);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (pTemp2-&gt;pLeft) &#123;</span><br><span class="line">				deque1.<span class="built_in">push_back</span>(pTemp2-&gt;pLeft);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="34-二叉搜索树的后序遍历序列"><a href="#34-二叉搜索树的后序遍历序列" class="headerlink" title="34 二叉搜索树的后序遍历序列"></a>34 二叉搜索树的后序遍历序列</h1><blockquote>
<p>输入一个整数数组,判断该数组是不是某二叉搜索树的后序遍历结果</p>
<p>如果是则返回true,否则返回false,假设输入的数组的任意数字都互不相同</p>
</blockquote>
<h2 id="Testing-case-41"><a href="#Testing-case-41" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(后序遍历序列对应/不对应一颗搜索二叉树，二叉树可以为完全二叉搜索树，普通二叉搜索树，无左/右子树的二叉搜索树，只有一个结点的二叉树)</li>
<li>边界测试(nullptr)</li>
</ul>
<h2 id="Key-41"><a href="#Key-41" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>递归</p>
<blockquote>
<ol>
<li>二叉树后序遍历序列的最后一个节点为本树的根节点，选取该根节点</li>
<li>结合二叉搜索树的性质，找寻序列根节点之前第一个比根节点的大的节点作为该根节点左右子树的分界</li>
<li>在左子树满足均小于根节点的性质下，判断右子树中是否存在比根节点小的节点</li>
<li>完成一轮二叉搜索树判断后，进而递归判断该根节点的左右子树是否也满足二叉搜索树性质</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>二叉树的后序遍历序列的最后一个节点为根节点</li>
<li>二叉搜索树根节点的左子树所有节点均小于根节点，右子树的所有节点均大于根节点</li>
<li>递归时通过序列首部与序列长度确定左右子树范围，若当前根节点无左/右子树，则无需判断</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-39"><a href="#Answer-39" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span>* Seq, <span class="keyword">int</span> Slength)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (Seq == <span class="literal">nullptr</span> || Slength &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断当前根节点与其左右子树是否满足二叉搜索树</span></span><br><span class="line">	<span class="comment">//取当前根节点</span></span><br><span class="line">	<span class="keyword">int</span> root = Seq[Slength - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//找寻第一个比根节点大节点作为左右子树分界，此时左子树均比根节点小</span></span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (; i &lt; Slength - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (Seq[i] &gt; root) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断该根节点右子树是否存在比其小的节点</span></span><br><span class="line">	<span class="keyword">int</span> j = i;</span><br><span class="line">	<span class="keyword">for</span> (; j &lt; Slength - <span class="number">1</span>; j++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (Seq[j] &lt; root) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//此时根节点左子树的节点均比根节点小，右子树的节点均比根节点大，满足二叉搜索树性质</span></span><br><span class="line">	<span class="comment">//--------------------------------------------------------------------</span></span><br><span class="line">	<span class="comment">//进而判断该根节点的左右子树是否满足二叉搜索树性质</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//若含左子树，则判断左子树是否满足二叉搜索树性质</span></span><br><span class="line">	<span class="keyword">bool</span> left = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">		left = <span class="built_in">VerifySquenceOfBST</span>(Seq, i);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//若含右子树，判断右子树是否满足二叉搜索树性质</span></span><br><span class="line">	<span class="keyword">bool</span> Right = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (i &lt; Slength - <span class="number">1</span>)</span><br><span class="line">		Right = <span class="built_in">VerifySquenceOfBST</span>(Seq + i, Slength - i - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> left &amp;&amp; Right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="35-二叉树中和为某一值的路径"><a href="#35-二叉树中和为某一值的路径" class="headerlink" title="35 二叉树中和为某一值的路径"></a>35 二叉树中和为某一值的路径</h1><blockquote>
<p>输入一棵二叉树和一个整数,打印出二叉树中节点值的和为输入整数的所有路径</p>
<p>从树的<strong>根节点开始</strong>往下<strong>一直到叶节点</strong>所经过的节点形成一条<strong>路径</strong>。二叉树节点的定义如下:</p>
</blockquote>
<h2 id="Testing-case-42"><a href="#Testing-case-42" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(二叉树中有一/多条符合的路径，二叉树中没有符合的路径)</li>
<li>边界测试(nullptr)</li>
</ul>
<h2 id="Key-42"><a href="#Key-42" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>先序遍历寻找路径</p>
</li>
<li><p>设置路径数组与状态记录变量来记录当前路径状态</p>
<blockquote>
<ol>
<li>先序遍历二叉树，当遍历到根节点时，将当前节点压入数组并记录当前路径累加和</li>
<li>若当前路径数组中的结点已构成一条路径(当前压入的结点为叶子结点)且满足期望和，则对数组中的路径序列进行输出</li>
<li>否则递归判断左右子树(若含有左右子树)的路径情况</li>
<li>若已为一条路径却不满足期望和，则先将当前结点从路径数组中弹出后继续遍历</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>当前结点从路径数组中弹出后累加和currentSum也需要回退，但是currentSum为值传递，在递归回溯再递归时，currentSum始终表示当前的累加和，也就是说当函数回到上一级时，当前currentSum的状态不再保存，自动还原到上一级的状态</li>
<li>树的路径为从根节点出发到叶子结点，因此若为到叶子结点但是期望值满足的并不符合路径要求</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-40"><a href="#Answer-40" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindPathInTree</span><span class="params">(TreeNode* pHead, <span class="keyword">int</span> ExpectedNum)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断异常</span></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置存储路径的容器与记录和的变量</span></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">	<span class="keyword">int</span> currentSum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//转调路径函数</span></span><br><span class="line">	<span class="built_in">FindPathInTree</span>(pHead, ExpectedNum, path, currentSum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindPathInTree</span><span class="params">(TreeNode* pHead, <span class="keyword">int</span> ExpectedNum, vector&lt;<span class="keyword">int</span>&gt;&amp; path, <span class="keyword">int</span> currentSum)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//先序遍历</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//将当前结点的值压入路径数组，记录当前路径</span></span><br><span class="line">	path.<span class="built_in">push_back</span>(pHead-&gt;pValue);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//累加和，记录当前路径和</span></span><br><span class="line">	currentSum += pHead-&gt;pValue;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断当前路径和是否为期望值且为一条树的路径(该结点为叶子结点)</span></span><br><span class="line">	<span class="keyword">if</span> (pHead-&gt;pLeft == <span class="literal">nullptr</span> &amp;&amp; pHead-&gt;pRight == <span class="literal">nullptr</span> &amp;&amp; ExpectedNum == currentSum) &#123;</span><br><span class="line">		<span class="comment">//找到一条路径，输出该路径</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Path1 : &quot;</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> i : path) &#123;</span><br><span class="line">			cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//先序遍历，判断左右子树中是否存在路径</span></span><br><span class="line">	<span class="keyword">if</span> (pHead-&gt;pLeft != <span class="literal">nullptr</span>)</span><br><span class="line">		<span class="built_in">FindPathInTree</span>(pHead-&gt;pLeft, ExpectedNum, path, currentSum);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pHead-&gt;pRight != <span class="literal">nullptr</span>)</span><br><span class="line">		<span class="built_in">FindPathInTree</span>(pHead-&gt;pRight, ExpectedNum, path, currentSum);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//直到找寻到叶子结点且不满足路径和才回退</span></span><br><span class="line">	path.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="36-复杂链表的复制"><a href="#36-复杂链表的复制" class="headerlink" title="36 复杂链表的复制"></a>36 复杂链表的复制</h1><blockquote>
<p>请实现函数ComplexListNode* Clone(ComplexListNode* pHead)，复制一个复杂链表</p>
<p>在复杂链表中,每个节点除了有一个m_pNext指针指向下一个节点,还有一个m_pSibling指针指向链表中的任意节点或者nullptr</p>
</blockquote>
<h2 id="Testing-case-43"><a href="#Testing-case-43" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(结点中m_pSibling指向自身，两个结点m_pSibling形成环状结构，链表只有一个结点)</li>
<li>边界测试(nullptr)</li>
</ul>
<h2 id="Key-43"><a href="#Key-43" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>复杂问题分解 T(n) = O(n) S(n) = 1</p>
<ol>
<li><p>对链表结点进行复制并与原链表链接 A-A‘-B-B’</p>
<blockquote>
<p>遍历原链表逐个结点复制，并将复制后的结点插入到原结点与原节点的下一个结点之间</p>
<p><code>注意:</code></p>
<ol>
<li>链接的作用在于进行第二步时，复制后结点的m_pSibling指向为其原结点的m_pSibling的下一个结点</li>
</ol>
</blockquote>
</li>
<li><p>对复制后且与原链表链接的新链表的m_pSibling指向更新</p>
<blockquote>
<p>遍历原链表每个结点，若其m_pSibling不为nullptr则将其复制结点(下一个结点)的m_pSibling置为其m_pSibling的下一个结点</p>
</blockquote>
</li>
<li><p>拆解链接链表并返回新链表头</p>
<blockquote>
<ol>
<li>遍历链接链表，通过两个指针实现将每一个结点的pNext指向其下下一个结点</li>
<li>pNode指针从头开始将其指向的结点的pNext指向其下下一个结点(原链表)</li>
<li>pCNode指针记录pNode的下一个结点，并将该结点的pNext指向其下下一个结点(复制后链表)</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>在拆解过程中应注意需要将原链表还原，因为整个复制过程是基于原链表的</li>
</ol>
</blockquote>
</li>
</ol>
</li>
<li><p>哈希表 T(n) = O(n) S(n) = n</p>
<blockquote>
<ol>
<li>完成链表结点的复制与pNext的指向复制</li>
<li>同时使用map容器完成原结点与相应复制结点映射关系的存储</li>
<li>同时遍历原链表与复制链表，将新链表结点的pSibiling指向置为相应原链表结点pSibiling指向在map中的映射即可</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-41"><a href="#Answer-41" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<p>1.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CopyNode</span><span class="params">(LinkNode* pHead)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建临时指针</span></span><br><span class="line">	LinkNode* pNode = pHead;</span><br><span class="line">	<span class="comment">//遍历链表并完成结点创建与链接</span></span><br><span class="line">	<span class="keyword">while</span> (pNode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		LinkNode* pCopyNode = <span class="keyword">new</span> <span class="built_in">LinkNode</span>();</span><br><span class="line">		pCopyNode-&gt;pSibling = <span class="literal">nullptr</span>;</span><br><span class="line">		<span class="comment">//复制结点</span></span><br><span class="line">		pCopyNode-&gt;pValue = pNode-&gt;pValue;</span><br><span class="line">		<span class="comment">//链接结点</span></span><br><span class="line">		pCopyNode-&gt;pNext = pNode-&gt;pNext;</span><br><span class="line">		pNode-&gt;pNext = pCopyNode;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//向下遍历</span></span><br><span class="line">		pNode = pCopyNode-&gt;pNext;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConnectSibiling</span><span class="params">(LinkNode* pHead)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建临时指针</span></span><br><span class="line">	LinkNode* pNode = pHead;</span><br><span class="line">	<span class="comment">//遍历链表并完成sibiling指向的复制</span></span><br><span class="line">	<span class="keyword">while</span> (pNode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="comment">//创建指向当前结点对应的复制结点的指针</span></span><br><span class="line">		LinkNode* pCopyNode = pNode-&gt;pNext;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//设置复制结点的sibiling指向</span></span><br><span class="line">		<span class="keyword">if</span> (pNode-&gt;pSibling)</span><br><span class="line">			pCopyNode-&gt;pSibling = pNode-&gt;pSibling-&gt;pNext;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//向下遍历</span></span><br><span class="line">		pNode = pCopyNode-&gt;pNext;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LinkNode* <span class="title">ConnectNext</span><span class="params">(LinkNode* pHead)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建临时遍历指针</span></span><br><span class="line">	LinkNode* pNode = pHead;</span><br><span class="line">	LinkNode* pCNode = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="comment">//创建最终存放复制链表头的指针</span></span><br><span class="line">	LinkNode* pCopyHead = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//首先确定复制后的链表头</span></span><br><span class="line">	pCopyHead = pNode-&gt;pNext;</span><br><span class="line">	<span class="comment">//还原原链表</span></span><br><span class="line">	pNode-&gt;pNext = pCopyHead-&gt;pNext;</span><br><span class="line">	<span class="comment">//初始化复制链表遍历指针</span></span><br><span class="line">	pCNode = pCopyHead;</span><br><span class="line">	<span class="comment">//向下遍历</span></span><br><span class="line">	pNode = pNode-&gt;pNext;</span><br><span class="line">	<span class="comment">//此时pNode位于pCNode之后一个结点</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (pNode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="comment">//将复制后的结点的指向更新，使其指向下一个复制后的结点</span></span><br><span class="line">		pCNode-&gt;pNext = pNode-&gt;pNext;</span><br><span class="line">		<span class="comment">//向下遍历</span></span><br><span class="line">		pCNode = pCNode-&gt;pNext;</span><br><span class="line">		<span class="comment">//将复制前的结点的指向更新，使其指向下一个复制前的结点</span></span><br><span class="line">		pNode-&gt;pNext = pCNode-&gt;pNext;</span><br><span class="line">		<span class="comment">//向下遍历</span></span><br><span class="line">		pNode = pNode-&gt;pNext;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pCopyHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LinkNode* <span class="title">CopyFromComplexList</span><span class="params">(LinkNode* pHead)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//分三步完成复杂链表的复制</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//第一步 复制每个结点并与原链表链接</span></span><br><span class="line">	<span class="built_in">CopyNode</span>(pHead);</span><br><span class="line">	<span class="comment">//第二步 将原链表的sibiling指向复制到新链表</span></span><br><span class="line">	<span class="built_in">ConnectSibiling</span>(pHead);</span><br><span class="line">	<span class="comment">//第三步 拆解链表，并完成新链表的pNext指向</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">ConnectNext</span>(pHead);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkNode* <span class="title">CopyFromComplexListByMap</span><span class="params">(LinkNode* pHead)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//复制结点并将结点对应关系存入Map</span></span><br><span class="line">	map&lt;LinkNode*, LinkNode*&gt; NodeMap;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置临时遍历指针,并完成链表头的复制</span></span><br><span class="line">	LinkNode* pNode = pHead;</span><br><span class="line">	LinkNode* pCopyHead = <span class="keyword">new</span> <span class="built_in">LinkNode</span>();</span><br><span class="line"></span><br><span class="line">	pCopyHead-&gt;pValue = pNode-&gt;pValue;</span><br><span class="line">	pCopyHead-&gt;pNext = <span class="literal">nullptr</span>;</span><br><span class="line">	pCopyHead-&gt;pSibling = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//map存放原结点与复制结点的映射</span></span><br><span class="line">	NodeMap[pNode] = pCopyHead;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//向下遍历</span></span><br><span class="line">	LinkNode* pCNode = pCopyHead;</span><br><span class="line">	pNode = pNode-&gt;pNext;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//遍历原链表完成结点的复制与映射的存放</span></span><br><span class="line">	<span class="keyword">while</span> (pNode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//结点复制</span></span><br><span class="line">		LinkNode* pCTemp = <span class="keyword">new</span> <span class="built_in">LinkNode</span>();</span><br><span class="line">		pCTemp-&gt;pValue = pNode-&gt;pValue;</span><br><span class="line">		pCTemp-&gt;pNext = <span class="literal">nullptr</span>;</span><br><span class="line">		pCTemp-&gt;pSibling = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//map存放原结点与复制结点的映射</span></span><br><span class="line">		NodeMap[pNode] = pCTemp;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//复制链表的链接</span></span><br><span class="line">		pCNode-&gt;pNext = pCTemp;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//向下遍历</span></span><br><span class="line">		pCNode = pCNode-&gt;pNext;</span><br><span class="line">		pNode = pNode-&gt;pNext;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重置遍历指针于链表表头</span></span><br><span class="line">	pNode = pHead;</span><br><span class="line">	pCNode = pCopyHead;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历原链表完成复制链表的pSibiling指向</span></span><br><span class="line">	<span class="keyword">while</span> (pNode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (pNode-&gt;pSibling != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			pCNode-&gt;pSibling = NodeMap[pNode-&gt;pSibling];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//向下遍历</span></span><br><span class="line">		pNode = pNode-&gt;pNext;</span><br><span class="line">		pCNode = pCNode-&gt;pNext;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pCopyHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="37-二叉搜索树与双向链表"><a href="#37-二叉搜索树与双向链表" class="headerlink" title="37 二叉搜索树与双向链表"></a>37 二叉搜索树与双向链表</h1><blockquote>
<p>输入一棵二叉搜索树,将该二叉搜索树转换成一个<strong>排序的双向链表</strong></p>
<p>要求不能创建任何新的节点,只能调整树中节点指针的指向</p>
</blockquote>
<h2 id="Testing-case-44"><a href="#Testing-case-44" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(二叉搜索树为完全二叉树，无左/右子树，只有一个结点)</li>
<li>边界测试(nullptr)</li>
</ul>
<h2 id="Key-44"><a href="#Key-44" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>中序遍历与链表尾部实时记录</p>
<blockquote>
<ol>
<li>中序遍历二叉搜索树并使用PointToListTail指针实时记录当前形成双向链表的尾部</li>
<li>遍历至根节点时，将该根节点与双向链表链接，并作为新的尾部</li>
<li>直至遍历结点为nullptr</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>二叉搜索树的中序遍历序列为小大排序的</li>
<li>一定要使用PointToListTail记录双向链表末尾结点，否则仅依靠递归返回当前遍历结点会遗漏部分结点</li>
<li>从最左下的最小结点开始将整个二叉搜索树串成一个小大排序的双向链表</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-42"><a href="#Answer-42" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">Convert</span><span class="params">(TreeNode* pHead)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置记录当前双向链表尾部的指针</span></span><br><span class="line">	TreeNode* PointToListTail = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="comment">//将尾部的指针一并传入进行递归</span></span><br><span class="line">	<span class="built_in">ConvertCore</span>(pHead, &amp;PointToListTail);</span><br><span class="line">	<span class="comment">//返回双向链表的首部</span></span><br><span class="line">	<span class="keyword">while</span> (PointToListTail != <span class="literal">nullptr</span> &amp;&amp; PointToListTail-&gt;pLeft != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		PointToListTail = PointToListTail-&gt;pLeft;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> PointToListTail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConvertCore</span><span class="params">(TreeNode* pHead, TreeNode** PointToListTail)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//设置遍历指针</span></span><br><span class="line">	TreeNode* pCurrentNode = pHead;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//basecase</span></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//中序遍历</span></span><br><span class="line">	<span class="keyword">if</span> (pCurrentNode-&gt;pLeft != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="built_in">ConvertCore</span>(pCurrentNode-&gt;pLeft, PointToListTail);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置当前根节点为双向链表的新尾部</span></span><br><span class="line">	pCurrentNode-&gt;pLeft = *PointToListTail;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (*PointToListTail != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		(*PointToListTail)-&gt;pRight = pCurrentNode;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	*PointToListTail = pCurrentNode;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将新双向链表与右子树连接</span></span><br><span class="line">	<span class="keyword">if</span> (pCurrentNode-&gt;pRight != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="built_in">ConvertCore</span>(pCurrentNode-&gt;pRight, PointToListTail);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="38-序列化二叉树"><a href="#38-序列化二叉树" class="headerlink" title="38 序列化二叉树"></a>38 序列化二叉树</h1><blockquote>
<p>请实现两个函数,分别用来序列化和反序列化二叉树</p>
</blockquote>
<h2 id="Testing-case-45"><a href="#Testing-case-45" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(二叉树为完全二叉树，无左/右子树，只有一个结点，值均相同的二叉树)</li>
<li>边界测试(nullptr)</li>
</ul>
<h2 id="Key-45"><a href="#Key-45" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>先序遍历 -序列化</p>
<blockquote>
<p>先序遍历二叉树，并且将根结点为nullptr的左右孩子使用特殊字符表示</p>
</blockquote>
</li>
<li><p>遍历序列化数组 -反序列化</p>
<blockquote>
<ol>
<li>遍历序列化数组，为数字元素创建结点，特殊字符元素跳过</li>
<li>直至序列化数组元素遍历完毕</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>递归条件以序列化数组为主，并且在设置当前根节点的左右子树时，应注意序列化数组指针的移动</li>
<li>二级指针的使用目的在于使用参数记录一级指针的改动(传出参数)，如序列化数组指针，根节点指针</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-43"><a href="#Answer-43" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于异常判断的全局变量</span></span><br><span class="line"><span class="keyword">bool</span> hasException = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//序列化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Serializaion</span><span class="params">(TreeNode* pHead)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;$,&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//先序遍历</span></span><br><span class="line">	cout &lt;&lt; pHead-&gt;pValue &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">	<span class="built_in">Serializaion</span>(pHead-&gt;pLeft);</span><br><span class="line">	<span class="built_in">Serializaion</span>(pHead-&gt;pRight);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反序列化</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isNumber</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (c == <span class="string">&#x27;$&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		hasException = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReSerializaionCore</span><span class="params">(TreeNode** pRoot, <span class="keyword">char</span>** ser)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">isNumber</span>(**ser)) &#123;</span><br><span class="line">		*pRoot = <span class="keyword">new</span> <span class="built_in">TreeNode</span>();</span><br><span class="line">		(*pRoot)-&gt;pValue = **ser - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		(*pRoot)-&gt;pLeft = <span class="literal">nullptr</span>;</span><br><span class="line">		(*pRoot)-&gt;pRight = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//序列指针后移</span></span><br><span class="line">		(*ser)++;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">ReSerializaionCore</span>(&amp;((*pRoot)-&gt;pLeft), ser);</span><br><span class="line">		<span class="built_in">ReSerializaionCore</span>(&amp;((*pRoot)-&gt;pRight), ser);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (hasException)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		<span class="comment">//序列指针后移</span></span><br><span class="line">		(*ser)++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="39-1-字符串的排列"><a href="#39-1-字符串的排列" class="headerlink" title="39.1 字符串的排列"></a>39.1 字符串的排列</h1><blockquote>
<p>输入一个字符串,打印出该字符串中字符的所有排列</p>
</blockquote>
<h2 id="Testing-case-46"><a href="#Testing-case-46" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(字符串有一个或多个字符，字符串中存在值相同的元素)</li>
<li>边界测试(nullptr,字符串为空)</li>
</ul>
<h2 id="Key-46"><a href="#Key-46" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>决策树 + 分治 + 穷举递归    无需额外的内存</p>
<blockquote>
<ol>
<li>使用pCurrntStart指针，从第一个位置开始逐个存放全排列后的元素</li>
<li>当决策好pCurrntStart位置的元素时，递归对pCurrntStart后其余位置进行元素决策</li>
<li>在进行下一次同位置(同层)决策前，需要还原字符串的排列顺序</li>
<li>直至每个全排列位置均已决策相应的元素，输出一次全排列结果</li>
<li>直至首位置水平决策全部作出且各决策均完成全排列输出，完成该字符串所有决策输出</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>pCurrntStart指针用于指向当前正作元素决策的全排列位置，初始为全排列后第一个位置开始，即字符串的首位置</li>
<li>决策的所有选择来自于当前字符串的所有元素，为保证能够作出所有同层决策，因此需要对当前剩余元素进行遍历</li>
<li>在2的决策作出之前，需要还原字符串状态，否则下一次决策将无意义</li>
<li>该方法直接使用原字符串内存作为排列后字符串的存储内存</li>
</ol>
</blockquote>
</li>
<li><p>决策树 + 分治 + 穷举递归 额外分配存储内存</p>
<blockquote>
<ol>
<li>遍历原字符串vector1，将第一个位置所有情况进行穷举决策</li>
<li>选择当前决策的元素压入到vector2，进行递归下一位置的穷举决策</li>
<li>在进行下一位置的穷举决策之前需要弹出已决策元素</li>
<li>在进行同层其他决策前，需要恢复已从vector1中弹出的元素以及对应的vector2的排列状态</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>使用一个vector暂存目前排列状态，无需在原内存上通过指针的较复杂操作</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-44"><a href="#Answer-44" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<p>1.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Permutation</span><span class="params">(<span class="keyword">char</span>* arr)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">PermutationCore</span>(arr, arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PermutationCore</span><span class="params">(<span class="keyword">char</span>* pAllStart, <span class="keyword">char</span>* pCurrntStart)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//base case</span></span><br><span class="line">	<span class="keyword">if</span> (*pCurrntStart == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">		cout &lt;&lt; pAllStart &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历字符串的每个元素 -- 保证作出所有可能的水平决策</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">char</span>* pCur = pCurrntStart; *pCur != <span class="string">&#x27;\0&#x27;</span>; pCur++) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//决策结果为 pCur元素位于pCurrntStart位置 --水平决策</span></span><br><span class="line">		<span class="keyword">char</span> pTemp = *pCur;</span><br><span class="line">		*pCur = *pCurrntStart;</span><br><span class="line">		*pCurrntStart = pTemp;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//pCurrntStart位置之后位置递归进行决策 --垂直决策</span></span><br><span class="line">		<span class="built_in">PermutationCore</span>(pAllStart, pCurrntStart + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//还原字符串  --水平决策复原</span></span><br><span class="line">		pTemp = *pCur;</span><br><span class="line">		*pCur = *pCurrntStart;</span><br><span class="line">		*pCurrntStart = pTemp;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PermutationCore</span><span class="params">(vector&lt;<span class="keyword">char</span>&gt;&amp; ori, vector&lt;<span class="keyword">char</span>&gt;&amp; pmt)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//base case</span></span><br><span class="line">	<span class="keyword">if</span> (ori.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="comment">//输出当前的全排列结果</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> i : pmt) &#123;</span><br><span class="line">			cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历字符串的每个元素 -- 保证作出所有可能的水平决策</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ori.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将当前决策结果存放于pmt数组中去 --水平决策</span></span><br><span class="line">		pmt.<span class="built_in">push_back</span>(ori[i]);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//为了确保在剩余元素中作出下次垂直决策，需要将当前元素暂时弹出，因为需要恢复，因此先暂存</span></span><br><span class="line">		<span class="keyword">char</span> temp = ori[i];</span><br><span class="line">		ori.<span class="built_in">erase</span>(ori.<span class="built_in">begin</span>() + i);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//对已决策的下一个位置作出元素决策 --垂直决策</span></span><br><span class="line">		<span class="built_in">PermutationCore</span>(ori, pmt);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//还原  --水平决策复原</span></span><br><span class="line">		ori.<span class="built_in">insert</span>(ori.<span class="built_in">begin</span>() + i, temp);</span><br><span class="line">		pmt.<span class="built_in">pop_back</span>();</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="39-2-字符串的组合"><a href="#39-2-字符串的组合" class="headerlink" title="39.2 字符串的组合"></a>39.2 字符串的组合</h1><blockquote>
<p>输入一个字符串,打印出该字符串中字符的所有组合</p>
</blockquote>
<h2 id="Testing-case-47"><a href="#Testing-case-47" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(字符串有一个或多个字符，字符串中存在值相同的元素)</li>
<li>边界测试(nullptr,字符串为空)</li>
</ul>
<h2 id="Key-47"><a href="#Key-47" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>分治 + 决策树 + 递归</p>
<blockquote>
<ol>
<li>辅助接口函数完成n次子问题的循环，从求长度为1的组合开始一直至长度为n的组合</li>
<li>对当前指针指向的字符进行决策</li>
<li>若含当前元素，则将当前元素压入组合数组，并递归在剩余元素中求长度为 k-1 的元素组合</li>
<li>若不含当前元素，则递归在剩余元素中求长度为 k 的元素组合</li>
<li>在进行4之前需要对组合数组进行复原</li>
<li>直至组合数组中的元素达到要求的元素长度k，即k=0时，终止递归</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>n个字符串的左右组合问题可以拆解为n次 m个元素中找寻长度为k的元素组合 k=1,2,…,n</li>
<li>决策树的分支为2，两种选择分别为k长度的组合中含/不含当前元素</li>
<li>两种决策必须均作出，因此不可以使用if-else进行决策</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-45"><a href="#Answer-45" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Combination</span><span class="params">(<span class="keyword">char</span>* arr)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将n个元素的所有组合拆解为求n次 mlen个元素中长度为k的组合</span></span><br><span class="line">	<span class="keyword">char</span> *len = arr;</span><br><span class="line">	<span class="keyword">int</span> mlen = <span class="number">0</span>;</span><br><span class="line">	vector&lt;<span class="keyword">char</span>&gt; comb;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (; *len != <span class="string">&#x27;\0&#x27;</span>; len++) &#123;</span><br><span class="line">		mlen++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= mlen; k++) &#123;</span><br><span class="line">		<span class="built_in">CombinationCore</span>(arr, k, comb);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CombinationCore</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">int</span> k, vector&lt;<span class="keyword">char</span>&gt;&amp; comb)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//base case</span></span><br><span class="line">	<span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">//输出组合结果</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> i : comb) &#123;</span><br><span class="line">			cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (*str == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//对str中的每个元素进行决策 长度为k的组合是否含有当前元素</span></span><br><span class="line">	<span class="comment">//yes k个元素组合中含当前元素</span></span><br><span class="line">	comb.<span class="built_in">push_back</span>(*str);</span><br><span class="line">	<span class="comment">//在str剩余元素中取k-1个元素进行组合</span></span><br><span class="line">	<span class="built_in">CombinationCore</span>(str + <span class="number">1</span>, k - <span class="number">1</span>, comb);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//在进行同层结果为no的决策前，需要恢复</span></span><br><span class="line">	comb.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//no k个元素组合中不含当前元素</span></span><br><span class="line">	<span class="comment">//在str剩余元素中取k个元素进行组合</span></span><br><span class="line">	<span class="built_in">CombinationCore</span>(str + <span class="number">1</span>, k, comb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="39-3-8皇后摆法问题"><a href="#39-3-8皇后摆法问题" class="headerlink" title="39.3 8皇后摆法问题"></a>39.3 8皇后摆法问题</h1><blockquote>
<p>在8x8的国际象棋上摆放8个皇后,使其不能相互攻击,即任意两,个皇后不得处在同一行、同一列或者同一条对角线上</p>
<p>请问总共有多少种符合条件的摆法？</p>
</blockquote>
<h2 id="Testing-case-48"><a href="#Testing-case-48" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(整数数组长度为8)</li>
<li>边界测试(nullptr)</li>
</ul>
<h2 id="Key-48"><a href="#Key-48" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>全排列 + 筛选</p>
<blockquote>
<ol>
<li>使用长度为8的数组代表8个皇后的位置 (i,ColIndex[i]) 并为其初始化为0 - 7，角标 i 表示行，数组元素 ColIndex[i] 表示 i 列</li>
<li>对ColIndex数组各元素进行全排列，将各元素的所有列排列情况列出</li>
<li>选取不在同一行，同一列，同一对角线的排列进行输出并计数</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>因为使用了不同的下标表示8个皇后的行数，因此8个皇后此条件下一定不在同一行</li>
<li>因为使用了不同的元素初始化ColIndex数组，因此8个皇后此条件下一定不在同一列</li>
<li>在同一对角线 i - j == ColIndex[i] - ColIndex[j] || j - i == ColIndex[i] - ColIndex[j]</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-46"><a href="#Answer-46" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记录符合条件的摆法</span></span><br><span class="line"><span class="keyword">int</span> Num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SameCheck</span><span class="params">(<span class="keyword">int</span>* str, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断是否存在同行，同列，同对角线的元素</span></span><br><span class="line">	<span class="comment">//双重循环时i，j必然不会相同，因此在于判断两元素是否在同一个对角线上</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i - j == str[i] - str[j] || j - i == str[i] - str[j]) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EightQueen</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">int</span> QueenNum)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">EightQueenCore</span>(arr, arr, QueenNum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EightQueenCore</span><span class="params">(<span class="keyword">int</span>* pAllStart, <span class="keyword">int</span>* pCurrntStart, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//base case</span></span><br><span class="line">	<span class="comment">//len为进行全排列的整数数目，当len减至0时，代表已将len长度的所有整数进行了全排列</span></span><br><span class="line">	<span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">		 </span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">SameCheck</span>(pAllStart, pCurrntStart - pAllStart))</span><br><span class="line">		&#123;</span><br><span class="line">			Num++;</span><br><span class="line">			<span class="keyword">int</span>* pStart = pAllStart;</span><br><span class="line">			cout &lt;&lt; Num &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">for</span> (; pStart &lt; pCurrntStart; pStart++) &#123;</span><br><span class="line">				cout &lt;&lt; *pStart &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历字符串的每个元素 -- 保证作出所有可能的水平决策</span></span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span>* pCur = pCurrntStart; i &lt; len; pCur++, i++) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//决策结果为 pCur元素位于pCurrntStart位置 --水平决策</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> pTemp = *pCur;</span><br><span class="line">		*pCur = *pCurrntStart;</span><br><span class="line">		*pCurrntStart = pTemp;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//pCurrntStart位置之后位置递归进行决策 --垂直决策</span></span><br><span class="line">		<span class="built_in">EightQueenCore</span>(pAllStart, pCurrntStart + <span class="number">1</span>, len - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//还原字符串  --水平决策复原</span></span><br><span class="line">		pTemp = *pCur;</span><br><span class="line">		*pCur = *pCurrntStart;</span><br><span class="line">		*pCurrntStart = pTemp;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="39-4-正方体顶点数分布"><a href="#39-4-正方体顶点数分布" class="headerlink" title="39.4 正方体顶点数分布"></a>39.4 正方体顶点数分布</h1><blockquote>
<p>输入一个含有8个数字的数组,判断有没有可能把这8个数字分别,放到正方体的8个顶点上</p>
<p>使得正方体上三组相对的面上的4个顶点的和都相等</p>
</blockquote>
<h2 id="Testing-case-49"><a href="#Testing-case-49" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(整数数组长度为8)</li>
<li>边界测试(nullptr)</li>
</ul>
<h2 id="Key-49"><a href="#Key-49" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>全排列 + 筛选</p>
<blockquote>
<ol>
<li>对传入的数组元素进行全排列</li>
<li>对全排列的结果进行筛选，若满足条件，则对分布情况进行输出</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>8个数字满足分布于正方体上的条件 a1+a2+a3+a4 == a5+a6+a7+a8 &amp;&amp; a1+a3+a5+a7 == a2+a4+a6+a8 &amp;&amp; a1+a2+a5+a6 == a3+a4+a7+a8</li>
</ol>
</blockquote>
</li>
</ul>
<h1 id="40-数组中出现次数超过一半的数字"><a href="#40-数组中出现次数超过一半的数字" class="headerlink" title="40 数组中出现次数超过一半的数字"></a>40 数组中出现次数超过一半的数字</h1><blockquote>
<p>数组中有一个数字出现的次数超过数组长度的一半,请找出这个数字</p>
<p>若不存在此数字则视为异常</p>
</blockquote>
<h2 id="Testing-case-50"><a href="#Testing-case-50" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(数组中 存在/不存在 次数超过一半的数字)</li>
<li>边界测试(nullptr，只有一个数字)</li>
</ul>
<h2 id="Key-50"><a href="#Key-50" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>排序后遍历计数 O(n) = nlogn</p>
</li>
<li><p>中位数 + 快排 O(n) = n</p>
<blockquote>
<ol>
<li>对数组进行快排划分，并记录返回的基数位置</li>
<li>若该基数位置不等于数组中位数位置 len &gt;&gt; 1(len / 2)，则继续在基数左/右继续划分记录基数位置</li>
<li>若基数位置大于数组中位数位置 len &gt;&gt; 1(len / 2)，则在基数左边的数字中寻找中位数位置</li>
<li>若基数位置小于数组中位数位置 len &gt;&gt; 1(len / 2)，则在基数右边的数字中寻找中位数位置</li>
<li>直至基数的位置等于数组中位数的位置，进一步判断该基数是否为要求数字</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>若数组中存在出现次数超过一半的数字，则该数字一定是数组的中位数</li>
<li>1的逆命题并不成立，在得到数组的中位数后应进一步判断是否为要求数</li>
</ol>
</blockquote>
</li>
<li><p>打擂 可能数字 -&gt; 确切数字 O(n) = n</p>
<blockquote>
<ol>
<li>设置result擂主与coefficient可能系数，遍历数组开始打擂</li>
<li>若下一个元素等于该result，则擂主可能系数加1，否则，擂主可能系数减一</li>
<li>若擂主系数减至0，则代表当前擂主不可能为要求数字，更换擂主并同时更新coefficient为1</li>
<li>最终得到最可能成为要求数字的擂主后进行最终遍历计数判断即可</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>数组中出现次数超过一半的数字只能有一个</li>
<li>coefficient可能系数并不代表result的出现次数，而是其成为要求数字的可能系数</li>
<li>若存在要求数字，则该数字一定是擂主并最终coefficient&gt;=1，但是若擂主最终coefficient&gt;=1，其不一定是要求数字，因此最后需要在此判断是否为要求数字</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-47"><a href="#Answer-47" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<p>1.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MedianMoreThanHalf</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IsValidInput</span>(arr, len)) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//记录数组的中位数位置</span></span><br><span class="line">	<span class="keyword">int</span> median = len &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取当前快排划分得到的基数位置</span></span><br><span class="line">	<span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> end = len - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> pivot = <span class="built_in">Partition</span>(arr, len, start, end);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//若此基数位置不为中位数，则在划分后的数中进而求基数位置直到基数位置等于median</span></span><br><span class="line">	<span class="keyword">while</span> (median != pivot) &#123;</span><br><span class="line">		<span class="keyword">if</span> (pivot &gt; median) &#123;</span><br><span class="line">			<span class="comment">//在基数左边的数字中寻找</span></span><br><span class="line">			end = pivot - <span class="number">1</span>;</span><br><span class="line">			pivot = <span class="built_in">Partition</span>(arr, len, start, end);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//在基数右边的数字中寻找</span></span><br><span class="line">			start = pivot + <span class="number">1</span>;</span><br><span class="line">			pivot = <span class="built_in">Partition</span>(arr, len, start, end);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//此时基数位置即为中位数位置，该基数可能为要求数，进一步判断</span></span><br><span class="line">	<span class="keyword">int</span> result = arr[pivot];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">IsMoreThanHalf</span>(arr, len, result)) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		result = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> len, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span> || start &lt; <span class="number">0</span> || end &gt;= len) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置small时刻指向当前最后一个比small小的元素</span></span><br><span class="line">	<span class="keyword">int</span> small = start - <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//数组某位暂存pivot基数 默认取start元素，此处并未随机</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> pivot = arr[start];</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">int</span> temp = arr[start];</span><br><span class="line">	arr[start] = arr[end];</span><br><span class="line">	arr[end] = temp;	</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历数组，以基数为基准进行划分</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> index = start; index &lt; end; index++) &#123;</span><br><span class="line">		<span class="comment">//若遍历元素比pivot基数小，则small后移，否则不作处理</span></span><br><span class="line">		<span class="keyword">if</span> (arr[index] &lt; pivot) &#123;</span><br><span class="line"></span><br><span class="line">			small++;</span><br><span class="line">			<span class="comment">//若遇到比pivot大的元素后又遇到比pivot小的元素，则small++后交换这两个元素位置</span></span><br><span class="line">			<span class="keyword">if</span> (index != small) &#123;</span><br><span class="line">				<span class="keyword">int</span> temp = arr[index];</span><br><span class="line">				arr[index] = arr[small];</span><br><span class="line">				arr[small] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将small指针指向pivot基数应存放位置</span></span><br><span class="line">	small++;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//交换基数与第一个比其大的元素</span></span><br><span class="line">	temp = arr[small];</span><br><span class="line">	arr[small] = arr[end];</span><br><span class="line">	arr[end] = temp;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> small;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="function"><span class="keyword">bool</span> <span class="title">IsMoreThanHalf</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> len, <span class="keyword">int</span> result)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置bool变量返回值</span></span><br><span class="line">	<span class="keyword">bool</span> isMoreThanHalf = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//记录result在数组中的出现次数</span></span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (arr[i] == result) &#123;</span><br><span class="line">			num++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置全局异常判断变量初始为true</span></span><br><span class="line">	isExcption = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (num &gt; (len / <span class="number">2</span>)) &#123;</span><br><span class="line"></span><br><span class="line">		isExcption = <span class="literal">false</span>;</span><br><span class="line">		isMoreThanHalf = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> isMoreThanHalf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsValidInput</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> isExc = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		isExc = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> isExc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LikelyMoreThanHalf</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IsValidInput</span>(arr, len)) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置变量记录可能数字</span></span><br><span class="line">	<span class="keyword">int</span> result = arr[<span class="number">0</span>];</span><br><span class="line">	<span class="comment">//设置其可能系数</span></span><br><span class="line">	<span class="keyword">int</span> coefficient = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//挑选出数组中最可能成为result的数字</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (coefficient == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//若此系数减弱至0，则表示该数字不可能为终值，切换至下一个值		</span></span><br><span class="line">			result = arr[i];</span><br><span class="line">			<span class="comment">//重新设置系数为1</span></span><br><span class="line">			coefficient = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (result == arr[i]) &#123;</span><br><span class="line">			<span class="comment">//系数增强</span></span><br><span class="line">			coefficient++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//系数减弱</span></span><br><span class="line">			coefficient--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//检查result是否为终值</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">IsMoreThanHalf</span>(arr, len, result)) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		result = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="41-最小的k个数"><a href="#41-最小的k个数" class="headerlink" title="41 最小的k个数"></a>41 最小的k个数</h1><blockquote>
<p>输入n个整数,找出其中最小的k个数</p>
</blockquote>
<h2 id="Testing-case-51"><a href="#Testing-case-51" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(数组中有相同数字，数组中无相同数字)</li>
<li>边界测试(nullptr，k&lt;=1，k&gt;=数组长度)</li>
</ul>
<h2 id="Key-51"><a href="#Key-51" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>快排划分 T(n) = O(n)</p>
<blockquote>
<ol>
<li>对数组进行快排划分，并记录返回的基数的位置</li>
<li>若该基数位置不等于 k - 1，则继续在基数左/右继续划分记录基数位置</li>
<li>若基数位置大于 k - 1，则在基数左边的数字中寻找划分后基准位置为 k - 1 的划分</li>
<li>若基数位置小于 k - 1，则在基数右边的数字中寻找划分后基准位置为 k - 1 的划分</li>
<li>直至基数的位置等于 k - 1，对该基准左边的数字(含该基准)进行输出</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>若快排划分后的基准位置即第k位，则该基准左边的数字(含该基准)即为最小的k个数</li>
<li>划分将导致原数组被修改</li>
</ol>
</blockquote>
</li>
<li><p>红黑树 / 堆 T(n) = O(nlogk)</p>
<blockquote>
<ol>
<li>对于输入的元素，若容器大小小于k，则直接压入容器</li>
<li>否则判断当前输入元素与容器中最大元素的大小</li>
<li>若输入元素小，则替换当前容器最大元素，否则，跳过该输入元素</li>
<li>直至遍历完输入元素容器</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>大顶堆或者红黑树结构可以O(1)复杂度取得最大元素，O(logn)复杂度插入删除元素</li>
<li>适合用于数据庞大或者无法一次载入内存的情形</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-48"><a href="#Answer-48" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<p>1.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> len, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span> || start &lt; <span class="number">0</span> || end &gt;= len) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置small时刻指向当前最后一个比small小的元素</span></span><br><span class="line">	<span class="keyword">int</span> small = start - <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//数组某位暂存pivot基数 默认取start元素，此处并未随机</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> pivot = arr[start];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> temp = arr[start];</span><br><span class="line">	arr[start] = arr[end];</span><br><span class="line">	arr[end] = temp;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历数组，以基数为基准进行划分</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> index = start; index &lt; end; index++) &#123;</span><br><span class="line">		<span class="comment">//若遍历元素比pivot基数小，则small后移，否则不作处理</span></span><br><span class="line">		<span class="keyword">if</span> (arr[index] &lt; pivot) &#123;</span><br><span class="line"></span><br><span class="line">			small++;</span><br><span class="line">			<span class="comment">//若遇到比pivot大的元素后又遇到比pivot小的元素，则small++后交换这两个元素位置</span></span><br><span class="line">			<span class="keyword">if</span> (index != small) &#123;</span><br><span class="line">				<span class="keyword">int</span> temp = arr[index];</span><br><span class="line">				arr[index] = arr[small];</span><br><span class="line">				arr[small] = temp;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将small指针指向pivot基数应存放位置</span></span><br><span class="line">	small++;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//交换基数与第一个比其大的元素</span></span><br><span class="line">	temp = arr[small];</span><br><span class="line">	arr[small] = arr[end];</span><br><span class="line">	arr[end] = temp;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> small;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetLeastNumbers</span><span class="params">(<span class="keyword">int</span>* input, <span class="keyword">int</span> len, <span class="keyword">int</span>* output, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (input == <span class="literal">nullptr</span> || len &lt; <span class="number">0</span> || k &gt; len || k &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//基于快排划分找到划分基准为 k-1 的划分结果</span></span><br><span class="line">	<span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> end = len - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> index = <span class="built_in">Partition</span>(input, len, start, end);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (index != k - <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (index &gt; k - <span class="number">1</span>) &#123;</span><br><span class="line">			end = index - <span class="number">1</span>;</span><br><span class="line">			index = <span class="built_in">Partition</span>(input, len, start, end);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			start = index + <span class="number">1</span>;</span><br><span class="line">			index = <span class="built_in">Partition</span>(input, len, start, end);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将划分后的前k个元素存入输出数组</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">		output[i] = input[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetLeastNumbersByRB</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; data, SetType&amp; store, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (data.<span class="built_in">size</span>() == <span class="number">0</span> || k &lt; <span class="number">0</span> || k &gt; data.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历输入数组，将前k大的元素存入到store容器中</span></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;::const_iterator ite = data.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">for</span> (; ite &lt; data.<span class="built_in">end</span>(); ite++) &#123;</span><br><span class="line">		<span class="comment">//若容器元素未满k个，则直接插入</span></span><br><span class="line">		<span class="keyword">if</span> (store.<span class="built_in">size</span>() &lt; k) &#123;</span><br><span class="line">			store.<span class="built_in">insert</span>(*ite);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//若满k个且当前输入元素小于红黑树根结点，则替换掉该根节点</span></span><br><span class="line">			<span class="keyword">if</span> (*ite &lt; *store.<span class="built_in">begin</span>()) &#123;</span><br><span class="line">				store.<span class="built_in">erase</span>(*(store.<span class="built_in">begin</span>()));</span><br><span class="line">				store.<span class="built_in">insert</span>(*ite);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</blockquote>
<h1 id="42-数据流中的中位数"><a href="#42-数据流中的中位数" class="headerlink" title="42 数据流中的中位数"></a>42 数据流中的中位数</h1><blockquote>
<p>如何得到一个数据流中的中位数</p>
<p>如果从数据流中读出奇数个数1值,那么中位数就是所有数值排序之后位于中间的数值</p>
<p>如果从数据流中读出偶数个数值,那么中位数就是所有数值排序之后中间两个数的平均值</p>
</blockquote>
<h2 id="Testing-case-52"><a href="#Testing-case-52" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(数据流中有奇数/偶数个数字)</li>
<li>边界测试(数据流中无数字)</li>
</ul>
<h2 id="Key-52"><a href="#Key-52" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>快排划分 O(1) 插入 O(n) 中位数</p>
</li>
<li><p>排序数组 O(n) 插入 O(1) 中位数</p>
</li>
<li><p>排序链表 O(n)插入 O(1) 中位数</p>
</li>
<li><p>二叉搜索树 O(logn) - O(n) 插入 O(logn) - O(n) 中位数</p>
</li>
<li><p>AVL树 O(logn) 插入 O(1) 中位数</p>
</li>
<li><p>双堆 O(logn) 插入 O(1) 中位数</p>
<blockquote>
<ol>
<li>建立一个动态数组，动态数组底层为两个堆，一个是大顶堆，一个为小顶堆</li>
<li>每次向动态数组中压入数字时，若目前动态数组中的元素个数为偶数(0)，则压入到min堆，保证数据流中数字的均匀分配</li>
<li>若压入min堆时，max不为空，则应先于max堆顶元素比较，若小于max堆顶元素，则将max堆顶元素压入min堆，当前元素压入max堆</li>
<li>若目前动态数组中的元素个数为奇数，则压入到max堆</li>
<li>若压入max堆时，min不为空，则应先于min堆顶元素比较，若大于min堆顶元素，则将min堆顶元素压入max堆，当前元素压入min堆</li>
</ol>
<p>-</p>
<ol>
<li>求中位数时若当前动态数组元素个数为奇数，则返回min堆堆顶</li>
<li>否则返回 ( max[0] + min[0] ) / 2</li>
</ol>
<h2 id="Answer-49"><a href="#Answer-49" class="headerlink" title="Answer"></a>Answer</h2><p><code>注意:</code></p>
<ol>
<li>中位数将整个数组划分为两部分，这两部分有如下特点<ul>
<li>左边部分的数字均比右边部分的数字小</li>
<li>左边部分数字个数与右边数字个数相差不超过1</li>
<li>中位数为左边部分最大值/右边部分最小值/两者的平均值</li>
</ul>
</li>
<li>如果压入时动态数组中元素个数为偶数，则压入到min堆，否则压入到max堆，保证数据流中数字的均匀分配</li>
<li>选择DynamicArray封装当前数据流中的数据</li>
<li>push_heap,pop_heap 的操作对象必须为已经形成的堆</li>
<li>push_heap应确保元素已经压入堆中</li>
<li>pop_heap并不会弹出堆顶元素，只要将堆顶元素与堆尾元素交换，徐亚使用pop_back弹出</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-50"><a href="#Answer-50" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> isExcption = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DynamicArray</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">DynamicArray</span>() = <span class="keyword">default</span>;</span><br><span class="line">	~<span class="built_in">DynamicArray</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(T num)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">GetMedian</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	vector&lt;T&gt; max;</span><br><span class="line">	vector&lt;T&gt; min;</span><br><span class="line">&#125;;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> DynamicArray&lt;T&gt;::<span class="built_in">Insert</span>(T num) &#123;</span><br><span class="line">	<span class="comment">//如果压入时动态数组中元素个数为偶数，则压入到min堆，否则压入到max堆，保证数据流的均匀分配</span></span><br><span class="line">	<span class="keyword">if</span> (((max.<span class="built_in">size</span>() + min.<span class="built_in">size</span>()) &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">//若压入的元素比max堆中的最大元素大，则需要将该元素压入max堆并将max堆中最大元素压入min堆</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (max.<span class="built_in">size</span>() &gt; <span class="number">0</span> &amp;&amp; num &lt; max[<span class="number">0</span>]) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//将当前元素压入到max堆中</span></span><br><span class="line">			max.<span class="built_in">push_back</span>(num);</span><br><span class="line">			<span class="built_in">push_heap</span>(max.<span class="built_in">begin</span>(), max.<span class="built_in">end</span>(), less&lt;T&gt;());</span><br><span class="line">			num = max[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">			<span class="built_in">pop_heap</span>(max.<span class="built_in">begin</span>(), max.<span class="built_in">end</span>(), less&lt;T&gt;());</span><br><span class="line">			max.<span class="built_in">pop_back</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		min.<span class="built_in">push_back</span>(num);</span><br><span class="line">		<span class="built_in">push_heap</span>(min.<span class="built_in">begin</span>(), min.<span class="built_in">end</span>(), greater&lt;T&gt;());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//如果压入时动态数组中元素个数为奇数，则压入到max堆</span></span><br><span class="line">		<span class="comment">//若压入的元素比min堆中的最小大，则需要将该元素压入min堆并将min堆中最小元素压入max堆</span></span><br><span class="line">		<span class="keyword">if</span> (min.<span class="built_in">size</span>() &gt; <span class="number">0</span> &amp;&amp; num &gt; min[<span class="number">0</span>]) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//将当前元素压入到max堆中</span></span><br><span class="line">			min.<span class="built_in">push_back</span>(num);</span><br><span class="line">			<span class="built_in">push_heap</span>(min.<span class="built_in">begin</span>(), min.<span class="built_in">end</span>(), greater&lt;T&gt;());</span><br><span class="line"></span><br><span class="line">			num = min[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">			<span class="built_in">pop_heap</span>(min.<span class="built_in">begin</span>(), min.<span class="built_in">end</span>(), greater&lt;T&gt;());</span><br><span class="line">			min.<span class="built_in">pop_back</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		max.<span class="built_in">push_back</span>(num);</span><br><span class="line">		<span class="built_in">push_heap</span>(max.<span class="built_in">begin</span>(), max.<span class="built_in">end</span>(), less&lt;T&gt;());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">double</span> DynamicArray&lt;T&gt;::<span class="built_in">GetMedian</span>() &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断异常</span></span><br><span class="line">	<span class="keyword">int</span> size = max.<span class="built_in">size</span>() + min.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	T median;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((size &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">		median = (max[<span class="number">0</span>] + min[<span class="number">0</span>]) / <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		median = min[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> median;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="—-堆-—"><a href="#—-堆-—" class="headerlink" title="—- 堆 —-"></a>—- 堆 —-</h1><h2 id="Interfaces"><a href="#Interfaces" class="headerlink" title="Interfaces"></a>Interfaces</h2><ul>
<li><p>make_heap(start_ite,end_ite,functor)</p>
<blockquote>
<p>对于给定的范围元素生成堆，默认为大顶堆</p>
<p>start_ite: 指向开始元素的迭代器</p>
<p>end_ite: 指向末尾元素的迭代器</p>
<p>functor: greater&lt; T &gt;() - 小顶堆, less&lt; T &gt;() - 大顶堆</p>
</blockquote>
</li>
<li><p>push_heap(start_ite,end_ite,functor)</p>
<blockquote>
<p>在堆的基础上进行数据的插入，本身不会有数据插入操作，须确保数据已经插入后再作堆调整</p>
<p>start_ite: 指向开始元素的迭代器</p>
<p>end_ite: 指向末尾元素的迭代器</p>
<p>functor: greater&lt; T &gt;() - 小顶堆, less&lt; T &gt;() - 大顶堆</p>
</blockquote>
</li>
<li><p>pop_heap(start_ite,end_ite,functor)</p>
<blockquote>
<p>在堆的基础上进行堆顶的弹出，本身不会有数据弹出操作，仅仅是将堆顶元素与堆尾元素进行了交换</p>
<p>start_ite: 指向开始元素的迭代器</p>
<p>end_ite: 指向末尾元素的迭代器</p>
<p>functor: greater&lt; T &gt;() - 小顶堆, less&lt; T &gt;() - 大顶堆</p>
</blockquote>
</li>
</ul>
<h1 id="43-连续子数组的最大和"><a href="#43-连续子数组的最大和" class="headerlink" title="43 连续子数组的最大和"></a>43 连续子数组的最大和</h1><blockquote>
<p>输入一个整型数组,数组里有正数也有负数，数组中的一个或连续多个整数组成一个子数组</p>
<p>求所有子数组的和的最大值</p>
<p>要求时间复杂度为0(n)。</p>
</blockquote>
<h2 id="Testing-case-53"><a href="#Testing-case-53" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(输入的数组有正数有负数，全是正数，全是负数)</li>
<li>边界测试(nullptr)</li>
</ul>
<h2 id="Key-53"><a href="#Key-53" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>动态规划 T(n) = O(n)</p>
<blockquote>
<ol>
<li>正向迭代计算由f(0)至f(len-1)，并记录当前元素作连续子数组末尾时的最大和currentSum</li>
<li>使用打擂法计算 len 个元素的数组中的连续子数组的最大和MaxNum</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>连续子数组的最大和是数组某个元素作连续子数组末尾元素时的最大和</li>
<li>只需求出每个元素作连续子数组末尾元素时的最大和并记录最大值即可</li>
<li>递归分析可得第 i 个元素作连续子数组末尾元素时的最大和为，记为f(i)<ul>
<li>a(i) — f(i - 1) &lt;= 0 || i = 0</li>
<li>a(i) + f(i) — f(i - 1) &gt; 0 &amp;&amp; i &gt; 0</li>
</ul>
</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-51"><a href="#Answer-51" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetGreatestNum</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//记录第 i-1 元素为尾的最大子数组的和</span></span><br><span class="line">	<span class="keyword">int</span> currentSum = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//记录最大子数组的和</span></span><br><span class="line">	<span class="keyword">int</span> MaxNum = arr[<span class="number">0</span>];</span><br><span class="line">	<span class="comment">//正向迭代 求i元素为尾的最大子数组和</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (currentSum &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">//如果第 i-1 元素为尾的最大子数组和小于等于0，则舍弃之前元素，当前元素构成的子数组和即为当前位置的最大和</span></span><br><span class="line">			currentSum = arr[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//如果第 i-1 元素为尾的最大子数组和大于0，则累加</span></span><br><span class="line">			currentSum += arr[i];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//打擂记录最大子数组和</span></span><br><span class="line">		<span class="keyword">if</span> (currentSum &gt;= MaxNum) &#123;</span><br><span class="line">			MaxNum = currentSum;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> MaxNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="44-1-n-整数中1出现的次数-—跳过"><a href="#44-1-n-整数中1出现的次数-—跳过" class="headerlink" title="44 1-n 整数中1出现的次数  —跳过"></a>44 1-n 整数中1出现的次数  —跳过</h1><blockquote>
</blockquote>
<h2 id="Testing-case-54"><a href="#Testing-case-54" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(输入的数组有正数有负数，全是正数，全是负数)</li>
<li>边界测试(nullptr)</li>
</ul>
<h2 id="Key-54"><a href="#Key-54" class="headerlink" title="Key"></a>Key</h2><ul>
<li></li>
</ul>
<h2 id="Answer-52"><a href="#Answer-52" class="headerlink" title="Answer"></a>Answer</h2><h1 id="45-数字序列中的某一位数字"><a href="#45-数字序列中的某一位数字" class="headerlink" title="45 数字序列中的某一位数字"></a>45 数字序列中的某一位数字</h1><blockquote>
<p>数字以0123456789101112131415 的格式序列化到一个字符序列中</p>
<p>在这个序列中,第5位(从0开始计数)是5,第13位是1,第19位是4,等等</p>
<p>请写一个函数,求任意第n位对应的数字</p>
</blockquote>
<h2 id="Testing-case-55"><a href="#Testing-case-55" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(10,190,1000等)</li>
<li>边界测试(0,1)</li>
</ul>
<h2 id="Key-55"><a href="#Key-55" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>穷举遍历数字</p>
<blockquote>
<ol>
<li>从数字1开始向下遍历，每次记录当前位数总数并与输入n进行比较</li>
<li>若小于等于n，则说明第n位在此数字所在序列中的位数之后，向下遍历</li>
<li>若大于n，则说明第n位数字在序列中的位置位于此数字之间</li>
<li>进而在此数字中根据偏移量找到最终的某一位数字</li>
</ol>
</blockquote>
</li>
<li><p>跳级定位范围</p>
<blockquote>
<ol>
<li>从1位数开始判断第n位数字所在的位数范围，将n不断与m位数的所有数字包含的位数作比较</li>
<li>若n&lt;m，则表示第n位数字所在的数为m位数，否则继续向后循环判断</li>
<li>锁定所在位数范围后，根据该m位数的首位数字与偏移量求得第n位数字所在的数字</li>
<li>进而在此数字中根据偏移量找到最终的某一位数字</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>数字序列排列递增有序，依次为所有一位数，二位数……..</li>
<li>不再穷举遍历定位所在的数字，而是先定位其位于哪一个位数范围内，进而定位位于该位数范围内的那个数中，再根据偏移量的最终数字</li>
<li>由于是从0开始计数，因此范围定位时注意条件是否能等于</li>
<li>各子功能分模块，防止代码冗余</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-53"><a href="#Answer-53" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> isExcption = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetNum</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetDiditNums</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetNumCore</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetHead</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetHead</span><span class="params">(<span class="keyword">int</span> digit)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (digit == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in"><span class="keyword">return</span></span> (<span class="keyword">int</span>)(<span class="built_in">pow</span>(<span class="number">10</span>, digit - <span class="number">1</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetNumCore</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> digit)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//获取digit位数的首位数字</span></span><br><span class="line">	<span class="keyword">int</span> NumHead = <span class="built_in">GetHead</span>(digit);</span><br><span class="line">	<span class="comment">//判断index位数位于哪个数字子序列中</span></span><br><span class="line">	<span class="keyword">int</span> indexInNum = NumHead + index / digit;</span><br><span class="line">	<span class="comment">//判断index位数于indexInNum子序列中相对于右侧的偏移量</span></span><br><span class="line">	<span class="keyword">int</span> offSetRight = digit - index % digit - <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//取终值index数</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; offSetRight; i++) &#123;</span><br><span class="line">		indexInNum /= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> indexInNum % <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetDiditNums</span><span class="params">(<span class="keyword">int</span> digit)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (digit == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">9</span> * (<span class="keyword">int</span>)(<span class="built_in">pow</span>(<span class="number">10</span>, digit - <span class="number">1</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetNum</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="comment">//多测试环境下需复原</span></span><br><span class="line">	isExcption = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//范围筛选位于某位数范围中</span></span><br><span class="line">	<span class="keyword">int</span> digit = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="comment">//从1位数开始锁定n位数字所在的位数范围</span></span><br><span class="line">		<span class="keyword">int</span> digitNums = <span class="built_in">GetDiditNums</span>(digit);</span><br><span class="line">		<span class="keyword">if</span> (index &lt; digitNums * digit) &#123;</span><br><span class="line">			<span class="comment">//锁定n位的数在digit位数范围内</span></span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">GetNumCore</span>(index, digit);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//n位的数不在digit位数的范围内，向下遍历</span></span><br><span class="line">		index -= digitNums * digit;</span><br><span class="line">		digit++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="46-把数组排成最小的数"><a href="#46-把数组排成最小的数" class="headerlink" title="46 把数组排成最小的数"></a>46 把数组排成最小的数</h1><blockquote>
<p>输入一个<strong>正整数数组</strong>,把数组里<strong>所有数字拼接</strong>起来排成一个数,打印能拼接出的所有数字中<strong>最小的一个</strong></p>
</blockquote>
<h2 id="Testing-case-56"><a href="#Testing-case-56" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(数组只有一个数字，含多个数字，数字相同，数字位数相同)</li>
<li>边界测试(nullptr)</li>
</ul>
<h2 id="Key-56"><a href="#Key-56" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>全排列筛选</p>
<blockquote>
<p>将整型数组中的元素进行全排列后求得最小的拼接数</p>
<p><code>注意:</code></p>
<ol>
<li>n个数字的全排列数为 n!</li>
<li>元素在int型的范围内，但是拼接后的元素不一定在int范围内，隐含大数问题，需要使用字符串进行拼接运算并比较大小</li>
</ol>
</blockquote>
</li>
<li><p>“排序”的二维字符数组</p>
<blockquote>
<ol>
<li>将整型数组中的数字元素转存至二维字符数组中</li>
<li>对二维字符数组一维度的每个数字字符串进行排序，按照自定义的字符串比较大小方法</li>
<li>对排序后的二维字符数组按序输出即可</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>考虑到大数问题，由数字字符串的拼接代替整数拼接比较大小进而判断两个数字字符串的排序顺序</li>
<li>sprintf(str, “%d”, intNum);将intNum整数打印成字符串保存于str字符串中</li>
<li>void qsort(    void *base,  size_t nmemb,  size_t size,  int (compare)(const void *, const void *)    ); 将元素大小为size，元素个数为nmemb的base按照compare规则进行排序 T(n) = O(nlogn)</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-54"><a href="#Answer-54" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> isExcption = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置全局拼接数暂存字符串</span></span><br><span class="line"><span class="keyword">int</span> MaxLen = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span>* PlusOne = <span class="keyword">new</span> <span class="keyword">char</span>[MaxLen * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">char</span>* PlusTwo = <span class="keyword">new</span> <span class="keyword">char</span>[MaxLen * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>*, <span class="keyword">const</span> <span class="keyword">void</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SortMinNum</span><span class="params">(<span class="keyword">int</span>*, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较规则</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* strNum1, <span class="keyword">const</span> <span class="keyword">void</span>* strNum2)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//拼接后字符串PlusOne strNum1在前，strNum2在后																				//*(char**)strNum1为取字符串首部取整个字符串而非某个字符</span></span><br><span class="line">	<span class="built_in">strcpy</span>(PlusOne, *(<span class="keyword">char</span>**)strNum1);</span><br><span class="line">	<span class="built_in">strcat</span>(PlusOne, *(<span class="keyword">char</span>**)strNum2);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//拼接后字符串PlusTwo strNum2在前，strNum1在后</span></span><br><span class="line">	<span class="built_in">strcpy</span>(PlusTwo, *(<span class="keyword">char</span>**)strNum2);</span><br><span class="line">	<span class="built_in">strcat</span>(PlusTwo, *(<span class="keyword">char</span>**)strNum1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//若返回值小于0 strNum1在前，大于0 strNum1在后，等于0 无法确定</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strcmp</span>(PlusOne, PlusTwo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SortMinNum</span><span class="params">(<span class="keyword">int</span>* intNum, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (intNum == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将整数数组元素存于二维字符数组中																							//动态创建二维字符数组									</span></span><br><span class="line">	<span class="keyword">char</span>** strNum = <span class="keyword">new</span> <span class="keyword">char</span>* [len];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		strNum[i] = <span class="keyword">new</span> <span class="keyword">char</span>[MaxLen + <span class="number">1</span>];</span><br><span class="line">		<span class="comment">//将整数输入到字符串中</span></span><br><span class="line">		<span class="built_in">sprintf</span>(strNum[i], <span class="string">&quot;%d&quot;</span>, intNum[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//对该二维字符数组进行排序</span></span><br><span class="line">	<span class="built_in">qsort</span>(strNum, len, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>*), Compare);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//输出拼接后的最小数字</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;最小数字:&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		cout &lt;&lt; strNum[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//内存回收</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		<span class="keyword">delete</span>[] strNum[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span> strNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="47-把数字翻译成字符串"><a href="#47-把数字翻译成字符串" class="headerlink" title="47 把数字翻译成字符串"></a>47 把数字翻译成字符串</h1><blockquote>
<p>给定一个数字,我们按照如下规则把它翻译为字符串: 0翻译成“a”, 1翻译成”b”, …, 11翻译成”l”,…., 25翻译成“z”</p>
<p>一个数字可能有多个翻译,请编程实现一个函数,用来计算一个数字有多少种不同的翻译方法</p>
</blockquote>
<h2 id="Testing-case-57"><a href="#Testing-case-57" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试()</li>
<li>边界测试(nullptr)</li>
</ul>
<h2 id="Key-57"><a href="#Key-57" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>自上而下递归</p>
<blockquote>
<ol>
<li>从首元素开始决策当前元素是否与后一个元素拼接</li>
<li>若不拼接，则 count += f(i + 1) </li>
<li>若拼接，则判断是否可拼接</li>
<li>若可拼接且不是倒数第二个元素，count += f(i + 2)，若是倒数第二个元素， count += 1</li>
<li>若不可拼接，则跳过</li>
<li>直至进行最后一个元素的决策，返回1</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li><p>记第i个位置可翻译的字符串数为f(i),则</p>
<p>f(i) = 1 i元素为末尾元素</p>
<p>f(i) = f(i + 1) i元素与i+1元素拼接结果不位于10-25之间</p>
<p>f(i) = f(i + 1) + 1 i元素与i+1元素拼接结果位于10-25之间，但是为倒数第二个元素</p>
<p>f(i) = f(i + 1) + f(i + 2) i元素与i+1元素拼接结果位于10-25之间</p>
</li>
<li><p>递归操作含多次重复操作</p>
</li>
<li><p>使用指针更方便拆分字符串</p>
</li>
</ol>
</blockquote>
</li>
<li><p>自下而上动态规划</p>
<blockquote>
<ol>
<li>从末尾元素计算可翻译的字符串数并记录当前结果</li>
<li>向前遍历，遍历同时计算当前元素作首元素可翻译的字符串数</li>
<li>直至遍历至首元素，得最终数字可翻译的字符串数</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>使用数组记录结果，因为数组角标可对应当前正遍历的元素</li>
<li>判断涉及是否为末尾元素，是否可拼接，若可拼接则该元素是否为倒数第二个元素</li>
<li>to_string(int) 可将一整数转换为字符串</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-55"><a href="#Answer-55" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<p>1.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Concat</span><span class="params">(<span class="keyword">char</span> cnum1, <span class="keyword">char</span> cnum2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> result = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> num1 = cnum1 - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	<span class="keyword">int</span> num2 = cnum2 - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> concat = num1 * <span class="number">10</span> + num2;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (concat &gt;= <span class="number">10</span> &amp;&amp; concat &lt;= <span class="number">25</span>) &#123;</span><br><span class="line">		result = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RecursiveTranslationNums</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">char</span> arr[<span class="number">10</span>];</span><br><span class="line">	<span class="built_in">sprintf</span>(arr, <span class="string">&quot;%d&quot;</span>, num);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">RecursiveTranslationNumsCore</span>(arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RecursiveTranslationNumsCore</span><span class="params">(<span class="keyword">char</span>* num)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//base case</span></span><br><span class="line">	<span class="keyword">if</span> ((*(num + <span class="number">1</span>)) == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//当前元素不与后一个元素组合</span></span><br><span class="line">	count += <span class="built_in">RecursiveTranslationNumsCore</span>(num + <span class="number">1</span>);</span><br><span class="line">	<span class="comment">//当前元素与后一个元素组合</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">Concat</span>(*num, *(num + <span class="number">1</span>))) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((*(num + <span class="number">2</span>)) != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">			count += <span class="built_in">RecursiveTranslationNumsCore</span>(num + <span class="number">2</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			count += <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Concat</span><span class="params">(<span class="keyword">char</span> cnum1, <span class="keyword">char</span> cnum2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> result = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> num1 = cnum1 - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	<span class="keyword">int</span> num2 = cnum2 - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> concat = num1 * <span class="number">10</span> + num2;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (concat &gt;= <span class="number">10</span> &amp;&amp; concat &lt;= <span class="number">25</span>) &#123;</span><br><span class="line">		result = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TranslationNums</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	string n = <span class="built_in">to_string</span>(num);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">TranslationNumsCore</span>(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TranslationNumsCore</span><span class="params">(<span class="keyword">const</span> string&amp; num)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//设置记录各个位置起可翻译的字符串数结果，避免重复计算</span></span><br><span class="line">	<span class="keyword">int</span>* counts = <span class="keyword">new</span> <span class="keyword">int</span>[num.<span class="built_in">length</span>()];</span><br><span class="line">	<span class="comment">//设置记录从当前位置元素开始的可翻译字符串数</span></span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从后向前遍历字符串，直至计算出第一个位置起的可翻译字符串数</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = num.<span class="built_in">length</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="comment">//清零，计算当前位置作起始位置的可翻译字符串数</span></span><br><span class="line">		count = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//若当前元素为末尾元素，则只能翻译1种字符串</span></span><br><span class="line">		<span class="keyword">if</span> (i == num.<span class="built_in">length</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">			count += <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//否则当前元素作起始位置的可翻译字符串数等于下一个位置的结果</span></span><br><span class="line">			count += counts[i + <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (i != num.<span class="built_in">length</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="comment">//若不为末尾元素，判断当前元素能否与后一个元素拼接</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">Concat</span>(num[i], num[i + <span class="number">1</span>])) &#123;</span><br><span class="line">				<span class="comment">//若可拼接但是当前元素为倒数第二个元素，则可翻译字符串数增1</span></span><br><span class="line">				<span class="keyword">if</span> (i == num.<span class="built_in">length</span>() - <span class="number">2</span>) &#123;</span><br><span class="line">					count += <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					count += counts[i + <span class="number">2</span>];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		counts[i] = count;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//释放内存</span></span><br><span class="line">	<span class="keyword">delete</span>[] counts;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="48-礼物的最大价值"><a href="#48-礼物的最大价值" class="headerlink" title="48 礼物的最大价值"></a>48 礼物的最大价值</h1><blockquote>
<p>在一个m×n的棋盘的每一格都放有一个礼物,每个礼物都有一定的价值(价值大于0),你可以从棋盘的左上角开始拿格子里的礼物,并每次向左或者向下移动一格,直到到达棋盘的右下角</p>
<p>给定一个棋盘及其上面的礼物,请计算你最多能拿到多少价值的礼物?</p>
</blockquote>
<h2 id="Testing-case-58"><a href="#Testing-case-58" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(多行多列矩阵，一行/列矩阵，只有一个数字的矩阵)</li>
<li>边界测试(nullptr)</li>
</ul>
<h2 id="Key-58"><a href="#Key-58" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>决策树 + 递归</p>
<blockquote>
<ol>
<li>从首元素开始进行决策，向下or向右</li>
<li>先进行向下的决策后对下方元素继续递归决策</li>
<li>后进行向右的决策后对友方元素继续递归决策</li>
<li>在作另一决策之前需要将当前决策恢复后再进行决策，但是注意恢复的位置</li>
<li>直至进行右下角元素的决策</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>从左上角开始，找寻所有至有右下角的路径，并记录路径上的礼物价值，打擂求解并使用全局变量记录</li>
<li>二维数组中的起点确定的各元素路径遍历的边界值问题，若边界选取不当并未作处理，将导致边界值的重复决策</li>
<li>注意对边界只能作一种决策的处理，此处统一处理，末尾元素单独处理</li>
<li>恢复的位置若位于2,3之间，则在作出另一决策前，当前正作出决策的结点将被弹出，因此应该置于3之后，仅弹出左决策结点而非本身</li>
</ol>
</blockquote>
</li>
<li><p>递归公式 + 递归</p>
<blockquote>
<ol>
<li>从右下角开始套用公式递归计算返回结果</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li><p>记(i,j)位置处礼物的最大价值为f(i,j),(i,j)位置处礼物的价值为gift(i,j)</p>
<p>f(i,j) = max(f(i-1,j),f(i,j-1)) + gift(i,j) , i!=0 &amp;&amp; j!=0 </p>
<p>f(i,j) = f(i-1,j)+ gift(i,j) , j=0</p>
<p>f(i,j) = f(i,j-1)+ gift(i,j) , i=0</p>
<p>f(i,j) = gift(i,j) , i=j=0</p>
</li>
</ol>
</blockquote>
</li>
<li><p>动态规划 + 迭代计算</p>
<blockquote>
<ol>
<li>自左上角开始遍历整个礼物矩阵，计算每个位置的礼物最大价值</li>
<li>分别使用left,up记录当前位置的左边与上边的礼物最大价值</li>
<li>取max(left,up) + gift(i,j) 作为当前位置处的礼物最大价值</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>使用二维数组记录相应位置处的礼物最大价值</li>
<li>left,up初始化为0，考虑边界情况，需每次判断是否位于某个边界</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-56"><a href="#Answer-56" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<p>1.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> isExcption = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> MaxGift = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxValueOfGift</span><span class="params">(<span class="keyword">int</span>**, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MaxValueOfGiftCore</span><span class="params">(<span class="keyword">int</span>**, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxValueOfGift</span><span class="params">(<span class="keyword">int</span>** arr, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="literal">nullptr</span> || rows &lt;= <span class="number">0</span> || cols &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; Gift;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">MaxValueOfGiftCore</span>(arr, <span class="number">0</span>, <span class="number">0</span>, rows, cols, Gift);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> MaxGift;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MaxValueOfGiftCore</span><span class="params">(<span class="keyword">int</span>** gift, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, vector&lt;<span class="keyword">int</span>&gt;&amp; Gift)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//base case</span></span><br><span class="line">	<span class="keyword">if</span> (row == rows - <span class="number">1</span> &amp;&amp; col == cols - <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">		Gift.<span class="built_in">push_back</span>(gift[row][col]);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> i : Gift) &#123;</span><br><span class="line">			cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">			sum += i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (sum &gt;= MaxGift) &#123;</span><br><span class="line">			MaxGift = sum;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;max = &quot;</span> &lt;&lt; MaxGift;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (Gift.<span class="built_in">size</span>() != <span class="number">0</span>)</span><br><span class="line">			Gift.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将从左上角至右下角的一条路径经过的所有礼物进行记录</span></span><br><span class="line">	<span class="comment">//防止边界元素的重复压入</span></span><br><span class="line"></span><br><span class="line">	Gift.<span class="built_in">push_back</span>(gift[row][col]);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//向下移动</span></span><br><span class="line">	<span class="keyword">if</span> (row &lt; rows - <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">//down = false;</span></span><br><span class="line">		<span class="built_in">MaxValueOfGiftCore</span>(gift, row + <span class="number">1</span>, col, rows, cols, Gift);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//向右移动</span></span><br><span class="line">	<span class="keyword">if</span> (col &lt; cols - <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">//right = false;</span></span><br><span class="line">		<span class="built_in">MaxValueOfGiftCore</span>(gift, row, col + <span class="number">1</span>, rows, cols, Gift);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//恢复</span></span><br><span class="line">	<span class="keyword">if</span> (Gift.<span class="built_in">size</span>() != <span class="number">0</span>)</span><br><span class="line">		Gift.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxValueOfGiftByFunc</span><span class="params">(<span class="keyword">int</span>** arr, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="literal">nullptr</span> || rows &lt;= <span class="number">0</span> || cols &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> max = <span class="built_in">MaxValueOfGiftCoreByFunc</span>(arr, rows - <span class="number">1</span>, cols - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxValueOfGiftCoreByFunc</span><span class="params">(<span class="keyword">int</span>** gift, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//base case</span></span><br><span class="line">	<span class="keyword">if</span> (row == <span class="number">0</span> &amp;&amp; col == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> gift[row][col];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (row == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">MaxValueOfGiftCoreByFunc</span>(gift, row, col - <span class="number">1</span>) + gift[row][col];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (col == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">MaxValueOfGiftCoreByFunc</span>(gift, row - <span class="number">1</span>, col) + gift[row][col];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">MaxValueOfGiftCoreByFunc</span>(gift, row - <span class="number">1</span>, col), <span class="built_in">MaxValueOfGiftCoreByFunc</span>(gift, row, col - <span class="number">1</span>)) + gift[row][col];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxValueOfGift</span><span class="params">(<span class="keyword">int</span>** gift, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (gift == <span class="literal">nullptr</span> || rows &lt;= <span class="number">0</span> || cols &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//辅助二维数组记录各个位置处的礼物最大价值</span></span><br><span class="line">	<span class="keyword">int</span>** MaxValue = <span class="keyword">new</span> <span class="keyword">int</span>*[rows];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">		MaxValue[i] = <span class="keyword">new</span> <span class="keyword">int</span>[cols];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//自左上角开始遍历，计算各个位置处的礼物最大价值</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//设置记录当前位置左边与上边礼物最大价值的变量</span></span><br><span class="line">			<span class="keyword">int</span> up = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">				up = MaxValue[i - <span class="number">1</span>][j];</span><br><span class="line">			<span class="keyword">if</span> (j &gt; <span class="number">0</span>)</span><br><span class="line">				left = MaxValue[i][j - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">			<span class="comment">//设置当前位置的礼物最大价值</span></span><br><span class="line">			MaxValue[i][j] = <span class="built_in">max</span>(up, left) + gift[i][j];</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> max = MaxValue[rows - <span class="number">1</span>][cols - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//释放内存</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">		<span class="keyword">delete</span>[] MaxValue[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span>[] MaxValue;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="49-最长不含重复字符的子字符串"><a href="#49-最长不含重复字符的子字符串" class="headerlink" title="49 最长不含重复字符的子字符串"></a>49 最长不含重复字符的子字符串</h1><blockquote>
<p>请从字符串中找出一个最长的不包含重复字符的子字符串,计算该最长子字符串的长度</p>
<p>假设字符串中只包含a~z的字符</p>
</blockquote>
<h2 id="Testing-case-59"><a href="#Testing-case-59" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(字符串含多个字符，字符均相同，仅含一个字符)</li>
<li>边界测试(字符串为空)</li>
</ul>
<h2 id="Key-59"><a href="#Key-59" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>暴力求解 T(n) = O(n3)</p>
<blockquote>
<ol>
<li>求解字符串的所有连续的子字符串 O(n2)</li>
<li>在所有子字符串中找寻并记录最长不含重复字符的子字符串 O(n)</li>
</ol>
</blockquote>
</li>
<li><p>动态规划 + 正向迭代</p>
<blockquote>
<ol>
<li>自首部开始遍历字符串，计算以 i(0,1..str.length()) 处元素作尾部元素时的最长不含重复字符的子字符串</li>
<li>每次遍历记录当前以i为末尾不含重复字符的子字符串的长度，并记录当前元素本次在str中出现的位置</li>
<li>当currentSubLen发生截断前打擂判断maxSum</li>
<li>直至 i=str.length()，最后打擂判断maxSum</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li><p>最长不含重复字符的子字符串为连续的字符串</p>
</li>
<li><p>入手点在于分析i处元素作该连续字符串末尾时的最长长度，i取值由 0-&gt;str.length() 即可得出当前长度的字符串的最长不含重复字符的子字符串</p>
</li>
<li><p>记f(i)为i处元素作该连续字符串末尾时的最长长度，则</p>
<p>f(i) = f(i-1) + 1 , f(i-1)对应的子字符串中不含i处元素(LastAppear[index] &lt; 0 || distance &gt; currentSubLen)</p>
<p>f(i) = distance , 对应的子字符串中含i处元素</p>
<p>distance为截断i处元素上一次出现位置到i所包含的所有元素</p>
</li>
<li><p>使用 currentSubLen 来记录 f(i-1)</p>
</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-57"><a href="#Answer-57" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> isExcption = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LongestSubstrWithoutDuplication</span><span class="params">(<span class="keyword">const</span> string&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LongestSubstrWithoutDuplication</span><span class="params">(<span class="keyword">const</span> string&amp; str)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (str.<span class="built_in">length</span>() == <span class="number">0</span> ) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置LastAppear数组记录&#x27;a&#x27;-&#x27;z&#x27;字符上一次在字符串中出现的位置，若当前未出现，则为-1</span></span><br><span class="line">	<span class="keyword">int</span>* LastAppear = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">		LastAppear[i] = <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置currentSum存储f(i-1)的值</span></span><br><span class="line">	<span class="keyword">int</span> currentSubLen = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//设置maxSum打擂存储最长字符串</span></span><br><span class="line">	<span class="keyword">int</span> maxSum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//自前向后求得目前第i个元素作满足要求的子字符串末尾时的最长长度</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">		<span class="comment">//判断当前元素是否位于f(i-1)对应的子字符串中</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//获取当前遍历元素在LastAppear数组中的映射关系,从而获取当前元素上次在str中出现的位置</span></span><br><span class="line">		<span class="keyword">int</span> index = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		<span class="comment">//获取当前元素与上一次出现位置的差值</span></span><br><span class="line">		<span class="keyword">int</span> distance;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(LastAppear[index] &gt;= <span class="number">0</span>)</span><br><span class="line">			distance = i - LastAppear[index];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (LastAppear[index] &lt; <span class="number">0</span> || distance &gt; currentSubLen) &#123;</span><br><span class="line">			<span class="comment">//若之前最长子字符串中不含当前位置字符，则子字符串长度增1</span></span><br><span class="line">			currentSubLen += <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//若之前最长子字符串中含当前位置字符，则存在重复，需要截断上一次出现位置以及之前的元素</span></span><br><span class="line">			<span class="comment">//此时maxSum才需要更新</span></span><br><span class="line">			<span class="keyword">if</span> (currentSubLen &gt;= maxSum) &#123;</span><br><span class="line">				maxSum = currentSubLen;</span><br><span class="line">			&#125;</span><br><span class="line">			currentSubLen = distance;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//记录当前元素本次在str出现的位置</span></span><br><span class="line">		LastAppear[index] = i;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//最后更新maxSum，记录最长不含重复字符的子字符串</span></span><br><span class="line">	<span class="keyword">if</span> (currentSubLen &gt;= maxSum) &#123;</span><br><span class="line">		maxSum = currentSubLen;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//清理内存</span></span><br><span class="line">	<span class="keyword">delete</span>[] LastAppear;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="—-动态规划-—"><a href="#—-动态规划-—" class="headerlink" title="—- 动态规划 —-"></a>—- 动态规划 —-</h1><ul>
<li>求解某个问题的最优解(最大，最小，最多有…)</li>
<li>某个问题可划分为多个子问题</li>
<li>多个子问题有相互重叠的更小的子问题</li>
<li>自上而下递归分析问题，自下而上迭代解决问题(记录上次结果)</li>
</ul>
<h1 id="50-丑数"><a href="#50-丑数" class="headerlink" title="50 丑数"></a>50 丑数</h1><blockquote>
<p>我们把只包含因子2、3和5的数称作丑数(Ugly Number)</p>
<p>求1按从小到大的顺序的第1500个丑数</p>
<p>我们把1当作第一个丑数。</p>
</blockquote>
<h2 id="Testing-case-60"><a href="#Testing-case-60" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(2,3,4,5,6)</li>
<li>边界测试(1,0)</li>
<li>性能测试(1500)</li>
</ul>
<h2 id="Key-60"><a href="#Key-60" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>暴力遍历所有数</p>
<blockquote>
<ol>
<li>从1开始遍历所有正整数，并判断是否为丑数</li>
<li>若为丑数则丑数计数器增1</li>
<li>直至找到第1500个丑数</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>若一个数为丑数，则其将2,3,5因子均除尽之后值为1.</li>
<li>需要遍历第1500个丑数之前的所有数字</li>
</ol>
</blockquote>
</li>
<li><p>使用数组仅记录所有丑数</p>
<blockquote>
<ol>
<li>使用一个数组递增有序记录前num个丑数</li>
<li>设置三个标志指针分别记录第一个 ×2，×3，×5 大于目前最大丑数的丑数元素，初始化为数组首元素</li>
<li>取min(*Multiply2 * 2, *Multiply3 * 3, *Multiply5 * 5),作为下一个丑数</li>
<li>更新三个标志指针指向</li>
<li>向下遍历，直至丑数数组元素满num个，即得出第num个丑数</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>使用大小为num的数组递增有序存放所有丑数，最后一个元素即为第num个丑数</li>
<li>一个丑数一定由之前某丑数乘某个因子(2,3,5)得之,1除外</li>
<li>为使数组有序，需要三个指针分别记录第一个 ×2，×3，×5 大于目前最大丑数的丑数元素</li>
<li>使用丑数数组记录前num个丑数可省去记录其余无关整数，但是增加了空间消耗</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-58"><a href="#Answer-58" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<p>1.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isUglyNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//丑数只含有2,3,5因子，将每个因子除尽若为1则为丑数</span></span><br><span class="line">	<span class="keyword">while</span> (num % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">		num /= <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (num % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">		num /= <span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (num % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">		num /= <span class="number">5</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getUglyNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (num &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//记录当前数字与丑数</span></span><br><span class="line">	<span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> uglyNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (uglyNum &lt; num) &#123;</span><br><span class="line">		<span class="comment">//遍历自1开始的数字</span></span><br><span class="line">		number++;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">isUglyNum</span>(number)) &#123;</span><br><span class="line">			uglyNum++;</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">(<span class="keyword">int</span> n1, <span class="keyword">int</span> n2, <span class="keyword">int</span> n3)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> min;</span><br><span class="line">	<span class="keyword">if</span> (n1 &lt; n2) &#123;</span><br><span class="line">		min = n1;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		min = n2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (n3 &lt; min) &#123;</span><br><span class="line">		min = n3;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getUglyNum2</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (num &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置由小到大排序的丑数数组</span></span><br><span class="line">	<span class="keyword">int</span>* Ugly = <span class="keyword">new</span> <span class="keyword">int</span>[num];</span><br><span class="line">	Ugly[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//三个标志指针，分别指向第一个 ×2，×3，×5 大于目前最大丑数的丑数元素</span></span><br><span class="line">	<span class="keyword">int</span>* Multiply2 = Ugly;</span><br><span class="line">	<span class="keyword">int</span>* Multiply3 = Ugly;</span><br><span class="line">	<span class="keyword">int</span>* Multiply5 = Ugly;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置指向下一个丑数的角标标志,用于遍历记录前num个丑数</span></span><br><span class="line">	<span class="keyword">int</span> pNextUgly = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (pNextUgly &lt; num) &#123;</span><br><span class="line">		<span class="comment">//获取当前最大丑数</span></span><br><span class="line">		<span class="keyword">int</span> min = <span class="built_in">getMin</span>(*Multiply2 * <span class="number">2</span>, *Multiply3 * <span class="number">3</span>, *Multiply5 * <span class="number">5</span>);</span><br><span class="line">		Ugly[pNextUgly] = min;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//重新定位三个标志指针,使分别指向第一个 ×2，×3，×5 大于目前最大丑数的丑数元素</span></span><br><span class="line">		<span class="comment">//分别×2，×3，×5 小于等于目前最大丑数的丑数元素一定已经位于丑数数组中</span></span><br><span class="line">		<span class="keyword">while</span> (*Multiply2 * <span class="number">2</span> &lt;= min) &#123;</span><br><span class="line">			Multiply2++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (*Multiply3 * <span class="number">3</span> &lt;= min) &#123;</span><br><span class="line">			Multiply3++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (*Multiply5 * <span class="number">5</span> &lt;= min) &#123;</span><br><span class="line">			Multiply5++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//向下遍历，直至丑数数组元素满num个，即得出第num个丑数</span></span><br><span class="line">		pNextUgly++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> uglyNum = Ugly[pNextUgly - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//清理内存</span></span><br><span class="line">	<span class="keyword">delete</span>[] Ugly;</span><br><span class="line">	Ugly = <span class="literal">nullptr</span>;</span><br><span class="line">	Multiply2 = <span class="literal">nullptr</span>;</span><br><span class="line">	Multiply3 = <span class="literal">nullptr</span>;</span><br><span class="line">	Multiply5 = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> uglyNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="51-第一次只出现一次的字符"><a href="#51-第一次只出现一次的字符" class="headerlink" title="51 第一次只出现一次的字符"></a>51 第一次只出现一次的字符</h1><blockquote>
<p>字符串中第一个只出现一次的字符</p>
</blockquote>
<h2 id="Testing-case-61"><a href="#Testing-case-61" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(字符串中有/无只出现一次的字符，字符串中所有字符均只出现一次)</li>
<li>边界测试(nullptr)</li>
</ul>
<h2 id="Key-61"><a href="#Key-61" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>哈希表 T(n) = O(n) S(n) = O(1) 1KB</p>
<blockquote>
<ol>
<li>第一遍历字符串根据字符串ascll码值在哈希表对应位置处记录其出现次数</li>
<li>恢复遍历字符串的指针，使其重新指向字符串首部</li>
<li>第二次遍历字符串根据哈希表中的出现次数返回第一次只出现一次的字符</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>哈希表可使用map或者unordered_map形成 字符-次数 键值对,哈希表存256个元素，共占用256*4=1024 1KB内存</li>
<li>此处考虑 ascll码 映射其在数组中的存放位置，形成简易哈希表</li>
<li>两次遍历使用同一个遍历指针，注意第二次使用该指针时需要还原位置</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-59"><a href="#Answer-59" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> isExcption = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">FirstNotRepeatChar</span><span class="params">(<span class="keyword">char</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">FirstNotRepeatChar</span><span class="params">(<span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (str == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//字符1byte 8bit 256中状态 256中不同字符表示</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> Allchar = <span class="number">256</span>;</span><br><span class="line">	<span class="comment">//设置大小为256的哈希表，使用取字符的ascll码值作哈希函数</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> hash[Allchar];</span><br><span class="line">	<span class="comment">//设置哈希表初值为0以便记录次数</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Allchar; i++) &#123;</span><br><span class="line">		hash[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//设置遍历字符串的指针</span></span><br><span class="line">	<span class="keyword">char</span>* pCur = str;</span><br><span class="line">	<span class="comment">//第一次遍历字符串记录各字符出现的次数并映射到哈希表的相应位置</span></span><br><span class="line">	<span class="keyword">while</span> (*pCur != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">		hash[*pCur]++;</span><br><span class="line">		pCur++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//第二次遍历前需要将遍历指针还原</span></span><br><span class="line">	pCur = str;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//第二次遍历字符串找寻第一个只出现一次的字符</span></span><br><span class="line">	<span class="keyword">while</span> (*pCur != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (hash[*pCur] == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> *pCur;</span><br><span class="line">		&#125;</span><br><span class="line">		pCur++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//若执行至此处说明无只出现一次的字符</span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="51-2-哈希表应用拓展"><a href="#51-2-哈希表应用拓展" class="headerlink" title="51.2 哈希表应用拓展"></a>51.2 哈希表应用拓展</h1><ul>
<li><p>定义两个字符串，在第一个字符串中删除第二个字符串中出现过的所有元素</p>
<blockquote>
<ol>
<li>遍历第二个字符串，并建立一个哈希表记录第二个字符串中的元素出现状态 键值对为 字符-bool</li>
<li>遍历第一个字符串，根据字符映射对应哈希表判断当前字符是否应该删除</li>
</ol>
</blockquote>
</li>
<li><p>定义一个函数删除字符串中重复出现的字符</p>
<blockquote>
<ol>
<li>遍历该字符串，并建立哈希表记录元素的出现状态</li>
<li>若 字符-bool bool为fasle，则将该值设置为true</li>
<li>若 字符-bool bool为true，则表明该字符之前已经出现过，删除该字符</li>
</ol>
</blockquote>
</li>
<li><p>英语单词的变位词，两个词中出现的字母相同，且各字母的出现次数相同</p>
<blockquote>
<ol>
<li>遍历其中一个英语单词，并建立一个哈希表记录字符的出现次数 键值对为 字符-num</li>
<li>遍历另一个英语单词，并将相应的哈希表中的值减1</li>
<li>若遍历完后，哈希表中各值均为0，则表明这两个词互为变位词</li>
</ol>
</blockquote>
</li>
</ul>
<h1 id="51-3-字符流中只出现一次的字符"><a href="#51-3-字符流中只出现一次的字符" class="headerlink" title="51.3 字符流中只出现一次的字符"></a>51.3 字符流中只出现一次的字符</h1><blockquote>
<p>字符流中第一个只出现一次的字符</p>
<p>请实现一个函数,用来找出字符流中第一个只出现一次的字符</p>
<p>例如,当从字符流中只读出前两个字符”go”时,第一个只出现一次的字符是g:当从该字符流中读出前6个字符”google”时,第一个只出现一次的字符是1。</p>
</blockquote>
<h2 id="Testing-case-62"><a href="#Testing-case-62" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(字符串中有/无只出现一次的字符，字符串中所有字符均只出现一次)</li>
<li>边界测试(nullptr)</li>
</ul>
<h2 id="Key-62"><a href="#Key-62" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>哈希表</p>
<blockquote>
<p><strong>插入元素</strong></p>
<ol>
<li>每插(输)入一个字符，则根据字符ascll码值判断对应哈希表的值是否为-1</li>
<li>若为-1，表明该字符为首次出现，将该字符的在字符流中的位置index值写入哈希表对应位置,然后index++，表明下一个字符在字符流中的位置</li>
<li>若&gt;=0，则表明该字符已经出现一次，将该字符的对应哈希表位置处的值设置为非法值-2，表明不可能为要求字符,然后index++，表明下一个字符在字符流中的位置</li>
<li>若为非法值，则仅需index++即可</li>
</ol>
<p><strong>获取要求字符</strong></p>
<ol>
<li><p>从头遍历整个哈希表，判断键值对对应值的状态</p>
<p>若&gt;=0，则表明该字符在字符流中仅出现了一次，但是无法确保为第一个字符，进而通过打擂判断其index是否为最小的index</p>
</li>
<li><p>遍历完后，最小index对应的键标识的字符即为最小字符</p>
</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>字符流区别于字符数组的点在于字符流无法遍历，因此需要有介质存放字符在字符流中的位置</li>
<li>仅仅通过遍历哈希表(记录字符出现次数)无法保证值为1的字符是第一次出现</li>
<li>因此哈希表中 键值对 值应存放字符在字符流中的位置索引，若重复出现，则值为非法值，标志该字符不可能为要求字符</li>
<li>对于流的操作考虑使用类来模拟流的输入并实时更新状态与获取状态</li>
<li>numeric_limits<int>::max() 可获取int类型中最大的int型数</int></li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-60"><a href="#Answer-60" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CharStatics</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CharStatics</span>():<span class="built_in">index</span>(<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Allchar; i++) &#123;</span><br><span class="line">			hash[i] = <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (hash[ch] == <span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="comment">//当前字符仅出现了一次，因此键值对值存放其在字符流中的位置</span></span><br><span class="line">			hash[ch] = index;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (hash[ch] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">//当前字符已经在字符流中出现了一次，因此当前元素不可能为要求元素,将值设置为-2标识</span></span><br><span class="line">			hash[ch] = <span class="number">-2</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//若当前字符已经重复出现了多次，则仅需更新index</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//index++用于标识下一个元素在字符流中的位置</span></span><br><span class="line">		index++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">char</span> <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//Front记录字符在字符流中出现的位置，初始化为int中的最大值</span></span><br><span class="line">		<span class="keyword">int</span> min = numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//minChar记录最小字符</span></span><br><span class="line">		<span class="keyword">char</span> minChar = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Allchar; i++) &#123;</span><br><span class="line">			<span class="comment">//因为哈希表中为元素顺序不代表在字符流中出现顺序，因此需要遍历整个哈希表，根据index记得位置判断是否靠前</span></span><br><span class="line">			<span class="keyword">if</span> (hash[i] &gt;= <span class="number">0</span> &amp;&amp; hash[i] &lt;= min) &#123;</span><br><span class="line">				minChar = (<span class="keyword">char</span>)i;</span><br><span class="line">				min = hash[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> minChar;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//哈希表，记录字符流中字符出现的次数</span></span><br><span class="line">	<span class="keyword">int</span> hash[Allchar];</span><br><span class="line">	<span class="comment">//记录当前字符流中字符在字符流中的位置</span></span><br><span class="line">	<span class="keyword">int</span> index;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="52-数组中的逆序对"><a href="#52-数组中的逆序对" class="headerlink" title="52 数组中的逆序对"></a>52 数组中的逆序对</h1><blockquote>
<p>在数组中的两个数字,如果前面一个数字大于后面的数字,则这两个数字组成一个逆序对</p>
<p>输入一个数组,求出这个数组中的逆序对的总数</p>
<p>例如,在数组7, 5, 6, 4中,一共存在5个逆序对,分别是(7, 6)(7, 5), (7, 4), (6, 4)和(5, 4)</p>
</blockquote>
<h2 id="Testing-case-63"><a href="#Testing-case-63" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(未经排序的数组，递增排序的数组，递减排序的数组，输入的数组包含重复数字)</li>
<li>边界测试(nullptr，只有两个数字，只有一个数字)</li>
</ul>
<h2 id="Key-63"><a href="#Key-63" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>暴力遍历 T(n) = O(n2)</p>
<blockquote>
<ol>
<li>从头遍历数组，将当前元素与后续O(n)元素进行比较计算含当前元素的逆序对数</li>
<li>直至遍历完数组，数组所有逆序数计算完毕</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>暴力遍历，时间效率低</li>
</ol>
</blockquote>
</li>
<li><p>归并划分 T(n) = (nlogn) S(n) = O(n)</p>
<blockquote>
<ol>
<li><p>基于归并排序对数组进行划分</p>
</li>
<li><p>计算左子数组中的逆序数</p>
</li>
<li><p>计算右子数组中的逆序数</p>
</li>
<li><p>设置三个指针和一个暂存数组，在递增有序的基础上，自左右子数组末位开始判断</p>
<p>若data[Lend] &gt; data[Rend]，将大者写入暂存数组，并将相应指针前移，此时data[Lend]的逆序数为data[Rend]以及之前所有元素个数</p>
<p>若data[Lend] &lt;= data[Rend]，将大者写入暂存数组，并将相应指针前移，此时无逆序数产生</p>
</li>
<li><p>将剩余未存入暂存数组中的元素进行判断并存入</p>
</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li><p>在进行相邻子数组逆序数判断时，如何保证判断完逆序数后的两个子数组递增有序</p>
<p>进行子数组逆序数计算时，copy与data参数不断对调，使下一次相邻子数组逆序数的计算基于两者中有序的一方</p>
</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-61"><a href="#Answer-61" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InversePair</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//判断异常</span></span><br><span class="line">		<span class="keyword">if</span> (data == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">			isExcption = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//设置辅助暂存数组,并初始化为arr</span></span><br><span class="line">		<span class="keyword">int</span>* copy = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">			copy[i] = data[i];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> count = <span class="built_in">InversePairCore</span>(data, copy, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//清理内存</span></span><br><span class="line">		<span class="keyword">delete</span>[] copy;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">InversePairCore</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span>* copy, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//base case</span></span><br><span class="line">		<span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">			<span class="comment">//递归终止条件为划分至仅有一个元素,此时子数组的逆序数为0																		//保证数组有序，将值存入暂存数组</span></span><br><span class="line">			copy[start] = data[start];</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//设置划分界限,对半划分</span></span><br><span class="line">		<span class="keyword">int</span> len = (end - start) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//获取左子数组中的逆序数</span></span><br><span class="line">		<span class="keyword">int</span> left = <span class="built_in">InversePairCore</span>(copy, data, start, start + len);</span><br><span class="line">		<span class="comment">//获取右子数组中的逆序数</span></span><br><span class="line">		<span class="keyword">int</span> right = <span class="built_in">InversePairCore</span>(copy, data, start + len + <span class="number">1</span>, end);</span><br><span class="line">		<span class="comment">//获取左右子数组合并后的逆序数</span></span><br><span class="line">		<span class="keyword">int</span> inNum = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//设置三个指针，分别指向左右与合并后子数组的末位</span></span><br><span class="line">		<span class="keyword">int</span> Lend = start + len;</span><br><span class="line">		<span class="keyword">int</span> Rend = end;</span><br><span class="line">		<span class="keyword">int</span> Mend = end;</span><br><span class="line">		<span class="comment">//从后向前遍历左右子数组所有元素进行合并</span></span><br><span class="line">		<span class="keyword">while</span> (Lend &gt;= start &amp;&amp; Rend &gt;= start + len + <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (data[Lend] &gt; data[Rend]) &#123;</span><br><span class="line">				<span class="comment">//若左子数组的末位元素大于右子树组的末位元素，将大者写入暂存数组</span></span><br><span class="line">				copy[Mend] = data[Lend];</span><br><span class="line">				<span class="comment">//并将相应指针前移</span></span><br><span class="line">				Mend--;</span><br><span class="line">				Lend--;</span><br><span class="line">				<span class="comment">//根据右子数组末位元素位置计算此时逆序数</span></span><br><span class="line">				inNum += Rend - start - len;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="comment">//若左子数组的末位元素小于等于右子树组的末位元素，将大者写入暂存数组</span></span><br><span class="line">				<span class="comment">//此时不构成逆序数</span></span><br><span class="line">				<span class="comment">//并将相应指针前移			</span></span><br><span class="line">				copy[Mend] = data[Rend];</span><br><span class="line">				Mend--;</span><br><span class="line">				Rend--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//定有一个子数组率先存入暂存数组，此时将另一数组元素按序存入暂存数组</span></span><br><span class="line">		<span class="keyword">while</span> (Lend &gt;= start) &#123;</span><br><span class="line">			copy[Mend] = data[Lend];</span><br><span class="line">			Mend--;</span><br><span class="line">			Lend--;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (Rend &gt;= start + len + <span class="number">1</span>) &#123;</span><br><span class="line">			copy[Mend] = data[Rend];</span><br><span class="line">			Mend--;</span><br><span class="line">			Rend--;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> left + right + inNum;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="53-在排序数组中查找数字"><a href="#53-在排序数组中查找数字" class="headerlink" title="53 在排序数组中查找数字"></a>53 在排序数组中查找数字</h1><blockquote>
<p>统计一个数字在排序数组中出现的次数</p>
</blockquote>
<h2 id="Testing-case-64"><a href="#Testing-case-64" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(数组中存在/不存在要查找的数字，要查找的数字出现多次/一次)</li>
<li>边界测试(nullptr，数组中只有一个数字，查找的值为数组最大/最小值)</li>
</ul>
<h2 id="Key-64"><a href="#Key-64" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>暴力遍历 T(n) = O(n)</p>
<blockquote>
<p>遍历数组，若当前元素与待查找数字相同，则计数变量增1</p>
</blockquote>
</li>
<li><p>二分查找 T(n) = O(logn)</p>
<blockquote>
<p><strong>获取基于二分查找的k第一次出现的位置</strong></p>
<ol>
<li><p>若mid值与待查找数字相同，则判断是否为第一次出现，若为第一次出现，返回该元素</p>
<p>首元素 / 非首元素且该元素之前的元素不是待查找数字 mid == 0 || (mid &gt; 0 &amp;&amp; data[mid - 1] != k)</p>
</li>
<li><p>若mid值与待查找数字相同，但不是第一次出现，则在其前子数组中继续查找第一次出现的位置</p>
</li>
<li><p>若mid值与待查找数字不相同，则在子数组中继续查询(二分思路略)</p>
</li>
</ol>
<p><strong>获取基于二分查找的k最后一次出现的位置</strong></p>
<ol start="4">
<li><p>若mid值与待查找数字相同，则判断是否为最后一次出现，若为最后一次出现，返回该元素</p>
<p>尾元素 / 非尾元素且该元素之后的元素不是待查找数字 mid == len - 1 || ((mid &lt; (len - 1)) &amp;&amp; data[mid + 1] != k)</p>
</li>
<li><p>若mid值与待查找数字相同，但不是最后一次出现，则在其后子数组中继续查找最后一次出现的位置</p>
</li>
<li><p>若mid值与待查找数字不相同，则在子数组中继续查询(二分思路略)</p>
</li>
<li><p>最后基于两个位置的差值返回数字在排序数组中出现的次数</p>
</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>利用二分查找查找数字在数组中第一次和最后一次出现的位置，即可省去遍历所有数字，利用差值计算数字出现次数</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-62"><a href="#Answer-62" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetNumOfK</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> length, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断异常</span></span><br><span class="line">	<span class="keyword">if</span> (data == <span class="literal">nullptr</span> || length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取基于二分查找的k第一次出现的位置</span></span><br><span class="line">	<span class="keyword">int</span> first = <span class="built_in">GetFirstK</span>(data, length, k, <span class="number">0</span>, length - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> last = <span class="built_in">GetLastK</span>(data, length, k, <span class="number">0</span>, length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (first != <span class="number">-1</span> &amp;&amp; last != <span class="number">-1</span>) &#123;</span><br><span class="line">		num = last - first + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> num;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetFirstK</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> len, <span class="keyword">int</span> k, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//base case</span></span><br><span class="line">	<span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span> (data[mid] == k) &#123;</span><br><span class="line">		<span class="comment">//若当前中值等于k，判断该值是否为第一个值为k的元素</span></span><br><span class="line">		<span class="keyword">if</span> (mid == <span class="number">0</span> || (mid &gt; <span class="number">0</span> &amp;&amp; data[mid - <span class="number">1</span>] != k)) &#123;</span><br><span class="line">			<span class="keyword">return</span> mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//若不是，则继续在该元素之前的子数组中查找</span></span><br><span class="line">		end = mid - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (data[mid] &lt; k) &#123;</span><br><span class="line">		start = mid + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		end = mid - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//二分递归</span></span><br><span class="line">	<span class="built_in">GetFirstK</span>(data, len, k, start, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetLastK</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> len, <span class="keyword">int</span> k, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//base case</span></span><br><span class="line">	<span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span> (data[mid] == k) &#123;</span><br><span class="line">		<span class="comment">//若当前中值等于k，判断该值是否为最后一个值为k的元素</span></span><br><span class="line">		<span class="keyword">if</span> (mid == len - <span class="number">1</span> || ((mid &lt; (len - <span class="number">1</span>)) &amp;&amp; data[mid + <span class="number">1</span>] != k)) &#123;</span><br><span class="line">			<span class="keyword">return</span> mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//若不是，则继续在该元素之后的子数组中查找</span></span><br><span class="line">		start = mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (data[mid] &lt; k) &#123;</span><br><span class="line">		start = mid + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		end = mid - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//二分递归</span></span><br><span class="line">	<span class="built_in">GetLastK</span>(data, len, k, start, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="53-1-0-n-1中缺失的数字"><a href="#53-1-0-n-1中缺失的数字" class="headerlink" title="53.1 0-n-1中缺失的数字"></a>53.1 0-n-1中缺失的数字</h1><blockquote>
<p>一个<strong>长度为n-1</strong>的<strong>递增排序</strong>数组中的所有<strong>数字都是唯一</strong>的,并且每个数字都在<strong>范围0-n-1之内</strong></p>
<p>在范围0~n-1内的n个数字中有且只有一个数字不在该数组中,请找出这个数字</p>
</blockquote>
<h2 id="Testing-case-65"><a href="#Testing-case-65" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(缺失的数字为数组首元素，尾元素，数组中某个元素)</li>
<li>边界测试(nullptr，数组中仅一个元素0)</li>
</ul>
<h2 id="Key-65"><a href="#Key-65" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>暴力遍历 T(n) = O(n)</p>
<blockquote>
<ol>
<li>通过公式 n(n-1) / 2，计算 0-n-1 数字的和</li>
<li>计算数组中所有数字元素的和</li>
<li>差值即为缺失的数字</li>
</ol>
</blockquote>
</li>
<li><p>二分查找 T(n) = O(logn)</p>
<blockquote>
<ol>
<li><p>二分查找，若data[mid] != mid，则进一步判断该元素是否为第一个下标不等于元素值的元素</p>
<p>(mid == 0) &amp;&amp; isSort，是数组首位元素且为缺失元素<br>mid &gt; 0 &amp;&amp; data[mid - 1] == mid - 1，不是数组首位元素且为缺失元素</p>
</li>
<li><p>若该元素是第一个下标不等于元素值的元素，则返回其下标，否则，在左子数组中继续查找</p>
</li>
<li><p>若data[mid] == mid，则在右子数组中进一步查找</p>
</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>数组长度为n-1且有序，若缺失数字为m，则数组中m位置之前的元素值均等于其下标，m以及m位置之后的元素均不等于其下标且差值为1</li>
<li>因此问题转换为求有序数组中第一个下标与元素不相等的下标值，缺失数字位置m处存放着元素m+1</li>
<li>注意代码鲁棒性，对于非法情况要有预防性处理</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-63"><a href="#Answer-63" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetMissingNum</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断异常</span></span><br><span class="line">	<span class="keyword">if</span> (data == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//二分查找第一个元素值不等于下标的元素</span></span><br><span class="line">	<span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> end = len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(start &lt;= end) &#123;</span><br><span class="line">		<span class="keyword">int</span> mid = (start + end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (data[mid] != mid) &#123;</span><br><span class="line">			<span class="comment">//首先判断该元素是否为非法元素</span></span><br><span class="line">			<span class="keyword">if</span> (data[mid] &gt;= len) &#123;</span><br><span class="line">				isExcption = <span class="literal">true</span>;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//进一步判断该元素是否为第一个下标不等于元素值的元素，两种可能</span></span><br><span class="line">			<span class="comment">//- 是首位元素且为缺失元素</span></span><br><span class="line">			<span class="comment">//- 不是首位元素且为缺失元素</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//若数组有序，则该元素与对应角标差值不超过1 --预防性处理</span></span><br><span class="line">			<span class="keyword">bool</span> isSort = data[mid] - mid == <span class="number">1</span>;</span><br><span class="line">			<span class="comment">//判断非首位的元素是否为第一个值不等于下标的元素</span></span><br><span class="line">			<span class="keyword">bool</span> isMFirst = mid &gt; <span class="number">0</span> &amp;&amp; data[mid - <span class="number">1</span>] == mid - <span class="number">1</span>;</span><br><span class="line">			<span class="comment">//判断首位元素是否为第一个一个值不等于下标的元素 --预防性处理</span></span><br><span class="line">			<span class="keyword">bool</span> isFFirst = (mid == <span class="number">0</span>) &amp;&amp; isSort;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (isFFirst || isMFirst) &#123;</span><br><span class="line">				<span class="keyword">return</span> mid;</span><br><span class="line">			&#125;</span><br><span class="line">			end = mid - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			start = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//考虑仅一个元素0的情况返回1</span></span><br><span class="line">	<span class="keyword">if</span> (start == len) &#123;</span><br><span class="line">		<span class="keyword">return</span> len;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//若二分遍历完都没有找到，则存在异常</span></span><br><span class="line">	<span class="comment">//非法数字，数组不是排序的</span></span><br><span class="line">	isExcption = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="53-2-数组中数值与下标相等的元素"><a href="#53-2-数组中数值与下标相等的元素" class="headerlink" title="53.2 数组中数值与下标相等的元素"></a>53.2 数组中数值与下标相等的元素</h1><blockquote>
<p>假设一个单调递增的数组里的每个元素都是整数并且是唯一的</p>
<p>请编程实现一个函数,找出数组中任意一个数值等于其下标的元素</p>
</blockquote>
<h2 id="Testing-case-66"><a href="#Testing-case-66" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(数组中含/不含数值与下标相等的元素)</li>
<li>边界测试(nullptr，数组中仅一个元素，要求元素位置数组首部/尾部)</li>
</ul>
<h2 id="Key-66"><a href="#Key-66" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>暴力遍历 T(n) = O(n)</p>
<blockquote>
<ol>
<li>遍历数组每个元素判断当前下标是否与对应元素相等</li>
</ol>
</blockquote>
</li>
<li><p>二分查找 T(n) = O(logn)</p>
<blockquote>
<ol>
<li><p>二分查找，若data[mid] != mid，则进一步缩小要求元素所在的范围</p>
<p>若data[mid]&lt;mid，由于数组单调递增，则mid左边的元素一定不存在值与下标相等的元素，在mid右边元素中继续查找</p>
<p>若data[mid]&gt;mid，由于数组单调递增，则mid右边的元素一定不存在值与下标相等的元素，在mid左边元素中继续查找</p>
</li>
<li><p>若data[mid] == mid，则返回mid</p>
</li>
<li><p>若数组中不存在要求元素，则返回-1</p>
</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li><p>数组为单调递增且元素唯一，基于二分查找，每次查找可将查找范围可缩小一半</p>
<p>若mid对应元素与mid不等，若data[mid]&lt;mid，由于数组单调递增，则mid左边的元素一定不存在值与下标相等的元素</p>
<p>若data[mid]&gt;mid，由于数组单调递增，则mid右边的元素一定不存在值与下标相等的元素</p>
</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-64"><a href="#Answer-64" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetNumberSameAsIndex</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断异常</span></span><br><span class="line">	<span class="keyword">if</span> (data == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> end = len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> mid = (start + end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (data[mid] == mid) &#123;</span><br><span class="line">			<span class="keyword">return</span> mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (data[mid] &lt; mid) &#123;</span><br><span class="line">			start = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			end = mid - <span class="number">1</span>;</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="54-二叉搜索树的第k大结点"><a href="#54-二叉搜索树的第k大结点" class="headerlink" title="54 二叉搜索树的第k大结点"></a>54 二叉搜索树的第k大结点</h1><blockquote>
<p>给定一棵二叉搜索树,请找出其中第k大的节点</p>
</blockquote>
<h2 id="Testing-case-67"><a href="#Testing-case-67" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(各种不同形态的二叉搜索树)</li>
<li>边界测试(nullptr，k=0,1,len，或k&gt;len len为二叉搜索树结点数)</li>
</ul>
<h2 id="Key-67"><a href="#Key-67" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>中序遍历</p>
<blockquote>
<ol>
<li>中序遍历二叉树搜索树，先判断左子树中是否存在第k大结点</li>
<li>若左子树中不存在，则判断当前根结点是否为第k大结点</li>
<li>若当前根结点不是，则判断其右子树中是否存在第k大结点</li>
<li>最终将pKthNode返回</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>二叉搜索树的中序遍历序列为由小到大的有序排列</li>
<li>异常判断是除了入口异常判断，还需注意k&gt;len时的越界处理</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-65"><a href="#Answer-65" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">GetKthNodePtr</span><span class="params">(TreeNode* pHead, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断异常</span></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span> || k &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		isException = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	TreeNode* pKthNode = <span class="built_in">GetKthNodePtrCore</span>(pHead, k);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//进行k越界的异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (pKthNode == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		isException = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pKthNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">GetKthNodePtrCore</span><span class="params">(TreeNode* pHead, <span class="keyword">int</span>&amp; k)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	TreeNode* pKthNode = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//左子树中找第k个结点</span></span><br><span class="line">	<span class="keyword">if</span> (pHead-&gt;pLeft != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		pKthNode = <span class="built_in">GetKthNodePtrCore</span>(pHead-&gt;pLeft, k);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//若左子树未找到第k个结点，判断当前结点是否为第k个结点</span></span><br><span class="line">	<span class="keyword">if</span> (pKthNode == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">			pKthNode = pHead;</span><br><span class="line">		&#125;</span><br><span class="line">		k--;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//若当前结点不是第k个结点，则在当前结点的右子树中找第k个结点</span></span><br><span class="line">	<span class="keyword">if</span> (pKthNode == <span class="literal">nullptr</span> &amp;&amp; pHead-&gt;pRight != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="built_in">GetKthNodePtrCore</span>(pHead-&gt;pRight, k);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pKthNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="55-二叉树的深度"><a href="#55-二叉树的深度" class="headerlink" title="55 二叉树的深度"></a>55 二叉树的深度</h1><blockquote>
<p>输入一棵二叉树的根节点,求该树的深度</p>
<p>从根节点到叶节点依次经过的节点(含根、叶节点)形成树的一条路径,最长路径的长度为树的深度</p>
</blockquote>
<h2 id="Testing-case-68"><a href="#Testing-case-68" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(普通二叉树，仅含左/右子树的二叉树)</li>
<li>边界测试(nullptr，二叉树仅含一个结点)</li>
</ul>
<h2 id="Key-68"><a href="#Key-68" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>先序遍历</p>
<blockquote>
<ol>
<li>先序遍历二叉树，对当前遍历的根节点进行计数</li>
<li>对于每一条路径，当到达叶子结点时打擂记录最大路径长度</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>遍历每一条路径记录最长的路径长度作为二叉树的深度</li>
<li>使用辅助接口函数返回二叉树的深度</li>
</ol>
</blockquote>
</li>
<li><p>后序遍历</p>
<blockquote>
<ol>
<li>后序遍历二叉树，使用两个变量记录当前根节点的左子树和右子树的深度</li>
<li>取左子树与右子树中深度较大者+1作为当前子树的深度</li>
<li>若当前根节点为空，则深度为0</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>每个子树的深度为其根节点左子树与右子树中深度较大者+1</li>
<li>base case若是对叶子结点的判断，则在对左/右子树遍历前需要保证左/右子树不为空</li>
<li>base case若是对nullptr的判断，则可放心递归获取左/右子树深度</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-66"><a href="#Answer-66" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<p>1.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode* pHead)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		isException = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//记录深度的变量</span></span><br><span class="line">	<span class="keyword">int</span> Depth = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//记录最大深度的变量</span></span><br><span class="line">	<span class="keyword">int</span> MaxDepth = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">TreeDepthCore</span>(pHead, Depth, MaxDepth);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> MaxDepth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TreeDepthCore</span><span class="params">(TreeNode* pHead, <span class="keyword">int</span> Depth, <span class="keyword">int</span>&amp; MaxDepth)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//先序遍历</span></span><br><span class="line">	Depth++;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//到达叶子结点</span></span><br><span class="line">	<span class="keyword">if</span> (pHead-&gt;pLeft == <span class="literal">nullptr</span> &amp;&amp; pHead-&gt;pRight == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (Depth &gt;= MaxDepth) &#123;</span><br><span class="line">			MaxDepth = Depth;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pHead-&gt;pLeft != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="built_in">TreeDepthCore</span>(pHead-&gt;pLeft, Depth, MaxDepth);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pHead-&gt;pRight != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="built_in">TreeDepthCore</span>(pHead-&gt;pRight, Depth, MaxDepth);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TreeDepthByPost</span><span class="params">(TreeNode* pHead)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		isException = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">TreeDepthByPostCore</span>(pHead);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TreeDepthByPostCore</span><span class="params">(TreeNode* pHead)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//base case</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	if (pHead == nullptr) &#123;</span></span><br><span class="line"><span class="comment">		return 0;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	int Left = TreeDepthByPostCore(pHead-&gt;pLeft);</span></span><br><span class="line"><span class="comment">	int Right = TreeDepthByPostCore(pHead-&gt;pRight);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	return (Left &gt; Right) ? Left + 1 : Right + 1;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pHead-&gt;pLeft == <span class="literal">nullptr</span> &amp;&amp; pHead-&gt;pRight == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> Left = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (pHead-&gt;pLeft != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		Left = <span class="built_in">TreeDepthByPostCore</span>(pHead-&gt;pLeft);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> Right = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (pHead-&gt;pRight != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		Right = <span class="built_in">TreeDepthByPostCore</span>(pHead-&gt;pRight);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (Left &gt; Right) ? Left + <span class="number">1</span> : Right + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="55-1-平衡二叉树"><a href="#55-1-平衡二叉树" class="headerlink" title="55.1 平衡二叉树"></a>55.1 平衡二叉树</h1><blockquote>
<p>输入一棵二叉树的根节点,判断该树是不是平衡二叉树</p>
<p>如果某二叉树中任意节点的左、右子树的深度相差不超过1,那么它就是一棵平衡二叉树</p>
</blockquote>
<h2 id="Testing-case-69"><a href="#Testing-case-69" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(普通二叉树/平衡二叉树，仅含左/右子树的平衡二叉树)</li>
<li>边界测试(nullptr，二叉树仅含一个结点)</li>
</ul>
<h2 id="Key-69"><a href="#Key-69" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>先序遍历</p>
<blockquote>
<ol>
<li>先序遍历二叉树的每一个结点</li>
<li>对于当前根结点基于TreeDepth求得当前结点的左右子树深度并判断当前结点的平衡因子是否满足要求</li>
<li>进而判断左右子树中的各结点是否满足要求</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>求解结点的平衡因子时存在大量的重复计算</li>
<li>设置两个全局异常判断变量，防止不同类型的异常混乱</li>
</ol>
</blockquote>
</li>
<li><p>后序遍历</p>
<blockquote>
<ol>
<li>后序遍历二叉树，在左右子树均满足平衡二叉树的条件下</li>
<li>根据两个子树的深度记录参数，判断当前根节点的平衡因子是否满足要求，并计算当前结点为根节点的子树的深度</li>
<li>直至根节点为nullptr返回true，深度记录为0</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>后序遍历二叉树，在左右子树均满足平衡二叉树的条件下，再判断当前根节点的平衡因子是否满足要求</li>
<li>当前根节点的平衡因子判断需要在遍历左右子树时实时记录左右子树的深度，增加一个记录深度的输出参数即可</li>
<li>对所有结点仅遍历了一次</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-67"><a href="#Answer-67" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<p>1.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalancedTreeByPre</span><span class="params">(TreeNode* pHead)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断异常</span></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		isBalancedException = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">isBalancedTreeByPreCore</span>(pHead);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalancedTreeByPreCore</span><span class="params">(TreeNode* pHead)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//base case</span></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取当前结点的左右子树深度</span></span><br><span class="line">	<span class="keyword">int</span> left = <span class="built_in">TreeDepthByPost</span>(pHead-&gt;pLeft);</span><br><span class="line">	<span class="keyword">int</span> Right = <span class="built_in">TreeDepthByPost</span>(pHead-&gt;pRight);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断当前结点的平衡因子是否满足要求</span></span><br><span class="line">	<span class="keyword">int</span> diff = left - Right;</span><br><span class="line">	<span class="keyword">if</span> (diff &lt; <span class="number">-1</span> || diff &gt; <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//若当前结点平衡因子满足要求，则进而判断其左右子树中各结点是否满足要求</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">isBalancedTreeByPreCore</span>(pHead-&gt;pLeft) &amp;&amp; <span class="built_in">isBalancedTreeByPreCore</span>(pHead-&gt;pRight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalancedTreeByPostCore</span><span class="params">(TreeNode* pHead, <span class="keyword">int</span>&amp; Depth)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//base case</span></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		Depth = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置记录左右子树深度的输出参数</span></span><br><span class="line">	<span class="keyword">int</span> Left;</span><br><span class="line">	<span class="keyword">int</span> Right;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">isBalancedTreeByPostCore</span>(pHead-&gt;pLeft, Left) &amp;&amp; <span class="built_in">isBalancedTreeByPostCore</span>(pHead-&gt;pRight, Right)) &#123;</span><br><span class="line">		<span class="keyword">int</span> diff = Left - Right;</span><br><span class="line">		<span class="keyword">if</span> (diff &gt;= <span class="number">-1</span> &amp;&amp; diff &lt;= <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//记录当前结点作根结点的子树的深度</span></span><br><span class="line">			Depth = <span class="number">1</span> + (Left &gt; Right ? Left : Right);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//若当前结点平衡因子不满足要求，则无需记录深度，直接返回false即可</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="56-数组中只出现一次的两个数字"><a href="#56-数组中只出现一次的两个数字" class="headerlink" title="56 数组中只出现一次的两个数字"></a>56 数组中只出现一次的两个数字</h1><blockquote>
<p>一个整型数组里除两个数字之外,其他数字都出现了两次</p>
<p>请写程序找出这两个只出现一次的数字</p>
<p>要求时间复杂度是0(n),空间复杂度是0(1)</p>
</blockquote>
<h2 id="Testing-case-70"><a href="#Testing-case-70" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(数组中有多对重复数字，数组中无重复数字)</li>
<li>边界测试(nullptr)</li>
</ul>
<h2 id="Key-70"><a href="#Key-70" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>位运算 - 异或 T(n) = O(n) S(n) = O(1)</p>
<blockquote>
<ol>
<li><p>遍历整个数组求所有元素的异或结果</p>
</li>
<li><p>根据1自低位起出现的出现的位置作为划分依据，将数组划分为分别包含一个只出现一次数字的两个子数组</p>
<p>FirstIndex位为1的为1组，FirstIndex位为0的为1组</p>
</li>
<li><p>分别计算两个子数组中只出现一次的数字</p>
</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>先分析数组中只出现一次的一个数字的求法，将数组每个元素进行异或运算，结果即为只出现一次的数字，因为重复的数字异或结果为0</li>
<li>而两个数字的求法基于方法1，可以想办法将这两个数字分于两个子数组中，分别求两个子数组中只出现一次的数字即可</li>
<li>因为返回值有两个，因此使用输出参数返回结果</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-68"><a href="#Answer-68" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isOneInIndex</span><span class="params">(<span class="keyword">int</span> Num, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//右移index次到达index位</span></span><br><span class="line">	Num &gt;&gt; index;</span><br><span class="line">	<span class="comment">//判断该位是否为1</span></span><br><span class="line">	<span class="keyword">return</span> Num &amp; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetIndexOfNum1</span><span class="params">(<span class="keyword">int</span> Num)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//自低位开始判断是否为1，若不是则右移，但注意防止溢出，注意边界判断，共 8*sizeof(int) 位</span></span><br><span class="line">	<span class="keyword">while</span> (((Num &amp; <span class="number">1</span>) == <span class="number">0</span>) &amp;&amp; (index &lt; <span class="number">8</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>))) &#123;</span><br><span class="line">		Num &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">		index++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> len, <span class="keyword">int</span>&amp; Num1, <span class="keyword">int</span>&amp; Num2)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断异常</span></span><br><span class="line">	<span class="keyword">if</span> (data == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//首次遍历数组，求得所有数字的异或结果</span></span><br><span class="line">	<span class="keyword">int</span> ExclusiveOr = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		ExclusiveOr ^= data[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//求得异或结果从低位记起 1 第一次出现的位置</span></span><br><span class="line">	<span class="keyword">int</span> FirstIndex = <span class="built_in">GetIndexOfNum1</span>(ExclusiveOr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将数组分成两组 一组FirstIndex位为0 一组FirstIndex位为1</span></span><br><span class="line">	<span class="comment">//分别计算两组的异或结果，结果即为两个出现次数为1的数字</span></span><br><span class="line"></span><br><span class="line">	Num1 = <span class="number">0</span>;</span><br><span class="line">	Num2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">isOneInIndex</span>(data[i], FirstIndex)) &#123;</span><br><span class="line">			Num1 ^= data[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			Num2 ^= data[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="56-1-数组中唯一只出现一次的数字"><a href="#56-1-数组中唯一只出现一次的数字" class="headerlink" title="56.1 数组中唯一只出现一次的数字"></a>56.1 数组中唯一只出现一次的数字</h1><blockquote>
<p>在一个数组中除一个数字只出现一次之外,其他数字都出现了三次</p>
<p>请找出那个只出现一次的数字</p>
</blockquote>
<h2 id="Testing-case-71"><a href="#Testing-case-71" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(只出现一次的数字为0，正数，负数，重复出现的数字为0，正数，负数)</li>
<li>边界测试(nullptr)</li>
</ul>
<h2 id="Key-71"><a href="#Key-71" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>位运算 T(n) = O(n) S(n) = O(1)</p>
<blockquote>
<ol>
<li>遍历数组，由低位起，将数组元素每一位的值累加到indexSum数组的对应位上</li>
<li>由indexSum的每一位累加和求得只出现一次的数字的每一位的值并作移位累加</li>
<li>将移位累加和返回</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>其他数字都出现了三次，数组各元素异或结果重复数字仍为原数字，异或不可取</li>
<li>但是若对数组各元素的每一位求和，并记录每一位的和，若该位求和结果可被3整除，则只出现一次的数字该位为0，否则为1</li>
<li>对int型数字的每一位均记录求和结果，可使用大小为32的int型数组，indexSum数组</li>
<li>选取更新掩码的方法来由低到高遍历整数的每一位</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-69"><a href="#Answer-69" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindNumAppearOnce</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断异常</span></span><br><span class="line">	<span class="keyword">if</span> (data == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历数组每一个元素，累加计算每个元素每一位上的和</span></span><br><span class="line">	<span class="keyword">int</span> indexSum[<span class="number">32</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		<span class="comment">//累加当前元素的各位上的和，整型元素共32位</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//各位遍历时不希望右移数据元素更改数据，而选择移动掩码来进行下一位的累加和计算</span></span><br><span class="line">		<span class="keyword">int</span> indexMask = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">31</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">			<span class="comment">//低位起记录当前位上的值</span></span><br><span class="line">			<span class="keyword">int</span> result = data[i] &amp; indexMask;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="comment">//若当前位值为1，则累加1，而非累加result，是该位的累加和不再考虑低位</span></span><br><span class="line">				indexSum[j] += <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//进行下一位的判断</span></span><br><span class="line">			indexMask &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//计算只出现一次数字的值，以位为单位计算最终得到Num值</span></span><br><span class="line">	<span class="keyword">int</span> Num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">		Num &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">		Num += indexSum[i] % <span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> Num;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="57-和为s的数字"><a href="#57-和为s的数字" class="headerlink" title="57 和为s的数字"></a>57 和为s的数字</h1><blockquote>
<p>输入一个递增排序的数组和一个数字S,在数组中查找两个数,使得它们的和正好是S</p>
<p>如果有多对数字的和等于S,则输出任意一对即可</p>
</blockquote>
<h2 id="Testing-case-72"><a href="#Testing-case-72" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(数组中存在/不存在和为s的两个数字)</li>
<li>边界测试(nullptr)</li>
</ul>
<h2 id="Key-72"><a href="#Key-72" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>暴力遍历 T(n) = O(n2)</p>
<blockquote>
<ol>
<li>遍历数组，同时固定当前数字，计算当前数字与其后数字的和是否满足和为S</li>
</ol>
</blockquote>
</li>
<li><p>双指针遍历 T(n) = O(n)</p>
<blockquote>
<ol>
<li><p>设置两个遍历指针，分别初始化为指向数组最小值与最大值</p>
</li>
<li><p>计算两个指针指向位置的和s，判断与S的大小关系，若与s=S，则设置传出参数返回</p>
<p>若 s&lt;S,则将指向较小元素的指针后移，增大s</p>
<p>若 s&gt;S,则将指向较大元素的指针前移，缩小s</p>
</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>数组为排序数组，因此当选择两个数计算和后，通过判断与s的大小关系可以缩小查找范围</li>
<li>设置双指针，一个指向较小的元素，一个指向较大的元素，通过指针的交替移动完成查找</li>
<li>涉及多个结果的返回，通过传出参数返回结果</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-70"><a href="#Answer-70" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FindNumWithSum</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> length, <span class="keyword">int</span> Sum, <span class="keyword">int</span>&amp; Num1, <span class="keyword">int</span>&amp; Num2)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断异常</span></span><br><span class="line">	<span class="keyword">if</span> (data == <span class="literal">nullptr</span> || length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置返回值</span></span><br><span class="line">	<span class="keyword">bool</span> find = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置两个指针分别用于指向Num1与Num2，初始化为排序数组最大值与最小值</span></span><br><span class="line">	<span class="keyword">int</span> maxIndex = length - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> minIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (minIndex &lt; maxIndex) &#123;</span><br><span class="line">		<span class="keyword">int</span> sum = data[maxIndex] + data[minIndex];</span><br><span class="line">		<span class="keyword">if</span> (sum == Sum) &#123;</span><br><span class="line">			find = <span class="literal">true</span>;</span><br><span class="line">			Num2 = data[maxIndex];</span><br><span class="line">			Num1 = data[minIndex];</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; Sum) &#123;</span><br><span class="line">			<span class="comment">//若此时指针指向的两个元素和小于Sum,则将指向较小元素的指针后移(数组由小到大排序)</span></span><br><span class="line">			minIndex++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//若此时指针指向的两个元素和大于Sum,则将指向较大元素的指针后移(数组由小到大排序)</span></span><br><span class="line">			maxIndex--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> find;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="57-1-和为s的连续正数序列"><a href="#57-1-和为s的连续正数序列" class="headerlink" title="57.1 和为s的连续正数序列"></a>57.1 和为s的连续正数序列</h1><blockquote>
<p>输入一个正数s,打印出所有和为s的连续正数序列(至少含有两个数)</p>
<p>例如,输入T5,由于1+2+3+4+5=4+5+6=7+8=15,所以打印出3个连续序列1<del>5,4</del>6和7~8</p>
</blockquote>
<h2 id="Testing-case-73"><a href="#Testing-case-73" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(存在/不存在和为s的序列,例如4)</li>
<li>边界测试(3)</li>
</ul>
<h2 id="Key-73"><a href="#Key-73" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>范围指针对</p>
<blockquote>
<ol>
<li>设置一对范围遍历指针，并使用curSum记录当前范围序列的累加和</li>
<li>移动指针对自1开始的正数序列进行遍历，若curSum == Sum ,则对当前序列进行输出，并进一步扩大范围，先对end++，后对curSum累加</li>
<li>若 curSum &gt; Sum，则一直缩小序列范围，curSum 剔除start当前指向的元素，并将start后移，直到curSum == Sum or curSum &lt; Sum</li>
<li>若 curSum &lt; Sum，则一直扩大序列范围，先对end++，后对curSum累加，直到curSum == Sum or curSum &gt; Sum</li>
<li>最终直至start &gt;= (sum + 1) / 2</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li><p>curSum记录当前范围序列的累加和</p>
<p>缩小序列范围时，应先将curSum剔除掉start对应的数，后对start++</p>
<p>扩大序列范围时，应先对end++，后对curSum累加</p>
</li>
<li><p>范围遍历指针时刻指向正数序列的两个边界</p>
</li>
<li><p>由于需要找到所有的正数序列，因此即使输出了一个正数序列之后，也应再次扩大范围，进行查找</p>
</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-71"><a href="#Answer-71" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSequene</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">		cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindContinuousSequene</span><span class="params">(<span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断异常</span></span><br><span class="line">	<span class="keyword">if</span> (sum &lt; <span class="number">3</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//设置序列范围指针</span></span><br><span class="line">	<span class="keyword">int</span> start = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> end = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//记录序列范围中所有数字的和</span></span><br><span class="line">	<span class="keyword">int</span> curSum = start + end;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历找寻满足条件的序列</span></span><br><span class="line">	<span class="keyword">while</span> (start &lt; (sum + <span class="number">1</span>) / <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="comment">//简化版</span></span><br><span class="line">        </span><br><span class="line">		<span class="keyword">if</span> (curSum == sum) &#123;</span><br><span class="line">			<span class="built_in">printSequene</span>(start, end);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (curSum &gt; sum &amp;&amp; start &lt; (sum + <span class="number">1</span>) / <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="comment">//剔除序列中最小的正数，先累减后++</span></span><br><span class="line">			curSum -= start;</span><br><span class="line">			start++;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (curSum == sum) &#123;</span><br><span class="line">				<span class="built_in">printSequene</span>(start, end);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//扩大序列的范围，先++后累加</span></span><br><span class="line">		end++;</span><br><span class="line">		curSum += end;		</span><br><span class="line"></span><br><span class="line">		<span class="comment">//冗余版</span></span><br><span class="line">		<span class="comment">//if (curSum == sum) &#123;</span></span><br><span class="line">		<span class="comment">//	printSequene(start, end);</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//	end++;</span></span><br><span class="line">		<span class="comment">//	curSum += end;</span></span><br><span class="line">		<span class="comment">//&#125;</span></span><br><span class="line">		<span class="comment">//else if (curSum &gt; sum) &#123;</span></span><br><span class="line">		<span class="comment">//	curSum -= start;</span></span><br><span class="line">		<span class="comment">//	start++;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//	if (curSum == sum) &#123;</span></span><br><span class="line">		<span class="comment">//		printSequene(start, end);</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//		end++;</span></span><br><span class="line">		<span class="comment">//		curSum += end;</span></span><br><span class="line">		<span class="comment">//	&#125;</span></span><br><span class="line">		<span class="comment">//&#125;</span></span><br><span class="line">		<span class="comment">//else &#123;</span></span><br><span class="line">		<span class="comment">//	//扩大序列的范围，先++后累加</span></span><br><span class="line">		<span class="comment">//	end++;</span></span><br><span class="line">		<span class="comment">//	curSum += end;</span></span><br><span class="line">		<span class="comment">//&#125;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="58-翻转字符串"><a href="#58-翻转字符串" class="headerlink" title="58 翻转字符串"></a>58 翻转字符串</h1><blockquote>
<p>输入一个英文句子,翻转句子中单词的顺序,但单词内字符的顺序不变</p>
<p>为简单起见,标点符号和普通字母一样处理</p>
<p>例如输入字符串”I am a student.”,则输出”student. a am I”</p>
</blockquote>
<h2 id="Testing-case-74"><a href="#Testing-case-74" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(句子中有多个单词，句子中只有一个单词)</li>
<li>边界测试(nullptr，空字符串，只有空格)</li>
</ul>
<h2 id="Key-74"><a href="#Key-74" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>范围指针对 + 整体与局部</p>
<blockquote>
<ol>
<li>设置范围指针对分别指向字符串首尾</li>
<li>根据范围指针对，先将整个字符串进行翻转</li>
<li>由范围指针对，对单个单词进行翻转，pEnd后移找寻单词末尾(‘ ‘ or ‘\0’ )，pStart进行遍历并时刻指向单词首部</li>
<li>直至 pStart == ‘\0’ ，字符串翻转完毕</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>对单词进行翻转判断时，注意pEnd后移找到单词末尾时，需要翻转不包含 ‘ ‘ or ‘\0’ 的子字符串,传参时注意指针的前移</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-72"><a href="#Answer-72" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">ReverseSentence</span><span class="params">(<span class="keyword">char</span>* pSen)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断异常</span></span><br><span class="line">	<span class="keyword">if</span> (pSen == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span>* pStart = pSen;</span><br><span class="line">	<span class="keyword">char</span>* pEnd = pStart;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置范围指针对的范围，使pEnd指向字符串尾部</span></span><br><span class="line">	<span class="keyword">while</span> (*pEnd != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">		pEnd++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pEnd--;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//翻转整个字符串</span></span><br><span class="line">	<span class="built_in">ReverseWords</span>(pStart, pEnd);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//翻转每个单词</span></span><br><span class="line">	<span class="comment">//重置范围指针对指向范围</span></span><br><span class="line">	pStart = pEnd = pSen;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (*pStart != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (*pStart == <span class="string">&#x27; &#x27;</span> &amp;&amp; *pEnd == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">			pStart++;</span><br><span class="line">			pEnd++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (*pEnd == <span class="string">&#x27; &#x27;</span> || *pEnd == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">			<span class="comment">//翻转单词</span></span><br><span class="line">			<span class="built_in">ReverseWords</span>(pStart, --pEnd);</span><br><span class="line">			pStart = ++pEnd;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			pEnd++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pSen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReverseWords</span><span class="params">(<span class="keyword">char</span>* pStart, <span class="keyword">char</span>* pEnd)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断异常</span></span><br><span class="line">	<span class="keyword">if</span> (pStart == <span class="literal">nullptr</span> || pEnd == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (pStart &lt; pEnd) &#123;</span><br><span class="line">		<span class="keyword">char</span> temp = *pStart;</span><br><span class="line">		*pStart = *pEnd;</span><br><span class="line">		*pEnd = temp;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//缩小范围</span></span><br><span class="line">		pStart++;</span><br><span class="line">		pEnd--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="58-1-左旋转字符串"><a href="#58-1-左旋转字符串" class="headerlink" title="58.1 左旋转字符串"></a>58.1 左旋转字符串</h1><blockquote>
<p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部</p>
<p>请定义一个函数实现字符串左旋转操作的功能</p>
<p>比如,输入字符串”abcdefg”和数字2,该函数将返回左旋转两位得到的结果”cdefgab”</p>
</blockquote>
<h2 id="Testing-case-75"><a href="#Testing-case-75" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(长度为n的字符串左旋0,1,2,n,n-1,n+1个字符)</li>
<li>边界测试(nullptr)</li>
</ul>
<h2 id="Key-75"><a href="#Key-75" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>范围指针对 + 整体与局部</p>
<blockquote>
<ol>
<li>设置范围指针对分别指向字符串首尾</li>
<li>根据范围指针对，先将整个字符串进行翻转</li>
<li>由范围指针对,根据左旋的字符数确定待翻转的子串范围，并将该范围子串翻转</li>
<li>将不需要左旋的字符串进行翻转恢复</li>
<li>将两个子字符串翻转完毕后，字符串左旋完毕</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>注意空串，待旋转子串长度越界问题，代码鲁棒性检查</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-73"><a href="#Answer-73" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReverseWords</span><span class="params">(<span class="keyword">char</span>* pStart, <span class="keyword">char</span>* pEnd)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断异常</span></span><br><span class="line">	<span class="keyword">if</span> (pStart == <span class="literal">nullptr</span> || pEnd == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (pStart &lt; pEnd) &#123;</span><br><span class="line">		<span class="keyword">char</span> temp = *pStart;</span><br><span class="line">		*pStart = *pEnd;</span><br><span class="line">		*pEnd = temp;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//缩小范围</span></span><br><span class="line">		pStart++;</span><br><span class="line">		pEnd--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">LeftRotateString</span><span class="params">(<span class="keyword">char</span>* pStr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断异常</span></span><br><span class="line">	<span class="keyword">if</span> (pStr == <span class="literal">nullptr</span> || *pStr == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span>* pStart = pStr;</span><br><span class="line">	<span class="keyword">char</span>* pEnd = pStart;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置范围指针对的范围，使pEnd指向字符串尾部</span></span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (*pEnd != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">		pEnd++;</span><br><span class="line">		num++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (n &gt; num) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pEnd--;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//翻转整个字符串</span></span><br><span class="line">	<span class="built_in">ReverseWords</span>(pStart, pEnd);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//对指定范围进行翻转</span></span><br><span class="line">	<span class="comment">//将需要左旋子字符串进行翻转</span></span><br><span class="line">	<span class="built_in">ReverseWords</span>(pEnd - n + <span class="number">1</span>, pEnd);</span><br><span class="line">	<span class="comment">//将不需要左旋的字符串进行恢复</span></span><br><span class="line">	<span class="built_in">ReverseWords</span>(pStart, pEnd - n);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pStr;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="59-滑动窗口的最大值"><a href="#59-滑动窗口的最大值" class="headerlink" title="59 滑动窗口的最大值"></a>59 滑动窗口的最大值</h1><blockquote>
<p>给定一个数组和滑动窗口的大小,请找出所有滑动窗口里的最大值</p>
<p>例如,如果输入数组(2,3,4,2,6,2,5,1)及滑动窗口的大小3,那么一共存在6个滑动窗口,它们的最大值分别为4,4,6,6,6,5</p>
</blockquote>
<h2 id="Testing-case-76"><a href="#Testing-case-76" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(输入的数组无序/单调递增/单调递减)</li>
<li>边界测试(数组为空，滑动窗口的大小为0，1，等于/大于 输入数组的大小)</li>
</ul>
<h2 id="Key-76"><a href="#Key-76" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>双向队列</p>
<blockquote>
<ol>
<li>设置一个双向队列Window以及待返回的存放各窗口最大值的maxInWindows数组</li>
<li>在窗口元素未满WinSize前，先遍历数组data的前WinSize个元素，若Window非空，则从队尾开始循环判断，将小于等于当前数组元素的Window元素(下标)从队尾弹出(将不可能成为当前滑动窗口的元素由Window队尾开始逐个弹出)，最终将当前元素下标压入</li>
<li>在窗口元素未满WinSize后，对数组剩余元素进行遍历，先将WinSize队首元素(当前滑动窗口的最大值元素在data中的下标)进行记录，进而将不可能成为当前滑动窗口的元素由Window队尾开始逐个弹出，再将已不在当前窗口内的队首元素逐个弹出，最终将当前元素下标压入</li>
<li>将最后一个滑动窗口的最大值元素下标记录后，返回maxInWindows数组</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>使用一个双向队列，仅存放当前滑动窗口中的最大值元素以及可能成为其后滑动窗口最大值的元素，队首始终为当前滑动窗口的最大值元素 -下标</li>
<li>为了确保队列滑动时此队列能排除窗口之外的元素，队列中存放数组元素下标而非元素，通过下标根据窗口大小判断队首元素是否已不在此窗口中</li>
<li>在窗口元素未满WinSize前，当前队列队首元素并不是最大值元素的下标，因此单独处理</li>
<li>在窗口元已满WinSize后，每遍历一个元素后，队首元素即为当前滑动窗口最大值元素的下标，记录该最大值元素</li>
<li>deque同时允许队首队尾删除元素，在非最值元素时队尾弹出，在超出窗口范围时队首弹出</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-74"><a href="#Answer-74" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">MaxInWindows</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; data, <span class="keyword">int</span> WinSize)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置返回各窗口最大值的数组</span></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; maxInWindows;</span><br><span class="line">	<span class="comment">//判断异常</span></span><br><span class="line">	<span class="keyword">if</span> (data.<span class="built_in">size</span>() &lt; WinSize || WinSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> maxInWindows;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置窗口队列，仅存可能为窗口最大值的元素</span></span><br><span class="line">	deque&lt;<span class="keyword">int</span>&gt; Window;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历数组元素，并对窗口状态进行更新，弹出不可能为窗口最大值的元素</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//先对数组前WinSize进行遍历，因为此时并未填满窗口</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; WinSize; i++) &#123;</span><br><span class="line">		<span class="comment">//根据当前元素值判断，弹出不可能为当前窗口最大值的元素</span></span><br><span class="line">		<span class="keyword">while</span> (!Window.<span class="built_in">empty</span>() &amp;&amp; data[i] &gt;= data[Window.<span class="built_in">back</span>()]) &#123;</span><br><span class="line">			Window.<span class="built_in">pop_back</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将当前元素数组下标压入窗口</span></span><br><span class="line">		Window.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = WinSize; i &lt; data.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		<span class="comment">//将窗口队列队首元素压入maxInWindows，记录窗口最大值</span></span><br><span class="line">		maxInWindows.<span class="built_in">push_back</span>(data[Window.<span class="built_in">front</span>()]);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//根据当前元素值判断，弹出不可能为当前窗口最大值的元素</span></span><br><span class="line">		<span class="keyword">while</span> (!Window.<span class="built_in">empty</span>() &amp;&amp; data[i] &gt;= data[Window.<span class="built_in">back</span>()]) &#123;</span><br><span class="line">			Window.<span class="built_in">pop_back</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//根据当前元素的下标判断，弹出当前窗口之外的的元素</span></span><br><span class="line">		<span class="keyword">while</span> (!Window.<span class="built_in">empty</span>() &amp;&amp; (i - Window.<span class="built_in">front</span>() &gt;= WinSize)) &#123;</span><br><span class="line">			Window.<span class="built_in">pop_front</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将当前元素数组下标压入窗口</span></span><br><span class="line">		Window.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将窗口队列队首元素压入maxInWindows，记录窗口最大值</span></span><br><span class="line">	maxInWindows.<span class="built_in">push_back</span>(data[Window.<span class="built_in">front</span>()]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> maxInWindows;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="59-1-队列的最大值"><a href="#59-1-队列的最大值" class="headerlink" title="59.1 队列的最大值"></a>59.1 队列的最大值</h1><blockquote>
<p>请定义一个队列并实现函数max得到队列里的最大值,要求函数max,push_back和pop_front的时间复杂度都是0(1)</p>
</blockquote>
<h2 id="Testing-case-77"><a href="#Testing-case-77" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(对队列进行 插入/删除 操作后求最大值)</li>
<li>边界测试(队列为空)</li>
</ul>
<h2 id="Key-77"><a href="#Key-77" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>队列特性</p>
<blockquote>
<p>队列的特性与栈不同，队列为先进先出</p>
<p>若当前压入的元素成为了队列的最大值，那么在该元素弹出之前(未压入新元素)，队列的最大值始终为该元素</p>
</blockquote>
</li>
<li><p>双向队列</p>
<blockquote>
<p>使用一个双向队列max来记录队列data不同状态下的最大值</p>
<p>max队列仅存放当前data队列最大值以及该最大值弹出后剩余状态的可能最大值，队首为当前data队列状态对应的最大值</p>
</blockquote>
</li>
<li><p>数据内部封装</p>
<blockquote>
<p>在弹出元素时需要根据data队列弹出的元素来更新当前最大值状态，通过index与相应元素的绑定封装可以标识当前弹出的元素是否为当前data队列的最大值，从而更新max队列相应的最大值状态</p>
</blockquote>
</li>
<li><p>push_back压入元素</p>
<blockquote>
<ol>
<li><p>将压入的元素封装为内部数据压入data队列</p>
</li>
<li><p>更新相应的max队列最大值状态，剔除max队列自队尾开始比当前压入元素小的元素，将当前元素压入max队列</p>
<p>由于队列特性，只要压入元素，那么该元素就可能成为data队列某一状态的最大值</p>
</li>
<li><p>更新currentIndex索引绑定下一个元素</p>
</li>
</ol>
</blockquote>
</li>
<li><p>pop_front弹出元素</p>
<blockquote>
<ol>
<li>先判断当前弹出元素是否会影响max队列状态，若当前弹出元素绑定的currentIndex索引与max队首currentIndex索引相同，则需弹出max队首</li>
<li>在将该元素从data队首弹出</li>
<li>若 data 队列 or max队列 为空，则弹异常</li>
</ol>
</blockquote>
</li>
<li><p>getMax取最大值</p>
<blockquote>
<ol>
<li>取max队列队首元素</li>
<li>若 data队列 or max队列 为空，则弹异常</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-75"><a href="#Answer-75" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueueWithMax</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">QueueWithMax</span>() :<span class="built_in">currentIndex</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(T val)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//将数据封装为内部数据</span></span><br><span class="line">		InternalData internalData;</span><br><span class="line">		internalData.number = val;</span><br><span class="line">		internalData.index = currentIndex;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将内部数据压入到data队列中</span></span><br><span class="line">		data.<span class="built_in">push_back</span>(internalData);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//更新目前data队列的最大值，目前data队列的最大值位于max队首</span></span><br><span class="line">		<span class="comment">//先将已不可能成为data队列剩余状态的最大值的元素弹出</span></span><br><span class="line">		<span class="keyword">while</span> (!max.<span class="built_in">empty</span>() &amp;&amp; val &gt;= max.<span class="built_in">back</span>().number) &#123;</span><br><span class="line">			max.<span class="built_in">pop_back</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//剔除掉不可能元素后，剩余元素即为可能成为队列某一状态下的最大值，当前最大值为max队首元素</span></span><br><span class="line">		<span class="comment">//当前元素可能作为data队列某一状态下的最大值，压入</span></span><br><span class="line">		max.<span class="built_in">push_back</span>(internalData);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将索引更新指向下一个元素</span></span><br><span class="line">		currentIndex++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!data.<span class="built_in">empty</span>() &amp;&amp; !max.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (data.<span class="built_in">front</span>().index == max.<span class="built_in">front</span>().index) &#123;</span><br><span class="line">				max.<span class="built_in">pop_front</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			data.<span class="built_in">pop_front</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">exception</span>(<span class="string">&quot;异常&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">T <span class="title">getMax</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!max.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">			<span class="keyword">return</span> max.<span class="built_in">front</span>().number;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">exception</span>(<span class="string">&quot;异常&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">InternalData</span> &#123;</span></span><br><span class="line">		T number;</span><br><span class="line">		<span class="keyword">int</span> index;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	deque&lt;InternalData&gt; data;</span><br><span class="line">	deque&lt;InternalData&gt; max;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> currentIndex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="60-n个骰子的点数"><a href="#60-n个骰子的点数" class="headerlink" title="60 n个骰子的点数"></a>60 n个骰子的点数</h1><blockquote>
<p>把n个骰子扔在地上,所有骰子朝上一面的点数之和为s</p>
<p>输入n,打印出s的所有可能的值出现的概率</p>
</blockquote>
<h2 id="Testing-case-78"><a href="#Testing-case-78" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(1,2,3,4)</li>
<li>边界测试(0)</li>
<li>性能测试(11)</li>
</ul>
<h2 id="Key-78"><a href="#Key-78" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>穷举递归</p>
<blockquote>
<ol>
<li>base case 剩余骰子数为0时记录骰子点数之和于数组中，对应存放位置累加计数</li>
<li>explore 向下递归，对剩余骰子点数之和进行记录</li>
<li>backtracking 在进行本骰子下一结果决策之前，先恢复骰子点数和，剔除上一次的结果</li>
<li>根据骰子各点数和与所有可能结果(6^n)计算某骰子和出现的概率</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>使用一个数组对n个骰子朝上一面点数之和的出现次数进行记录，无需使用maxSum大小的数组直接使用点数和映射位置，而是仅存minSum - maxSum之间的maxSum - minSum + 1 个元素，使用 点数和 - minSum 映射存放位置</li>
<li>递归含多次重复计算</li>
</ol>
</blockquote>
</li>
<li><p>自下而上 + 迭代计算 + 哈希表</p>
<blockquote>
<ol>
<li><p>计算并记录一个骰子的所有点数和出现次数，使用数组记录，角标对应点数和，元素值对应该点数和出现的次数</p>
</li>
<li><p>根据一个骰子的结果，计算两个骰子的结果，基于第一个数组结果在第二个数组中记录结果</p>
<blockquote>
<p>f(n,sum) = f(n-1,sum-1) + f(n-1,sum-2) + … + f(n-1,sum-6)，(n&gt;1,n &lt;= sum &lt;= n*6) </p>
</blockquote>
</li>
<li><p>根据两个骰子的结果，计算三个骰子的结果，基于第二个数组结果在第一个数组中记录结果</p>
</li>
<li><p>直至计算出n个骰子的结果，进而计算各结果出现的概率</p>
</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li><p>记 f(n,sum) 为n个骰子时，和为sum的出现次数，则</p>
<p>f(n,sum) = f(n-1,sum-1) + f(n-1,sum-2) + … + f(n-1,sum-6)，(n&gt;1,n &lt;= sum &lt;= n*6) </p>
<p>f(n,sum) = 1，(n=1,1 &lt;= sum &lt;= 6)</p>
</li>
<li><p>n个骰子时各点数和的出现次数与且仅与n-1个骰子时的各点数和的出现次数有关</p>
</li>
<li><p>使用两个数组交替记录n个骰子时各点数和的出现次数与n-1个骰子时的各点数和的出现次数，自n=1时记录，直至计算至n=num，并使用flag标志位来交替记录</p>
</li>
<li><p>数组角标对应n个骰子的某点数和，元素值为其出现次数</p>
</li>
<li><p>注意在交替记录本次骰子各点数和时需要清零数组，因为仅使用两个数组记录，若不清零，会使计算混乱</p>
</li>
<li><p>注意边界值的考量，代码鲁棒性，条件的判断</p>
</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-76"><a href="#Answer-76" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<p>1.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProbabilityCore</span><span class="params">(<span class="keyword">int</span> minSum, <span class="keyword">int</span> remainingDice, <span class="keyword">int</span> curSum, <span class="keyword">int</span>* countSum)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//base case </span></span><br><span class="line">	<span class="keyword">if</span> (remainingDice == <span class="number">0</span>) &#123;</span><br><span class="line">		countSum[curSum - minSum]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">			<span class="comment">//记录当前骰子点数</span></span><br><span class="line">			curSum += i;</span><br><span class="line">			<span class="comment">//向下递归，求剩余骰子的点数</span></span><br><span class="line">			<span class="built_in">ProbabilityCore</span>(minSum, remainingDice - <span class="number">1</span>, curSum, countSum);</span><br><span class="line">			<span class="comment">//在进行下一种决策前回退</span></span><br><span class="line">			curSum -= i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Probability</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>* countSum)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">ProbabilityCore</span>(n, n, <span class="number">0</span>, countSum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintProbability</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断异常</span></span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//记录骰子和的最大值与最小值</span></span><br><span class="line">	<span class="keyword">int</span> maxNum = <span class="number">6</span>;</span><br><span class="line">	<span class="keyword">int</span> maxSum = maxNum * n;</span><br><span class="line">	<span class="keyword">int</span> minSum = n;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置记录骰子和出现次数的数组，和为 0 - (minSum-1) 的无需记录，因此无需maxSum长度，只需记录 minSum - maxSum 之间的数</span></span><br><span class="line">	<span class="keyword">int</span>* countSum = <span class="keyword">new</span> <span class="keyword">int</span>[maxSum - minSum + <span class="number">1</span>];</span><br><span class="line">	<span class="comment">//计数数组的初始化</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt;= maxSum; i++) &#123;</span><br><span class="line">		countSum[i - minSum] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//递归计算各种骰子和出现的次数</span></span><br><span class="line">	<span class="built_in">Probability</span>(n, countSum);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置概率分母</span></span><br><span class="line">	<span class="keyword">int</span> countMax = <span class="built_in">pow</span>(maxNum, n);</span><br><span class="line">	<span class="comment">//计算各骰子和出现的概率</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt;= maxSum; i++) &#123;</span><br><span class="line">		cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;概率: &quot;</span>;</span><br><span class="line">		cout &lt;&lt; countSum[i - minSum] &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; countMax &lt;&lt; <span class="string">&quot; ≈ &quot;</span>;</span><br><span class="line">		cout &lt;&lt; ((<span class="keyword">double</span>)(countSum[i - minSum])) / countMax &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//清理内存</span></span><br><span class="line">	<span class="keyword">delete</span>[] countSum;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintProbabilityNR</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断异常</span></span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//记录n个骰子和的最大值与最小值以及单个骰子的最大值</span></span><br><span class="line">	<span class="keyword">int</span> maxNum = <span class="number">6</span>;</span><br><span class="line">	<span class="keyword">int</span> maxSum = maxNum * n;</span><br><span class="line">	<span class="keyword">int</span> minSum = n;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//开辟暂存n个骰子点数和所有结果出现次数的数组</span></span><br><span class="line">	<span class="comment">//使用两个数组交替存放n-1个骰子的点数和所有结果出现次数 与 当前n个骰子的点数和所有结果出现次数</span></span><br><span class="line">	<span class="comment">//下标对应点数和，元素值为该点数和出现的次数</span></span><br><span class="line">	<span class="keyword">int</span>** curSum = <span class="keyword">new</span> <span class="keyword">int</span>*[<span class="number">2</span>];</span><br><span class="line">	curSum[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[maxSum + <span class="number">1</span>];</span><br><span class="line">	curSum[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[maxSum + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= maxSum; i++) &#123;</span><br><span class="line">		curSum[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">		curSum[<span class="number">1</span>][i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置交替时的标志位</span></span><br><span class="line">	<span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//记录一个骰子点数和的所有结果出现的次数</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxNum; i++) &#123;</span><br><span class="line">		curSum[flag][i] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//自下而上计算两个，三个，...，n个骰子的点数和结果的出现次数</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> Dicenum = <span class="number">2</span>; Dicenum &lt;= n; Dicenum++) &#123;</span><br><span class="line">		<span class="comment">//借用上次Dicenum - 1个骰子的点数和次数结果计算本次Dicenum个骰子的点数和出现结果</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//先清空记录本次Dicenum个骰子的点数和出现结果的数组</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= maxSum; i++) &#123;</span><br><span class="line">			curSum[<span class="number">1</span> - flag][i] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//记录Dicenum个骰子的每种点数和出现的次数，最小为Dicenum，最大为 maxNum * Dicenum</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> curDiceSum = Dicenum; curDiceSum &lt;= maxNum * Dicenum; curDiceSum++) &#123;</span><br><span class="line">			<span class="comment">//累加记录之前先清零</span></span><br><span class="line">			curSum[<span class="number">1</span> - flag][curDiceSum] = <span class="number">0</span>;</span><br><span class="line">			<span class="comment">//n个骰子时的和curDiceSum出现次数等于n-1个骰子时 f(curDiceSum-1) + f(curDiceSum-2) + ... + f(curDiceSum-6)</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> presum = <span class="number">1</span>; presum &lt;= curDiceSum &amp;&amp; presum &lt;= maxNum; presum++) &#123;</span><br><span class="line">				curSum[<span class="number">1</span> - flag][curDiceSum] += curSum[flag][curDiceSum - presum];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//交替数组，使用本次结果计算++Dicenum的结果</span></span><br><span class="line">		flag = <span class="number">1</span> - flag;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置概率分母</span></span><br><span class="line">	<span class="keyword">int</span> countMax = <span class="built_in">pow</span>(maxNum, n);</span><br><span class="line">	<span class="comment">//计算各骰子和出现的概率</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt;= maxSum; i++) &#123;</span><br><span class="line">		cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;概率: &quot;</span>;</span><br><span class="line">		cout &lt;&lt; curSum[flag][i] &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; countMax &lt;&lt; <span class="string">&quot; ≈ &quot;</span>;</span><br><span class="line">		cout &lt;&lt; ((<span class="keyword">double</span>)(curSum[flag][i])) / countMax &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//清理内存</span></span><br><span class="line">	<span class="keyword">delete</span>[] curSum[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">delete</span>[] curSum[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">delete</span>[] curSum;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="61-扑克牌中的顺子"><a href="#61-扑克牌中的顺子" class="headerlink" title="61 扑克牌中的顺子"></a>61 扑克牌中的顺子</h1><blockquote>
<p>从扑克牌中随机抽5张牌,判断是不是一个顺子,即这5张牌是不是连续的</p>
<p>2~10为数字本身, A为1,J为11, Q为12, K为13,而大,小王可以看成任意数字</p>
</blockquote>
<h2 id="Testing-case-79"><a href="#Testing-case-79" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(有一个/多个大小王，无大小王，有对子)</li>
<li>边界测试(nullptr)</li>
</ul>
<h2 id="Key-79"><a href="#Key-79" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>抽象建模 + 双指针</p>
<blockquote>
<ol>
<li>先对整型数组中的数字进行排序</li>
<li>对排序后的数组计算0:大小王的出现次数</li>
<li>从第一个不是0:大小王的位置起求各相邻数字的间隙数，并排除对子</li>
<li>通过判断大小王出现次数与相邻数字的间隙数大小，来判断是否大小王的张数能够填补非连续空隙，从而判断是否是顺子</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>扑克牌中的顺子可抽象为计算机中的整型数组中的连续数字，大小王用0表示</li>
<li>相邻元素的比较判断可使用间隔为1的双指针遍历</li>
<li>相邻数字的间隙数 = data[big] - data[small] - 1</li>
<li>使用T(n) = O(nlogn) 的qsort排序，因为扑克牌只有13种牌，而时间复杂度仅当n足够大时才有意义</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-77"><a href="#Answer-77" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* data1, <span class="keyword">const</span> <span class="keyword">void</span>* data2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> d1 = *((<span class="keyword">int</span>*)data1);</span><br><span class="line">	<span class="keyword">int</span> d2 = *((<span class="keyword">int</span>*)data2);</span><br><span class="line">	<span class="keyword">return</span> d1 - d2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsContinuous</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断异常</span></span><br><span class="line">	<span class="keyword">if</span> (data == <span class="literal">nullptr</span> || length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置记录扑克牌中记录 0:大小王，相邻数字间隙的变量</span></span><br><span class="line">	<span class="keyword">int</span> NumOfZero = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> NumOfGap = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//对数组进行排序</span></span><br><span class="line">	<span class="built_in">qsort</span>(data, length, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>), Compare);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//记录数组中0出现的次数</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (data[i] == <span class="number">0</span>) &#123;</span><br><span class="line">			NumOfZero++;</span><br><span class="line">			<span class="keyword">if</span> (NumOfZero &gt; <span class="number">2</span>) &#123;</span><br><span class="line">				isExcption = <span class="literal">true</span>;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line"></span><br><span class="line">	<span class="comment">//记录数组中所有数字的相邻数字的间隙大小</span></span><br><span class="line">	<span class="keyword">int</span> small = NumOfZero;</span><br><span class="line">	<span class="keyword">int</span> big = small + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (big != length) &#123;</span><br><span class="line">		<span class="comment">//排除对子</span></span><br><span class="line">		<span class="keyword">if</span> (data[small] == data[big]) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//累加计算间隙数</span></span><br><span class="line">		NumOfGap += data[big] - data[small] - <span class="number">1</span>;</span><br><span class="line">		<span class="comment">//向下遍历，移动游标</span></span><br><span class="line">		small = big++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过判断0:大小王是否能够填补空隙来判断是否为顺子</span></span><br><span class="line">	<span class="keyword">return</span> NumOfZero &gt;= NumOfGap ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="62-圆圈中最后剩下的数字"><a href="#62-圆圈中最后剩下的数字" class="headerlink" title="62 圆圈中最后剩下的数字"></a>62 圆圈中最后剩下的数字</h1><blockquote>
<p>0,1,..-1这n个数字排成一个圆圈,从数字0开始,每次从这个圆圈里删除第m个数字</p>
<p>求出这个圆圈里剩下的最后一个数字</p>
</blockquote>
<h2 id="Testing-case-80"><a href="#Testing-case-80" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(m&lt;n或m&gt;=n)</li>
<li>边界测试(0)</li>
<li>性能测试(n=4000,m=997)</li>
</ul>
<h2 id="Key-80"><a href="#Key-80" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>环形链表 T(n) = O(mn) S(n) = O(n)</p>
<blockquote>
<ol>
<li>使用双向链表模拟环状链表并将0至n-1的元素压入到链表中</li>
<li>剔除自0起的第m个元素，首先将迭代器自当前元素起移动至第m个元素(向后移动m-1次)，记录第m个元素的下一个元素，剔除第m个元素</li>
<li>自第m个元素在环状链表中的下一个元素起重复2，直至环状链表中的元素仅有一个</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>使用双向链表list模拟环形链表，注意遍历至end()迭代器时需要重置与链表首部</li>
</ol>
</blockquote>
</li>
<li><p>数学分析 + 递归or循环 T(n) = O(n) S(n) = O(1)</p>
<blockquote>
<p>有点顶，先不作要求</p>
</blockquote>
</li>
</ul>
<h2 id="Answer-78"><a href="#Answer-78" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> isExcption = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断异常</span></span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">0</span> || m &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//使用双向链表模拟环状链表</span></span><br><span class="line">	list&lt;<span class="keyword">int</span>&gt; RingList;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将0至n-1的元素压入到链表中</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		RingList.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置遍历迭代器</span></span><br><span class="line">	<span class="keyword">auto</span> currentIte = RingList.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//剔除自0起的第m个元素,直至仅剩一个元素</span></span><br><span class="line">	<span class="keyword">while</span> (RingList.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">//定位迭代器于自当前元素起的第m个元素</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">			currentIte++;</span><br><span class="line">			<span class="keyword">if</span> (currentIte == RingList.<span class="built_in">end</span>()) &#123;</span><br><span class="line">				<span class="comment">//通过手动设置来模拟环形链表</span></span><br><span class="line">				currentIte = RingList.<span class="built_in">begin</span>();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//记录环状链表中当前元素的下一个元素</span></span><br><span class="line">		<span class="keyword">auto</span> nextIte = ++currentIte;</span><br><span class="line">		<span class="keyword">if</span> (nextIte == RingList.<span class="built_in">end</span>()) &#123;</span><br><span class="line">			nextIte = RingList.<span class="built_in">begin</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//恢复currentIte迭代器指向元素</span></span><br><span class="line">		currentIte--;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//剔除元素</span></span><br><span class="line">		RingList.<span class="built_in">erase</span>(currentIte);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//向下遍历</span></span><br><span class="line">		currentIte = nextIte;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> *currentIte;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="63-股票的最大利润"><a href="#63-股票的最大利润" class="headerlink" title="63 股票的最大利润"></a>63 股票的最大利润</h1><blockquote>
<p>假设把某股票的价格按照时间先后顺序存储在数组中,请问买卖该股票一次可能获得的最大利润是多少?</p>
<p>例如,一只股票在某些时间节点的价格为{9,11,8,5,7,12,16,14},如果我们能在价格为5的时候买入并在价格为16时卖出,则能收获最大的利润11</p>
</blockquote>
<h2 id="Testing-case-81"><a href="#Testing-case-81" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(数组无序/单调递增/单调递减)</li>
<li>边界测试(nullptr，数组只有两个数字)</li>
</ul>
<h2 id="Key-81"><a href="#Key-81" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>蛮力尾部遍历 + 打擂 T(n) = S(n2)</p>
<blockquote>
<ol>
<li>自数组尾部开始，逐个元素作卖出点，向前遍历元素组成(卖出,买入)数对打擂计算最大利润</li>
<li>直至卖出点为数组第二个元素</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>暴力遍历，含多次重复计算，可进一步优化记录最小买入点并自首部遍历</li>
</ol>
</blockquote>
</li>
<li><p>最小买入 + 三指针 + 打擂 T(n) = S(n)</p>
<blockquote>
<ol>
<li>自首部遍历数组，通过curSell遍历数组，计算每一个元素(自第二个元素起)作卖出点时的最大利润</li>
<li>在进行本次利润计算前，先根据上次卖出点的值与最小买入点的值比较，更新最小买入点</li>
<li>计算本次最大利润并打擂记录至目前为止的最大利润</li>
<li>进行下一利润计算前，先更新preSell，curSell的状态</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>设置三个指针分别记录最小买入点smallestBuy，当前卖出点curSell与上一次卖出点preSell</li>
<li>curDiff = data[curSell] - data[smallestBuy] ，当前卖出点的最大利润为当前卖出值 - 之前最小买入值</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-79"><a href="#Answer-79" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> isExcption = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//股票的最大利润</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxDiff</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>*, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxDiff</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* data, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断异常</span></span><br><span class="line">	<span class="keyword">if</span> (data == <span class="literal">nullptr</span> || length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置记录股票最小买入点与当前卖出点的指针</span></span><br><span class="line">	<span class="keyword">int</span> smallestBuy = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> curSell = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//打擂记录big指向的元素作卖出点的最大利润</span></span><br><span class="line">	<span class="keyword">int</span> maxDiff = data[curSell] - data[smallestBuy];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//记录上一次卖出点的价格并向下遍历</span></span><br><span class="line">	<span class="keyword">int</span> preSell = curSell++;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历剩余元素，记录剩余元素作卖出点的最大利润</span></span><br><span class="line">	<span class="keyword">while</span> (curSell &lt; length) &#123;</span><br><span class="line">		<span class="comment">//若上一次卖出点的值小于最小买入点的值，则应在上一点买入，更新最小买入点</span></span><br><span class="line">		<span class="keyword">if</span> (data[preSell] &lt; data[smallestBuy]) &#123;</span><br><span class="line">			smallestBuy = preSell;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//计算当前最大利润</span></span><br><span class="line">		<span class="keyword">int</span> curDiff = data[curSell] - data[smallestBuy];</span><br><span class="line">		<span class="comment">//打擂记录到目前为止的最大利润</span></span><br><span class="line">		<span class="keyword">if</span> (curDiff &gt;= maxDiff) &#123;</span><br><span class="line">			maxDiff = curDiff;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//向后遍历</span></span><br><span class="line">		preSell = curSell;</span><br><span class="line">		curSell++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> maxDiff;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="64-求-1-2-…-n"><a href="#64-求-1-2-…-n" class="headerlink" title="64 求 1+2+…+n"></a>64 求 1+2+…+n</h1><blockquote>
<p>要求不能使用乘除法,for,while,if else,switch,case等关键字及条件判断语句(A?B:C)</p>
</blockquote>
<h2 id="Testing-case-82"><a href="#Testing-case-82" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(5,10)</li>
<li>边界测试(0，1)</li>
</ul>
<h2 id="Key-82"><a href="#Key-82" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>围绕循环与递归展开</p>
<blockquote>
<ol>
<li>创造循环实现累加</li>
<li>无法在一个函数中通过if完成递归，则设置两个函数，一个函数作递归函数使用，一个函数作bacecase终止递归使用</li>
<li>通过类似bool类型的变量选择调用的函数，!!n , n&gt;0时 !!n = true(1)，n=0时 !!n = false(0)</li>
</ol>
</blockquote>
</li>
<li><p>基于循环 - 构造函数 + 静态成员</p>
<blockquote>
<ol>
<li>创建一个类含两个静态成员变量，一个为N，一个为Sum，并初始化为0</li>
<li>设置相应的静态获取函数GetSum，用于返回静态成员变量Sum</li>
<li>在类的构造函数处对N进行累加，并使用Sum记录N的累加和</li>
<li>创建N个对象后，直接类名::GetSum()获取累加和</li>
</ol>
</blockquote>
</li>
<li><p>基于递归 - 函数指针</p>
<blockquote>
<ol>
<li>在递归函数中设置函数指针数组，并通过!!n来区分下标选择函数进行调用</li>
<li>当n=0时，!!0 = 0 ，选择arr[0]函数终止递归</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li> 设置一个静态函数指针数组存放两个函数地址，静态数组只会初始化一次</li>
</ol>
</blockquote>
</li>
<li><p>基于递归 - 虚函数</p>
<blockquote>
<ol>
<li>父类的待重写虚函数作终止递归函数</li>
<li>子类的重写函数中，根据!!n选择 父类/子类重写 函数进行绑定，调用GetSum方法</li>
<li>子类设置一个基类指针数组，并在构造函数中使用相应的指针参数完成初始化</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>通过虚函数的动态绑定完成对递归函数的选择</li>
</ol>
</blockquote>
</li>
<li><p>基于递归 - 非类型模板参数 + 模板特化</p>
<blockquote>
<ol>
<li>使用非类型模板类并基于枚举常量元素完成递归累加</li>
<li>递归终止时的枚举元素值由特化模板确定</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>当一个模板的参数非类型而是一个编译期间可确定的常量时，在模板中可直接使用该常量</li>
<li>递归编译时的递归深度受限，n不能太大</li>
<li>n必须能够在编译时确定，不能动态输入</li>
<li>使用枚举常量元素的值完成累加</li>
<li>编译时的递归</li>
<li>::作用域运算符 若运算符前无类/命名空间/结构体，则默认为全局作用域，可通过该运算符取对应作用域中共有的成员</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-80"><a href="#Answer-80" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<p>1.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于循环 - 构造函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GSum</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetSumFrom1TonByClass</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GSum</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">GSum</span>() &#123;</span><br><span class="line">		<span class="comment">//记录当前数字</span></span><br><span class="line">		N++;</span><br><span class="line">		<span class="comment">//记录累加和</span></span><br><span class="line">		Sum += N;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ResetSum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		N = Sum = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">GetSum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Sum;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> N;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> Sum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员初始化</span></span><br><span class="line"><span class="keyword">int</span> GSum::N = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> GSum::Sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetSumFrom1TonByClass</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//重置</span></span><br><span class="line">	GSum::<span class="built_in">ResetSum</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建n个GSum对象，进而累加1-n的和</span></span><br><span class="line">	GSum* arr = <span class="keyword">new</span> GSum[n];</span><br><span class="line">	<span class="comment">//清理内存</span></span><br><span class="line">	<span class="keyword">delete</span>[] arr;</span><br><span class="line">	arr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> GSum::<span class="built_in">GetSum</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于递归 - 函数指针</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*func)</span> <span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetSumByPointerBaseCase</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetSumByPointer</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetSumByPointer</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> func arr[<span class="number">2</span>] = &#123; GetSumByPointerBaseCase,GetSumByPointer &#125;;</span><br><span class="line">	<span class="keyword">return</span> arr[!!n](n - <span class="number">1</span>) + n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetSumByPointerBaseCase</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于递归 - 虚函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GSumByVirtualBase</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">GetSum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GSumByVirtual</span> :</span> <span class="keyword">public</span> GSumByVirtualBase &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">GSumByVirtual</span>(GSumByVirtualBase* GBS) :<span class="built_in">GSumByVirtualBase</span>() &#123;</span><br><span class="line">		arr[<span class="number">0</span>] = GBS;</span><br><span class="line">		arr[<span class="number">1</span>] = <span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">GetSum</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> n + arr[!!n]-&gt;<span class="built_in">GetSum</span>(n - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	GSumByVirtualBase* arr[<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetSumByVirtual</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetSumByVirtual</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	GSumByVirtualBase* GBS = <span class="keyword">new</span> <span class="built_in">GSumByVirtualBase</span>();</span><br><span class="line">	GSumByVirtual* GS = <span class="keyword">new</span> <span class="built_in">GSumByVirtual</span>(GBS);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> GS-&gt;<span class="built_in">GetSum</span>(n);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于递归 - 非类型模板参数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">const</span> <span class="keyword">int</span> n&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GetSumByTem</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">value</span> &#123;</span> N = GetSumByTem&lt;n - <span class="number">1</span>&gt;::N + n &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GetSumByTem</span>&lt;</span><span class="number">1</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">value</span> &#123;</span> N = <span class="number">1</span> &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="65-不用加减乘除做加法"><a href="#65-不用加减乘除做加法" class="headerlink" title="65 不用加减乘除做加法"></a>65 不用加减乘除做加法</h1><blockquote>
<p>写一个函数,求两个整数之和,要求在函数体内不得使用”+”,”-“,”×”,”÷”四则运算符号</p>
</blockquote>
<h2 id="Testing-case-83"><a href="#Testing-case-83" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(整数，负数)</li>
<li>边界测试(0)</li>
</ul>
<h2 id="Key-83"><a href="#Key-83" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>异或运算 + 与运算 + 移位运算 - 递归</p>
<blockquote>
<ol>
<li>通过异或运算，计算两数不产生进位的和</li>
<li>通过与运算后左移一位，计算两数产生的进位值</li>
<li>递归向下计算1,2结果的和，直至无进位产生，即进位值为0，则返回最终结果</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>可使用底层的位运算模拟加减乘除运算</li>
<li>加法的运算法则<ul>
<li>计算两数不产生进位的和</li>
<li>计算两数产生的进位值</li>
<li>计算上述两个结果的和</li>
</ul>
</li>
<li>二进制下的进位，逢2进1，若某位产生进位，则应左移一位(乘基数2)，才为进位值</li>
</ol>
</blockquote>
</li>
<li><p>异或运算 + 与运算 + 移位运算 - 循环</p>
<blockquote>
<pre><code>1. 通过异或运算，计算两数不产生进位的和
2. 通过与运算后左移一位，计算两数产生的进位值
3. 循环计算1,2结果的和，但是在进行下次计算之前需要记录本次计算的结果作下次的加数
4. 直至第二个加数(进位值)为0终止循环
</code></pre>
</blockquote>
</li>
</ul>
<h2 id="Answer-81"><a href="#Answer-81" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<p>1.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> isExcption = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加法计算 - 递归</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PlusByRecursive</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//base case </span></span><br><span class="line">	<span class="keyword">if</span> (num2 == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> num1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//记录两数不产生进位的和 异或运算结果</span></span><br><span class="line">	<span class="keyword">int</span> NoCarrySum = num1 ^ num2;</span><br><span class="line">	<span class="comment">//记录两数产生进位的和 与运算结果后左移一位</span></span><br><span class="line">	<span class="keyword">int</span> Carry = (num1 &amp; num2) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//计算上述两个结果的和</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">PlusByRecursive</span>(NoCarrySum, Carry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> isExcption = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加法计算 - 循环</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PlusNotByRecursive</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//a 记录两数不产生进位的和 异或运算结果</span></span><br><span class="line">		<span class="keyword">int</span> NoCarrySum = num1 ^ num2;</span><br><span class="line">		<span class="comment">//b 记录两数产生进位的和 与运算结果后左移一位</span></span><br><span class="line">		<span class="keyword">int</span> Carry = (num1 &amp; num2) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">		<span class="comment">//下次循环计算a+b，但是在进行下次计算之前需要记录本次计算的结果作下次的加数</span></span><br><span class="line">		num1 = NoCarrySum;</span><br><span class="line">		num2 = Carry;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">while</span> (num2 != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> num1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="65-1-不使用新的变量交换两个变量的值"><a href="#65-1-不使用新的变量交换两个变量的值" class="headerlink" title="65.1 不使用新的变量交换两个变量的值"></a>65.1 不使用新的变量交换两个变量的值</h1><blockquote>
<p>不使用新的变量交换两个变量的值</p>
</blockquote>
<h2 id="Key-84"><a href="#Key-84" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>异或运算</p>
<blockquote>
<p><code>注意:</code></p>
<ol>
<li>a0,b0为初始值，a1,b1为交换后的值</li>
<li>第一次异或结果含a0,b0</li>
<li>第二次异或将 (a0^b0) ^ b0，剔除结果中的b0，留下a0存于b1中，此时b1已交换为a0</li>
<li>第三次异或将 (a0^b0) ^ b1，剔除结果中的a0，留下b0存于a1中，此时完成交换</li>
</ol>
</blockquote>
</li>
<li><p>加减法运算</p>
<blockquote>
<p><code>注意:</code></p>
<ol>
<li>a0,b0为初始值，a1,b1为交换后的值</li>
<li>第一次加法结果为 a0 + b0</li>
<li>第二次减法将 (a0+b0) - b0，剔除结果中的b0，留下a0存于b1中，此时b1已交换为a0</li>
<li>第三次减法将 (a0+b0) - b1，剔除结果中的a0，留下b0存于a1中，此时完成交换</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Anwser"><a href="#Anwser" class="headerlink" title="Anwser"></a>Anwser</h2><blockquote>
<p>1.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a ^ b;</span><br><span class="line">b = a ^ b;</span><br><span class="line">a = a ^ b;</span><br></pre></td></tr></table></figure>

<p>2.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a + b;</span><br><span class="line">b = a - b;</span><br><span class="line">a = a - b;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="66-构建乘积数组"><a href="#66-构建乘积数组" class="headerlink" title="66 构建乘积数组"></a>66 构建乘积数组</h1><blockquote>
<p>暂略</p>
</blockquote>
<h1 id="67-把字符串转换为整数"><a href="#67-把字符串转换为整数" class="headerlink" title="67 把字符串转换为整数"></a>67 把字符串转换为整数</h1><blockquote>
<p>写一个函数，完成函数库中atoi函数的功能，把字符串转换为整数</p>
</blockquote>
<h2 id="Testing-case-84"><a href="#Testing-case-84" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(正数，负数，0)</li>
<li>边界测试(最大正整数，最小负整数)</li>
<li>特殊输入测试(nullptr,””,含非数字字符)</li>
</ul>
<h2 id="Key-85"><a href="#Key-85" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>基本 字符串 -&gt; 整数 方法</p>
<blockquote>
<ol>
<li><p>设置累加各位数字的long long变量num，并初始化为0</p>
</li>
<li><p>自首部遍历字符串，先根据首位判断数字正负情况，设置isNegative值</p>
</li>
<li><p>若2含+/-号，设置isNegative值后结束本次子循环，向下遍历</p>
</li>
<li><p>若当前判断字符是数字字符，则记录各位数字(数字+位)于num中，num = num * 10 + (*p - ‘0’)</p>
</li>
<li><p>进行下次记录前，先判断是否发生溢出</p>
</li>
<li><p>重复4,5直至遍历至字符串尾部，此时完成对整数绝对值的记录</p>
</li>
<li><p>根据isNegative返回正/负整数num</p>
</li>
</ol>
</blockquote>
</li>
<li><p>非法字符的考量</p>
<blockquote>
<p>isNumber完成是否为数字字符的考量，排除空字符串，非法字符串</p>
</blockquote>
</li>
<li><p>整数的三种情况</p>
<blockquote>
<ol>
<li>带+号的正数</li>
<li>不带+号的正数</li>
<li>带-号的负数</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>在对字符串各位进行判断并累加时，注意首位的字符情况</li>
<li>若为+号，更新状态，结束本次循环，继续向下遍历</li>
<li>若为-号，更新状态，结束本次循环，继续向下遍历</li>
<li>若为数字，则需要记录，然后向下遍历</li>
</ol>
</blockquote>
</li>
<li><p>异常处理</p>
<blockquote>
<p>设置全局变量作异常判断</p>
<p>若出现异常，在设置返回值为0并设置全局变量，最后通过全局变量值完成异常判断</p>
<p><code>注意:</code></p>
<ol>
<li>数字字符0与发生异常返回值相同，切记不要忘记对全局变量的判断来区分这两种返回情况</li>
</ol>
</blockquote>
</li>
<li><p>溢出判断</p>
<blockquote>
<ol>
<li><p>无法通过int型变量完成溢出的判断，借助范围更大的long long型完成溢出判断</p>
<p>int型最大值 = numeric_limits<int>::max() = 0x7FFFFFFF<br>int型最小值 = numeric_limits<int>::min() = (signed int)0x80000000</int></int></p>
</li>
<li><p>进行溢出判断时，不能仅根据绝对值的大小完成溢出判断，而需要结合整数的正负情况来完成最大正整数与最小负整数的溢出判断</p>
</li>
</ol>
</blockquote>
</li>
<li><p>一元减运算符</p>
<blockquote>
<p>作用于单个操作数以产生新值</p>
<p><code>注意:</code></p>
<ol>
<li>当一元减运算符作用于无符号整数时，返回值不是其取反值，而是该无符号整数本身</li>
<li>-2147483648表达式分两阶段进行<ul>
<li>判断2147483648作为int型已溢出，因此将其当做unsigned int处理</li>
<li>-2147483648结果为2147483648</li>
</ul>
</li>
<li>-2147483648 != (signed int)2147483648</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-82"><a href="#Answer-82" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串转换为整数</span></span><br><span class="line"><span class="keyword">bool</span> isExcption = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isNumber</span><span class="params">(<span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> isNum = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断空串</span></span><br><span class="line">	<span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">		isNum = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断是否为数字字符串，含空格判断，以及正负号判断</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//判断首字符是否为+,-号，若均不是，则进而判断是否为数字字符</span></span><br><span class="line">		<span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; str[i] == <span class="string">&#x27;+&#x27;</span> || i == <span class="number">0</span> &amp;&amp; str[i] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//判断剩余字符是否为数字字符</span></span><br><span class="line">		<span class="keyword">if</span> (str[i]&lt;<span class="string">&#x27;0&#x27;</span> || str[i]&gt;<span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">			isNum = <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> isNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(<span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//边界异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (str == <span class="literal">nullptr</span> || !<span class="built_in">isNumber</span>(str)) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//转换字符串</span></span><br><span class="line">	<span class="keyword">char</span>*p = str;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断是否为首位</span></span><br><span class="line">	<span class="keyword">bool</span> isFirst = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">bool</span> isNegative = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (*p != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">		<span class="comment">//判断正负号</span></span><br><span class="line">		<span class="keyword">if</span> (isFirst &amp;&amp; (*p) == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">			isNegative = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//向下遍历</span></span><br><span class="line">			p++;</span><br><span class="line">			<span class="comment">//更新首位判断遍历状态</span></span><br><span class="line">			isFirst = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (isFirst &amp;&amp; (*p) == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">			<span class="comment">//向下遍历</span></span><br><span class="line">			p++;</span><br><span class="line">			<span class="comment">//更新首位判断遍历状态</span></span><br><span class="line">			isFirst = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//累加转换为数字</span></span><br><span class="line">		num = num * <span class="number">10</span> + (*p - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//进行下次前先判断当前是否产生越界溢出,正数判断最大正整数溢出，负数判断最小负整数溢出</span></span><br><span class="line">		<span class="keyword">if</span> ((!isNegative &amp;&amp; num &gt; <span class="number">0x7fffffff</span>) || (isNegative &amp;&amp; num &lt; (<span class="keyword">signed</span> <span class="keyword">int</span>)<span class="number">0x80000000</span>)) &#123;</span><br><span class="line">			isExcption = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		<span class="comment">//向下遍历</span></span><br><span class="line">		p++;</span><br><span class="line">		<span class="comment">//更新首位判断遍历状态</span></span><br><span class="line">		isFirst = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> isNegative ? -num : num;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="68-链表的第一个公共结点"><a href="#68-链表的第一个公共结点" class="headerlink" title="68 链表的第一个公共结点"></a>68 链表的第一个公共结点</h1><blockquote>
<p>输入两个链表,找出它们的第一个公共节点</p>
</blockquote>
<h2 id="Testing-case-85"><a href="#Testing-case-85" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(两个链表 有/无 公共结点，两个链表的公共结点位于首部/尾部/中部)</li>
<li>边界测试(nullptr)</li>
</ul>
<h2 id="Key-86"><a href="#Key-86" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>两个链表组合型</p>
<blockquote>
<p>含公共结点的两个链表组合型可以为Y型(公共结点位于链表中间)，V型(公共结点位于链表末尾)，l型(公共结点位于链表首部)</p>
<p>上为链表首部，下为链表尾部</p>
</blockquote>
</li>
<li><p>蛮力首部遍历 T(n) = O(mn)</p>
</li>
<li><p>尾部遍历 + 辅助栈 T(n) = O(m+n) S(n) = O(m+n)</p>
<blockquote>
<ol>
<li>将两个链表元素分别压入两个栈，设置pCommonNode指针指向公共结点，初始为nullptr</li>
<li>判断两个栈的栈顶结点是否为公共结点</li>
<li>若是公共结点，则使用pCommonNode指针记录当前公共结点，弹出栈顶结点后继续2，直至某一栈为空</li>
<li>若不是公共结点，则跳出循环，返回pCommonNode</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>单链表无法完成尾部遍历，因此使用辅助栈完成结点的尾部遍历</li>
<li>自尾部开始查找第一个产生分叉的结点(两链表自该结点后的下一个结点值不同)，该结点即为第一个公共结点</li>
</ol>
</blockquote>
</li>
<li><p>同步移动 T(n) = O(m+n) S(n) = O(1)</p>
<blockquote>
<ol>
<li>设置较长链表的遍历指针pLongerHead，默认为pHead1</li>
<li>计算两个链表的表长并计算偏移量pOffset，初始为pLen1-pLen2</li>
<li>根据两链表表长判断使pLongerHead指向较长链表的表头</li>
<li>先将pLongerHead后移|pOffset|个单位</li>
<li>同步移动pShorterHead，pLongerHead，使用pCommonNode记录第一次值相同的结点，直至表尾</li>
<li>返回pCommonNode</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>将较长链表先向后偏移pOffset(两链表长度之差的绝对值)，因为确保两个链表遍历指针同时到达尾部</li>
<li>若两个表长不同的链表含公共结点，则该公共结点一定不存在于较长链表的前pOffset个结点中</li>
<li>取代蛮力法中固定一链表结点遍历另一个链表的方法，时间效率更高</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-83"><a href="#Answer-83" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<p>1.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">GetFirstCommonNodeByStack</span><span class="params">(ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (pHead1 == <span class="literal">nullptr</span> || pHead2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置两个辅助栈分别存放两个链表的结点</span></span><br><span class="line">	stack&lt;ListNode*&gt; pStack1;</span><br><span class="line">	stack&lt;ListNode*&gt; pStack2;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历两个链表并分别将结点压栈</span></span><br><span class="line">	ListNode* pNode1 = pHead1;</span><br><span class="line">	ListNode* pNode2 = pHead2;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (pNode1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		pStack1.<span class="built_in">push</span>(pNode1);</span><br><span class="line">		pNode1 = pNode1-&gt;pNext;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (pNode2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		pStack2.<span class="built_in">push</span>(pNode2);</span><br><span class="line">		pNode2 = pNode2-&gt;pNext;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//根据栈中结点从尾结点开始向前比较是否存在 Y or V 型公共链表结点</span></span><br><span class="line">	<span class="comment">//设置指针存放公共结点的地址</span></span><br><span class="line">	ListNode* pCommonNode = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (pStack1.<span class="built_in">size</span>() != <span class="number">0</span> &amp;&amp; pStack2.<span class="built_in">size</span>() != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (pStack1.<span class="built_in">top</span>()-&gt;pValue == pStack2.<span class="built_in">top</span>()-&gt;pValue) &#123;</span><br><span class="line">			pCommonNode = pStack1.<span class="built_in">top</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		pStack1.<span class="built_in">pop</span>();</span><br><span class="line">		pStack2.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pCommonNode;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetListLength</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	ListNode* pNode = pHead;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (pNode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		len++;</span><br><span class="line">		pNode = pNode-&gt;pNext;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">GetFirstCommonNode</span><span class="params">(ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//异常判断</span></span><br><span class="line">	<span class="keyword">if</span> (pHead1 == <span class="literal">nullptr</span> || pHead2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		isExcption = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置两个指针分别指向较长的链表头和较短的链表头</span></span><br><span class="line">	ListNode* pLongerHead = pHead1;</span><br><span class="line">	ListNode* pShorterHead = pHead2;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//取两个链表的长度，并获取两链表长度之差</span></span><br><span class="line">	<span class="keyword">int</span> pLen1 = <span class="built_in">GetListLength</span>(pHead1);</span><br><span class="line">	<span class="keyword">int</span> pLen2 = <span class="built_in">GetListLength</span>(pHead2);</span><br><span class="line">	<span class="keyword">int</span> pOffset = pLen1 - pLen2;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//使两个指针分别指向较长的链表头和较短的链表头</span></span><br><span class="line">	<span class="keyword">if</span> (pLen2 &gt; pLen1) &#123;</span><br><span class="line">		pLongerHead = pHead2;</span><br><span class="line">		pShorterHead = pHead1;</span><br><span class="line">		<span class="comment">//使差值取正</span></span><br><span class="line">		pOffset = -pOffset;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//先将指向长度较长链表的指针后移pOffset，使两个指针同步移动</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pOffset; i++) &#123;</span><br><span class="line">		pLongerHead = pLongerHead-&gt;pNext;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//向后遍历，直至找到第一个公共结点或至末尾</span></span><br><span class="line">	<span class="keyword">while</span> (pLongerHead != <span class="literal">nullptr</span> &amp;&amp; pShorterHead != <span class="literal">nullptr</span> &amp;&amp; pLongerHead-&gt;pValue != pShorterHead-&gt;pValue) &#123;</span><br><span class="line">		pLongerHead = pLongerHead-&gt;pNext;</span><br><span class="line">		pShorterHead = pShorterHead-&gt;pNext;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ListNode* pCommonNode = pLongerHead;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pCommonNode;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="69-树中两个结点的最低公共祖先"><a href="#69-树中两个结点的最低公共祖先" class="headerlink" title="69 树中两个结点的最低公共祖先"></a>69 树中两个结点的最低公共祖先</h1><blockquote>
<p>输入两个树节点,求它们的最低公共祖先</p>
<p>二叉搜索树，含/不含 指向父结点指针的普通树</p>
</blockquote>
<h2 id="Testing-case-86"><a href="#Testing-case-86" class="headerlink" title="Testing case"></a>Testing case</h2><ul>
<li>功能测试(普通二叉树，退化为链表的树)</li>
<li>边界测试(nullptr)</li>
</ul>
<h2 id="Key-87"><a href="#Key-87" class="headerlink" title="Key"></a>Key</h2><ul>
<li><p>最低公共祖先</p>
<blockquote>
<p>若两个结点为同一个结点，则返回其本身</p>
<p>若两个结点在同一条路径上，则返回更靠近根结点的结点</p>
</blockquote>
</li>
<li><p>二叉搜索树</p>
<blockquote>
<ol>
<li>由根结点开始作判断，若当前结点比两结点值都大，则在此根结点的左子树中查找</li>
<li>若当前结点比两结点值都小，则在此根结点的右子树中查找</li>
<li>若当前结点值介于两结点值之间或等于其中一者，则返回该根结点</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>由于二叉搜索树性质，所以最低公共祖先一定是值介于两者之间的的结点(含等于某一结点)</li>
<li>注意若结点不在树结构中，本方法无法作出异常判断，需要先判断结点是否位于树结构中</li>
</ol>
</blockquote>
</li>
<li><p>含指向父结点指针的普通树</p>
<blockquote>
<ol>
<li>自两个结点开始，分别依据pParent指针向上遍历，直接将遍历的结点分别压入栈</li>
<li>设置记录最低公共祖先的指针pCommon，初始为nullptr</li>
<li>自两个栈的栈顶开始找寻(自两链表尾部开始)第一个不相等结点，若两栈顶结点值相同，则记录该结点并弹出向下找寻，直至某一个栈为空</li>
<li>返回pCommon</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>转换为两个链表的第一个公共结点，两个链表的表头分别为pNode1，pNode2，表尾均为pHead</li>
<li>注意若结点不在树结构中，本方法返回nullptr</li>
<li>栈由栈顶-&gt;栈底 存放 链表尾部-&gt;链表首部</li>
</ol>
</blockquote>
</li>
<li><p>不含指向父结点指针的普通树</p>
<blockquote>
<p><strong>获取根节点 -&gt; 要求结点 的路径链表</strong></p>
<ol>
<li>基于先序遍历，使用两个双向链表List，分别记录到两个结点的路径上的所有结点</li>
<li>先将记录当前遍历结点，并判断当前路径是否为要求路径，即当前压入结点是否等于给定结点value值</li>
<li>若当前压入结点等于给定结点value值，则已找到要求路径，设置返回值，返回结果</li>
<li>若不等，则进而在该结点的左子树中继续查找路径</li>
<li>当左子树中仍不存在要求路径时，进而在该根结点的右子树中查找路径</li>
<li>最后若hasPath仍等于false，表明要求路径不含当前结点，剔除已记录的当前结点</li>
<li>返回判断结果</li>
</ol>
<p><strong>根据路径链表找寻最低公共祖先</strong></p>
<ol>
<li>正向遍历两个路径链表，若遍历的两个结点值相同，则表明该结点可能为其公共祖先，记录于pCommon指针中</li>
<li>若遍历的两个结点值不相同，则上一次pCommon指针记录结点即为最低公共祖先</li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>普通树的递归遍历只能是基于前序/中序/后序遍历，对先序遍历进行改良，添加遍历左右子树的条件</li>
<li>对左右子树遍历的先决条件是当前仍为找到要求路径(hasPath==false)</li>
<li>注意若要求路径不含当前结点，需要回溯剔除</li>
<li>对路径链表的正向遍历，即从尾部遍历(根节点)找寻两链表的的第一个公共结点</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Answer-84"><a href="#Answer-84" class="headerlink" title="Answer"></a>Answer</h2><blockquote>
<ol>
<li>二叉搜索树</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">GetLastCommonNodeCore</span><span class="params">(TreeNode* pHead, TreeNode* pNode1, TreeNode* pNode2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//base case</span></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//若当前结点比两个结点值都大，根据二叉搜索树性质，在其左子树中继续查找</span></span><br><span class="line">	<span class="keyword">if</span> (pHead-&gt;pValue &gt; pNode1-&gt;pValue &amp;&amp; pHead-&gt;pValue &gt; pNode2-&gt;pValue) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">GetLastCommonNodeCore</span>(pHead-&gt;pLeft, pNode1, pNode2);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//若当前结点比两个结点值都小，根据二叉搜索树性质，在其右子树中继续查找</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pHead-&gt;pValue &lt; pNode1-&gt;pValue &amp;&amp; pHead-&gt;pValue &lt; pNode2-&gt;pValue) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">GetLastCommonNodeCore</span>(pHead-&gt;pRight, pNode1, pNode2);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//此时pHead结点值要么介于两结点之间，要么等于其中一者的值</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> pHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">GetLastCommonNode</span><span class="params">(TreeNode* pHead, TreeNode* pNode1, TreeNode* pNode2)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断异常</span></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span> || pNode1 == <span class="literal">nullptr</span> || pNode2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		isException = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;																													<span class="comment">//应添加判断两结点是否位于树结构中的异常判断</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">GetLastCommonNodeCore</span>(pHead, pNode1, pNode2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>含指向父结点指针的普通树</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> pValue;</span><br><span class="line">	TreeNode* pLeft;</span><br><span class="line">	TreeNode* pRight;</span><br><span class="line">	TreeNode* pParent;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">GetLastCommonNodeCoreByStack</span><span class="params">(TreeNode* pNode1, TreeNode* pNode2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置两个辅助栈</span></span><br><span class="line">	stack&lt;TreeNode*&gt; List1;</span><br><span class="line">	stack&lt;TreeNode*&gt; List2;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将两个链表结点分别压栈</span></span><br><span class="line">	<span class="keyword">while</span> (pNode1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		List1.<span class="built_in">push</span>(pNode1);</span><br><span class="line">		pNode1 = pNode1-&gt;pParent;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (pNode2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		List2.<span class="built_in">push</span>(pNode2);</span><br><span class="line">		pNode2 = pNode2-&gt;pParent;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置记录公共祖先的指针</span></span><br><span class="line">	TreeNode* pCommon = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//自链表尾部开始找寻第一次产生分叉的结点</span></span><br><span class="line">	<span class="keyword">while</span> (!List1.<span class="built_in">empty</span>() &amp;&amp; !List2.<span class="built_in">empty</span>() &amp;&amp; List1.<span class="built_in">top</span>() == List2.<span class="built_in">top</span>()) &#123;</span><br><span class="line">		</span><br><span class="line">		pCommon = List1.<span class="built_in">top</span>();</span><br><span class="line">		List1.<span class="built_in">pop</span>();</span><br><span class="line">		List2.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;		</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pCommon;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">GetLastCommonNode</span><span class="params">(TreeNode* pNode1, TreeNode* pNode2)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断异常</span></span><br><span class="line">	<span class="keyword">if</span> (pNode1 == <span class="literal">nullptr</span> || pNode2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		isException = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">GetLastCommonNodeCoreByStack</span>(pNode1, pNode2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>不含指向父结点指针的普通树</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通树中两个结点的最低公共祖先</span></span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">GetLastCommonNodeCore</span><span class="params">(list&lt;TreeNode*&gt;&amp; PathList1, list&lt;TreeNode*&gt;&amp; PathList2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置记录公共结点的指针</span></span><br><span class="line">	TreeNode* pCommon = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//正向遍历两个链表(根节点为头结点)，找寻第一个产生分叉的结点</span></span><br><span class="line">	<span class="keyword">auto</span> ite1 = PathList1.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">auto</span> ite2 = PathList2.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (ite1 != PathList1.<span class="built_in">end</span>() &amp;&amp; ite2 != PathList2.<span class="built_in">end</span>()) &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> ((*ite1)-&gt;pValue == (*ite2)-&gt;pValue) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//记录当前公共结点</span></span><br><span class="line">			pCommon = *ite1;</span><br><span class="line">			<span class="comment">//向后遍历</span></span><br><span class="line">			ite1++;</span><br><span class="line">			ite2++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pCommon;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetLastCommonNodePath</span><span class="params">(TreeNode* pHead, TreeNode* pNode, list&lt;TreeNode*&gt;&amp; PathList)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置返回值记录变量</span></span><br><span class="line">	<span class="keyword">bool</span> hasPath = <span class="literal">false</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//路径链表中记录当前遍历结点</span></span><br><span class="line">	PathList.<span class="built_in">push_back</span>(pHead);	</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断当前压入结点构成的路径是否为要求的路径</span></span><br><span class="line">	<span class="keyword">if</span> (pHead-&gt;pValue == pNode-&gt;pValue) &#123;</span><br><span class="line">		hasPath = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//若当前压入结点构成的路径不满足要求，则在当前结点的左子树中继续找寻路径</span></span><br><span class="line">	<span class="keyword">if</span> (!hasPath &amp;&amp; pHead-&gt;pLeft != <span class="literal">nullptr</span>)</span><br><span class="line">		hasPath = <span class="built_in">GetLastCommonNodePath</span>(pHead-&gt;pLeft, pNode, PathList);</span><br><span class="line">	<span class="comment">//若左子树中未找寻到路径，则在当前结点的右子树中继续找寻路径</span></span><br><span class="line">	<span class="keyword">if</span> (!hasPath &amp;&amp; pHead-&gt;pRight != <span class="literal">nullptr</span>)</span><br><span class="line">		hasPath = <span class="built_in">GetLastCommonNodePath</span>(pHead-&gt;pRight, pNode, PathList);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//回溯</span></span><br><span class="line">	<span class="keyword">if</span>(!hasPath)</span><br><span class="line">		PathList.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> hasPath;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">GetLastCommonNode</span><span class="params">(TreeNode* pHead, TreeNode* pNode1, TreeNode* pNode2)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断异常</span></span><br><span class="line">	<span class="keyword">if</span> (pHead == <span class="literal">nullptr</span> || pNode1 == <span class="literal">nullptr</span> || pNode2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		isException = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建存储路径的辅助空间</span></span><br><span class="line">	list&lt;TreeNode*&gt; PathList1;</span><br><span class="line">	list&lt;TreeNode*&gt; PathList2;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置返回值</span></span><br><span class="line">	TreeNode* pCommonNode = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取根结点到两个结点的路径，若有一条路径不存在，则无公共结点</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">GetLastCommonNodePath</span>(pHead, pNode1, PathList1) &amp;&amp; <span class="built_in">GetLastCommonNodePath</span>(pHead, pNode2, PathList2)) &#123;</span><br><span class="line">		pCommonNode = <span class="built_in">GetLastCommonNodeCore</span>(PathList1, PathList2);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pCommonNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">YunDid</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/10/30/Algorithm_Structure/SwordToOffer/">http://example.com/2021/10/30/Algorithm_Structure/SwordToOffer/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">YunDid's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Algorithm-and-DataStruture/">Algorithm and DataStruture</a></div><div class="post_share"><div class="social-share" data-image="/img/ma3.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/03/22/SVN/%E6%96%B0%E4%BA%BATortoiseSVN%E5%85%A5%E9%97%A8/"><img class="prev-cover" src="/img/ma3.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">TurtoiseSVN</div></div></a></div><div class="next-post pull-right"><a href="/2021/08/11/C++Primer/Design_Mode/"><img class="next-cover" src="/img/ma3.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Design mode / 设计模式</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/07/07/Algorithm_Structure/A_plus_D/" title="Algorithm and DataStruture -Primary"><img class="cover" src="/img/ma3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-07</div><div class="title">Algorithm and DataStruture -Primary</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/1.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">YunDid</div><div class="author-info__description">欢迎来到 YunDid's Blog！有疑问可以到 “留言板” 提问！^_^</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">46</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/YunDid"><i class="fab fa-github"></i><span>博主的GitHub首页</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/YunDid" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:512862613@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">萌新一枚~</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#DataStruct-and-Algorithm"><span class="toc-number">1.</span> <span class="toc-text">DataStruct and Algorithm</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E5%87%BD%E6%95%B0"><span class="toc-number">2.</span> <span class="toc-text">1 赋值运算符函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case"><span class="toc-number">2.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key"><span class="toc-number">2.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer"><span class="toc-number">2.3.</span> <span class="toc-text">Answer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E8%A7%A3%E6%B3%95"><span class="toc-number">2.3.1.</span> <span class="toc-text">经典解法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%80%83%E8%99%91%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">2.3.2.</span> <span class="toc-text">考虑异常安全性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-1-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-number">3.</span> <span class="toc-text">2.1 数组中重复的数字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-1"><span class="toc-number">3.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-1"><span class="toc-number">3.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-1"><span class="toc-number">3.3.</span> <span class="toc-text">Answer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8-T-n-O-n-S-n-O-n"><span class="toc-number">3.3.1.</span> <span class="toc-text">哈希表 T(n)&#x3D;O(n) S(n)&#x3D;O(n)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%92%E4%BD%8D%E6%B3%95-T-n-O-n-S-n-O-1"><span class="toc-number">3.3.2.</span> <span class="toc-text">归位法 T(n)&#x3D;O(n) S(n)&#x3D;O(1)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-2-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97"><span class="toc-number">4.</span> <span class="toc-text">2.2 数组中的重复数字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-2"><span class="toc-number">4.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-2"><span class="toc-number">4.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-2"><span class="toc-number">4.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="toc-number">5.</span> <span class="toc-text">4 二维数组中的查找</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-3"><span class="toc-number">5.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-3"><span class="toc-number">5.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-3"><span class="toc-number">5.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-1-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC"><span class="toc-number">6.</span> <span class="toc-text">5.1 替换空格</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-4"><span class="toc-number">6.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-4"><span class="toc-number">6.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-4"><span class="toc-number">6.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-2-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-number">7.</span> <span class="toc-text">5.2 合并两个有序数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-5"><span class="toc-number">7.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-5"><span class="toc-number">7.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-5"><span class="toc-number">7.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8"><span class="toc-number">8.</span> <span class="toc-text">6 从尾到头打印链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-6"><span class="toc-number">8.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-6"><span class="toc-number">8.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-6"><span class="toc-number">8.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">9.</span> <span class="toc-text">7 重建二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-7"><span class="toc-number">9.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-7"><span class="toc-number">9.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-7"><span class="toc-number">9.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="toc-number">10.</span> <span class="toc-text">8 二叉树的下一个结点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-8"><span class="toc-number">10.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-8"><span class="toc-number">10.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-8"><span class="toc-number">10.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="toc-number">11.</span> <span class="toc-text">9 用两个栈实现队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-9"><span class="toc-number">11.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-9"><span class="toc-number">11.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-9"><span class="toc-number">11.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-%E7%94%A8%E4%B8%A4%E4%B8%AA%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88"><span class="toc-number">12.</span> <span class="toc-text">10 用两个队列实现栈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-10"><span class="toc-number">12.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-10"><span class="toc-number">12.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-10"><span class="toc-number">12.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="toc-number">13.</span> <span class="toc-text">11 斐波那契数列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-11"><span class="toc-number">13.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-11"><span class="toc-number">13.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-T-n-O-n"><span class="toc-number">13.3.</span> <span class="toc-text">Answer - T(n) &#x3D; O(n)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-1-%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6"><span class="toc-number">14.</span> <span class="toc-text">11.1 青蛙跳台阶</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-12"><span class="toc-number">14.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-12"><span class="toc-number">14.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-11"><span class="toc-number">14.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-2-%E9%9D%92%E8%9B%99%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6"><span class="toc-number">15.</span> <span class="toc-text">11.2 青蛙变态跳台阶</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-13"><span class="toc-number">15.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-13"><span class="toc-number">15.2.</span> <span class="toc-text">Key</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%80%94-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E2%80%94"><span class="toc-number">16.</span> <span class="toc-text">—- 快速排序算法 —-</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-14"><span class="toc-number">16.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-14"><span class="toc-number">16.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-12"><span class="toc-number">16.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97"><span class="toc-number">17.</span> <span class="toc-text">12 旋转数组最小数字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-15"><span class="toc-number">17.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-15"><span class="toc-number">17.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-13"><span class="toc-number">17.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%80%94-Exhaustive-Search-%E7%A9%B7%E4%B8%BE%E6%90%9C%E7%B4%A2-%E2%80%94"><span class="toc-number">18.</span> <span class="toc-text">—- Exhaustive Search 穷举搜索 —-</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Pattern-%E5%86%B3%E7%AD%96%E6%A0%91%E4%B8%8B%E7%9A%84%E9%80%92%E5%BD%92"><span class="toc-number">18.1.</span> <span class="toc-text">Pattern - 决策树下的递归</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="toc-number">19.</span> <span class="toc-text">13 矩阵中的路径</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-16"><span class="toc-number">19.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-16"><span class="toc-number">19.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-14"><span class="toc-number">19.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4"><span class="toc-number">20.</span> <span class="toc-text">14 机器人的运动范围</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-17"><span class="toc-number">20.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-17"><span class="toc-number">20.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-15"><span class="toc-number">20.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15-%E5%89%AA%E7%BB%B3%E5%AD%90"><span class="toc-number">21.</span> <span class="toc-text">15 剪绳子</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-18"><span class="toc-number">21.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-18"><span class="toc-number">21.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-16"><span class="toc-number">21.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#16-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-number">22.</span> <span class="toc-text">16 二进制中1的个数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-19"><span class="toc-number">22.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-19"><span class="toc-number">22.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-17"><span class="toc-number">22.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#17-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9"><span class="toc-number">23.</span> <span class="toc-text">17 数值的整数次方</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-20"><span class="toc-number">23.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-20"><span class="toc-number">23.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-18"><span class="toc-number">23.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#18-%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0"><span class="toc-number">24.</span> <span class="toc-text">18 打印从1到最大的n位数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-21"><span class="toc-number">24.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-21"><span class="toc-number">24.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-19"><span class="toc-number">24.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#19-1-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BB%93%E7%82%B9"><span class="toc-number">25.</span> <span class="toc-text">19.1 删除链表的结点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-22"><span class="toc-number">25.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-22"><span class="toc-number">25.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-20"><span class="toc-number">25.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#19-2-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E8%BF%9E%E7%BB%AD%E7%BB%93%E7%82%B9"><span class="toc-number">26.</span> <span class="toc-text">19.2 删除链表中的重复连续结点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-23"><span class="toc-number">26.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-23"><span class="toc-number">26.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-21"><span class="toc-number">26.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#20-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="toc-number">27.</span> <span class="toc-text">20 正则表达式匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-24"><span class="toc-number">27.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-24"><span class="toc-number">27.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-22"><span class="toc-number">27.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#21-%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">28.</span> <span class="toc-text">21 表示数值的字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-25"><span class="toc-number">28.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-25"><span class="toc-number">28.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-23"><span class="toc-number">28.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#22-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2"><span class="toc-number">29.</span> <span class="toc-text">22 调整数组顺序使奇数位于偶数前面</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-26"><span class="toc-number">29.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-26"><span class="toc-number">29.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-24"><span class="toc-number">29.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#23-1-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="toc-number">30.</span> <span class="toc-text">23.1 链表中倒数第k个结点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-27"><span class="toc-number">30.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-27"><span class="toc-number">30.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-25"><span class="toc-number">30.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#23-2-%E6%B1%82%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9"><span class="toc-number">31.</span> <span class="toc-text">23.2 求链表的中间结点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-28"><span class="toc-number">31.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-28"><span class="toc-number">31.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-26"><span class="toc-number">31.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#24-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9"><span class="toc-number">32.</span> <span class="toc-text">24 链表中环的入口结点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-29"><span class="toc-number">32.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-29"><span class="toc-number">32.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-27"><span class="toc-number">32.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#25-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">33.</span> <span class="toc-text">25 反转链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-30"><span class="toc-number">33.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-30"><span class="toc-number">33.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-28"><span class="toc-number">33.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#26-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8"><span class="toc-number">34.</span> <span class="toc-text">26 合并两个排序的链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-31"><span class="toc-number">34.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-31"><span class="toc-number">34.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-29"><span class="toc-number">34.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#27-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84"><span class="toc-number">35.</span> <span class="toc-text">27 树的子结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-32"><span class="toc-number">35.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-32"><span class="toc-number">35.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-30"><span class="toc-number">35.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#28-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F"><span class="toc-number">36.</span> <span class="toc-text">28 二叉树的镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-33"><span class="toc-number">36.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-33"><span class="toc-number">36.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-31"><span class="toc-number">36.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#29-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">37.</span> <span class="toc-text">29 对称的二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-34"><span class="toc-number">37.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-34"><span class="toc-number">37.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-32"><span class="toc-number">37.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#30-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5"><span class="toc-number">38.</span> <span class="toc-text">30 顺时针打印矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-35"><span class="toc-number">38.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-35"><span class="toc-number">38.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-33"><span class="toc-number">38.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#31-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88"><span class="toc-number">39.</span> <span class="toc-text">31 包含min函数的栈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-36"><span class="toc-number">39.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-36"><span class="toc-number">39.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-34"><span class="toc-number">39.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#32-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5-%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97"><span class="toc-number">40.</span> <span class="toc-text">32 栈的压入,弹出序列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-37"><span class="toc-number">40.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-37"><span class="toc-number">40.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-35"><span class="toc-number">40.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#33-1-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">41.</span> <span class="toc-text">33.1 从上到下打印二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-38"><span class="toc-number">41.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-38"><span class="toc-number">41.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-36"><span class="toc-number">41.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#33-2-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">42.</span> <span class="toc-text">33.2 从上到下打印二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-39"><span class="toc-number">42.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-39"><span class="toc-number">42.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-37"><span class="toc-number">42.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#33-3-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">43.</span> <span class="toc-text">33.3 从上到下打印二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-40"><span class="toc-number">43.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-40"><span class="toc-number">43.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-38"><span class="toc-number">43.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#34-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97"><span class="toc-number">44.</span> <span class="toc-text">34 二叉搜索树的后序遍历序列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-41"><span class="toc-number">44.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-41"><span class="toc-number">44.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-39"><span class="toc-number">44.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#35-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="toc-number">45.</span> <span class="toc-text">35 二叉树中和为某一值的路径</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-42"><span class="toc-number">45.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-42"><span class="toc-number">45.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-40"><span class="toc-number">45.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#36-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="toc-number">46.</span> <span class="toc-text">36 复杂链表的复制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-43"><span class="toc-number">46.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-43"><span class="toc-number">46.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-41"><span class="toc-number">46.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#37-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">47.</span> <span class="toc-text">37 二叉搜索树与双向链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-44"><span class="toc-number">47.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-44"><span class="toc-number">47.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-42"><span class="toc-number">47.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#38-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">48.</span> <span class="toc-text">38 序列化二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-45"><span class="toc-number">48.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-45"><span class="toc-number">48.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-43"><span class="toc-number">48.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#39-1-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97"><span class="toc-number">49.</span> <span class="toc-text">39.1 字符串的排列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-46"><span class="toc-number">49.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-46"><span class="toc-number">49.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-44"><span class="toc-number">49.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#39-2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%BB%84%E5%90%88"><span class="toc-number">50.</span> <span class="toc-text">39.2 字符串的组合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-47"><span class="toc-number">50.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-47"><span class="toc-number">50.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-45"><span class="toc-number">50.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#39-3-8%E7%9A%87%E5%90%8E%E6%91%86%E6%B3%95%E9%97%AE%E9%A2%98"><span class="toc-number">51.</span> <span class="toc-text">39.3 8皇后摆法问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-48"><span class="toc-number">51.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-48"><span class="toc-number">51.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-46"><span class="toc-number">51.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#39-4-%E6%AD%A3%E6%96%B9%E4%BD%93%E9%A1%B6%E7%82%B9%E6%95%B0%E5%88%86%E5%B8%83"><span class="toc-number">52.</span> <span class="toc-text">39.4 正方体顶点数分布</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-49"><span class="toc-number">52.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-49"><span class="toc-number">52.2.</span> <span class="toc-text">Key</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#40-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-number">53.</span> <span class="toc-text">40 数组中出现次数超过一半的数字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-50"><span class="toc-number">53.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-50"><span class="toc-number">53.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-47"><span class="toc-number">53.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#41-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0"><span class="toc-number">54.</span> <span class="toc-text">41 最小的k个数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-51"><span class="toc-number">54.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-51"><span class="toc-number">54.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-48"><span class="toc-number">54.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#42-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="toc-number">55.</span> <span class="toc-text">42 数据流中的中位数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-52"><span class="toc-number">55.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-52"><span class="toc-number">55.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-49"><span class="toc-number">55.3.</span> <span class="toc-text">Answer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-50"><span class="toc-number">55.4.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%80%94-%E5%A0%86-%E2%80%94"><span class="toc-number">56.</span> <span class="toc-text">—- 堆 —-</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Interfaces"><span class="toc-number">56.1.</span> <span class="toc-text">Interfaces</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#43-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C"><span class="toc-number">57.</span> <span class="toc-text">43 连续子数组的最大和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-53"><span class="toc-number">57.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-53"><span class="toc-number">57.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-51"><span class="toc-number">57.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#44-1-n-%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0-%E2%80%94%E8%B7%B3%E8%BF%87"><span class="toc-number">58.</span> <span class="toc-text">44 1-n 整数中1出现的次数  —跳过</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-54"><span class="toc-number">58.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-54"><span class="toc-number">58.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-52"><span class="toc-number">58.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#45-%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E7%9A%84%E6%9F%90%E4%B8%80%E4%BD%8D%E6%95%B0%E5%AD%97"><span class="toc-number">59.</span> <span class="toc-text">45 数字序列中的某一位数字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-55"><span class="toc-number">59.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-55"><span class="toc-number">59.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-53"><span class="toc-number">59.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#46-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0"><span class="toc-number">60.</span> <span class="toc-text">46 把数组排成最小的数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-56"><span class="toc-number">60.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-56"><span class="toc-number">60.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-54"><span class="toc-number">60.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#47-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">61.</span> <span class="toc-text">47 把数字翻译成字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-57"><span class="toc-number">61.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-57"><span class="toc-number">61.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-55"><span class="toc-number">61.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#48-%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC"><span class="toc-number">62.</span> <span class="toc-text">48 礼物的最大价值</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-58"><span class="toc-number">62.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-58"><span class="toc-number">62.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-56"><span class="toc-number">62.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#49-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">63.</span> <span class="toc-text">49 最长不含重复字符的子字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-59"><span class="toc-number">63.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-59"><span class="toc-number">63.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-57"><span class="toc-number">63.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%80%94-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E2%80%94"><span class="toc-number">64.</span> <span class="toc-text">—- 动态规划 —-</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#50-%E4%B8%91%E6%95%B0"><span class="toc-number">65.</span> <span class="toc-text">50 丑数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-60"><span class="toc-number">65.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-60"><span class="toc-number">65.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-58"><span class="toc-number">65.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#51-%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6"><span class="toc-number">66.</span> <span class="toc-text">51 第一次只出现一次的字符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-61"><span class="toc-number">66.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-61"><span class="toc-number">66.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-59"><span class="toc-number">66.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#51-2-%E5%93%88%E5%B8%8C%E8%A1%A8%E5%BA%94%E7%94%A8%E6%8B%93%E5%B1%95"><span class="toc-number">67.</span> <span class="toc-text">51.2 哈希表应用拓展</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#51-3-%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6"><span class="toc-number">68.</span> <span class="toc-text">51.3 字符流中只出现一次的字符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-62"><span class="toc-number">68.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-62"><span class="toc-number">68.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-60"><span class="toc-number">68.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#52-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9"><span class="toc-number">69.</span> <span class="toc-text">52 数组中的逆序对</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-63"><span class="toc-number">69.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-63"><span class="toc-number">69.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-61"><span class="toc-number">69.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#53-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97"><span class="toc-number">70.</span> <span class="toc-text">53 在排序数组中查找数字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-64"><span class="toc-number">70.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-64"><span class="toc-number">70.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-62"><span class="toc-number">70.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#53-1-0-n-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-number">71.</span> <span class="toc-text">53.1 0-n-1中缺失的数字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-65"><span class="toc-number">71.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-65"><span class="toc-number">71.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-63"><span class="toc-number">71.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#53-2-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%80%BC%E4%B8%8E%E4%B8%8B%E6%A0%87%E7%9B%B8%E7%AD%89%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-number">72.</span> <span class="toc-text">53.2 数组中数值与下标相等的元素</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-66"><span class="toc-number">72.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-66"><span class="toc-number">72.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-64"><span class="toc-number">72.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#54-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E7%BB%93%E7%82%B9"><span class="toc-number">73.</span> <span class="toc-text">54 二叉搜索树的第k大结点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-67"><span class="toc-number">73.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-67"><span class="toc-number">73.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-65"><span class="toc-number">73.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#55-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6"><span class="toc-number">74.</span> <span class="toc-text">55 二叉树的深度</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-68"><span class="toc-number">74.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-68"><span class="toc-number">74.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-66"><span class="toc-number">74.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#55-1-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">75.</span> <span class="toc-text">55.1 平衡二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-69"><span class="toc-number">75.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-69"><span class="toc-number">75.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-67"><span class="toc-number">75.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#56-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97"><span class="toc-number">76.</span> <span class="toc-text">56 数组中只出现一次的两个数字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-70"><span class="toc-number">76.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-70"><span class="toc-number">76.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-68"><span class="toc-number">76.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#56-1-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%94%AF%E4%B8%80%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-number">77.</span> <span class="toc-text">56.1 数组中唯一只出现一次的数字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-71"><span class="toc-number">77.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-71"><span class="toc-number">77.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-69"><span class="toc-number">77.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#57-%E5%92%8C%E4%B8%BAs%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-number">78.</span> <span class="toc-text">57 和为s的数字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-72"><span class="toc-number">78.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-72"><span class="toc-number">78.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-70"><span class="toc-number">78.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#57-1-%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97"><span class="toc-number">79.</span> <span class="toc-text">57.1 和为s的连续正数序列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-73"><span class="toc-number">79.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-73"><span class="toc-number">79.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-71"><span class="toc-number">79.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#58-%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">80.</span> <span class="toc-text">58 翻转字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-74"><span class="toc-number">80.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-74"><span class="toc-number">80.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-72"><span class="toc-number">80.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#58-1-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">81.</span> <span class="toc-text">58.1 左旋转字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-75"><span class="toc-number">81.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-75"><span class="toc-number">81.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-73"><span class="toc-number">81.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#59-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number">82.</span> <span class="toc-text">59 滑动窗口的最大值</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-76"><span class="toc-number">82.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-76"><span class="toc-number">82.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-74"><span class="toc-number">82.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#59-1-%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number">83.</span> <span class="toc-text">59.1 队列的最大值</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-77"><span class="toc-number">83.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-77"><span class="toc-number">83.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-75"><span class="toc-number">83.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#60-n%E4%B8%AA%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0"><span class="toc-number">84.</span> <span class="toc-text">60 n个骰子的点数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-78"><span class="toc-number">84.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-78"><span class="toc-number">84.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-76"><span class="toc-number">84.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#61-%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90"><span class="toc-number">85.</span> <span class="toc-text">61 扑克牌中的顺子</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-79"><span class="toc-number">85.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-79"><span class="toc-number">85.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-77"><span class="toc-number">85.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#62-%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-number">86.</span> <span class="toc-text">62 圆圈中最后剩下的数字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-80"><span class="toc-number">86.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-80"><span class="toc-number">86.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-78"><span class="toc-number">86.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#63-%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6"><span class="toc-number">87.</span> <span class="toc-text">63 股票的最大利润</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-81"><span class="toc-number">87.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-81"><span class="toc-number">87.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-79"><span class="toc-number">87.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#64-%E6%B1%82-1-2-%E2%80%A6-n"><span class="toc-number">88.</span> <span class="toc-text">64 求 1+2+…+n</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-82"><span class="toc-number">88.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-82"><span class="toc-number">88.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-80"><span class="toc-number">88.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#65-%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95"><span class="toc-number">89.</span> <span class="toc-text">65 不用加减乘除做加法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-83"><span class="toc-number">89.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-83"><span class="toc-number">89.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-81"><span class="toc-number">89.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#65-1-%E4%B8%8D%E4%BD%BF%E7%94%A8%E6%96%B0%E7%9A%84%E5%8F%98%E9%87%8F%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC"><span class="toc-number">90.</span> <span class="toc-text">65.1 不使用新的变量交换两个变量的值</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-84"><span class="toc-number">90.1.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Anwser"><span class="toc-number">90.2.</span> <span class="toc-text">Anwser</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#66-%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84"><span class="toc-number">91.</span> <span class="toc-text">66 构建乘积数组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#67-%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B4%E6%95%B0"><span class="toc-number">92.</span> <span class="toc-text">67 把字符串转换为整数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-84"><span class="toc-number">92.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-85"><span class="toc-number">92.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-82"><span class="toc-number">92.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#68-%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9"><span class="toc-number">93.</span> <span class="toc-text">68 链表的第一个公共结点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-85"><span class="toc-number">93.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-86"><span class="toc-number">93.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-83"><span class="toc-number">93.3.</span> <span class="toc-text">Answer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#69-%E6%A0%91%E4%B8%AD%E4%B8%A4%E4%B8%AA%E7%BB%93%E7%82%B9%E7%9A%84%E6%9C%80%E4%BD%8E%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-number">94.</span> <span class="toc-text">69 树中两个结点的最低公共祖先</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Testing-case-86"><span class="toc-number">94.1.</span> <span class="toc-text">Testing case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-87"><span class="toc-number">94.2.</span> <span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Answer-84"><span class="toc-number">94.3.</span> <span class="toc-text">Answer</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/02/27/Matlab/Matlab/" title="Matlab 入门"><img src="/img/ma3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Matlab 入门"/></a><div class="content"><a class="title" href="/2023/02/27/Matlab/Matlab/" title="Matlab 入门">Matlab 入门</a><time datetime="2023-02-27T01:30:00.000Z" title="发表于 2023-02-27 09:30:00">2023-02-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/22/Animation/CenterAI_%E7%A5%9E%E7%BB%8F%E7%8A%B6%E6%80%81%E6%9C%BA/" title="Siggraph Asia 2019 - 神经状态机"><img src="/img/ma3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Siggraph Asia 2019 - 神经状态机"/></a><div class="content"><a class="title" href="/2022/03/22/Animation/CenterAI_%E7%A5%9E%E7%BB%8F%E7%8A%B6%E6%80%81%E6%9C%BA/" title="Siggraph Asia 2019 - 神经状态机">Siggraph Asia 2019 - 神经状态机</a><time datetime="2022-03-22T02:40:00.000Z" title="发表于 2022-03-22 10:40:00">2022-03-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/22/Unreal/Ue4_GamePlay%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3/" title="YumiGame - Ue4 - GamePlay"><img src="/img/ma3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="YumiGame - Ue4 - GamePlay"/></a><div class="content"><a class="title" href="/2022/03/22/Unreal/Ue4_GamePlay%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3/" title="YumiGame - Ue4 - GamePlay">YumiGame - Ue4 - GamePlay</a><time datetime="2022-03-22T02:30:00.000Z" title="发表于 2022-03-22 10:30:00">2022-03-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/22/Unreal/Ue4_%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F%E6%9C%AA%E5%AE%8C/" title="Ue4 - Animation System"><img src="/img/ma3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Ue4 - Animation System"/></a><div class="content"><a class="title" href="/2022/03/22/Unreal/Ue4_%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F%E6%9C%AA%E5%AE%8C/" title="Ue4 - Animation System">Ue4 - Animation System</a><time datetime="2022-03-22T02:28:00.000Z" title="发表于 2022-03-22 10:28:00">2022-03-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/22/Unity/Unity_%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/" title="Unity - Animation Systems"><img src="/img/ma3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity - Animation Systems"/></a><div class="content"><a class="title" href="/2022/03/22/Unity/Unity_%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/" title="Unity - Animation Systems">Unity - Animation Systems</a><time datetime="2022-03-22T02:27:00.000Z" title="发表于 2022-03-22 10:27:00">2022-03-22</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By YunDid</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><i class="fab fa-qq"></i> 512862613 | <i class="fab fa-weixin"></i> Mmm-myy1</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">簡</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'RUIbtPgCc0o0TGaeqMWlX9P5-gzGzoHsz',
      appKey: 'PaoiG1dlQjiDQAVRBexH6KkR',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="https://cdn.jsdelivr.net/npm/live2d-widget@^3.1.3/lib/L2Dwidget.min.js"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"superSample":2,"position":"left","width":150,"height":300,"hOffset":20,"vOffset":-90},"mobile":{"show":true,"scale":1},"react":{"opacityDefault":0.3,"opacityOnHover":0.3,"opacity":0.95},"log":false});</script></body></html>
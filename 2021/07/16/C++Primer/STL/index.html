<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>C++ STL | YunDid's Blog</title><meta name="keywords" content="C++Primer"><meta name="author" content="YunDid"><meta name="copyright" content="YunDid"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="STL体系结构六大组件容器 container 分配器 allocator 适配器 adaptor 算法 algorithm 迭代器 itrator  泛化指针 [)前闭后开区间 o.begin()指向首元素，o.end()指向尾元素的下一个位置  仿函数 functor OOP and GPObject-Oriented Programming 面向对象编程  datas 和 methods 封">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ STL">
<meta property="og:url" content="http://example.com/2021/07/16/C++Primer/STL/index.html">
<meta property="og:site_name" content="YunDid&#39;s Blog">
<meta property="og:description" content="STL体系结构六大组件容器 container 分配器 allocator 适配器 adaptor 算法 algorithm 迭代器 itrator  泛化指针 [)前闭后开区间 o.begin()指向首元素，o.end()指向尾元素的下一个位置  仿函数 functor OOP and GPObject-Oriented Programming 面向对象编程  datas 和 methods 封">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/ma3.jpg">
<meta property="article:published_time" content="2021-07-16T01:00:00.000Z">
<meta property="article:modified_time" content="2021-07-16T01:10:48.833Z">
<meta property="article:author" content="YunDid">
<meta property="article:tag" content="C++Primer">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/ma3.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/07/16/C++Primer/STL/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: YunDid","link":"链接: ","source":"来源: YunDid's Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-07-16 09:10:48'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">46</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/ma3.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">YunDid's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C++ STL</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-07-16T01:00:00.000Z" title="发表于 2021-07-16 09:00:00">2021-07-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-07-16T01:10:48.833Z" title="更新于 2021-07-16 09:10:48">2021-07-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C-Primer/">C++Primer</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C++ STL"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2021/07/16/C++Primer/STL/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2021/07/16/C++Primer/STL/" itemprop="commentCount"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="STL体系结构"><a href="#STL体系结构" class="headerlink" title="STL体系结构"></a>STL体系结构</h1><h2 id="六大组件"><a href="#六大组件" class="headerlink" title="六大组件"></a>六大组件</h2><p>容器 container</p>
<p>分配器 allocator</p>
<p>适配器 adaptor</p>
<p>算法 algorithm</p>
<p>迭代器 itrator</p>
<blockquote>
<p>泛化指针</p>
<p>[)前闭后开区间</p>
<p>o.begin()指向首元素，o.end()指向尾元素的下一个位置</p>
</blockquote>
<p>仿函数 functor</p>
<h2 id="OOP-and-GP"><a href="#OOP-and-GP" class="headerlink" title="OOP and GP"></a>OOP and GP</h2><p>Object-Oriented Programming 面向对象编程</p>
<blockquote>
<p>datas 和 methods 封装在一个类中</p>
</blockquote>
<p>Generic Programming 泛型编程</p>
<blockquote>
<p>datas 和 methods 分开</p>
<p>algorithms 通过 Iterators 操作 containers 中的数据 并可使用functors</p>
</blockquote>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="容器分类"><a href="#容器分类" class="headerlink" title="容器分类"></a>容器分类</h3><p>Sequence Containers 序列容器</p>
<blockquote>
<p>Arrays 数组</p>
<p>Vector 动态数组</p>
<p>deque 双向队列</p>
<p>List 双向链表</p>
<p>Forward-List 单链表</p>
</blockquote>
<ul>
<li><p>Associative Containers 关联容器</p>
<blockquote>
<p>set 无重复元素的集合</p>
<p>multiset 可有重复元素</p>
<p>map 无重复元素的键值对集合</p>
<p>multimap 可有重复元素</p>
<p>底层结构为红黑树</p>
</blockquote>
</li>
<li><p>Unordered Containers 无序容器</p>
<blockquote>
<p>unordered set/unordered multiset</p>
<p>unordered map/unordered multimap</p>
<p>底层结构为hashTable-Separate Chaining</p>
</blockquote>
</li>
</ul>
<h3 id="容器测试"><a href="#容器测试" class="headerlink" title="容器测试"></a>容器测试</h3><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试常用库</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span>  <span class="comment">//引入qsort,search等等算法</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">clock_t</span> nowtime = <span class="built_in">clock</span>(); <span class="comment">//clock()函数返回从开启这个程序进程到调用clock()函数的CPU时钟计时单元数，返回单位是毫秒，类型为clock_t</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="Sequence-Containers-序列容器"><a href="#Sequence-Containers-序列容器" class="headerlink" title="Sequence Containers 序列容器"></a>Sequence Containers 序列容器</h4><blockquote>
<p>不便于查找</p>
</blockquote>
<h5 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h5><blockquote>
<p>数组</p>
<h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line">array&lt;type,size&gt; name; <span class="comment">//需要指定定长array的初始大小,size为常量</span></span><br></pre></td></tr></table></figure>
<h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>通过下标来放置元素</p>
<h5 id="接口测试"><a href="#接口测试" class="headerlink" title="接口测试"></a>接口测试</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array.<span class="built_in">size</span>(); <span class="comment">//容器元素个数</span></span><br><span class="line">array.<span class="built_in">front</span>(); <span class="comment">//取首元素</span></span><br><span class="line">array.<span class="built_in">back</span>(); <span class="comment">//取尾部元素</span></span><br><span class="line">array.<span class="built_in">data</span>(); <span class="comment">//返回容器的首元素地址</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h5><blockquote>
<p>动态数组</p>
<h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line">vector&lt;type&gt; name; <span class="comment">//等等</span></span><br></pre></td></tr></table></figure>

<p>动态扩容一般为扩容为原来的2倍</p>
<p>先创建2倍的内存空间，再逐个元素copy过去</p>
<h5 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h5><p>push_back()</p>
<h5 id="接口测试-1"><a href="#接口测试-1" class="headerlink" title="接口测试"></a>接口测试</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector.<span class="built_in">size</span>(); <span class="comment">//容器元素个数</span></span><br><span class="line">vector.<span class="built_in">front</span>(); <span class="comment">//取首元素</span></span><br><span class="line">vector.<span class="built_in">back</span>(); <span class="comment">//取尾部元素</span></span><br><span class="line">vector.<span class="built_in">data</span>(); <span class="comment">//返回容器的首元素地址</span></span><br><span class="line">vector.<span class="built_in">capacity</span>(); <span class="comment">//查看容器可容纳的空间大小</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h5><blockquote>
<p>双向队列</p>
<h5 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h5><p>双向扩容,一次扩充一个buffer，并由deque中的指针指向</p>
<p>分段buffer连续,段中存放着连续数据 </p>
<p>涵盖了容器适配器stack与queue的功能</p>
<blockquote>
<p>stack与queue均操作受限，因此无法使用iterator迭代器，无法调用find方法</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line">deque&lt;type&gt; name;</span><br></pre></td></tr></table></figure>

<h5 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h5><p>push_back() //将数据放置在deque中段buffer的结构中</p>
<h5 id="接口测试-2"><a href="#接口测试-2" class="headerlink" title="接口测试"></a>接口测试</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deque.<span class="built_in">size</span>(); <span class="comment">//容器元素个数</span></span><br><span class="line">deque.<span class="built_in">max_size</span>(); <span class="comment">//容器所能容纳的最大元素个数</span></span><br><span class="line">deque.<span class="built_in">front</span>(); <span class="comment">//取首元素</span></span><br><span class="line">deque.<span class="built_in">back</span>(); <span class="comment">//取尾部元素</span></span><br></pre></td></tr></table></figure>


</blockquote>
<h5 id="List"><a href="#List" class="headerlink" title="List"></a>List</h5><blockquote>
<p>双向链表</p>
<h5 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line">list&lt;type&gt; name;</span><br></pre></td></tr></table></figure>

<h5 id="初始化-3"><a href="#初始化-3" class="headerlink" title="初始化"></a>初始化</h5><p>push_back()</p>
<h5 id="接口测试-3"><a href="#接口测试-3" class="headerlink" title="接口测试"></a>接口测试</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list.<span class="built_in">size</span>(); <span class="comment">//容器元素个数</span></span><br><span class="line">list.<span class="built_in">max_size</span>(); <span class="comment">//容器所能容纳的最大元素个数</span></span><br><span class="line">list.<span class="built_in">front</span>(); <span class="comment">//取首元素</span></span><br><span class="line">list.<span class="built_in">back</span>(); <span class="comment">//取尾部元素</span></span><br></pre></td></tr></table></figure>

<p><code>注意:</code>list不提供randomaccessiterator 所以无法调用全局sort方法,需要内部重载</p>
</blockquote>
<h5 id="Forward-list"><a href="#Forward-list" class="headerlink" title="Forward_list"></a>Forward_list</h5><blockquote>
<p>单链表</p>
<h5 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line">forward_list&lt;type&gt; name;</span><br></pre></td></tr></table></figure>

<h5 id="初始化-4"><a href="#初始化-4" class="headerlink" title="初始化"></a>初始化</h5><p>push_front() 头插</p>
<h5 id="接口测试-4"><a href="#接口测试-4" class="headerlink" title="接口测试"></a>接口测试</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">forward_list.<span class="built_in">max_size</span>(); <span class="comment">//容器所能容纳的最大元素个数</span></span><br><span class="line">forward_list.<span class="built_in">front</span>(); <span class="comment">//取首元素</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="Associative-Containers-关联容器"><a href="#Associative-Containers-关联容器" class="headerlink" title="Associative Containers 关联容器"></a>Associative Containers 关联容器</h4><blockquote>
<p>查找效率高</p>
</blockquote>
<h5 id="Multiset"><a href="#Multiset" class="headerlink" title="Multiset"></a>Multiset</h5><blockquote>
<h5 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line">multiset&lt;type&gt;  name;</span><br></pre></td></tr></table></figure>

<h5 id="初始化-5"><a href="#初始化-5" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Multiset.<span class="built_in">insert</span>(value)  <span class="comment">//安插到该安插的位置而非固定头尾</span></span><br></pre></td></tr></table></figure>

<p>相较于::find(),multiset.find()查找更快,通过(*item)取得值</p>
<h5 id="接口测试-5"><a href="#接口测试-5" class="headerlink" title="接口测试"></a>接口测试</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">multiset.<span class="built_in">size</span>(); <span class="comment">//</span></span><br><span class="line">multiset.<span class="built_in">max_size</span>(); <span class="comment">//</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h5><blockquote>
<blockquote>
<p>底层为红黑树</p>
</blockquote>
<h5 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line">set&lt;type&gt;  name;</span><br></pre></td></tr></table></figure>

<h5 id="初始化-6"><a href="#初始化-6" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set.<span class="built_in">insert</span>(value)  <span class="comment">//安插到该安插的位置而非固定头尾</span></span><br></pre></td></tr></table></figure>

<h5 id="接口测试-6"><a href="#接口测试-6" class="headerlink" title="接口测试"></a>接口测试</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set.<span class="built_in">size</span>(); <span class="comment">//</span></span><br><span class="line">set.<span class="built_in">max_size</span>(); <span class="comment">//</span></span><br></pre></td></tr></table></figure>

<p><code>注意:</code> 不允许重复</p>
</blockquote>
<h5 id="Multimap"><a href="#Multimap" class="headerlink" title="Multimap"></a>Multimap</h5><blockquote>
<h5 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line">multimap&lt;key_type,value_type&gt; name</span><br></pre></td></tr></table></figure>

<h5 id="初始化-7"><a href="#初始化-7" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Multimap.<span class="built_in">insert</span>(pair&lt;key_type,value_type&gt;(key,value)) <span class="comment">//使用pair模板对象来封装key-value</span></span><br><span class="line"><span class="comment">//pair.second为value pair.first为key</span></span><br><span class="line"><span class="comment">//不可以用[]做insertion</span></span><br></pre></td></tr></table></figure>

<p>相较于::find(),obj.find()查找更快，通过(*item).second取得值</p>
<h5 id="接口测试-7"><a href="#接口测试-7" class="headerlink" title="接口测试"></a>接口测试</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">multimap.<span class="built_in">size</span>(); <span class="comment">//</span></span><br><span class="line">multimap.<span class="built_in">max_size</span>(); <span class="comment">//</span></span><br></pre></td></tr></table></figure>


</blockquote>
<h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h5><blockquote>
<blockquote>
<p>底层为红黑树</p>
</blockquote>
<h5 id="定义-8"><a href="#定义-8" class="headerlink" title="定义"></a>定义</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line">map&lt;key_type,value_type&gt; name</span><br></pre></td></tr></table></figure>

<h5 id="初始化-8"><a href="#初始化-8" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map[i] = valve; <span class="comment">// map自动执行封装key-value</span></span><br><span class="line"><span class="comment">//Map.insert(pair&lt;key_type,key_value&gt;(key,value));</span></span><br></pre></td></tr></table></figure>

<h5 id="接口测试-8"><a href="#接口测试-8" class="headerlink" title="接口测试"></a>接口测试</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map.<span class="built_in">size</span>(); <span class="comment">//</span></span><br><span class="line">map.<span class="built_in">max_size</span>(); <span class="comment">//</span></span><br></pre></td></tr></table></figure>

<p><code>注意:</code> 不允许重复，但是该重复指的是key-value重复，仅一个不同另一个相同不算重复</p>
</blockquote>
<h4 id="Unordered-Containers-无序容器"><a href="#Unordered-Containers-无序容器" class="headerlink" title="Unordered Containers 无序容器"></a>Unordered Containers 无序容器</h4><blockquote>
<p>hash Containers 以hashtable为底层结构</p>
</blockquote>
<h5 id="Unordered-multiset"><a href="#Unordered-multiset" class="headerlink" title="Unordered_multiset"></a>Unordered_multiset</h5><blockquote>
<h5 id="定义-9"><a href="#定义-9" class="headerlink" title="定义"></a>定义</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unordered_multiset&lt;type&gt; name</span><br></pre></td></tr></table></figure>

<h5 id="初始化-9"><a href="#初始化-9" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unordered_multiset.<span class="built_in">insert</span>(value);</span><br></pre></td></tr></table></figure>

<h5 id="接口测试-9"><a href="#接口测试-9" class="headerlink" title="接口测试"></a>接口测试</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">u_mset.<span class="built_in">size</span>(); <span class="comment">//</span></span><br><span class="line">u_mset.<span class="built_in">max_size</span>(); <span class="comment">//</span></span><br><span class="line">u_mset.<span class="built_in">bucket_count</span>(); <span class="comment">//篮子数，存放hash值的数组长度</span></span><br><span class="line">u_mset.<span class="built_in">bucket_size</span>(i); <span class="comment">//第i个篮子的连接的结点数</span></span><br><span class="line">u_mset.<span class="built_in">load_factor</span>(); <span class="comment">//负载因子</span></span><br><span class="line">u_mset.<span class="built_in">max_bucket_count</span>(); <span class="comment">//最大篮子数，存放hash值的数组长度</span></span><br><span class="line">u_mset.<span class="built_in">max_load_factor</span>(); <span class="comment">//最大负载因子</span></span><br></pre></td></tr></table></figure>


</blockquote>
<h5 id="Unordered-Multimap"><a href="#Unordered-Multimap" class="headerlink" title="Unordered_Multimap"></a>Unordered_Multimap</h5><blockquote>
<h5 id="定义-10"><a href="#定义-10" class="headerlink" title="定义"></a>定义</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unordered_multimap&lt;key_type,value_type&gt; name;</span><br></pre></td></tr></table></figure>

<h5 id="初始化-10"><a href="#初始化-10" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unordered_multimap.<span class="built_in">insert</span>(pair&lt;key_type,value_type&gt;(key,value)) <span class="comment">//使用pair模板对象来封装key-value</span></span><br><span class="line"><span class="comment">//pair.second为value pair.first为key</span></span><br></pre></td></tr></table></figure>

<h5 id="接口测试-10"><a href="#接口测试-10" class="headerlink" title="接口测试"></a>接口测试</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unordered_multimap.<span class="built_in">size</span>(); <span class="comment">//</span></span><br><span class="line">unordered_multimap.<span class="built_in">max_size</span>(); <span class="comment">//</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="Unordered-Set"><a href="#Unordered-Set" class="headerlink" title="Unordered_Set"></a>Unordered_Set</h5><blockquote>
<p>底部为hashtable</p>
</blockquote>
<h5 id="Unordered-Map"><a href="#Unordered-Map" class="headerlink" title="Unordered_Map"></a>Unordered_Map</h5><blockquote>
<p>底部为hashtable</p>
</blockquote>
<h3 id="容器源码剖析"><a href="#容器源码剖析" class="headerlink" title="容器源码剖析"></a>容器源码剖析</h3><h4 id="Sequence-Containers-序列容器-1"><a href="#Sequence-Containers-序列容器-1" class="headerlink" title="Sequence Containers 序列容器"></a>Sequence Containers 序列容器</h4><h5 id="List-1"><a href="#List-1" class="headerlink" title="List"></a>List</h5><blockquote>
<p>环状双向链表</p>
<p>将有一个空结点使该环状双向链表满足前闭后开原则(begin()指向第一个结点,end()指向尾结点的下一个位置)</p>
</blockquote>
<ul>
<li>GCC2.9</li>
</ul>
<blockquote>
<p>组成</p>
<p>结点模板类</p>
<blockquote>
<p>指向前一个结点成员的空指针</p>
<p>指向下一个结点成员的空指针</p>
</blockquote>
<p>list模板类</p>
<blockquote>
<p>指向结点的头指针node </p>
<ul>
<li>一个list类对象的大小为4byte在GCC2.9编译器下</li>
</ul>
<p>iterator迭代器模板类成员</p>
<p>…</p>
</blockquote>
<p>iterator迭代器模板类</p>
<blockquote>
<p>5个不可或缺的typedef类型声明</p>
<ul>
<li>Link_type 元素类型</li>
<li>Reference 引用类型</li>
<li>Pointer 指针类型</li>
</ul>
<p>指向结点的指针node</p>
<p>对各种运算符的重载函数</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//list_gcc29.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __USER__</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> __USER__ myy</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">list_node</span>&#123;</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">void</span>* nptr; <span class="comment">//空指针比较鸡肋需要进行类型转型gcc4.9对此也进行了改善直接使用指针类型</span></span><br><span class="line">	nptr pre;</span><br><span class="line">	nptr next;</span><br><span class="line">	T data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">list</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> __list_node&lt;T&gt; node_type; <span class="comment">//可能其他部分使用到了这个结点类型</span></span><br><span class="line">	<span class="keyword">typedef</span> node_type* nodeptr;</span><br><span class="line">	<span class="keyword">typedef</span> list_iterator&lt;T,T&amp;,T*&gt; iterator; <span class="comment">//gcc2.9需要传递3个参数gcc4.9对此做了改善只需要传递T类型参数即可</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	nodeptr node;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="keyword">class</span> <span class="title">Ref</span>,<span class="keyword">class</span> <span class="title">Ptr</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_iterator</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//typedef类型声明部分</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> list_iterator&lt;T, Ref, Ptr&gt; self;</span><br><span class="line">	<span class="keyword">typedef</span> __list_node&lt;T&gt;* node_type;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//必要的5中类型声明</span></span><br><span class="line">	<span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category; <span class="comment">//迭代器的种类</span></span><br><span class="line">	<span class="keyword">typedef</span> T value_type; <span class="comment">//数据类型</span></span><br><span class="line">	<span class="keyword">typedef</span> Ptr pointer; <span class="comment">//指向node类型的指针</span></span><br><span class="line">	<span class="keyword">typedef</span> Ref reference; <span class="comment">//node类型的引用类型</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type; <span class="comment">//两个迭代器之间距离的类型</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//- - -</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//运算符重载</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//后置++重载</span></span><br><span class="line">	<span class="comment">//注意返回类型为对象而非引用，所以后置自增无法多次++,例如a++++</span></span><br><span class="line">	self <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">		<span class="function">self <span class="title">temp</span><span class="params">(*<span class="keyword">this</span>)</span></span>; <span class="comment">//调用拷贝构造函数进行深拷贝，将当前保存为临时对象</span></span><br><span class="line">		++*<span class="keyword">this</span>; <span class="comment">//当前对象执行已重载的前置自增操作</span></span><br><span class="line">		<span class="keyword">return</span> temp; <span class="comment">//返回临时对象的拷贝-调用拷贝构造函数</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//前置++重载</span></span><br><span class="line">	<span class="comment">//注意返回类型为引用，所以前置自增可多次++,例如++++a</span></span><br><span class="line">	self&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">		node = (node_type)(node-&gt;next);</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;; </span><br><span class="line"></span><br><span class="line">	reference <span class="keyword">operator</span>*() <span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (*node).data;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*())</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	node_type node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !USER</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>GCC4.9</p>
<blockquote>
<p>相较于2.9的改善</p>
<ol>
<li>结点指针类型明确不再是空指针</li>
<li>结点继承自一个父类</li>
<li>iterator模板参数为1个不再是冗杂的3个</li>
</ol>
<p>gcc4.9下一个list对象所占的内存为8byte</p>
<p>vs2017下一个list对象所占的内存为12byte</p>
</blockquote>
</li>
</ul>
<h5 id="Vector-1"><a href="#Vector-1" class="headerlink" title="Vector"></a>Vector</h5><p>GCC2.9</p>
<p>组成</p>
<blockquote>
<p>三个Iteretor迭代器成员</p>
<blockquote>
<p>分别指向首元素,尾元素下一个位置,最后一个内存位置</p>
<p>一个vector对象的内存为12byte</p>
</blockquote>
<p>各种运算符的重载</p>
<p>基本操作函数成员</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vector_gcc29.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __user__</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> __user__ myy</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vector</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> T value_name;</span><br><span class="line">	<span class="keyword">typedef</span> value_name* iterator;</span><br><span class="line">	<span class="keyword">typedef</span> T&amp; reference;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line"></span><br><span class="line">	<span class="function">iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> start;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> finish;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">size_type</span>(<span class="built_in">end</span>() - <span class="built_in">begin</span>());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> empty <span class="title">const</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">begih</span>() == <span class="built_in">end</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">size_type <span class="title">capacity</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">size_type</span>(end_storage - <span class="built_in">begin</span>());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连续空间支持下标索引所以需要对[]运算符重载</span></span><br><span class="line">	reference <span class="keyword">operator</span>[] <span class="built_in"><span class="keyword">const</span></span>(size_type&amp; s) &#123;</span><br><span class="line">		<span class="keyword">return</span> *(start + s);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">reference <span class="title">front</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> *<span class="built_in">begin</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">reference <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> *(<span class="built_in">end</span>() - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">end</span>() != end_storage) &#123;</span><br><span class="line">			<span class="built_in">construct</span>(finish,x); <span class="comment">//全局函数</span></span><br><span class="line">			finish++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">insert_aux</span>(<span class="built_in">end</span>(), x); <span class="comment">//插入辅助函数</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert_aux</span><span class="params">(iterator position, <span class="keyword">const</span> T&amp; x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	iterator start;</span><br><span class="line">	iterator finish;</span><br><span class="line">	iterator end_stroage;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !__user__</span></span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Iterator</p>
<blockquote>
<p>vector的内存为连续空间因此不再使用泛型指针而是采用native pointor</p>
</blockquote>
</blockquote>
<p>扩容</p>
<p>GCC2.9</p>
<blockquote>
<p>当vector满时(end() == end_storage)进行二倍扩容</p>
<p>任何扩容不会原地扩容，因为其后连续空间可能已被占用，只能预先申请新的内存并将原元素copy过去</p>
<p>在插入操作时可能引发扩容操作</p>
<blockquote>
<ol>
<li>使用alloc分配器申请二倍内存空间</li>
<li>在copy原vector元素时完成插入操作而非copy扩容完成后再重新插入<ul>
<li>将原vector插入位置position之前的元素先copy到新vector中</li>
<li>执行插入操作</li>
<li>将原vector插入位置position之后的元素再copy到新vector中</li>
</ul>
</li>
<li>删除原内存空间</li>
<li>调整迭代器</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> vector&lt;T,Alloc&gt;::<span class="built_in">insert_aux</span>(iterator position, <span class="keyword">const</span> T&amp; x) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">end</span>() != end_storage) &#123;</span><br><span class="line">		<span class="built_in">insert_aux</span>(finish, *(finish - <span class="number">1</span>));<span class="comment">//position位置之后的元素需要后移</span></span><br><span class="line">		finish++;</span><br><span class="line"></span><br><span class="line">		T temp = x;</span><br><span class="line">		<span class="built_in">copy_backward</span>(position, finish - <span class="number">2</span>, finish - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		*(position) = temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">const</span> size_type old_size = <span class="built_in">size</span>();</span><br><span class="line">		<span class="keyword">const</span> size_type len = ole_size != <span class="number">0</span> ? old_size * <span class="number">2</span> : <span class="number">1</span>; <span class="comment">//获取新创建空间的长度</span></span><br><span class="line"></span><br><span class="line">		iterator new_start = data_allocator::<span class="built_in">allocate</span>(len); <span class="comment">//分配长度为len的内存空间</span></span><br><span class="line">		iterator new_finish = new_start; <span class="comment">//初始为空</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			new_finish = <span class="built_in">uninitialized_copy</span>(start, position, new_start); <span class="comment">//将原vector中position之前的元素copy到扩容后的新内存</span></span><br><span class="line"></span><br><span class="line">			<span class="built_in">construct</span>(new_finish, x); <span class="comment">//将待插入的值插入到position位置</span></span><br><span class="line">			new_finish++;</span><br><span class="line"></span><br><span class="line">			new_finish = <span class="built_in">uninitialized_copy</span>(position, finish, new_finish); <span class="comment">//将原vector中position之后的元素copy到扩容后的新内存</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in"><span class="keyword">catch</span></span> (...) &#123;</span><br><span class="line">			<span class="comment">// &quot;roll back or commit&quot;</span></span><br><span class="line">			<span class="comment">//销毁申请失败的新内存</span></span><br><span class="line">			<span class="built_in">destroy</span>(new_start, new_finish);</span><br><span class="line">			data_allocator::<span class="built_in">deallocate</span>(new_start, len);</span><br><span class="line">			<span class="keyword">throw</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//销毁原vector</span></span><br><span class="line">		<span class="built_in">destroy</span>(<span class="built_in">begin</span>(), <span class="built_in">end</span>());</span><br><span class="line">		<span class="built_in">deallocate</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//调整迭代器</span></span><br><span class="line">		start = new_start;</span><br><span class="line">		finish = new_finish;</span><br><span class="line">		end_storage = new_start + len;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="Array-1"><a href="#Array-1" class="headerlink" title="Array"></a>Array</h5><blockquote>
<p>数组</p>
</blockquote>
<p>GCC2.9</p>
<p>组成</p>
<blockquote>
<p>数组成员</p>
<p>迭代器 native pointer</p>
<p>无构造函数析构函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp,std::<span class="keyword">size_t</span> _Nm&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Array</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> _Tp value_type;</span><br><span class="line">	<span class="keyword">typedef</span> _Tp* pointer;</span><br><span class="line">	<span class="keyword">typedef</span> value_type* iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"></span><br><span class="line">	<span class="comment">//Array无构造函数析构函数</span></span><br><span class="line"></span><br><span class="line">	<span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;arr[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;arr[_Nm];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	value_type arr[_Nm ? _Nm : <span class="number">1</span>]; <span class="comment">//若数组长度参数为0默认将长度值为1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="Forward-list-1"><a href="#Forward-list-1" class="headerlink" title="Forward list"></a>Forward list</h5><blockquote>
<p>单向链表  </p>
<p>无法对 – 运算符重载，所以只能单向移动迭代器</p>
<p>push_front头插</p>
</blockquote>
<h5 id="Deque-1"><a href="#Deque-1" class="headerlink" title="Deque"></a>Deque</h5><blockquote>
<p> 双向队列</p>
<p> 分段有序但是存在是连续空间的假象</p>
</blockquote>
<p>结构</p>
<blockquote>
<p>map + buffer  / 中控 + 缓冲</p>
<p>map</p>
<blockquote>
<p>是一个vector，元素类型为指向bufer的指针</p>
</blockquote>
<p>buffer</p>
<blockquote>
<p>实际存放数据的一段内存</p>
<p>创建deque对象时需要指定buffer大小，若未指定，则使用默认值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">size_t</span> __deque_buf_size(<span class="keyword">size_t</span> n,<span class="keyword">size_t</span> sz) &#123;</span><br><span class="line">	<span class="keyword">return</span> n != <span class="number">0</span> ? n : ( sz &lt; <span class="number">512</span> ? (<span class="keyword">size_t</span>)(<span class="number">512</span> / sz): <span class="built_in">size_t</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<p>组成</p>
<blockquote>
<p>数据元素大小为40byte 16+16+4+4</p>
<p>-</p>
<p>start迭代器 16byte</p>
<blockquote>
<p>-</p>
<p>first指针 - 指向所有buffer中的第一个buffer的起始内存位置</p>
<p>last指针 - 指向所有buffer中的第一个buffer内存的末尾 </p>
<blockquote>
<p>last = first + difference_type(buffer_size());</p>
</blockquote>
<p>cur指针 - 指向所有元素的首元素</p>
<p>map-poninter指针 - 指向map中控vector的首元素</p>
<p>-</p>
</blockquote>
<p>finish迭代器 16byte</p>
<blockquote>
<p>-</p>
<p>first指针 - 指向所有buffer中的最后一个buffer的起始内存位置</p>
<p>last指针- 指向所有buffer中的最后一个buffer内存的末尾 </p>
<blockquote>
<p>last = first + difference_type(buffer_size());</p>
</blockquote>
<p>cur指针 - 指向所有元素中最后一个元素的下一个位置</p>
<p>map-poninter指针 - 指向map中控vector的尾元素</p>
<p>-</p>
</blockquote>
<p>指向map中控的指针 4byte</p>
<p>存储map大小的size_t变量 4byte</p>
<p>-</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc ,<span class="keyword">size_t</span> BufSiz=<span class="number">0</span>&gt;</span><br><span class="line">class Deque &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> iterator&lt;T, T&amp;, T*, BufSiz&gt; iterator;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> T** map_pointer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> start;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> finish;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">size_type <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> finish - start;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">insert</span><span class="params">(iterator pos, <span class="keyword">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (pos.cur == start.cur)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">push_front</span>();</span><br><span class="line">			<span class="keyword">return</span> start;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (pos.cur==finsh.cur) &#123;</span><br><span class="line">			<span class="built_in">push_back</span>();</span><br><span class="line">			iterator temp = finsh;</span><br><span class="line">			<span class="keyword">return</span> --temp;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">insert_aux</span>(pos, x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//deque的元素插入函数</span></span><br><span class="line">	<span class="function">iterator <span class="title">insert_aux</span><span class="params">(iterator pos, <span class="keyword">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">		difference_type len = pos - start;</span><br><span class="line">		<span class="keyword">if</span> (len &lt; <span class="built_in">size</span>() / <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="built_in">push_front</span>(<span class="built_in">front</span>()); <span class="comment">//在最前端插入与第一个元素同值的元素</span></span><br><span class="line">			<span class="built_in">copy</span>(...); <span class="comment">//pos位置之前的元素前移</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">push_back</span>(<span class="built_in">back</span>()); <span class="comment">//在最后端插入与最后一个元素同值的元素</span></span><br><span class="line">			<span class="built_in">copyback</span>(...); <span class="comment">//pos位置之后的元素后移</span></span><br><span class="line">		&#125;</span><br><span class="line">		*pos = x;</span><br><span class="line">		<span class="keyword">return</span> pos;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//&quot;连续空间&quot;需要有对[]运算符的重载</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>[] (<span class="keyword">size_t</span> n) &#123;</span><br><span class="line">        <span class="keyword">return</span> start[<span class="built_in">difference_type</span>(n)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	iterator start;</span><br><span class="line">	iterator finsh;</span><br><span class="line">	map_pointer map;</span><br><span class="line">	size_type map_size;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


</blockquote>
<p>迭代器组成</p>
<blockquote>
<p>-</p>
<p>first指针</p>
<p>last指针</p>
<p>cur指针</p>
<p>map-poninter指针</p>
<p>-</p>
<p>对基本运算符的重载</p>
<ul>
<li><p>*解引用运算符</p>
<blockquote>
<p>取迭代器cur对应的元素</p>
</blockquote>
</li>
<li><p>-&gt;箭头运算符</p>
<blockquote>
<p>取迭代器cur对应的元素的地址</p>
</blockquote>
</li>
<li><p>ite1 - ite2</p>
<blockquote>
<p>得两迭代器之间的所有元素</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>分三部分求得 </p>
<ol>
<li>ite2指向的buffer元素</li>
<li>ite1指向的buffer元素</li>
<li>两个迭代器之间的buffer的所有元素</li>
</ol>
</blockquote>
<ul>
<li><p>++运算符</p>
<blockquote>
<p>“连续空间”下++使ite指向后一个元素</p>
<p>根据cur与边界(first/last)的等值关系来判断是超过buffer界限</p>
</blockquote>
</li>
<li><p>–运算符</p>
<blockquote>
<p>“连续空间”下++使ite指向前一个元素</p>
<p>根据cur与边界(first/last)的等值关系来判断是超过buffer界限</p>
</blockquote>
</li>
<li><p>+=运算符 ite += n</p>
<blockquote>
<p>根据偏移量大小正负来判断是否超过buffer界限(前后均有界)</p>
</blockquote>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="keyword">class</span> <span class="title">Ref</span>,<span class="keyword">class</span> <span class="title">Ptr</span>, <span class="title">size_t</span> <span class="title">BufSiz</span>=</span><span class="number">0</span>&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">iterator</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> random_acsess_iterator_tag iterator_category;</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">	<span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">	<span class="keyword">typedef</span> Ref reference;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> iterator self;</span><br><span class="line">	<span class="keyword">typedef</span> T** map_pointer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	reference <span class="keyword">operator</span>*() <span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> *cur;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">inline</span> <span class="keyword">size_t</span> __deque_buf_size(<span class="keyword">size_t</span> n, <span class="keyword">size_t</span> sz) &#123;</span><br><span class="line">		<span class="keyword">return</span> n != <span class="number">0</span> ? n : (sz &lt; <span class="number">512</span> ? (<span class="keyword">size_t</span>)(<span class="number">512</span> / sz) : <span class="built_in">size_t</span>(<span class="number">1</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	difference_type <span class="keyword">operator</span>- (<span class="keyword">const</span> self&amp; x) &#123;</span><br><span class="line">		<span class="keyword">auto</span> bfnums = (node - x.node - <span class="number">1</span>)*(difference_type)(<span class="built_in">buffer_size</span>()); <span class="comment">//作差的两个迭代器之间的(buffer个数)*(buffer大小)得出之间的元素个数</span></span><br><span class="line">		<span class="keyword">auto</span> front = x.last - x.cur; <span class="comment">// 被减的迭代器指向的buffer中的元素个数</span></span><br><span class="line">		<span class="keyword">auto</span> back = cur - first; <span class="comment">//减数迭代器指向的buffer中的元素个数</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> bfnums + front + back; <span class="comment">//三者作和得两作差迭代器之间的元素个数</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	self&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line"></span><br><span class="line">		cur++; <span class="comment">//当做连续空间，需要将cur指向下一个元素</span></span><br><span class="line">		<span class="comment">// 若cur++后超过当前buffer范围，则该迭代器需要指向下一个buffer</span></span><br><span class="line">		<span class="keyword">if</span> (cur == last) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">set_node</span>(node + <span class="number">1</span>); <span class="comment">//更新迭代器中first,last，node与buffer相关的特定属性</span></span><br><span class="line">			cur = first; <span class="comment">//重新更新cur指向使得cur指向&quot;连续空间&quot;的下一个元素</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	self <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line"></span><br><span class="line">		self temp = *<span class="keyword">this</span>;</span><br><span class="line">		++*<span class="keyword">this</span>;</span><br><span class="line">		<span class="keyword">return</span> *temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	self&amp; <span class="keyword">operator</span>--() &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 判断当前cur是否位于边界处，则该迭代器需要指向下一个buffer</span></span><br><span class="line">		<span class="keyword">if</span> (cur == first) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">set_node</span>(node - <span class="number">1</span>); <span class="comment">//更新迭代器中first,last，node与buffer相关的特定属性</span></span><br><span class="line">			cur = last; <span class="comment">//重新更新cur指向使得cur指向&quot;连续空间&quot;的下一个元素</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cur--; <span class="comment">//因为buffer的左边界就是首元素所以需要先作判断,并且last指向尾元素的下一个位置,需要--指向尾元素</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	self <span class="keyword">operator</span>--(<span class="keyword">int</span>) &#123;</span><br><span class="line"></span><br><span class="line">		self temp = *<span class="keyword">this</span>;</span><br><span class="line">		--*<span class="keyword">this</span>;</span><br><span class="line">		<span class="keyword">return</span> *temp;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">set_node</span><span class="params">(<span class="keyword">const</span> map_pointer&amp; new_node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		node = new_node;</span><br><span class="line">		first = *(new_node);</span><br><span class="line">		last = first + <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	self&amp; <span class="keyword">operator</span>+=(difference_type n) &#123;</span><br><span class="line">		difference_type offset = n + (cur - first); <span class="comment">//通过原cur位置前的元素与偏移量之和得出的新偏移量判断是否超出单buffer范围</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (offset &gt;= <span class="number">0</span> &amp;&amp; offset &lt; <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>())) &#123;</span><br><span class="line"></span><br><span class="line">			cur += n; <span class="comment">//未超过且执行的为+=操作则直接移动cur指针</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">			difference_type node_offset = offset &gt; <span class="number">0</span> ? offset / <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>()) : -<span class="built_in">difference_type</span>((-offset - <span class="number">1</span>) / (<span class="built_in">buffer_size</span>()); <span class="comment">//否则计算跨的buffer个数--node偏移量</span></span><br><span class="line">			<span class="built_in">set_node</span>(node + node_offset); <span class="comment">//更新迭代器</span></span><br><span class="line">			cur = first + offset - node_offset * <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>()); <span class="comment">//更新cur使其指向&quot;连续&quot;空间后移n位的元素，通过first+本buffer偏移量指定</span></span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">                                                                                                                  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	self <span class="keyword">operator</span>+(difference_type n) &#123;</span><br><span class="line">		self temp = *<span class="keyword">this</span>;</span><br><span class="line">		<span class="keyword">return</span> temp += n;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	self&amp; <span class="keyword">operator</span>-=(difference_type n) &#123;</span><br><span class="line">		*<span class="keyword">this</span> += -n;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	self&amp; <span class="keyword">operator</span>-(difference_type n) &#123;</span><br><span class="line">		self temp = *<span class="keyword">this</span>;</span><br><span class="line">		<span class="keyword">return</span> temp -= n;</span><br><span class="line">	&#125;</span><br><span class="line">	                                                                                                            reference <span class="keyword">operator</span>[] (difference_type n) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> *(*<span class="keyword">this</span> + n);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	map_pointer map;</span><br><span class="line">	pointer start;</span><br><span class="line">	pointer last;</span><br><span class="line">	pointer cur;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</blockquote>
<p>常用方法</p>
<blockquote>
<p><code>insert(iterator,const Type&amp;);</code></p>
<p>插入时候需要判断插入的位置距离头部与尾部的位置来决定头插还是尾插</p>
<p>距离谁近，从哪里插入！</p>
</blockquote>
<p>扩容机制</p>
<blockquote>
<p>vector扩容后各元素copy到中段，方便buffer的双向扩充而非从新内存的起始开始</p>
</blockquote>
<h5 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h5><blockquote>
<p>adapter适配器</p>
<p>不提供iterator迭代器以此来防止遍历操作</p>
<p>内含(复用)底层容器(默认deque)，直接使用底层容器的方法来实现queue的方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//queue</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="keyword">class</span> <span class="title">Sequence</span>=</span>deque&lt;T&gt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">queue</span>&#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="keyword">typedef</span> Sequence::value_type value_type</span><br><span class="line"> <span class="keyword">typedef</span> Sequence::size_type size_type</span><br><span class="line"> <span class="keyword">typedef</span> Sequence::reference reference</span><br><span class="line"> <span class="keyword">typedef</span> Sequence::const_reference const_reference</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"> Sequence c;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">empty</span>();&#125;</span><br><span class="line"> <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="keyword">return</span> c.<span class="built_in">size</span>();&#125;</span><br><span class="line"> <span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">front</span>();&#125;</span><br><span class="line"> <span class="function">const_reference <span class="title">front</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">front</span>();&#125;</span><br><span class="line"> <span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">back</span>();&#125;</span><br><span class="line"> <span class="function">const_reference <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">back</span>();&#125;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> value_type&amp; x)</span> </span>&#123;c.<span class="built_in">push_back</span>(x);&#125;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;c.<span class="built_in">pop_front</span>();&#125;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h5><blockquote>
<p>adapter适配器</p>
<p>不提供iterator迭代器以此来防止遍历操作</p>
<p>内含(复用)底层容器(默认deque)，直接使用底层容器的方法来实现stack的方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//stack</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="keyword">class</span> <span class="title">Sequence</span>=</span>deque&lt;T&gt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">stack</span>&#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="keyword">typedef</span> Sequence::value_type value_type</span><br><span class="line"> <span class="keyword">typedef</span> Sequence::size_type size_type</span><br><span class="line"> <span class="keyword">typedef</span> Sequence::reference reference</span><br><span class="line"> <span class="keyword">typedef</span> Sequence::const_reference const_reference</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"> Sequence c;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">empty</span>();&#125;</span><br><span class="line"> <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="keyword">return</span> c.<span class="built_in">size</span>();&#125;</span><br><span class="line"> <span class="function">reference <span class="title">top</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">back</span>();&#125;</span><br><span class="line"> <span class="function">const_reference <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">back</span>();&#125;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> value_type&amp; x)</span> </span>&#123;c.<span class="built_in">push_back</span>(x);&#125;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;c.<span class="built_in">pop_back</span>();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>底层容器的选择</p>
<blockquote>
<p>理论上说含有对应queue/stack所有方法的转调函数的容器均可以作底层容器如list</p>
<p>但是vector无法作queue的底层容器因为vector不提供queue.pop()的转调函数</p>
<p>set/map均无法作底层容器</p>
</blockquote>
<h4 id="Associative-Containers-关联容器-1"><a href="#Associative-Containers-关联容器-1" class="headerlink" title="Associative Containers 关联容器"></a>Associative Containers 关联容器</h4><h5 id="Rb-tree-红黑树初识"><a href="#Rb-tree-红黑树初识" class="headerlink" title="Rb_tree 红黑树初识"></a>Rb_tree 红黑树初识</h5><blockquote>
<p>高度平衡的二叉搜索树</p>
<p>提供iterator迭代器遍历整个红黑树</p>
<p>但是不应使用iterator迭代器去改变元素值，但是map可以因为map容器应提供可更改元素data的迭代器，只是元素的key不可被改变</p>
</blockquote>
<p>rb_tree</p>
<p>GCC2.9</p>
<blockquote>
<p>部分组成</p>
<p>数据成员大小 4+4+1=9 -&gt; 12 byte  函数对象为仿函数，类中仅有对()操作符的重载，因此大小为0，编译器作1处理，但是应为4的倍数，最近的为12</p>
<p>-</p>
<p>红黑树结点个数</p>
<p>头结点</p>
<p>Compare仿函数</p>
<blockquote>
<p>封装通过value值得到key值函数的类</p>
</blockquote>
<p>-</p>
<p>GCC4.9</p>
<p>增加了color enum类型的颜色成员</p>
<p>数据成员大小为24byte</p>
<p>-</p>
<p>需要有5个模板参数</p>
<p>key 键的类型</p>
<p>value value对象 = key对象 + data对象</p>
<p>Alloc 分配器</p>
<p>keyofvalue </p>
<blockquote>
<p>用于从value取出key值的仿函数</p>
<p>若key = value ，则gcc2.9提供了identity<T>仿函数来返回key值</T></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Arg</span>,<span class="keyword">class</span> <span class="title">Result</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">unary_function</span> &#123;</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">typedef</span> Arg argument_type;</span><br><span class="line"> <span class="keyword">typedef</span> Result result_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">identity</span>:</span><span class="keyword">public</span> unary_function&lt;T,T&gt; &#123;</span><br><span class="line"> <span class="comment">// 1.需要公用继承unary_function</span></span><br><span class="line"> <span class="comment">// 2.identity为GCC2.9提供的其他编译环境需要将定义内置于对应容器类中</span></span><br><span class="line"> <span class="comment">// 3.返回值为const类型标明key值不允许被改变</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> T&amp; <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> T&amp; x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</blockquote>
<p>compare 封装key对象比较大小的仿函数</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Arg1</span>,<span class="keyword">class</span> <span class="title">Arg2</span>,<span class="keyword">class</span> <span class="title">Result</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binary_function</span> &#123;</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">typedef</span> Arg1 first_argument_type;</span><br><span class="line"> <span class="keyword">typedef</span> Arg2 second_argument_type;</span><br><span class="line"> <span class="keyword">typedef</span> Result result_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">less</span>:</span><span class="keyword">public</span> binary_function&lt;T,T,T&gt; &#123;</span><br><span class="line"> <span class="comment">// 需要公用继承binary_function</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> T&amp; x,<span class="keyword">const</span> T&amp; y)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt; y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</blockquote>
<p>-</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>,</span></span><br><span class="line"><span class="class">	<span class="keyword">class</span> <span class="title">Value</span>,</span></span><br><span class="line"><span class="class">	<span class="keyword">class</span> <span class="title">Keyofvalue</span>,</span></span><br><span class="line"><span class="class">	<span class="keyword">class</span> <span class="title">Compare</span>,</span></span><br><span class="line"><span class="class">	<span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc</span><br><span class="line">&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">rb_tree</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> __rb_tree_node&lt;Value&gt;* rb_tree_node;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> rb_tree_node* link_type;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">	size_type node_count; <span class="comment">//红黑树结点个数</span></span><br><span class="line">	link_type header; <span class="comment">//头结点</span></span><br><span class="line">	Compare key_compare; <span class="comment">//函数对象 functor</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接口函数</p>
<blockquote>
<p>insert_unique() 插入元素不可重复，若重复不会插入元素</p>
<p>insert_equal() 插入元素可重复</p>
</blockquote>
</blockquote>
<h5 id="Set-Multiset"><a href="#Set-Multiset" class="headerlink" title="Set/Multiset"></a>Set/Multiset</h5><blockquote>
<p>以rb_tree为底层结构</p>
<p>key = value</p>
<p>set调用的insert接口为insert_unique()</p>
<p>Multiset调用的insert接口为insert_equal()</p>
<p>以set为例</p>
</blockquote>
<p>重要组成</p>
<blockquote>
<p>-</p>
<p>底层容器红黑树</p>
<p>const迭代器 不允许更改元素的key与data</p>
<p>-</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>,<span class="keyword">class</span> <span class="title">Compare</span> =</span> less&lt;Key&gt;,<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>=</span>alloc&gt;</span><br><span class="line">&gt;<span class="class"><span class="keyword">class</span> <span class="title">set</span> &#123;</span></span><br><span class="line">&gt;<span class="comment">//...</span></span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> Key Value_Type;</span><br><span class="line"><span class="keyword">typedef</span> Key Key_Type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Compare Key_Compare;</span><br><span class="line"><span class="keyword">typedef</span> Compare Value_Compare;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">identity</span> :</span><span class="keyword">public</span> unary_function&lt;T, T&gt; &#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">const</span> T&amp; <span class="title">operator</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x; <span class="comment">//其实x这里传入的是value，再由value取key</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">typedef</span> rb_tree&lt;Key_Type, Value_Type, identity, Key_Compare,Alloc&gt; rbt;</span><br><span class="line">rbt r;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> rbt::const_iterator iterator; <span class="comment">//使用const_iterator保证无法通过iterator改变元素值</span></span><br><span class="line"></span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="Map-Multimap"><a href="#Map-Multimap" class="headerlink" title="Map/Multimap"></a>Map/Multimap</h5><blockquote>
<p>以rb_tree为底层结构</p>
<p>均将key与data封装为一个pair对象作为value</p>
<p>Map调用的insert接口为insert_unique()</p>
<blockquote>
<p>map还提供了对[key]运算符的重载,存在key指定的元素则返回data值，不存在则insert插入元素</p>
</blockquote>
<p>Multimap调用的insert接口为insert_equal()</p>
<p>以map为例</p>
</blockquote>
<p>重要组成</p>
<blockquote>
<p>-</p>
<p>底层容器红黑树</p>
<p>迭代器 不允许更改元素的key但可以更改元素的data</p>
<p>-</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Compare</span> =</span> less&lt;Key&gt;, <span class="class"><span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">map</span> &#123;</span></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> Key Key_Type;</span><br><span class="line">	<span class="keyword">typedef</span> T Data_Type;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> pair&lt;<span class="keyword">const</span> Key_Type, Data_Type&gt; Value_Type; <span class="comment">//保证key无法被更改但是data可以</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> Compare Key_Compare;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">selectlst</span> :</span> unary_function&lt;value_type, Key_Type&gt; &#123;</span><br><span class="line">     <span class="function"><span class="keyword">const</span> Key_Type&amp; <span class="title">operator</span><span class="params">(<span class="keyword">const</span> value_type&amp; x)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">         <span class="keyword">return</span> x.first;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> rbt::iterator iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">typedef</span> rb_tree&lt;Key_Type, Value_Type, selectlst, Key_Compare, Alloc&gt; rbt;</span><br><span class="line">	rbt r;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="Unordered-Containers-无序容器-1"><a href="#Unordered-Containers-无序容器-1" class="headerlink" title="Unordered Containers 无序容器"></a>Unordered Containers 无序容器</h4><h5 id="hashtable"><a href="#hashtable" class="headerlink" title="hashtable"></a>hashtable</h5><blockquote>
<p>buckets vector + node   buckets数为质数 </p>
<p>hashtable hashmap详解本文略</p>
</blockquote>
<p>类结构基本组成</p>
<blockquote>
<p>五个模板参数</p>
<blockquote>
<p>相较于rb_tree多了一个hashfuc，用于计算obj对应的hash值</p>
</blockquote>
<p>-</p>
<p>…数据成员大小为 1+1+1+12+4 = 19 -&gt; 20 byte</p>
<p>内部维护一个vector容器，存放指向链结点的指针</p>
<p>-</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// buckets vector + node</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">hash_node</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//GCC2.9中node为单向链表</span></span><br><span class="line">	__hash_node* next;</span><br><span class="line">	T data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>,</span></span><br><span class="line"><span class="class">	<span class="keyword">class</span> <span class="title">Key</span>,</span></span><br><span class="line"><span class="class">	<span class="keyword">class</span> <span class="title">Hashfun</span>,</span></span><br><span class="line"><span class="class">	<span class="keyword">class</span> <span class="title">ExtractKey</span>,</span></span><br><span class="line"><span class="class">	<span class="keyword">class</span> <span class="title">EqualKey</span>,</span></span><br><span class="line"><span class="class">	<span class="keyword">class</span> <span class="title">Alloc</span>=</span>alloc</span><br><span class="line">&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hashtable</span> &#123;</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> Hashfun hasher;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> EqualKey key_equal;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">	hasher hash;</span><br><span class="line">	ExtractKey get_key;</span><br><span class="line">	key_equal equals;</span><br><span class="line"></span><br><span class="line">	size_type node_sums; <span class="comment">//存放所有结点元素数的寄存器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> __hash_node&lt;Data&gt; node;    </span><br><span class="line">    vector&lt;node*, alloc&gt; buckets;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>迭代器</p>
<blockquote>
<p>迭代器需要支持加减操作因此不仅需要有指向结点的指针还需要有返回中控vector的指针</p>
<p>hashtable的迭代器相较于rb_tree其允许通过迭代器改变结点的data但是不允许改变key，因为key是hash计算的依据</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>,</span></span><br><span class="line"><span class="class">	<span class="keyword">class</span> <span class="title">Key</span>,</span></span><br><span class="line"><span class="class">	<span class="keyword">class</span> <span class="title">Hashfun</span>,</span></span><br><span class="line"><span class="class">	<span class="keyword">class</span> <span class="title">ExtractKey</span>,</span></span><br><span class="line"><span class="class">	<span class="keyword">class</span> <span class="title">EqualKey</span>,</span></span><br><span class="line"><span class="class">	<span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc</span><br><span class="line">&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">hashtable_iterator</span> &#123;</span></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	__hash_node* next; <span class="comment">//指向结点的指针</span></span><br><span class="line">	hashtable* bk; <span class="comment">//指回vector的指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>扩容</p>
<blockquote>
<p>当node_sums结点个数大于buckets边界值时会进行2倍扩容并重新进行hash计算</p>
<p><code>注意:</code>buckets.size()扩容大小在GCC2.9中并不是一定为2的整数倍，而是2的整数倍附近的质数，初始53</p>
</blockquote>
<p>hashfunc and hashcode</p>
<blockquote>
<p>模板特化完成个类型对象-&gt;size_t类型的转换</p>
<p><code>注意:</code>Gcc2.9中 std模板库并没有提供对<code>hash&lt;std::string&gt;</code>的定义 目前已经有了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>&gt;</span> hash &#123;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Allocators-分配器"><a href="#Allocators-分配器" class="headerlink" title="Allocators 分配器"></a>Allocators 分配器</h2><h3 id="Allocator测试"><a href="#Allocator测试" class="headerlink" title="Allocator测试"></a>Allocator测试</h3><blockquote>
<p>为容器分配内存，不同分配器有不同的分配方式</p>
<p>内部包含一个allocate函数来分配内存，一个deallocate来删除内存并且需要知道起初分配的内存大小</p>
</blockquote>
<h3 id="operator-new-delete-与malloc-free"><a href="#operator-new-delete-与malloc-free" class="headerlink" title="operator new/delete 与malloc/free"></a>operator new/delete 与malloc/free</h3><blockquote>
<p>malloc分配的内存模型</p>
<ul>
<li>一对cookie</li>
<li>一对debug头</li>
<li>struct -size对应的部分</li>
<li>填充字节</li>
</ul>
<p>operator new/delete 的底层实现就是malloc/free</p>
</blockquote>
<h3 id="allocator"><a href="#allocator" class="headerlink" title="allocator"></a>allocator</h3><p>一个类模板,重要的两个函数</p>
<blockquote>
<p>pointer allocator(size_t)</p>
<p>void deallocator(pointer,size_t)</p>
<p>原型并不规范但是值得注意的是一般分配器的deallocator需要知道回收的内存大小才能进行回收，脱离容器直接使用很不方便</p>
</blockquote>
<h3 id="不同编译器对allocator的处理"><a href="#不同编译器对allocator的处理" class="headerlink" title="不同编译器对allocator的处理"></a>不同编译器对allocator的处理</h3><ul>
<li><p>VC6 STL 对allocator的使用与实现</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Visual c++ Builder Compiler</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;xmemory&gt;</span> <span class="comment">// 需要引入对应头文件</span></span></span><br><span class="line"><span class="comment">// VC6+的allocator只是以::operator new和::operator delete完成allocate()和deallocate()，没有任何特殊设计</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">int</span>*p=allocator&lt;<span class="keyword">int</span>&gt;().<span class="built_in">allocator</span>(size,(<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">allocator&lt;<span class="keyword">int</span>&gt;().<span class="built_in">deallocator</span>(p,size);</span><br><span class="line"><span class="comment">// 脱离容器直接使用分配器进行内存分配</span></span><br></pre></td></tr></table></figure>

<p>VC6+的allocator只是以::operator new和::operator delete完成allocate()和deallocate()，没有任何特殊设计</p>
</blockquote>
</li>
<li><p>BC5 STL 对allocator的使用与实现  </p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Borland C++ Builder Compiler</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory.stl&gt;</span> <span class="comment">// 需要引入对应头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">int</span>*p=allocator&lt;<span class="keyword">int</span>&gt;().<span class="built_in">allocator</span>(size); <span class="comment">// 第二个指针参数这里为默认参数省略</span></span><br><span class="line">allocator&lt;<span class="keyword">int</span>&gt;().<span class="built_in">deallocator</span>(p,size);</span><br><span class="line"><span class="comment">// 脱离容器直接使用分配器进行内存分配</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>BC++ 的allocator只是以::operator new和::operator delete完成allocate()和deallocate()，没有任何特殊设计</p>
</blockquote>
</li>
<li><p>GCC2.9</p>
<blockquote>
<p>GCC2.9 的allocator仍只是以::operator new和::operator delete完成allocate()和deallocate()，没有任何特殊设计</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GNU Compiler C++ Builder Compiler</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;defalloc.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>但是GCC2.9库中虽然有allocator但是实际并不使用该类模板做分配器，实际采用的是效率更高的alloc</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stl_alloc.h&gt;</span></span></span><br><span class="line"><span class="comment">// 脱离容器直接使用分配器进行内存分配</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">int</span>*p=alloc::<span class="built_in">allocate</span>(size);</span><br><span class="line">alloc::<span class="built_in">deallocate</span>(p,size);</span><br></pre></td></tr></table></figure>

<p>alloc内存管理</p>
<blockquote>
<p>尽量减少malloc的次数</p>
<p>尽量使得为容器元素分配的内存不带cookie</p>
</blockquote>
<p>具体先略，理解模糊</p>
</blockquote>
</li>
<li><p>GCC4.9</p>
<blockquote>
<p>GCC4.9实际使用的仍是以::operator new和::operator delete完成allocate()和deallocate()</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/allocator.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/new_allocator.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>但是仍然可选择使用GCC2.9的alloc分配器</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span> <span class="comment">// 内含std::allocator</span></span></span><br><span class="line"><span class="comment">// 欲使用std::allocator以外的分配器需要自行#include&lt;ext\...&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// extension allocators 中的__pool_alloc就是GCC2.9的alloc分配器</span></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ext\pool_allocator.h&gt;</span></span></span><br><span class="line">vector&lt;<span class="keyword">int</span>,__gnu_cxx::__pool_alloc&lt;string&gt;&gt; vec;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<h2 id="Iterator-迭代器"><a href="#Iterator-迭代器" class="headerlink" title="Iterator 迭代器"></a>Iterator 迭代器</h2><h3 id="迭代器的设计原则"><a href="#迭代器的设计原则" class="headerlink" title="迭代器的设计原则"></a>迭代器的设计原则</h3><p>至少需要具备5个associated关联类型</p>
<blockquote>
<p>需要回答算法的提问，某些算法中会使用到其中的类型</p>
</blockquote>
<h3 id="Class-iterator"><a href="#Class-iterator" class="headerlink" title="Class iterator"></a>Class iterator</h3><blockquote>
<p>以类封装的iterator可以自己定义associated type</p>
<p>cl_iterator</p>
<blockquote>
<p>模板类内部对关联类型作定义</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cl_iterator</span> &#123;</span></span><br><span class="line">	<span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category; <span class="comment">//迭代器的种类</span></span><br><span class="line">	<span class="comment">//bidirectional为双向链表iterator类型</span></span><br><span class="line">	<span class="keyword">typedef</span> T value_type; <span class="comment">//数据类型</span></span><br><span class="line">	<span class="keyword">typedef</span> Ptr pointer; <span class="comment">//指向node类型的指针</span></span><br><span class="line">	<span class="keyword">typedef</span> Ref reference; <span class="comment">//node类型的引用类型</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type; <span class="comment">//两个迭代器之间距离的类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>algorithm</p>
<blockquote>
<p>直接通过迭代器本身来获取关联类型</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">algorithm</span><span class="params">(I first,I last)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> I::category v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Native-pointer"><a href="#Native-pointer" class="headerlink" title="Native pointer"></a>Native pointer</h3><blockquote>
<p>native pointer是一种退化的iterator，没有能力自己定义associated type</p>
<p>所以algorithm无法直接通过迭代器本身获取关联类型</p>
</blockquote>
<h3 id="Iterator-Triats"><a href="#Iterator-Triats" class="headerlink" title="Iterator Triats"></a>Iterator Triats</h3><blockquote>
<p>”萃取机“以<strong>偏特化</strong>使得以上两种iterator类型均满足设计原则</p>
<p>for cl_iterator</p>
<blockquote>
<p>在已定义cl_cl_iterator迭代器的情况下可直接使用已定义的</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span> &#123;</span></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> T::category iterator_category;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> T::value_type value_type;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> T::pointer pointer;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> T::reference reference;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> T::difference_type difference_type;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>for native pointer</p>
<blockquote>
<p>区分const pointer与no_const pointer</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//no_const pointer </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span>&lt;</span>T*&gt; &#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="keyword">typedef</span> random_access_iterator_tag iterator_category; <span class="comment">//迭代器的种类</span></span><br><span class="line">	<span class="comment">//bidirectional为双向链表特有iterator类型</span></span><br><span class="line">	<span class="keyword">typedef</span> T value_type; <span class="comment">//数据类型</span></span><br><span class="line">	<span class="keyword">typedef</span> T* pointer; <span class="comment">//指向node类型的指针</span></span><br><span class="line">	<span class="keyword">typedef</span> T&amp; reference; <span class="comment">//node类型的引用类型</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type; <span class="comment">//两个迭代器之间距离的类型</span></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//const pointer特殊在取得的value_type不希望为const T</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span>&lt;</span><span class="keyword">const</span> T*&gt; &#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="keyword">typedef</span> random_access_iterator_tag iterator_category; <span class="comment">//迭代器的种类</span></span><br><span class="line">	<span class="comment">//bidirectional为双向链表特有iterator类型</span></span><br><span class="line">	<span class="keyword">typedef</span> T value_type; <span class="comment">//数据类型</span></span><br><span class="line">	<span class="keyword">typedef</span> T* pointer; <span class="comment">//指向node类型的指针</span></span><br><span class="line">	<span class="keyword">typedef</span> T&amp; reference; <span class="comment">//node类型的引用类型</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type; <span class="comment">//两个迭代器之间距离的类型</span></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>algorithm</p>
<blockquote>
<p>通过”萃取机”来间接获取迭代器的关联类型</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>,...&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">algorithm</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">typedef</span> iterator_traits&lt;I&gt;::category v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight plain"><figcaption><span>typename 后面声明的字符串作类型处理</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## Algorithm - STL中的算法</span><br><span class="line"></span><br><span class="line">&gt; function template</span><br><span class="line">&gt;</span><br><span class="line">&gt; Algogithms 对 Containers进行操作，必须由Iterators提供容器的一些性质信息，而Iterators也必须能够回答算法的这些提问</span><br><span class="line"></span><br><span class="line">### Iterator_category</span><br><span class="line"></span><br><span class="line">#### 五大迭代器种类以及继承关系</span><br><span class="line"></span><br><span class="line">&gt; struct input_iterator_tag</span><br><span class="line">&gt;</span><br><span class="line">&gt; -</span><br><span class="line">&gt;</span><br><span class="line">&gt; struct forward_iterator_tag : input_iterator_tag</span><br><span class="line">&gt;</span><br><span class="line">&gt; struct bidirectional_iterator_tag :  forward_iterator_tag</span><br><span class="line">&gt;</span><br><span class="line">&gt; struct random_acess_iterator_tag : bidirectional_iterator_tag</span><br><span class="line">&gt;</span><br><span class="line">&gt; -</span><br><span class="line">&gt;</span><br><span class="line">&gt; struct output_iterator_tag</span><br><span class="line">&gt;</span><br><span class="line">&gt; &gt; write-only 不允许使用该迭代器读取数据</span><br><span class="line"></span><br><span class="line">#### 类型名称</span><br><span class="line"></span><br><span class="line">&gt; &#96;&#96;&#96;c++ </span><br><span class="line">&gt; #include&lt;typeinfo&gt;</span><br><span class="line">&gt; typeid(iterator).name()  &#x2F;&#x2F;获得对应迭代器的类型名称</span><br><span class="line">&gt; &#x2F;&#x2F;不同编译环境下有不同的类型名称，不过核心部分相同，一些编号不同</span><br></pre></td></tr></table></figure>

<h4 id="容器的迭代器种类"><a href="#容器的迭代器种类" class="headerlink" title="容器的迭代器种类"></a>容器的迭代器种类</h4><blockquote>
<p>input_iterator_tag</p>
<blockquote>
<p>iostream</p>
</blockquote>
<p>-</p>
<p>forward_iterator_tag</p>
<blockquote>
<p>hashtable</p>
<p>单向链表forward_list</p>
</blockquote>
<p>bidirectional_iterator_tag</p>
<blockquote>
<p>rb_tree</p>
<p>双向链表list</p>
</blockquote>
<p>random_acess_iterator_tag</p>
<blockquote>
<p>array</p>
<p>vector</p>
<p>deque</p>
</blockquote>
<p>-</p>
<p>output_iterator_tag</p>
<blockquote>
<p>ostream</p>
</blockquote>
</blockquote>
<h4 id="Iterator-category对Algorithm的影响"><a href="#Iterator-category对Algorithm的影响" class="headerlink" title="Iterator_category对Algorithm的影响"></a>Iterator_category对Algorithm的影响</h4><blockquote>
<p><strong>distance</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//distance 计算两个迭代器之间的距离</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">iterator</span>&gt;</span></span><br><span class="line">iterator_traits&lt;iterator&gt;::<span class="function">difference_type <span class="title">distance</span><span class="params">(iterator ite1,iterator ite2)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;iterator&gt;::iterator_category category; <span class="comment">//获取category类型</span></span><br><span class="line"> <span class="comment">//通过__distance完成对类型不同迭代器的distance操作，需要传入临时类型对象</span></span><br><span class="line"> <span class="keyword">return</span> __distance(ite1,ite2,<span class="built_in">category</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">iterator</span>&gt;</span></span><br><span class="line">iterator_traits&lt;iterator&gt;::difference_type __distance(iterator ite1,iterator ite2,random_access_iterator_tag) &#123;</span><br><span class="line"> <span class="keyword">return</span> ite2 - ite1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">iterator</span>&gt;</span></span><br><span class="line">iterator_traits&lt;iterator&gt;::difference_type __distance(iterator ite1,input_iterator) &#123;</span><br><span class="line"> <span class="keyword">typename</span> iterator_traits&lt;iterator&gt;::difference_type n = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">while</span>(ite1 != ite2) &#123;</span><br><span class="line">     ite++;</span><br><span class="line">     n++;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>advance</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//advance 移动指针</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">iterator</span>,<span class="keyword">class</span> <span class="title">distance</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">advance</span><span class="params">(iterator&amp; ite,distance dis)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;iterator&gt;::iterator_category category; <span class="comment">//获取category类型</span></span><br><span class="line"> <span class="comment">//通过__advance完成对类型不同迭代器的advance操作，需要传入临时类型对象</span></span><br><span class="line"> <span class="keyword">return</span> __advance(ite,dis,<span class="built_in">category</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">iterator</span>,<span class="keyword">class</span> <span class="title">distance</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">advance</span><span class="params">(iterator&amp; ite,distance dis,input_iterator)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(--n) &#123;</span><br><span class="line">     ite++;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">iterator</span>,<span class="keyword">class</span> <span class="title">distance</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">advance</span><span class="params">(iterator&amp; ite,distance dis,bidirectional_iterator_tag)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n&gt;<span class="number">0</span>) &#123;</span><br><span class="line">     <span class="keyword">while</span>(--n) &#123;</span><br><span class="line">     ite++;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">while</span>(++n) &#123;</span><br><span class="line">     ite--;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">iterator</span>,<span class="keyword">class</span> <span class="title">distance</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">advance</span><span class="params">(iterator ite,distance dis,random_access_iterator_tag)</span> </span>&#123;</span><br><span class="line">	ite += dis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>注意:</code>算法只能够<strong>暗示</strong>该算法需要接收的模板迭代器类型，无法控制或者说限制调用时传入的模板类型</p>
</blockquote>
<h3 id="算法部分源码剖析"><a href="#算法部分源码剖析" class="headerlink" title="算法部分源码剖析"></a>算法部分源码剖析</h3><p><strong>accumulate</strong> </p>
<blockquote>
<p>累积运算 将指定范围的数据进行累积运算并将结果返回</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span> <span class="comment">//std::accumulate</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span>&lt;</span><span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>,<span class="keyword">class</span> <span class="title">T</span>,<span class="keyword">class</span> <span class="title">BinaryOperator</span>&gt;</span></span><br><span class="line"><span class="function">T <span class="title">accumulate</span><span class="params">(InputIterator first,InputIterator last,T init,BinaryOperator binary_op)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;first!=last;first++) &#123;</span><br><span class="line">        init = <span class="built_in">binary_op</span>(init,*first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> init;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="keyword">int</span> init = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> num[] = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;;</span><br><span class="line"><span class="built_in">accumulate</span>(num,num+<span class="number">3</span>,init);</span><br><span class="line"></span><br><span class="line"><span class="comment">//binary_op可以传入函数入口地址，或者仿函数对象，或者不传入使用默认的二元操作函数plus&lt;&gt;();</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>for_each</strong></p>
<blockquote>
<p>遍历操作 将指定指定范围的每个数据进行相同操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span> <span class="comment">//std::for_each</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>,<span class="keyword">class</span> <span class="title">Function</span>&gt;</span></span><br><span class="line"><span class="function">Function <span class="title">for_each</span><span class="params">(InputIterator first,InputIterator last,Function f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;first!=last;++first) &#123;</span><br><span class="line">        <span class="built_in">f</span>(*first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>replace,replace_if,replace_copy</strong></p>
<blockquote>
<p>对指定指定范围内的数据进行<strong>替代与拷贝</strong></p>
<p>replace 指定范围的数据使用新值替代指定的旧值</p>
<p>replace_if 指定范围的数据满足条件的替换 需要传入一个可返回true/false的函数对象</p>
<p>replace_copy 对指定范围的数据进行拷贝，等于指定值时使用新值替代否则原样拷贝</p>
</blockquote>
<p><strong>count,count_if</strong></p>
<blockquote>
<p>对指定指定范围内的数据进行<strong>计数</strong></p>
<p>count 计数等于指定值的元素个数</p>
<p>count_if 计数满足指定条件的元素个数</p>
<p>序列容器没有内置的count,count_if函数重载</p>
<p>关联式容器内置有对count,count_if函数的重载</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//count</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>,<span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::<span class="function">difference_type <span class="title">count</span><span class="params">(InputIterator first,InputIterator last,<span class="keyword">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::difference_type n = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span>(;first!=last;++first) &#123;</span><br><span class="line">     <span class="keyword">if</span>(*first==value) &#123;</span><br><span class="line">         n++;</span><br><span class="line">     &#125;</span><br><span class="line"> <span class="keyword">return</span> n;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//count_if</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>,<span class="keyword">class</span> <span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::<span class="function">difference_type <span class="title">count_if</span><span class="params">(InputIterator first,InputIterator last,Predicate pre)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::difference_type n = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span>(;first!=last;++first) &#123;</span><br><span class="line">     <span class="keyword">if</span>(<span class="built_in">pre</span>(*<span class="keyword">this</span>)) &#123;</span><br><span class="line">         n++;</span><br><span class="line"> 	&#125;</span><br><span class="line"> <span class="keyword">return</span> n;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</blockquote>
<p><strong>find,find_if</strong></p>
<blockquote>
<p>对指定指定范围内的数据进行<strong>循序式查找</strong></p>
<p>find 查找等于指定值的元素</p>
<p>find_if 查找满足指定条件的元素 </p>
<p>序列容器没有内置的find,find_if函数重载</p>
<p>关联式容器内置有对find,find_if函数的重载</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//find</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>,<span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function">InputIterator <span class="title">find</span><span class="params">(InputIterator first,InputIterator last,<span class="keyword">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">for</span>(;first!=last;++first) &#123;</span><br><span class="line">     <span class="keyword">if</span>(*first==value) &#123;</span><br><span class="line">         <span class="keyword">return</span> first;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//find_if</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>,<span class="keyword">class</span> <span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="function">InputIterator <span class="title">find_if</span><span class="params">(InputIterator first,InputIterator last,Predicate pre)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"> <span class="keyword">for</span>(;first!=last;++first) &#123;</span><br><span class="line">     <span class="keyword">if</span>(<span class="built_in">pre</span>(*<span class="keyword">this</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span> first;</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>sort</strong></p>
<blockquote>
<p>对指定指定范围内的数据进行<strong>排序</strong></p>
<blockquote>
<p>暗示要求的迭代器类型为random_acess_iterator_tag，所以其他容器无法调用该方法</p>
</blockquote>
<p>list,forward_list内置有对sort函数的重载</p>
<p>其余容器没有内置的sort函数重载</p>
<blockquote>
<p>关联容器内的元素已经是”有序”的不要再去调用sort排序了</p>
</blockquote>
</blockquote>
<p><strong>binary_search</strong></p>
<blockquote>
<p>对指定指定范围内的<strong>有序</strong>数据进行<strong>二分查找</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内部实际为调用lower_bound/upper_bound</span></span><br><span class="line"><span class="comment">//lower_bound(first,last,val); 返回不违反当前排序状态的情况下val能插入的最低点</span></span><br><span class="line"><span class="comment">//upper_bound(first,last,val); 返回不违反当前排序状态的情况下val能插入的最高点</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>,<span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">binary_search</span><span class="params">(ForwardIterator first,ForwardIterator last,<span class="keyword">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">	first = <span class="built_in">lower_bound</span>(first,last,value);</span><br><span class="line">    <span class="keyword">return</span> (first!=last &amp;&amp; !(val&lt;*first))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Functors-仿函数"><a href="#Functors-仿函数" class="headerlink" title="Functors 仿函数"></a>Functors 仿函数</h2><blockquote>
<p>只为算法服务，提供规范标准</p>
</blockquote>
<h4 id="STL标准库中Functors的基本种类"><a href="#STL标准库中Functors的基本种类" class="headerlink" title="STL标准库中Functors的基本种类"></a>STL标准库中Functors的基本种类</h4><blockquote>
<p><strong>算数类</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//+</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">plus</span>:</span><span class="keyword">public</span> binary_function&lt;T,T,T&gt; &#123;</span><br><span class="line">    <span class="function">T <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>逻辑运算类</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&amp;&amp;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">logic_and</span>:</span><span class="keyword">public</span> binary_function&lt;T,T,T&gt; &#123;</span><br><span class="line">    <span class="function">T <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp;&amp; y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>相对关系类</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//==</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">equal_to</span>:</span><span class="keyword">public</span> binary_function&lt;T,T,<span class="keyword">bool</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> T&amp; x, <span class="keyword">const</span> T&amp; y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x == y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="GNU-C-独有的Functors的种类"><a href="#GNU-C-独有的Functors的种类" class="headerlink" title="GNU C++独有的Functors的种类"></a>GNU C++独有的Functors的种类</h4><blockquote>
<p><strong>keyofvalue</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// identity</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">identity</span> :</span><span class="keyword">public</span> unary_function&lt;T, T&gt; &#123;</span><br><span class="line">	<span class="function"><span class="keyword">const</span> T&amp; <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> T&amp; x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x; <span class="comment">//其实x这里传入的是value，再由value取key</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//selectlst</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="function">struct <span class="title">pair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">pair</span>():<span class="built_in">first</span>(<span class="built_in">T1</span>()),<span class="built_in">second</span>(<span class="built_in">T2</span>())&#123;&#125;</span><br><span class="line">    <span class="built_in">pair</span>(<span class="keyword">const</span> T1&amp; a,<span class="keyword">const</span> T2&amp; b):<span class="built_in">first</span>(a),<span class="built_in">second</span>(b)&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">typedef</span> T1 first_type;</span><br><span class="line">    <span class="keyword">typedef</span> T2 second_type;</span><br><span class="line">    </span><br><span class="line">    T1 first;</span><br><span class="line">    T2 second;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">selectlst</span> :</span> unary_function&lt;Pair, <span class="keyword">typename</span> Pair::first_type&gt; &#123;</span><br><span class="line">	<span class="function"><span class="keyword">const</span> <span class="keyword">typename</span> Pair::first_type&amp; <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> Pair&amp; x)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> x.first;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="Functors的可适配-adaptable-条件"><a href="#Functors的可适配-adaptable-条件" class="headerlink" title="Functors的可适配(adaptable)条件"></a>Functors的可适配(adaptable)条件</h4><blockquote>
<p>Functors必须继承unary_function或者binary_function中的一个</p>
<p>因为父类中typedef的类型会被适配器提问到</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//运算只有一个操作数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Arg</span>,<span class="keyword">class</span> <span class="title">Result</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">unary_function</span> &#123;</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">typedef</span> Arg argument_type;</span><br><span class="line"> <span class="keyword">typedef</span> Result result_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运算具有两个操作数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Arg1</span>,<span class="keyword">class</span> <span class="title">Arg2</span>,<span class="keyword">class</span> <span class="title">Result</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binary_function</span> &#123;</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">typedef</span> Arg1 first_argument_type;</span><br><span class="line"> <span class="keyword">typedef</span> Arg2 second_argument_type;</span><br><span class="line"> <span class="keyword">typedef</span> Result result_type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Adapter-适配器"><a href="#Adapter-适配器" class="headerlink" title="Adapter 适配器"></a>Adapter 适配器</h2><blockquote>
<p>复合 + “改造”</p>
</blockquote>
<h4 id="Container-Adapters"><a href="#Container-Adapters" class="headerlink" title="Container Adapters"></a>Container Adapters</h4><blockquote>
<p>复合了底层容器的”容器”</p>
</blockquote>
<p><strong>Stack,Queue</strong></p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//stack</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="keyword">class</span> <span class="title">Sequence</span>=</span>deque&lt;T&gt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">stack</span>&#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> Sequence::value_type value_type</span><br><span class="line">    <span class="keyword">typedef</span> Sequence::size_type size_type</span><br><span class="line">    <span class="keyword">typedef</span> Sequence::reference reference</span><br><span class="line">    <span class="keyword">typedef</span> Sequence::const_reference const_reference</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Sequence c;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">empty</span>();&#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="keyword">return</span> c.<span class="built_in">size</span>();&#125;</span><br><span class="line">    <span class="function">reference <span class="title">top</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">back</span>();&#125;</span><br><span class="line">    <span class="function">const_reference <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">back</span>();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> value_type&amp; x)</span> </span>&#123;c.<span class="built_in">push_back</span>(x);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;c.<span class="built_in">pop_back</span>();&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//queue</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="keyword">class</span> <span class="title">Sequence</span>=</span>deque&lt;T&gt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">queue</span>&#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> Sequence::value_type value_type</span><br><span class="line">    <span class="keyword">typedef</span> Sequence::size_type size_type</span><br><span class="line">    <span class="keyword">typedef</span> Sequence::reference reference</span><br><span class="line">    <span class="keyword">typedef</span> Sequence::const_reference const_reference</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Sequence c;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">empty</span>();&#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="keyword">return</span> c.<span class="built_in">size</span>();&#125;</span><br><span class="line">    <span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">front</span>();&#125;</span><br><span class="line">    <span class="function">const_reference <span class="title">front</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">front</span>();&#125;</span><br><span class="line">    <span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">back</span>();&#125;</span><br><span class="line">    <span class="function">const_reference <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">back</span>();&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> value_type&amp; x)</span> </span>&#123;c.<span class="built_in">push_back</span>(x);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;c.<span class="built_in">pop_front</span>();&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="Functor-Adapters"><a href="#Functor-Adapters" class="headerlink" title="Functor Adapters"></a>Functor Adapters</h4><blockquote>
<p>复合了底层Functor的”Functor”,本身也具有原Functor的性质，只不过叫成了Functor Adapters</p>
</blockquote>
<p><strong>binder2nd</strong></p>
<blockquote>
<p>绑定二元操作functor的第二个参数为指定值</p>
<p>实际为一个一元操作符的Functor</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//count_if</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>,<span class="keyword">class</span> <span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::<span class="function">difference_type <span class="title">count_if</span><span class="params">(InputIterator first,InputIterator last,Predicate pre)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::difference_type n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;first!=last;++first) &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">pre</span>(*<span class="keyword">this</span>)) &#123;</span><br><span class="line">n++;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="keyword">int</span> n = <span class="built_in">count_if</span>(v1.first,v1.last,<span class="built_in">bind2nd</span>(less&lt;<span class="keyword">int</span>&gt;(),<span class="number">40</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//bind2nd&lt;&gt;</span></span><br><span class="line"><span class="comment">//辅助函数 用于使用更为简易的参数创建并返回binder2nd&lt;Operation&gt;适配器对象</span></span><br><span class="line"><span class="comment">//创建binder2nd&lt;&gt;对象的类型参数为functor类型，但是普通用户很难知道摸个functor的类型是什么</span></span><br><span class="line"><span class="comment">//对于函数模板,编译器会根据实参传入的对象推断其类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>&lt;</span><span class="class"><span class="keyword">class</span> <span class="title">Operation</span>,<span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">typename</span> binder2nd&lt;Operation&gt; <span class="title">bind2nd</span><span class="params">(<span class="keyword">const</span> Operation&amp; op,<span class="keyword">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">tydef <span class="keyword">typename</span> Operation::second_type arg2_type;</span><br><span class="line"><span class="keyword">return</span> binder2nd&lt;Operation&gt;(op,<span class="built_in">arg2_type</span>(x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//binder2nd&lt;&gt;</span></span><br><span class="line"><span class="comment">//为了使该适配器也是adaptable的可是配的，因此该适配器也要继承对应父类模板，来回答问题</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>&lt;</span><span class="class"><span class="keyword">class</span> <span class="title">Operation</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder2nd</span>:</span><span class="keyword">public</span> unary_function&lt;<span class="keyword">typename</span> Operation::first_argument_type,<span class="keyword">typename</span> Operation::result_type&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">binder2nd</span>(<span class="keyword">const</span> Operation&amp; x,<span class="keyword">typename</span> Operation::second_argument_type y):<span class="built_in">op</span>(x),<span class="built_in">value</span>(y)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typename</span> Operation::result_type <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">typename</span> Operation::first_argument_type&amp; x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">op</span>(x,value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">Operation op;</span><br><span class="line"><span class="comment">//使用value记录用于原functor的需要绑定的参数</span></span><br><span class="line"><span class="keyword">typename</span> Operation::second_argument_type value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>not1</strong></p>
<blockquote>
<p>取否</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//count_if</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>,<span class="keyword">class</span> <span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::<span class="function">difference_type <span class="title">count_if</span><span class="params">(InputIterator first,InputIterator last,Predicate pre)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::difference_type n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;first!=last;++first) &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">pre</span>(*<span class="keyword">this</span>)) &#123;</span><br><span class="line">n++;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="keyword">int</span> n = <span class="built_in">count_if</span>(c1.first,c1.last,<span class="built_in">not1</span>(<span class="built_in">bind2nd</span>(less&lt;<span class="keyword">int</span>&gt;(),<span class="number">40</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">//not1</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="function">unary_negate&lt;Predicate&gt; <span class="title">count_if</span><span class="params">(<span class="keyword">const</span> Predicate&amp; pre)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unary_negate&lt;Predicate&gt;(pre);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">unary_negate</span>:</span><span class="keyword">public</span> unary_function&lt;<span class="keyword">typename</span> Predicate::first_argument_type,<span class="keyword">bool</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//单个参数的为了禁止隐式转换而是用explicit修饰符</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">unary_negate</span><span class="params">(<span class="keyword">const</span> Predicate&amp; pre)</span>:op(pre)&#123;</span>&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Predicate op;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">typename</span> Predicate::first_argument_type&amp; x)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> !<span class="built_in">op</span>(x);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>bind</strong></p>
<blockquote>
<p>c++11提供的新型适配器</p>
<p>std::bind可以绑定</p>
<ul>
<li>functions</li>
<li>function objects</li>
<li>member functions _1必须是某个object地址</li>
<li>data members _1必须是某个object地址</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholder; <span class="comment">//adds visibility of _1,_2 占位符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n = <span class="built_in">count_if</span>(v1.first,v1.last,<span class="built_in">bind2nd</span>(less&lt;<span class="keyword">int</span>&gt;(),<span class="number">40</span>));</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">auto</span> fn_ = <span class="built_in">bind</span>(less&lt;<span class="keyword">int</span>&gt;(),_1,<span class="number">40</span>);</span><br><span class="line"><span class="keyword">int</span> n = <span class="built_in">count_if</span>(v1.first,v1.last,fn_);</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="Iterator-Adapters"><a href="#Iterator-Adapters" class="headerlink" title="Iterator Adapters"></a>Iterator Adapters</h4><p><strong>Reverse_iterator</strong></p>
<blockquote>
<p>逆向”迭代器”</p>
<p>rbegin(); 返回指向正向容器尾元素的迭代器</p>
<p>rend(); 返回指向正向容器首元素上一个位置的迭代器</p>
<p>++实现从rbegin() -&gt; rend()的遍历</p>
<p><img src="/images/C++/image-20210711194134888.png" alt="image-20210711194134888"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//reverse_iterator为适配器</span></span><br><span class="line"><span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">reverse_iterator</span>(<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">reverse_iterator</span>(<span class="built_in">begin</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">reverse_iterator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="comment">//为了使该适配器仍可适配-改造 仍需要具备迭代器基本的5个关联类型</span></span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::iterator_category category;</span><br><span class="line">   	<span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::value_type value_type; <span class="comment">//数据类型</span></span><br><span class="line">   	<span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::pointer pointer; <span class="comment">//指向node类型的指针</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::reference reference; <span class="comment">//node类型的引用类型</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::difference_type difference_type; <span class="comment">//两个迭代器之间距离的类型</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">typedef</span> Iterator iterator_type;</span><br><span class="line">     <span class="keyword">typedef</span> reverse_iterator&lt;Iterator&gt; self;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//可使用正向迭代器初始化逆向迭代器也可使用逆向迭代器初始化</span></span><br><span class="line"> <span class="built_in">reverse_iterator</span>(<span class="keyword">const</span> Iterator&amp; x):<span class="built_in">current</span>(x)&#123;&#125;</span><br><span class="line">    <span class="built_in">reverse_iterator</span>(<span class="keyword">const</span> self&amp; x):<span class="built_in">current</span>(x.current)&#123;&#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//取出相应的正向迭代器</span></span><br><span class="line">     <span class="function">iterator_type <span class="title">base</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> current;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//逆向迭代器返回对应正向迭代器的前一位的值</span></span><br><span class="line">     reference <span class="keyword">operator</span>*() <span class="keyword">const</span>&#123;</span><br><span class="line">        self temp = current;</span><br><span class="line">        <span class="keyword">return</span> *--temp;</span><br><span class="line">    &#125;</span><br><span class="line">    pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*())</span><br><span class="line">    &#125;</span><br><span class="line">    self&amp; <span class="keyword">operator</span>++()&#123;</span><br><span class="line">        --current;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    self&amp; <span class="keyword">operator</span>--() &#123;</span><br><span class="line">        ++current;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    self <span class="keyword">operator</span>+(<span class="keyword">const</span> value_type&amp; x) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">self</span>(current - x);</span><br><span class="line">    &#125;</span><br><span class="line">    self <span class="keyword">operator</span>-(<span class="keyword">const</span> value_type&amp; x) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">self</span>(current + x);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">    Iterator current;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>inserter</strong></p>
<p>copy</p>
<blockquote>
<p>a copy to b<br><code>copy(a.begin(),a.end(),b.begin());</code></p>
<p>参数12指定a中copy的范围 </p>
<p>参数3指定指向目的内存的起始迭代器</p>
<p>但是参数3为默认迭代器时必须保证b有充足的内存空间因为copy底层为逐个元素的赋值操作</p>
</blockquote>
<p>inserter适配器</p>
<blockquote>
<p>inserter适配器对迭代器的赋值操作进行了重载，使赋值操作包含insert方法</p>
<p>看似赋值实则插入</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//inserter</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Container</span>,<span class="keyword">class</span> <span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="function">insert_iterator&lt;Container&gt; <span class="title">inserter</span><span class="params">(<span class="keyword">const</span> Container&amp; x,<span class="keyword">const</span> Iterator&amp; y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Container::iterator iter;</span><br><span class="line">    <span class="comment">//需要对传入的迭代器类型进行校验，进行类型转型，失败则提早停止预防运行出错</span></span><br><span class="line">    <span class="keyword">return</span> insert_iterator&lt;Container&gt;(x,<span class="built_in">iter</span>(y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Container</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">insert_iterator</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">insert_iterator</span>(Container&amp; x,<span class="keyword">const</span> <span class="keyword">typename</span> Container::iterator i):<span class="built_in">container</span>(&amp;x),<span class="built_in">ite</span>(i)&#123;&#125;</span><br><span class="line">    <span class="keyword">typedef</span> output_iterator_tag iterator_type;</span><br><span class="line">    </span><br><span class="line">    insert_iterator&lt;Container&gt;&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> Container::value_type&amp; x) &#123;</span><br><span class="line">        ite = container -&gt; <span class="built_in">insert</span>(ite,x);</span><br><span class="line">        ++ite;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Container* container;</span><br><span class="line">    <span class="keyword">typename</span> Container::iterator ite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="X适配器"><a href="#X适配器" class="headerlink" title="X适配器"></a>X适配器</h4><p><strong>ostream_iterator</strong></p>
<p>绑定cout输出流对象,在执行copy操作时可以将被copy的元素输出</p>
<blockquote>
<p>啥也不是，就一个有赋值运算符重载的一个玩意儿</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="keyword">class</span> <span class="title">charT</span>=</span><span class="keyword">char</span>,<span class="class"><span class="keyword">class</span> <span class="title">traits</span>=</span>char_traits&lt;charT&gt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ostream_iterator</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">	<span class="keyword">typedef</span> basic_ostream&lt;charT, traits&gt; ostream_type;</span><br><span class="line">	<span class="keyword">typedef</span> charT char_type;</span><br><span class="line">	<span class="keyword">typedef</span> traits traits_type;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">ostream_iterator</span>(ostream_type&amp; s) :<span class="built_in">out_stream</span>(&amp;s), <span class="built_in">delim</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">	<span class="built_in">ostream_iterator</span>(ostream_type&amp; s,<span class="keyword">const</span> charT* delimm) :<span class="built_in">out_stream</span>(&amp;s), <span class="built_in">delim</span>(delimm) &#123;&#125;</span><br><span class="line">	<span class="built_in">ostream_iterator</span>(<span class="keyword">const</span> ostream_iterator&lt;T&gt;&amp; x):<span class="built_in">out_stream</span>(x.out_stream), <span class="built_in">delim</span>(x.delim) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">ostream_iterator</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">	ostream_iterator&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> T&amp; value) &#123;</span><br><span class="line">		*out_stream &lt;&lt; value;</span><br><span class="line">		<span class="keyword">if</span> (delim != <span class="number">0</span>) &#123;</span><br><span class="line">			*out_stream &lt;&lt; delim;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ostream_iterator&lt;T&gt;&amp; <span class="keyword">operator</span>*() &#123;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ostream_iterator&lt;T&gt;&amp; <span class="keyword">operator</span>++ () &#123;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ostream_iterator&lt;T&gt;&amp; <span class="keyword">operator</span>++ (<span class="keyword">int</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">//内含指向标准输出流对象的指针和分隔符的记录</span></span><br><span class="line">	basic_ostream&lt;charT, traits&gt;* out_stream;</span><br><span class="line">	<span class="keyword">const</span> charT* delim;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="function">ostream_iterator&lt;<span class="keyword">int</span>&gt; <span class="title">out</span><span class="params">(cout, <span class="string">&quot;,&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">copy</span>(v.begin, v.end, out);</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>istream_iterator</strong></p>
<p>绑定cin输入流对象</p>
<blockquote>
<p>当创建istream_iterator&lt;&gt;对象时已经在读取数据了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; c&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">istream_iterator&lt;int&gt; iit(cin),eos; //读取用户输入的数据</span><br><span class="line"><span class="comment">//eos 未绑定输入流对象输入做结束标志用</span></span><br><span class="line"><span class="built_in">copy</span>(iit,eos,<span class="built_in">inserter</span>(c,c.<span class="built_in">begin</span>())); <span class="comment">//将用户输入的数据插入到指定容器中去</span></span><br><span class="line"><span class="comment">//同样也需要对=,++,*做重载操作</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="STL-Surround"><a href="#STL-Surround" class="headerlink" title="STL Surround"></a>STL Surround</h1><h2 id="hash-function"><a href="#hash-function" class="headerlink" title="hash function"></a>hash function</h2><h3 id="两大型式"><a href="#两大型式" class="headerlink" title="两大型式"></a>两大型式</h3><p>functor</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomerHash</span> &#123;</span></span><br><span class="line">    <span class="function">size_type <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Customer&amp; Customer)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ...;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">unorderedset&lt;Customer,CustomerHash&gt; cus;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>function</p>
<blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">size_type <span class="title">CustomerHash</span><span class="params">(<span class="keyword">const</span> Customer&amp; Customer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ...;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">unorderedset&lt;Customer,size_type(*)(const Customer&amp;)&gt; cus(20,CustomerHash);  </span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="An-universal-hash-function"><a href="#An-universal-hash-function" class="headerlink" title="An universal hash function"></a>An universal hash function</h3><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::hash&lt;datatype&gt;()(data) </span><br></pre></td></tr></table></figure>

<p>目前标准库中已经有了用于每种基本类型的hashcode计算functor</p>
<p>而对于自定义对象的hashcode计算不能仅仅为各数据成员的hashcode计算值之和</p>
<p>通过<strong>可变类型参数</strong>实现hash_val的参数类型与参数数量的任意</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span> <span class="comment">//引入相应的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomerHash</span> &#123;</span></span><br><span class="line">	<span class="function">std::<span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Customer&amp; c)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">hash_val</span>(c.first, c.second, c.third);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算hashcode的函数模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hash_combine</span><span class="params">(std::<span class="keyword">size_t</span>&amp; seed, <span class="keyword">const</span> T&amp; val)</span> </span>&#123;</span><br><span class="line">	seed ^= std::hash&lt;T&gt;()(val) + <span class="number">0x9e3779b9</span> + (seed &lt;&lt; <span class="number">6</span>) + (seed &gt;&gt; <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//辅助接口函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;class... Types&gt;</span><br><span class="line"><span class="function">std::<span class="keyword">size_t</span> <span class="title">hash_val</span><span class="params">(<span class="keyword">const</span> Types&amp;... args)</span> </span>&#123;</span><br><span class="line">	std::<span class="keyword">size_t</span> seed = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">hash_val</span>(seed, args...);</span><br><span class="line">	<span class="keyword">return</span> seed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span>... <span class="title">Types</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hash_val</span><span class="params">(std::<span class="keyword">size_t</span>&amp; seed, <span class="keyword">const</span> T&amp; val, <span class="keyword">const</span> Types&amp;... args)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">hash_combine</span>(seed, val);</span><br><span class="line">	<span class="built_in">hash_val</span>(seed, args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hash_val</span><span class="params">(std::<span class="keyword">size_t</span>&amp; seed, <span class="keyword">const</span> T&amp; val)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">hash_combine</span>(seed, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h2><blockquote>
<p>元组 不同数据类型数据的组合</p>
</blockquote>
<h3 id="Interface-testing"><a href="#Interface-testing" class="headerlink" title="Interface testing"></a>Interface testing</h3><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tuple对象的创建</span></span><br><span class="line">tuple&lt;string, int, int&gt; t(&quot;123&quot;,10,11);</span><br><span class="line"><span class="keyword">auto</span> t2 = <span class="built_in">make_tuple</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象成员的获取</span></span><br><span class="line"><span class="comment">//get&lt;num&gt;(tuple_obj) num为从0开始的序号索引 </span></span><br><span class="line"><span class="keyword">int</span> i = get&lt;<span class="number">1</span>&gt;(t);</span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line">string c;</span><br><span class="line"></span><br><span class="line"><span class="comment">//tie(args...) = tuple_obj 元素绑定</span></span><br><span class="line"><span class="comment">//实现用args参数&quot;绑定&quot;tuple中的元素 赋值性的绑定 即绑定后值变化互不影响</span></span><br><span class="line"><span class="built_in">tie</span>(c, a, b) = t;</span><br><span class="line"><span class="comment">//eg:</span></span><br><span class="line">get&lt;<span class="number">0</span>&gt;(t) = <span class="string">&quot;5&quot;</span>;</span><br><span class="line">cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"><span class="comment">//结果仍为123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//stl中tuple对运算符的重载</span></span><br><span class="line"><span class="comment">//t &lt; t2</span></span><br><span class="line"><span class="comment">//t = t2;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取tuple中元素个数</span></span><br><span class="line"><span class="keyword">typedef</span> tuple&lt;string, <span class="keyword">int</span>, <span class="keyword">int</span> TupleType</span><br><span class="line">cout &lt;&lt; tuple_size&lt;TupleType&gt;::value &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取某个元素的类型</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取tuple的head元素</span></span><br><span class="line">string s = t.<span class="built_in">head</span>(); <span class="comment">// s=&quot;123&quot;</span></span><br><span class="line"><span class="comment">//获取tuple的tail部分tuple对象</span></span><br><span class="line"><span class="keyword">auto</span> tail = t.<span class="built_in">tail</span>(); <span class="comment">// tail = tuple&lt;int, int&gt; t(10,11)</span></span><br><span class="line"><span class="comment">//获取tail的head元素</span></span><br><span class="line"><span class="keyword">int</span> se = tail.<span class="built_in">head</span>();</span><br><span class="line"><span class="comment">//值得注意的是head(),tail()在c++17中不再使用该名称</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Internal-structure-G4-8"><a href="#Internal-structure-G4-8" class="headerlink" title="Internal structure - G4.8"></a>Internal structure - G4.8</h3><blockquote>
<p>通过可变类型参数<strong>可动态拆分</strong>特性而构建的一个继承体系结构</p>
<p>即每一个数据类型的数据单独封装为一个类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tuple对象的创建</span></span><br><span class="line">tuple&lt;int, float, string&gt; t(41,6.3,&quot;nico&quot;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//tuple</span></span><br><span class="line"><span class="comment">//通过可变参数的可动态拆分特性递归实现继承体系</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Head</span>,<span class="title">class</span>... <span class="title">Tail</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tuple</span>&lt;</span>Head,Tail...&gt; : <span class="keyword">private</span> tuple&lt;Tail...&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> tuple&lt;Tail...&gt; inherited;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">tuple</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">tuple</span>(<span class="keyword">const</span> Head&amp; a,<span class="keyword">const</span> Tail&amp;... args):<span class="built_in">m_head</span>(a),<span class="built_in">inherited</span>(args...)&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回tuple对象的head元素</span></span><br><span class="line">    <span class="function">Head <span class="title">head</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过上转型为父类类型截断本类数据</span></span><br><span class="line">    <span class="comment">//返回不含m_head的含tail部分的tuple对象</span></span><br><span class="line">    <span class="function">inherited&amp; <span class="title">tail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Head m_head;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当递归至父类为tuple&lt;&gt;时作停止递归的处理</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tuple</span>&lt;</span>&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>继承图示</p>
<p><img src="/.com//Users\YunDid\AppData\Roaming\Typora\typora-user-images\image-20210712164552782.png" alt="image-20210712164552782"></p>
</blockquote>
<h2 id="Type-triats"><a href="#Type-triats" class="headerlink" title="Type triats"></a>Type triats</h2><blockquote>
<p>它所提供的判断功能，在<strong>编译期间</strong>可以检查出是否是正确的类型，以便能编写更为安全的代码。</p>
</blockquote>
<h3 id="Interface-testing-1"><a href="#Interface-testing-1" class="headerlink" title="Interface testing"></a>Interface testing</h3><p><strong>G2.9</strong></p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//询问</span></span><br><span class="line">__type_traits&lt;<span class="keyword">int</span>&gt;::has_trivial_copy_constructor <span class="comment">//return 0/1</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>C++11</strong></p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//询问</span></span><br><span class="line">is_copy_constructible&lt;T&gt;::value <span class="comment">//return 0/1</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Structure-G2-9"><a href="#Structure-G2-9" class="headerlink" title="Structure G2.9"></a>Structure G2.9</h3><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以询问萃取机对应类型的某些性质类型从而做出判断</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">type_traits</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> __true_type this_dummy_member_must-be_first;</span><br><span class="line">    <span class="keyword">typedef</span> __false_type has_trivial_default_constructor;</span><br><span class="line">    <span class="keyword">typedef</span> __false_type has_trivial_copy_constructor;</span><br><span class="line">    <span class="keyword">typedef</span> __false_type has_trivial_assignment_constructor;</span><br><span class="line">    <span class="keyword">typedef</span> __false_type has_trivial_destructor;</span><br><span class="line">    <span class="keyword">typedef</span> __false_type is_POD_type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//POD - plain old data</span></span><br><span class="line"><span class="comment">//trivial 不重要的/平凡的</span></span><br><span class="line"><span class="comment">//特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">type_traits</span>&lt;</span><span class="keyword">int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">typedef</span> __true_type has_trivial_default_constructor;</span><br><span class="line">    <span class="keyword">typedef</span> __true_type has_trivial_copy_constructor;</span><br><span class="line">    <span class="keyword">typedef</span> __true_type has_trivial_assignment_constructor;</span><br><span class="line">    <span class="keyword">typedef</span> __true_type has_trivial_destructor;</span><br><span class="line">    <span class="keyword">typedef</span> __true_type is_POD_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//询问</span></span><br><span class="line">__type_traits&lt;<span class="keyword">int</span>&gt;::has_trivial_copy_constructor</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Structure-C-11"><a href="#Structure-C-11" class="headerlink" title="Structure C++11"></a>Structure C++11</h3><h4 id="type-traits-categories"><a href="#type-traits-categories" class="headerlink" title="type traits categories"></a>type traits categories</h4><ul>
<li><p>Primary type categories</p>
<blockquote>
<p>is_array</p>
<p>is_class</p>
</blockquote>
</li>
<li><p>Type properties</p>
<blockquote>
<p>is_abstract</p>
<p>is_const</p>
</blockquote>
</li>
<li><p>Type features</p>
<blockquote>
<p>is_copy_constructible</p>
<p>is_move_constructible</p>
</blockquote>
</li>
<li><p>Composite type categories </p>
<blockquote>
<p>is_compound</p>
<p>is_object</p>
</blockquote>
</li>
</ul>
<h4 id="is-void"><a href="#is-void" class="headerlink" title="is_void"></a>is_void</h4><blockquote>
<p>将类型丢给is_void萃取机可判断是否为void类型</p>
<p>is_void -&gt; __is_void_helper&lt;…&gt;::type -&gt; false_type/true_type   -&gt;表示继承关系</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//remove_cv去除const与volatile类型的影响,remove_cv本身也是萃取机</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_void</span> :</span> <span class="keyword">public</span> __is_void_helper&lt; <span class="keyword">typename</span> remove_cv&lt;T&gt;::type &gt;::type</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//泛化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">is_void_helper</span> :</span> <span class="keyword">public</span> false_type&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_cv</span> &#123;</span></span><br><span class="line">   	<span class="keyword">typedef</span> <span class="keyword">typename</span> remove_const&lt; <span class="keyword">typename</span> remove_volatile&lt;T&gt;::type &gt;::type type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">is_void_helper</span>&lt;</span><span class="keyword">void</span>&gt; : <span class="keyword">public</span> true_type&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_const</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_const</span>&lt;</span>T <span class="keyword">const</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">typedef</span> remove_const&lt; <span class="keyword">typename</span> remove_volatile&lt;T&gt;::type &gt;::type type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_volatile</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remove_volatile</span>&lt;</span>T <span class="keyword">volatile</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Moveable-elements"><a href="#Moveable-elements" class="headerlink" title="Moveable elements"></a>Moveable elements</h2><blockquote>
<p>移动构造函数</p>
<blockquote>
<p>浅拷贝，仅拷贝指针且拷贝后切断原对象的指向即将原对象的指针设为NULL</p>
<p>确保movecopy后原对象不再使用，所以一般用临时对象做movecopy</p>
</blockquote>
<p>拷贝构造函数</p>
<blockquote>
<p>深拷贝</p>
</blockquote>
</blockquote>
<h4 id="vector中的movecopy"><a href="#vector中的movecopy" class="headerlink" title="vector中的movecopy"></a>vector中的movecopy</h4><p><strong>深拷贝</strong></p>
<blockquote>
<p>调用std::__uninitialized_copy_a(…) 即copy函数来进行逐个元素的赋值</p>
</blockquote>
<p><strong>浅拷贝</strong></p>
<blockquote>
<p>vector中的三个指针进行简单的swap()交换 ·</p>
</blockquote>
<h1 id="勿在浮沙筑高台"><a href="#勿在浮沙筑高台" class="headerlink" title="勿在浮沙筑高台"></a>勿在浮沙筑高台</h1></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">YunDid</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/07/16/C++Primer/STL/">http://example.com/2021/07/16/C++Primer/STL/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">YunDid's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C-Primer/">C++Primer</a></div><div class="post_share"><div class="social-share" data-image="/img/ma3.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/07/16/C++Primer/C++11/"><img class="prev-cover" src="/img/ma3.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C++ 2.0新特性</div></div></a></div><div class="next-post pull-right"><a href="/2021/07/07/Algorithm_Structure/A_plus_D/"><img class="next-cover" src="/img/ma3.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Algorithm and DataStruture -Primary</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/04/24/C++Primer/Iterator/" title="Iterator"><img class="cover" src="/img/ma3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-24</div><div class="title">Iterator</div></div></a></div><div><a href="/2021/04/24/C++Primer/Vector/" title="Vector"><img class="cover" src="/img/ma3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-24</div><div class="title">Vector</div></div></a></div><div><a href="/2021/05/26/C++Primer/Compile/" title="Compile"><img class="cover" src="/img/ma3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-26</div><div class="title">Compile</div></div></a></div><div><a href="/2021/05/26/C++Primer/File_pointer/" title="File Pointer"><img class="cover" src="/img/ma3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-26</div><div class="title">File Pointer</div></div></a></div><div><a href="/2021/07/07/C++Primer/C++standard/" title="C++ 面向对象初级"><img class="cover" src="/img/ma3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-07</div><div class="title">C++ 面向对象初级</div></div></a></div><div><a href="/2021/07/07/C++Primer/Object/" title="C++ 面向对象进阶"><img class="cover" src="/img/ma3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-07</div><div class="title">C++ 面向对象进阶</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/1.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">YunDid</div><div class="author-info__description">欢迎来到 YunDid's Blog！有疑问可以到 “留言板” 提问！^_^</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">46</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/YunDid"><i class="fab fa-github"></i><span>博主的GitHub首页</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/YunDid" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:512862613@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">萌新一枚~</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#STL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">STL体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E5%A4%A7%E7%BB%84%E4%BB%B6"><span class="toc-number">1.1.</span> <span class="toc-text">六大组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OOP-and-GP"><span class="toc-number">1.2.</span> <span class="toc-text">OOP and GP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8"><span class="toc-number">1.3.</span> <span class="toc-text">容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%88%86%E7%B1%BB"><span class="toc-number">1.3.1.</span> <span class="toc-text">容器分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E6%B5%8B%E8%AF%95"><span class="toc-number">1.3.2.</span> <span class="toc-text">容器测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Sequence-Containers-%E5%BA%8F%E5%88%97%E5%AE%B9%E5%99%A8"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">Sequence Containers 序列容器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Array"><span class="toc-number">1.3.2.1.1.</span> <span class="toc-text">Array</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">1.3.2.1.2.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.3.2.1.3.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95"><span class="toc-number">1.3.2.1.4.</span> <span class="toc-text">接口测试</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Vector"><span class="toc-number">1.3.2.1.5.</span> <span class="toc-text">Vector</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="toc-number">1.3.2.1.6.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-1"><span class="toc-number">1.3.2.1.7.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95-1"><span class="toc-number">1.3.2.1.8.</span> <span class="toc-text">接口测试</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Deque"><span class="toc-number">1.3.2.1.9.</span> <span class="toc-text">Deque</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-2"><span class="toc-number">1.3.2.1.10.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-2"><span class="toc-number">1.3.2.1.11.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95-2"><span class="toc-number">1.3.2.1.12.</span> <span class="toc-text">接口测试</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#List"><span class="toc-number">1.3.2.1.13.</span> <span class="toc-text">List</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-3"><span class="toc-number">1.3.2.1.14.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-3"><span class="toc-number">1.3.2.1.15.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95-3"><span class="toc-number">1.3.2.1.16.</span> <span class="toc-text">接口测试</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Forward-list"><span class="toc-number">1.3.2.1.17.</span> <span class="toc-text">Forward_list</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-4"><span class="toc-number">1.3.2.1.18.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-4"><span class="toc-number">1.3.2.1.19.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95-4"><span class="toc-number">1.3.2.1.20.</span> <span class="toc-text">接口测试</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Associative-Containers-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">Associative Containers 关联容器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Multiset"><span class="toc-number">1.3.2.2.1.</span> <span class="toc-text">Multiset</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-5"><span class="toc-number">1.3.2.2.2.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-5"><span class="toc-number">1.3.2.2.3.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95-5"><span class="toc-number">1.3.2.2.4.</span> <span class="toc-text">接口测试</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Set"><span class="toc-number">1.3.2.2.5.</span> <span class="toc-text">Set</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-6"><span class="toc-number">1.3.2.2.6.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-6"><span class="toc-number">1.3.2.2.7.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95-6"><span class="toc-number">1.3.2.2.8.</span> <span class="toc-text">接口测试</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Multimap"><span class="toc-number">1.3.2.2.9.</span> <span class="toc-text">Multimap</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-7"><span class="toc-number">1.3.2.2.10.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-7"><span class="toc-number">1.3.2.2.11.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95-7"><span class="toc-number">1.3.2.2.12.</span> <span class="toc-text">接口测试</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Map"><span class="toc-number">1.3.2.2.13.</span> <span class="toc-text">Map</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-8"><span class="toc-number">1.3.2.2.14.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-8"><span class="toc-number">1.3.2.2.15.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95-8"><span class="toc-number">1.3.2.2.16.</span> <span class="toc-text">接口测试</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Unordered-Containers-%E6%97%A0%E5%BA%8F%E5%AE%B9%E5%99%A8"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">Unordered Containers 无序容器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Unordered-multiset"><span class="toc-number">1.3.2.3.1.</span> <span class="toc-text">Unordered_multiset</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-9"><span class="toc-number">1.3.2.3.2.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-9"><span class="toc-number">1.3.2.3.3.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95-9"><span class="toc-number">1.3.2.3.4.</span> <span class="toc-text">接口测试</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Unordered-Multimap"><span class="toc-number">1.3.2.3.5.</span> <span class="toc-text">Unordered_Multimap</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-10"><span class="toc-number">1.3.2.3.6.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-10"><span class="toc-number">1.3.2.3.7.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95-10"><span class="toc-number">1.3.2.3.8.</span> <span class="toc-text">接口测试</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Unordered-Set"><span class="toc-number">1.3.2.3.9.</span> <span class="toc-text">Unordered_Set</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Unordered-Map"><span class="toc-number">1.3.2.3.10.</span> <span class="toc-text">Unordered_Map</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="toc-number">1.3.3.</span> <span class="toc-text">容器源码剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Sequence-Containers-%E5%BA%8F%E5%88%97%E5%AE%B9%E5%99%A8-1"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">Sequence Containers 序列容器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#List-1"><span class="toc-number">1.3.3.1.1.</span> <span class="toc-text">List</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Vector-1"><span class="toc-number">1.3.3.1.2.</span> <span class="toc-text">Vector</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Array-1"><span class="toc-number">1.3.3.1.3.</span> <span class="toc-text">Array</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Forward-list-1"><span class="toc-number">1.3.3.1.4.</span> <span class="toc-text">Forward list</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Deque-1"><span class="toc-number">1.3.3.1.5.</span> <span class="toc-text">Deque</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Queue"><span class="toc-number">1.3.3.1.6.</span> <span class="toc-text">Queue</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Stack"><span class="toc-number">1.3.3.1.7.</span> <span class="toc-text">Stack</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Associative-Containers-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8-1"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">Associative Containers 关联容器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Rb-tree-%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%9D%E8%AF%86"><span class="toc-number">1.3.3.2.1.</span> <span class="toc-text">Rb_tree 红黑树初识</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Set-Multiset"><span class="toc-number">1.3.3.2.2.</span> <span class="toc-text">Set&#x2F;Multiset</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Map-Multimap"><span class="toc-number">1.3.3.2.3.</span> <span class="toc-text">Map&#x2F;Multimap</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Unordered-Containers-%E6%97%A0%E5%BA%8F%E5%AE%B9%E5%99%A8-1"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">Unordered Containers 无序容器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#hashtable"><span class="toc-number">1.3.3.3.1.</span> <span class="toc-text">hashtable</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Allocators-%E5%88%86%E9%85%8D%E5%99%A8"><span class="toc-number">1.4.</span> <span class="toc-text">Allocators 分配器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Allocator%E6%B5%8B%E8%AF%95"><span class="toc-number">1.4.1.</span> <span class="toc-text">Allocator测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#operator-new-delete-%E4%B8%8Emalloc-free"><span class="toc-number">1.4.2.</span> <span class="toc-text">operator new&#x2F;delete 与malloc&#x2F;free</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#allocator"><span class="toc-number">1.4.3.</span> <span class="toc-text">allocator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%BC%96%E8%AF%91%E5%99%A8%E5%AF%B9allocator%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">1.4.4.</span> <span class="toc-text">不同编译器对allocator的处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Iterator-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.5.</span> <span class="toc-text">Iterator 迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">1.5.1.</span> <span class="toc-text">迭代器的设计原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Class-iterator"><span class="toc-number">1.5.2.</span> <span class="toc-text">Class iterator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Native-pointer"><span class="toc-number">1.5.3.</span> <span class="toc-text">Native pointer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Iterator-Triats"><span class="toc-number">1.5.4.</span> <span class="toc-text">Iterator Triats</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%A7%8D%E7%B1%BB"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">容器的迭代器种类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Iterator-category%E5%AF%B9Algorithm%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">1.5.4.2.</span> <span class="toc-text">Iterator_category对Algorithm的影响</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="toc-number">1.5.5.</span> <span class="toc-text">算法部分源码剖析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Functors-%E4%BB%BF%E5%87%BD%E6%95%B0"><span class="toc-number">1.6.</span> <span class="toc-text">Functors 仿函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#STL%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%ADFunctors%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%A7%8D%E7%B1%BB"><span class="toc-number">1.6.0.1.</span> <span class="toc-text">STL标准库中Functors的基本种类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GNU-C-%E7%8B%AC%E6%9C%89%E7%9A%84Functors%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-number">1.6.0.2.</span> <span class="toc-text">GNU C++独有的Functors的种类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Functors%E7%9A%84%E5%8F%AF%E9%80%82%E9%85%8D-adaptable-%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.6.0.3.</span> <span class="toc-text">Functors的可适配(adaptable)条件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Adapter-%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">1.7.</span> <span class="toc-text">Adapter 适配器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Container-Adapters"><span class="toc-number">1.7.0.1.</span> <span class="toc-text">Container Adapters</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Functor-Adapters"><span class="toc-number">1.7.0.2.</span> <span class="toc-text">Functor Adapters</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Iterator-Adapters"><span class="toc-number">1.7.0.3.</span> <span class="toc-text">Iterator Adapters</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#X%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">1.7.0.4.</span> <span class="toc-text">X适配器</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#STL-Surround"><span class="toc-number">2.</span> <span class="toc-text">STL Surround</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#hash-function"><span class="toc-number">2.1.</span> <span class="toc-text">hash function</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E5%A4%A7%E5%9E%8B%E5%BC%8F"><span class="toc-number">2.1.1.</span> <span class="toc-text">两大型式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#An-universal-hash-function"><span class="toc-number">2.1.2.</span> <span class="toc-text">An universal hash function</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tuple"><span class="toc-number">2.2.</span> <span class="toc-text">Tuple</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Interface-testing"><span class="toc-number">2.2.1.</span> <span class="toc-text">Interface testing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Internal-structure-G4-8"><span class="toc-number">2.2.2.</span> <span class="toc-text">Internal structure - G4.8</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Type-triats"><span class="toc-number">2.3.</span> <span class="toc-text">Type triats</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Interface-testing-1"><span class="toc-number">2.3.1.</span> <span class="toc-text">Interface testing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Structure-G2-9"><span class="toc-number">2.3.2.</span> <span class="toc-text">Structure G2.9</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Structure-C-11"><span class="toc-number">2.3.3.</span> <span class="toc-text">Structure C++11</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#type-traits-categories"><span class="toc-number">2.3.3.1.</span> <span class="toc-text">type traits categories</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#is-void"><span class="toc-number">2.3.3.2.</span> <span class="toc-text">is_void</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Moveable-elements"><span class="toc-number">2.4.</span> <span class="toc-text">Moveable elements</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#vector%E4%B8%AD%E7%9A%84movecopy"><span class="toc-number">2.4.0.1.</span> <span class="toc-text">vector中的movecopy</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8B%BF%E5%9C%A8%E6%B5%AE%E6%B2%99%E7%AD%91%E9%AB%98%E5%8F%B0"><span class="toc-number">3.</span> <span class="toc-text">勿在浮沙筑高台</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/02/27/Matlab/Matlab/" title="Matlab 入门"><img src="/img/ma3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Matlab 入门"/></a><div class="content"><a class="title" href="/2023/02/27/Matlab/Matlab/" title="Matlab 入门">Matlab 入门</a><time datetime="2023-02-27T01:30:00.000Z" title="发表于 2023-02-27 09:30:00">2023-02-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/22/Animation/CenterAI_%E7%A5%9E%E7%BB%8F%E7%8A%B6%E6%80%81%E6%9C%BA/" title="Siggraph Asia 2019 - 神经状态机"><img src="/img/ma3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Siggraph Asia 2019 - 神经状态机"/></a><div class="content"><a class="title" href="/2022/03/22/Animation/CenterAI_%E7%A5%9E%E7%BB%8F%E7%8A%B6%E6%80%81%E6%9C%BA/" title="Siggraph Asia 2019 - 神经状态机">Siggraph Asia 2019 - 神经状态机</a><time datetime="2022-03-22T02:40:00.000Z" title="发表于 2022-03-22 10:40:00">2022-03-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/22/Unreal/Ue4_GamePlay%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3/" title="YumiGame - Ue4 - GamePlay"><img src="/img/ma3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="YumiGame - Ue4 - GamePlay"/></a><div class="content"><a class="title" href="/2022/03/22/Unreal/Ue4_GamePlay%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3/" title="YumiGame - Ue4 - GamePlay">YumiGame - Ue4 - GamePlay</a><time datetime="2022-03-22T02:30:00.000Z" title="发表于 2022-03-22 10:30:00">2022-03-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/22/Unreal/Ue4_%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F%E6%9C%AA%E5%AE%8C/" title="Ue4 - Animation System"><img src="/img/ma3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Ue4 - Animation System"/></a><div class="content"><a class="title" href="/2022/03/22/Unreal/Ue4_%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F%E6%9C%AA%E5%AE%8C/" title="Ue4 - Animation System">Ue4 - Animation System</a><time datetime="2022-03-22T02:28:00.000Z" title="发表于 2022-03-22 10:28:00">2022-03-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/22/Unity/Unity_%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/" title="Unity - Animation Systems"><img src="/img/ma3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity - Animation Systems"/></a><div class="content"><a class="title" href="/2022/03/22/Unity/Unity_%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/" title="Unity - Animation Systems">Unity - Animation Systems</a><time datetime="2022-03-22T02:27:00.000Z" title="发表于 2022-03-22 10:27:00">2022-03-22</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By YunDid</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><i class="fab fa-qq"></i> 512862613 | <i class="fab fa-weixin"></i> Mmm-myy1</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">簡</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'RUIbtPgCc0o0TGaeqMWlX9P5-gzGzoHsz',
      appKey: 'PaoiG1dlQjiDQAVRBexH6KkR',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="https://cdn.jsdelivr.net/npm/live2d-widget@^3.1.3/lib/L2Dwidget.min.js"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"superSample":2,"position":"left","width":150,"height":300,"hOffset":20,"vOffset":-90},"mobile":{"show":true,"scale":1},"react":{"opacityDefault":0.3,"opacityOnHover":0.3,"opacity":0.95},"log":false});</script></body></html>
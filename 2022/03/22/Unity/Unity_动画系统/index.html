<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Unity - Animation Systems | YunDid's Blog</title><meta name="keywords" content="Animation Systems"><meta name="author" content="YunDid"><meta name="copyright" content="YunDid"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Unity Animation Systems &#x2F; Unity 动画系统The Current Progress &#x2F; 当前进度 Unity初级编程 - 中级编程 &#x2F; √ 动画系统demo实践 完成模型导入-&gt; 动画绑定 -&gt; 状态机组织动画 &#x2F; ing 工具 fbx -&gt; motiondate -&gt; 中间数据 ue4状态机 + AI + 行为树 着手AIAnimation框">
<meta property="og:type" content="article">
<meta property="og:title" content="Unity - Animation Systems">
<meta property="og:url" content="http://example.com/2022/03/22/Unity/Unity_%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="YunDid&#39;s Blog">
<meta property="og:description" content="Unity Animation Systems &#x2F; Unity 动画系统The Current Progress &#x2F; 当前进度 Unity初级编程 - 中级编程 &#x2F; √ 动画系统demo实践 完成模型导入-&gt; 动画绑定 -&gt; 状态机组织动画 &#x2F; ing 工具 fbx -&gt; motiondate -&gt; 中间数据 ue4状态机 + AI + 行为树 着手AIAnimation框">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/ma3.jpg">
<meta property="article:published_time" content="2022-03-22T02:27:00.000Z">
<meta property="article:modified_time" content="2022-03-22T02:43:12.718Z">
<meta property="article:author" content="YunDid">
<meta property="article:tag" content="Animation Systems">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/ma3.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/03/22/Unity/Unity_%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: YunDid","link":"链接: ","source":"来源: YunDid's Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-03-22 10:43:12'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">47</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/ma3.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">YunDid's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Unity - Animation Systems</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-03-22T02:27:00.000Z" title="发表于 2022-03-22 10:27:00">2022-03-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-03-22T02:43:12.718Z" title="更新于 2022-03-22 10:43:12">2022-03-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/YumiGame/">YumiGame</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Unity - Animation Systems"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2022/03/22/Unity/Unity_%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2022/03/22/Unity/Unity_%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/" itemprop="commentCount"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Unity-Animation-Systems-Unity-动画系统"><a href="#Unity-Animation-Systems-Unity-动画系统" class="headerlink" title="Unity Animation Systems / Unity 动画系统"></a>Unity Animation Systems / Unity 动画系统</h1><h1 id="The-Current-Progress-当前进度"><a href="#The-Current-Progress-当前进度" class="headerlink" title="The Current Progress / 当前进度"></a>The Current Progress / 当前进度</h1><ul>
<li>Unity初级编程 - 中级编程 / √</li>
<li>动画系统demo实践 完成模型导入-&gt; 动画绑定 -&gt; 状态机组织动画 / ing</li>
<li>工具 fbx -&gt; motiondate -&gt; 中间数据</li>
<li>ue4状态机 + AI + 行为树</li>
<li>着手AIAnimation框架，着手动画系统的改写</li>
</ul>
<h1 id="Animation-Data-动画数据"><a href="#Animation-Data-动画数据" class="headerlink" title="Animation Data / 动画数据"></a>Animation Data / 动画数据</h1><blockquote>
<p><code>U3D Document : Animation data is stored as an asset called an Animation Clip.</code></p>
<p><code>An Animation Clip can store any GameObject animation.</code></p>
<p><code>Animation Clips are the fundamental building blocks of Unity’s animation systems. </code></p>
<p>动画数据被存储为动画切片，动画切片为动画系统的基本构件</p>
</blockquote>
<h2 id="Animation-Clip-动画切片"><a href="#Animation-Clip-动画切片" class="headerlink" title="Animation Clip / 动画切片"></a>Animation Clip / 动画切片</h2><h4 id="Values-值"><a href="#Values-值" class="headerlink" title="Values / 值"></a>Values / 值</h4><blockquote>
<p><code>U3D Document : The values of an Animation Clip are usually, but not always, represented by Animation Curves.</code></p>
<p>值数据总是以曲线的形式体现</p>
<p> <code>Animation Curves contain information about the way the GameObject you’re animating changes. </code></p>
<p>动画曲线包含了游戏对象动画化的方式信息</p>
</blockquote>
<h4 id="Bindings-绑定"><a href="#Bindings-绑定" class="headerlink" title="Bindings / 绑定"></a>Bindings / 绑定</h4><blockquote>
<p><code>U3D Document : The bindings of an Animation Clip are a way of connecting the values to a particular field of a GameObject or component.</code></p>
<p>绑定 : 将值与游戏对象或组件的具体字段建立关联</p>
<p><code>1. The path through the Hierarchy to the GameObject’s Transform component</code></p>
<p>先将值与游戏对象的相应组件建立关联</p>
<p><code>2. The path from that Transform component to a particular field</code></p>
<p>再将值与相应组件的具体字段建立关联</p>
<p><code>注意:</code></p>
<ol>
<li>每个值都具有其意义，其意义取决于与其一对一绑定的特定字段</li>
</ol>
</blockquote>
<h2 id="Binding-System-绑定系统"><a href="#Binding-System-绑定系统" class="headerlink" title="Binding System / 绑定系统"></a>Binding System / 绑定系统</h2><blockquote>
<p><code>U3D Document : Bindings have two parts ：A Transform path，A Property name.</code></p>
<p>动画窗口中的绑定包含两部分，一个是索引到层级结构中的游戏对象的路径，一个是动画化字段的具体属性名称</p>
<p><code>U3D Document : The Transform path is a string that includes: </code></p>
<p><code>1. The names of the Transforms in the hierarchy that must be traversed to get to the GameObject.</code></p>
<p><code>2. The component and property that is to be animated. </code></p>
<p>转换路径仍为字符串，该字符串格式为 : [ 能在层级结构中索引到存在游戏对象的层级名称 - 动画化的字段名称 ]</p>
<p><code>U3D Document : Any properties on the same GameObject as the Animator component have a blank path, as no Transforms need to be traversed to get to that property. Any properties on a direct child of the GameObject with the Animator component have a Transform path of just that child’s name. This continues down the hierarchy for other GameObjects. </code></p>
<p>Animator 组件所附加上的游戏对象的属性具有默认空白路径，其直接子对象也具有子对象名称起始的默认路径</p>
<p><code>U3D Document : It’s important to remember that this pattern for bindings means that only properties on the same GameObject as the Animator component and below it in the hierarchy can have their properties controlled by the Animator.</code></p>
<p>这种绑定模式意味着 Animator 只能向下控制游戏对象即子游戏对象的动画化属性</p>
</blockquote>
<h3 id="Animation-Mode-动画化方式"><a href="#Animation-Mode-动画化方式" class="headerlink" title="Animation Mode / 动画化方式"></a>Animation Mode / 动画化方式</h3><blockquote>
<p><code>U3D Document : When an animation is playing, the current time for its Animation Clip changes. At any given time, the values for all the bindings are being checked and the fields that those bindings correspond to have their values set.</code></p>
<p>动画一旦开始播放，其时间轴上的时间也将变化，进而完成动画化</p>
<ol>
<li>任意一个时间点，该时间点下的所有绑定对应的值都将被检查</li>
<li>并且与该值也将被设置到其绑定的字段上</li>
</ol>
</blockquote>
<h1 id="Animation-Blending-动画混合"><a href="#Animation-Blending-动画混合" class="headerlink" title="Animation Blending / 动画混合"></a>Animation Blending / 动画混合</h1><blockquote>
<p><code>U3D Document : Sometimes when a GameObject is playing an animation, you’ll want to change which animation is playing or play another animation at the same time. When multiple animations are played at the same time and through the same GameObject hierarchy, the animations are doing what is called blending. </code></p>
<p>动画混合的使用场景为你期望改变游戏对象正在播放的动画或者同时播放多个动画在同一个游戏对象上</p>
<p><code>U3D Document : When you play more than one Animation Clip at the same time, Unity blends them together. The result of the blend is then applied to the bindings. </code></p>
<p>当播放超过一个的动画切片时，Unity会将这些动画混合后应用于绑定</p>
<p><code>U3D Document : To blend Animation Clips, each animation has a relative weight. These weights are used to calculate how much influence each individual Animation Clip has on the final animation. </code></p>
<p>动画权重的意义在于指出被混合的每一个动画切片对最终动画的影响</p>
</blockquote>
<h2 id="Blending-Algorithms-混合算法"><a href="#Blending-Algorithms-混合算法" class="headerlink" title="Blending Algorithms / 混合算法"></a>Blending Algorithms / 混合算法</h2><blockquote>
<p><code>U3D Document : All the algorithms follow the same overall process: </code></p>
<p><code>Each animation is given a weight. This weight represents how much the animation affects the result of the blend.</code></p>
<p>首先，每个混合的动画切片将具有其混合权重</p>
<p><code>Higher weights mean the animation will have more of an effect and lower weights mean the animation will have less of an effect. </code></p>
<p>该混合权重用于表示该动画切片对混合结果动画的影响，权重值越高，意味着影响越大，混合结果与该动画越接近</p>
<p><code>Typically, weights are normalized. This means that the sum of the weights for all the animations being blended equals one. </code></p>
<p>并且该权重值时规范化的，意味着所有动画切片的权重值之和为1</p>
</blockquote>
<ul>
<li><p>Weighted Sum / 加权平均</p>
<blockquote>
<p>遍历所有混合切片的绑定，将某时刻下每个动画切片的绑定值与对应切片的动画权重相乘后累加作为该时刻下的混合结果，并将该结果写入到绑定</p>
</blockquote>
</li>
</ul>
<h2 id="Features-Using-Blending-混合应用"><a href="#Features-Using-Blending-混合应用" class="headerlink" title="Features Using Blending / 混合应用"></a>Features Using Blending / 混合应用</h2><ul>
<li><p>Transitions / 过渡</p>
<blockquote>
<p><code>U3D Document : As the Transition continues, the weight of it increases, while the weight of the previous state decreases.</code></p>
<p>当过渡发生时，过渡前的状态权重降低，过渡后的状态权重增加</p>
</blockquote>
</li>
<li><p>Blending Trees / 混合树</p>
<blockquote>
<p><code>U3D Document : Blend Trees are used in place of a single Animation Clip in a state. They blend the multiple Animation Clips they contain. </code></p>
<p>混合树可以混合多种动画并作为一种状态参与过渡</p>
</blockquote>
</li>
<li><p>Layer / 动画层</p>
<blockquote>
<p><code>U3D Document : Blending in Layers works slightly differently than with Transitions and Blend Trees. All the animation in a Layer is completely evaluated before it’s then blended with the next Layer. The result of this blend is then evaluated before it is blended with subsequent Layers, and so on. </code></p>
<p>动画层的混合，在该层与下一动画层混合前，会评估该层的所有动画</p>
</blockquote>
</li>
</ul>
<h2 id="Nested-Blending-混合嵌套"><a href="#Nested-Blending-混合嵌套" class="headerlink" title="Nested Blending / 混合嵌套"></a>Nested Blending / 混合嵌套</h2><blockquote>
<p><code>U3D Document : Animation blending can be nested. Weighting happens multiplicatively, so each Animation Clip has its weight calculated before the final result is calculated. </code></p>
<p>动画混合可以被嵌套，在最终结果被计算之前，每个动画切片将计算其自身权重</p>
</blockquote>
<h2 id="Animator-Controller-动画控制器"><a href="#Animator-Controller-动画控制器" class="headerlink" title="Animator Controller / 动画控制器"></a>Animator Controller / 动画控制器</h2><blockquote>
<p><code>U3D Document : An Animator Controller is a way of controlling when an Animation Clip starts playing and how it’s blended with other Animation Clips. </code></p>
<p>动画控制器用于控制动画切片的播放时机以及动画切片之间的混合方式</p>
<p><code>U3D Document : They are a collection of logical States, containing one or more Animation Clips. </code></p>
<p>动画控制器是一组逻辑状态的集合，包含一个或多个动画切片</p>
<p><code>U3D Document : The Animator Controller takes a path between these States, evaluating the Animation Clip(s) in the State currently being played. </code></p>
<p>控制器将选取状态之间的一条路径来评估当前状态下应播放的动画切片</p>
<p><code>U3D Document : The States are connected by Transitions, which blend the Animation Clips of the States they connect together. </code></p>
<p>状态通过 transition 来完成过渡混合</p>
</blockquote>
<h3 id="Animator-Transition-状态过渡"><a href="#Animator-Transition-状态过渡" class="headerlink" title="Animator Transition / 状态过渡"></a>Animator Transition / 状态过渡</h3><blockquote>
<p><code>U3D Document : Transitions are used to blend two animations together. </code></p>
<p>Transitions 被用于状态之间的过渡混合</p>
<p><code>U3D Document : Transitions are a blend between one Animator State and another. </code></p>
<p>过渡是状态之间的混合</p>
<p><code>注意:</code></p>
<ol>
<li>默认 Entry 下的过渡是不可预览的，即没有以下各 Settings</li>
</ol>
</blockquote>
<h4 id="Current-and-Next-States-当前与下一状态"><a href="#Current-and-Next-States-当前与下一状态" class="headerlink" title="Current and Next States / 当前与下一状态"></a>Current and Next States / 当前与下一状态</h4><blockquote>
<p><code>U3D Document : When a Transition starts, the Animator State that is being Transitioned to (which is called the **next State**) starts playing. </code></p>
<p>当过渡发生时，Next State 开始播放</p>
<p><code>U3D Document : At this point, the next State has a weight of 0 and the Animation State that is being transitioned from (which is called the current State) has a Weight of 1. </code></p>
<p>当过渡发生时，Next State 将获得0的权重，Current State (过渡发生的状态) 将获得1的权重</p>
<p><code>U3D Document : As the Transition continues, both Animation States continue to play and the Weight of the current State starts reducing as the next State increases linearly. When the Weight of the current State reaches **0** (which will happen at the end of the Transition), it stops playing and the next State becomes the new current State. </code></p>
<p>当过渡持续进行时，Current State 的权重不断变小，同时 Next State 的权重线性增加，直至 Current State 权重减小至0，Next State 成为 Current State</p>
</blockquote>
<h4 id="Transition-Settings-过渡设置"><a href="#Transition-Settings-过渡设置" class="headerlink" title="Transition Settings / 过渡设置"></a>Transition Settings / 过渡设置</h4><ul>
<li><p>Multiple Transitions / 多重过渡</p>
<blockquote>
<p>可在两个过渡之间重复添加多个过渡，多重过渡具有三个箭头</p>
</blockquote>
</li>
<li><p>Conditions / 条件</p>
<blockquote>
<p>条件依附于动画参数而存在，根据判断动画参数的状态的来设置过渡条件</p>
<p><code>U3D Document : When these statements are satisfied, the Transition will start. </code></p>
<p>当所有条件均满足时才会发生过渡，并且可以设置条件判断的优先级</p>
</blockquote>
</li>
<li><p>Exit Time / 退出时间</p>
<blockquote>
<p>float 类型，表明当前状态播放百分之 n(n为退出时间 * 100) 后开始过渡，若想当前状态至少播放一次完毕后再过渡，该值需要大于1</p>
<p><code>U3D Document : Exit Time is the time at which a Transition starts. This is measured in the Normalized Time of the current state. </code></p>
<p>Exit Time 可控制 Current State 发生过渡的时机，该值通过归一化时间来衡量</p>
<p><code>The Normalized Time on the previous frame is less than the Exit Time.</code></p>
<p><code>The Normalized Time on the current frame is greater than the Exit Time.</code></p>
<p>只有在上一帧状态的归一化时间小于 Exit Time，当前帧的归一化时间大于 Exit Time 时，过渡才会发生</p>
</blockquote>
</li>
<li><p>Transition Duration / 持续时间</p>
<blockquote>
<p><code>U3D Document : To control the length of time a Transition takes.</code></p>
<p><code>U3D Document : seconds, if Fixed Duration is enabled</code></p>
<p><code>U3D Document : Normalized Time of the current State, if Fixed Duration is disabled </code></p>
<p>控制过渡持续的时间，可以秒/s或者归一化时间来衡量，取决于 Fixed Duration 是否被选中</p>
<p><code>U3D Document : Transition duration in normalized time from current state</code></p>
<p>若使用归一化时间，则表示相对于 Current State 的时间</p>
</blockquote>
</li>
<li><p>Transition Offset / 过渡偏移</p>
<blockquote>
<p><code>U3D Document : You want the animations you’re blending to do so smoothly, so it’s important for the animations to be in phase like they were when you were manually adjusting the weights of the Circle and Square Animation Clips. </code></p>
<p>动画混合时为了使混合更自然，因此被混合的动画应该处于相位态，即上一个动画从50%结束时，下一个动画不能从头开始而应该也从50%处开始播放，这样才能在调整权重之后动画过渡更自然</p>
<p><code>U3D Document : The offset is the Normalized Time of the next State at which the State will start playing when the Transition occurs. </code></p>
<p>过渡偏移是相对于 Next State 的归一化时间，用于设置过渡发生时 Next State 的播放内容，或者说过渡发生时，Next State 的播放起始点</p>
<p><code>注意:</code></p>
<ol>
<li>偏移时间应该根据退出时间而定，自上一动画的退出时间点来设置下一动画的偏移量</li>
</ol>
</blockquote>
</li>
<li><p>Transition Interruption / 过渡中断</p>
<blockquote>
<p><code>U3D Document : Transitions can be interrupted by other Transitions. When this happens, the values for the animation at the current frame of the Transition are stored and act as the current State for the interrupting Transition.</code></p>
<p>当前过渡可以被其他过渡中断，当中断过渡发生时，将保存当前帧下属性在当前过渡下的值，并作为中断过渡的 Current State</p>
<p><code>U3D Document : This means that the blend for the interrupting Transition happens between a single time on the original Transition and the interrupting Transition’s next State. </code></p>
<p>这意味着中断类型的过渡发生于 Current Transition 的中断点 与 Interrupting Transition 的 Next State 之间，而不是 Current State 与 Next State 之间</p>
<p><code>注意:</code></p>
<ol>
<li>默认情况下过渡在发生时是不允许中断的，需要通过下列设置手动触发该机制</li>
</ol>
</blockquote>
</li>
<li><p>Interruption Source / 中断源</p>
<blockquote>
<p><code>U3D Document : Animator Controllers maintain a list of Transitions that can currently be taken for each Animation Layer. These Transitions have their Conditions and Exit Time checked each frame. By default, this list only contains Transitions from the Any State followed by the current State’s Transition list.</code></p>
<p>Animator Controllers 将维护一个 Transitions 列表，区别于每个状态下的 Orderable Transitions 列表，该列表每一帧都会检查列表下所有过渡的条件与退出时间，以便可作为源进行 Transition Interruption，该列表默认情况下仅包含任何状态的转换与当前状态下的转换</p>
<p><code>U3D Document : However, when an Animation Layer is transitioning, this list of Transitions is replaced by the Transitions from the Any State and whatever additional Transitions are defined by the Interruption Source of the current Transition. </code></p>
<p>Transitions 列表中的过渡发生时，其可以被其他过渡所取代，这取决于 Interruption Source 选中的源，非 None 的情况下会将选中源的 Orderable Transitions 添加至 Transitions 列表中，用于 Transition Interruption</p>
</blockquote>
</li>
<li><p>Ordered Interruption / 有序中断</p>
<blockquote>
<p><code>U3D Document : Ordered Interruption controls whether Transitions of lower priority on the current State can interrupt the Transition. If this property is enabled, Transitions of lower priority on the current State cannot interrupt the Transition because of their lower order.</code></p>
<p>该选项用于控制低优先级的过渡是否可以中断 Current Transition ，若被选中，则低优先级的不允许中断 Current Transition</p>
</blockquote>
</li>
<li><p>Any State / 任何状态</p>
<blockquote>
<p><code>U3D Document : Each layer in an Animator Controller has a special node called Any State. This node allows Transitions to be made from it but not to it, so that no matter what State is currently playing, a Transition can happen. </code></p>
<p>Animator Controller 的每一动画层下均有一个 Any State 状态，该状态可以过渡至任何状态，但是不允许其他状态过渡至该状态，Any State 状态即使未播放，其下的过渡仍可以发生</p>
<p><code>U3D Document : The Any State node appears in all State machines for convenience, but it only has a single list of Transitions. Each instance of the Any State node in an Animation Layer is the same one.</code></p>
<p>每个状态机下均存在 Any State，但是 Any State 仅会有一个实例，即每个动画层下的 Any State 使用同一个 Transitions List</p>
<p><code>U3D Document : In each frame, the Animator Controller checks a list of Transitions to see whether any of them should start. It checks them in order, starting with all the Transitions from the Any State node and then all the Transitions from the current State. </code></p>
<p>Animator Controller 每一帧均会检查该 Transitions List，检查该列表下的所有过渡是否应该发生，先检查源为 Any State 的过渡，然后是源为 Current State 的过渡</p>
<p><code>注意:</code></p>
<ol>
<li>Any State 下的过渡是逐帧检查的，使用时需要注意该条件</li>
</ol>
</blockquote>
</li>
</ul>
<h3 id="State-Machines-状态机"><a href="#State-Machines-状态机" class="headerlink" title="State Machines / 状态机"></a>State Machines / 状态机</h3><blockquote>
<p><code>U3D Document : State Machines are purely an organisational tool. State Machines allow you to group States and Transitions together</code></p>
<p>状态机仅仅是一种状态与过渡组织管理工具，处理复杂动画时很有用</p>
<p><code>U3D Document : Each Animator Controller has one or more Animator Layers (or Layers), and each Animator Layer contains a State Machine. However, any State Machine may also have additional State Machines nested within it. </code></p>
<p>每个 Animator Controller 将有一个或多个 Layers，而每个动画层将包含一个状态机，状态机还可以有附加的子状态机</p>
</blockquote>
<h4 id="State-Machine-Transitions-状态机过渡"><a href="#State-Machine-Transitions-状态机过渡" class="headerlink" title="State Machine Transitions / 状态机过渡"></a>State Machine Transitions / 状态机过渡</h4><blockquote>
<p>可以由外部状态 &lt;-&gt; 状态机，也可以外部状态 &lt;-&gt;状态机内部状态，还可以状态机内部状态 &lt;-&gt; 状态机</p>
</blockquote>
<ul>
<li><p>Entry Node and Exit Node / 进入与退出状态</p>
<blockquote>
<p><code>U3D Document : The Entry and Exit nodes are used for Transitions to/from the State Machine itself. </code></p>
<p>仅用于进入与退出子状态机状态本身</p>
</blockquote>
</li>
<li><p>Up Node / Up状态</p>
<blockquote>
<p><code>U3D Document : The Up node represents a direct Transition between the internal and external nodes. </code></p>
<p>Up Node 用于子状态机内部与外部状态的直接转换</p>
</blockquote>
</li>
</ul>
<h3 id="Animator-Layers-动画层"><a href="#Animator-Layers-动画层" class="headerlink" title="Animator Layers / 动画层"></a>Animator Layers / 动画层</h3><blockquote>
<p><code>U3D Document : Animator Layers are a way of playing multiple animations at the same time and blending the result.</code></p>
<p>动画层也是一种同时播放多种动画并混合结果的一种方式</p>
<p><code>1. The blending overrides what’s happening on other Animator Layers.</code></p>
<p>一种混合方式是覆盖至其他动画层播放的动画上</p>
<p><code>2. The blending adds to what is happening on other Animator Layers.</code></p>
<p>一种混合方式是附加到其他动画层播放的动画上</p>
</blockquote>
<ul>
<li><p>Animator Layer indices / 索引</p>
<blockquote>
<p><code>U3D Document : The base Layer has an index of 0 and all subsequent Layers have indices incrementing from there.</code></p>
<p>Base Layer 使用0索引，其余动画层以此递增</p>
<p><code>U3D Document : Animator Layers are evaluated in ascending index order, starting with 0.</code></p>
<p>动画层将按索引顺序被计算/评估，自0索引开始计算</p>
</blockquote>
</li>
<li><p>Animator Layer weights / 权重</p>
<blockquote>
<p><code>U3D Document : Each Animator Layer has a weight that determines its contribution to the final result. </code></p>
<p>每个动画层均具有权重用于表示其对混合结果的影响程度</p>
</blockquote>
</li>
</ul>
<h4 id="Animator-Layer-Blending-Layer-混合"><a href="#Animator-Layer-Blending-Layer-混合" class="headerlink" title="Animator Layer Blending / Layer 混合"></a>Animator Layer Blending / Layer 混合</h4><blockquote>
<p>动画层的计算将按索引顺序计算评估，因此会先计算 Layer0 的动画，之后计算 Layer1 的动画并与 Layer0 混合</p>
<p>混合方式 : 1. 计算当前动画层的动画 2. 与之前 Layer 动画混合结果进行混合</p>
</blockquote>
<ul>
<li><p>Mask / 遮罩</p>
<blockquote>
<p><code>U3D Document : When you’re working on a transform animation or humanoid animation, it can often be useful to only animate part of a skeleton at once.</code></p>
<p>一般使用人形动画时可能会使用遮罩，使得某些骨骼不受某些动画的影响，该动画控制的绑定将不会写入到设定的骨骼中，骨骼设定取决于 Avatar Mask</p>
</blockquote>
</li>
<li><p>Override Blending / 覆盖</p>
<blockquote>
<p><code>U3D Document : Override blending is similar to the blending used by Transitions and 1D Blend Trees. As the contribution from the next Animator Layer increases, the contribution from the previous  Animator Layers decreases. </code></p>
<p>覆盖混合类型类似于过渡混合于1D混合树混合，当前动画层权重增加时，之前混合结果的权重将降低</p>
<p><code>U3D Document : The weight of the previous Animator Layers is equal to the inverse of the overriding (next) Animator Layer.</code></p>
<p>当前动画层权重与之前混合动画结果权重的关系 : 相加为1</p>
</blockquote>
</li>
<li><p>Additive Blending / 附加</p>
<blockquote>
<p><code>U3D Document : This is used to support additive animation. Additive animation is when the animation itself is stored as a delta (or change) from a reference pose.</code></p>
<p>附加动画将以相对于参考姿势的增量形式存储</p>
<p><code>U3D Document : When you use Additive blending, the already evaluated Animator Layers always have an effective weight of 1. Any animation from the Additive Animator Layer is added to the contribution from those Layers. The animation data is taken as a delta (or change) between a default value and its current value to calculate the weighted contribution. </code></p>
<p>当使用附加绑定类型时，已评估的混合结果将始终具有1的权重，而任何来自 Additive Layer 层的动画数据将以增量形式存储并附加于之前的混合动画中</p>
<p><code>注意:</code></p>
<ol>
<li>若将未设置附加动画参考姿势的切片所在的 Layer 设置为使用附加绑定类型，则可能导致不期望的结果</li>
</ol>
</blockquote>
</li>
</ul>
<h4 id="Sync-and-IK-Pass-同步与IK"><a href="#Sync-and-IK-Pass-同步与IK" class="headerlink" title="Sync and IK Pass / 同步与IK"></a>Sync and IK Pass / 同步与IK</h4><ul>
<li><p>Sync / 同步</p>
<blockquote>
<p><code>U3D Document : This will create an identical State Machine to the one on the source Animator Layer. </code></p>
<p>同步将创建一个与源动画层完全相同的状态机</p>
<p><code>U3D Document : By default, the State Machine will match the timing of the source State Machine. This means that when Transitions happen in the source Animator Layer, they will also happen in the synced Animator Layer. </code></p>
<p>默认情况下，同步层与原动画层的状态机时间将匹配，即状态机管理下的过渡发生时机将相同</p>
<p><code>U3D Document : However, if Timing is enabled, State durations will be an interpolation of the source Animator Layer’s Animation Clip length and the synced Animator Layer’s Animation Clip length. They will be based on the weight of the synced Animator Layer. </code></p>
<p>若选中 Timing，则状态的持续时间将不再与原动画层状态相同，而是根据同步层的权重，对源动画层切片持续时间与同步层切片持续时间进行插值，使用此插值作为同步层切片持续时间</p>
</blockquote>
</li>
<li><p>IK Pass</p>
<blockquote>
<p><code>U3D Document : This setting is just for humanoid animation. </code></p>
<p>仅适用于具有IK系统的人形动画</p>
<p><code>U3D Document : If it’s enabled, it will cause methods for evaluating IK to be called on MonoBehaviours on the same GameObject as the Animator component, as well in State Machine behaviours for this Animator Layer. </code></p>
<p>若其被选中，则造成 MonoBehaviours 脚本与 State Machine behaviours 状态机行为中的IK评估方法被调用</p>
</blockquote>
</li>
</ul>
<hr>
<p>**Questions: **</p>
<ul>
<li><del>动画切片的组成 - 绑定是什么概念？一对一绑定是什么东西？</del></li>
<li>Multiple Transitions / 多重过渡 时所有条件均满足？还是满足其一？</li>
<li><del>多个过渡条件时全部满足时才发生过渡？</del></li>
<li> <del>Current Transition 是用来指定中断过渡的源的？</del></li>
<li>状态机之间的过渡，是如何混合的？？</li>
</ul>
<hr>
<p>2022/1/7 21:42 - 2022/1/10 17:52</p>
<h1 id="Model-Specific-Animation-模型动画"><a href="#Model-Specific-Animation-模型动画" class="headerlink" title="Model-Specific Animation / 模型动画"></a>Model-Specific Animation / 模型动画</h1><h2 id="Fundamentals-基础"><a href="#Fundamentals-基础" class="headerlink" title="Fundamentals / 基础"></a>Fundamentals / 基础</h2><blockquote>
<p><code>U3D Document : Models in Unity are represented by a Mesh of triangles. When you want to animate a model, the Mesh must be deformed so that its triangles change position and shape. </code></p>
<p>模型是由三角形组成的网格体表示的，当动画化模型时，其网格体需要作出改变，以便其三角形改变位置与形状</p>
<p><code>U3D Document : Models can contain too many triangles for each of them to be moved individually. The higher the definition of a model, the greater the number of triangles. </code></p>
<p>但是模型越复杂，其所包含的三角形越多，因此当改变网格体时，手动逐个操作具体的三角形是不现实的</p>
<p><code>U3D Document : Instead of moving each triangle individually during animation, models are skinned before they are animated.</code></p>
<p>取而代之的是在动画化模型之前，先对模型进行蒙皮</p>
<p><code>U3D Document : Skinning gives each of the vertices making up the triangles a dependence on a bone. This bone is then moved using animation data and the associated vertices work out where they should be based on the bone’s position and rotation.</code></p>
<p>蒙皮使模型的三角形顶点依附于骨骼而运动，形成动画数据控制骨骼的移动，骨骼带动绑定到其上的三角形顶点的运动</p>
<p><code>U3D Document : Bone hierarchies and the way they affect meshes are part of Rigs.</code></p>
<p>骨骼影响网格体运动的方式由 Rigs 决定</p>
<p><code>U3D Document : In Unity, bones are represented by Transforms.</code></p>
<p>在Unity中，骨骼由 Transforms 表示</p>
</blockquote>
<h3 id="Triangle-Mesh-三角网格"><a href="#Triangle-Mesh-三角网格" class="headerlink" title="Triangle Mesh / 三角网格"></a>Triangle Mesh / 三角网格</h3><blockquote>
<p><code>U3D Document : Generally, animated models have a skinned mesh. </code></p>
<p>动画化的模型一般都会有一个蒙皮网格体</p>
<p><code>U3D Document : Skinning is the process of connecting each vertex of a mesh to one or multiple bones and then giving those bones a weight to affect that vertex. </code></p>
<p>而蒙皮使模型每个网格体的顶点会关联到一个或多个骨骼，这些骨骼被赋予了权重来决定对顶点移动的影响程度</p>
<p><code>U3D Document : In Unity, bones are represented by the Transforms of a model，which are part of GameObjects, so each vertex moves with a weighted combination of the Transforms it is skinned to. </code></p>
<p>在Unity中，骨骼通过模型的 Transforms 来表示，即游戏对象上的 transform 组件，所以网格体顶点的移动将跟随其附加到的所有 Transforms 权重组合的变化而变化 </p>
<p><code>注意:</code></p>
<ol>
<li>一个模型可能有多个游戏对象用以表示多个骨骼</li>
</ol>
</blockquote>
<h3 id="Forward-Kinematics-FK正向动力学"><a href="#Forward-Kinematics-FK正向动力学" class="headerlink" title="Forward Kinematics / FK正向动力学"></a>Forward Kinematics / FK正向动力学</h3><blockquote>
<p><code>U3D Document : This means that child Transforms move relative to their parents.</code></p>
<p>子变换依赖于父变换，由父变换带动子变换</p>
</blockquote>
<h3 id="Inverse-Kinematics-IK逆向动力学"><a href="#Inverse-Kinematics-IK逆向动力学" class="headerlink" title="Inverse Kinematics / IK逆向动力学"></a>Inverse Kinematics / IK逆向动力学</h3><blockquote>
<p><code>U3D Document : This is where the end of a chain of bones has its position or rotation set, and then the positions and rotations of bones further up the chain are set via an algorithm to accommodate the end bone’s position and rotation.</code></p>
<p>IK中，骨骼链的末端骨骼有其位置与旋转集，骨骼链更深层次的骨骼运动将由算法计算，来适应末端骨骼的位置与旋转</p>
</blockquote>
<h2 id="Model-Specific-Import-Settings-模型导入设置"><a href="#Model-Specific-Import-Settings-模型导入设置" class="headerlink" title="Model-Specific Import Settings / 模型导入设置"></a>Model-Specific Import Settings / 模型导入设置</h2><blockquote>
<p><code>U3D Document : When models are imported from digital content creation (DCC) programs, they have animation settings that are split into two sections: </code></p>
<p><code>1. Model-specific settings, which affect all animations imported with that model.</code></p>
<p><code>2. Animation-specific settings, which affect individual animations imported with that model.</code></p>
<p>当模型是由GCC程序集导入时，其动画设置具有针对于整个动画模型的设置，也具有针对于某个具体动画切片的设置，以下为部分 Model-specific settings</p>
</blockquote>
<ul>
<li><p>Import Constraints</p>
<blockquote>
<p>是否导入相应的关节约束</p>
</blockquote>
</li>
<li><p>Import Animation</p>
<blockquote>
<p>是否将模型对应的动画导入，若不勾选则无其余动画设置</p>
</blockquote>
</li>
<li><p>Baking animations / 烘焙动画</p>
<blockquote>
<p><code>U3D Document : This determines whether animations imported as inverse kinematics (IK) or simulation data should be converted into forward kinematics (FK) through a process called baking. </code></p>
<p>该设置表明以 IK 或 仿真数据 导入的动画，是否应该被转换为 FK 数据，烘焙后将以 FK 格式存储动画数据</p>
</blockquote>
</li>
<li><p>Resampling Animation Curves / 重新采样</p>
<blockquote>
<p><code>U3D Document : This setting determines whether animations imported with euler angles for their rotations should have these converted to quaternion angles instead. </code></p>
<p>该设置表明是否应该将以欧拉角定义旋转的数据应转换为以四元数定义</p>
<p><code>注意: </code></p>
<ol>
<li>this option is only available for models with generic rigs, as humanoid rigs are automatically resampled. </li>
<li>if an animation makes a rotation greater than 180 degrees between frames.  注意是否存在180°旋转</li>
</ol>
</blockquote>
</li>
<li><p>Animation Compression / 动画压缩优化</p>
<blockquote>
<p><code>The Animation Compression setting refers to how the animation’s size, both on disk and in memory, can be reduced by making approximations from the original imported file. </code></p>
<p>该设置可以选择 对原始动画的近似方式 来减少动画数据在内存以及硬盘中所占的大小</p>
<ol>
<li>off / 不压缩</li>
<li>Keyframe Reduction / 减少关键帧</li>
<li>Optimal / 最优</li>
</ol>
</blockquote>
</li>
<li><p>Custom Properties / 定制属性</p>
</li>
</ul>
<h2 id="Animation-Specific-Import-Settings-切片导入设置"><a href="#Animation-Specific-Import-Settings-切片导入设置" class="headerlink" title="Animation-Specific Import Settings / 切片导入设置"></a>Animation-Specific Import Settings / 切片导入设置</h2><h3 id="Cutting-Imported-Animation-Clips-剪切动画切片"><a href="#Cutting-Imported-Animation-Clips-剪切动画切片" class="headerlink" title="Cutting Imported Animation Clips / 剪切动画切片"></a>Cutting Imported Animation Clips / 剪切动画切片</h3><blockquote>
<p><code>U3D Document : You’ll use animation-specific settings to cut an imported Animation Clip. One of the most common uses for cutting animation is using motion capture (or mocap) data, but it can be used to adjust any imported animation. </code></p>
<p>使用 animation-specific 针对动画切片的设置完成对导入动画的剪切</p>
</blockquote>
<h3 id="Timeline-时间轴"><a href="#Timeline-时间轴" class="headerlink" title="Timeline / 时间轴"></a>Timeline / 时间轴</h3><blockquote>
<p><code>U3D Document : The animation timeline shows all of the animation data for the current Animation Clip</code></p>
<p>时间轴显示了当前选中动画切片的动画数据</p>
<p><code>U3D Document : There are handles you can drag to set the start and end of the Animation Clip to cut the take.</code></p>
<p>通过拖拽切片来对动画切片进行剪切，也可通过 Start 与 End 完成对剪切点的选择</p>
</blockquote>
<h3 id="Timeline-Settings-时间轴设置"><a href="#Timeline-Settings-时间轴设置" class="headerlink" title="Timeline Settings / 时间轴设置"></a>Timeline Settings / 时间轴设置</h3><ul>
<li><p>Loop Time / 循环时间</p>
<blockquote>
<p><code>U3D Document : If the Loop Time setting is enabled, the animation will begin again at the start once it finishes. </code></p>
<p>只有选中了 Loop Time 选项，动画才会循环播放</p>
</blockquote>
</li>
<li><p>Loop Pose / 循环姿势</p>
<blockquote>
<p><code>U3D Document : The Loop Pose setting changes the values of the keyframes in the Animation Clip so that they match at the start and end. </code></p>
<p>选中 Loop Pose 会改变关键帧的值以便该动画切片的关键帧在 start 与 end 处可匹配关联，使其不会在循环时发生突变，循环更自然</p>
</blockquote>
</li>
<li><p>Cycle Offset / 周期偏移</p>
<blockquote>
<p><code>U3D Document : Cycle Offset adjusts when the Animation Clip actually starts in the frame range you have selected. </code></p>
<p>Cycle Offset 可用于调整剪切后的该动画真正开始的时间，相对于选中 start 的偏移量</p>
<p><code>U3D Document : It is measured in Normalized Time, which means that a value of 0.2 would start the Animation Clip 20% of the way into the selected frame range.</code></p>
<p>该值若为0.2，则代表由剪切后切片的20%处开始播放，注意此时 Plane 预览面板的动画时间初始值也随之变化</p>
<p><code>U3D Document : When blending similar animations, it makes sense for them to be in phase. </code></p>
<p>该设置在混合动画时很有用，被混合的动画切片可能需要具备相应的条件，比如设置标准化的起始姿势</p>
</blockquote>
</li>
</ul>
<h3 id="Root-Motion-根运动"><a href="#Root-Motion-根运动" class="headerlink" title="Root Motion / 根运动"></a>Root Motion / 根运动</h3><blockquote>
<p><code>U3D Document : Root nodes are used to define Root Motion in animations. Root Motion is when an animation causes GameObjects to offset from their previous position, rather than just moving in absolute terms.This means you can make movements look a lot more realistic, as they can be based on the animation itself and not simply scripted. </code></p>
<p>根运动是指一个动画导致游戏对象的位置发生变动，而不是通过绝对值移动，这意味着你可以作出更自然的移动，因为这些移动将基于动画本身</p>
<p><code>U3D Document : For example, if a GameObject is animated to move forward on its z-axis, then with Root Motion, the GameObject would continue to move further and further along the z-axis as the animation loops. Without Root Motion, whenever the animation loops, the GameObject would return to where it started and then move forward in its z-axis again. </code></p>
<p>例如动画中游戏对象将沿z轴移动，那么场景中随着动画的循环播放，游戏对象将一直沿z轴移动，但是如果没有根运动，那么场景中游戏对象只会随动画循环播放而不断地从初始位置移动，再恢复，再移动</p>
<p><code>U3D Document : You can fix these things by baking some elements of the Root Motion into the pose. This means they won’t affect the Root Motion at all.</code></p>
<p>可以将切片的 Root Motion 中某些元素 bake into the pose 来使这些元素不会影响根运动</p>
</blockquote>
<ul>
<li><p>Root Node / 根节点</p>
<blockquote>
<p><code>U3D Document : The Root node is used as a reference for this Motion.</code></p>
<p>根节点用作根运动的参考</p>
</blockquote>
</li>
</ul>
<h3 id="Additional-Settings-其他设置"><a href="#Additional-Settings-其他设置" class="headerlink" title="Additional Settings / 其他设置"></a>Additional Settings / 其他设置</h3><h4 id="Mirror-Setting-镜像设置"><a href="#Mirror-Setting-镜像设置" class="headerlink" title="Mirror Setting / 镜像设置"></a>Mirror Setting / 镜像设置</h4><blockquote>
<p><code>U3D Document : This particular setting is exclusively for humanoid rigged animation.</code></p>
<p>镜像设置针对于人形动画</p>
<p><code>U3D Document : When enabled, the Mirror setting flips the animation on the YZ plane down the character’s middle. Since this flips both the pose and the Root Motion, you can use it for making a left turn into a right turn, for example.</code></p>
<p>勾选镜像设置后，模型YZ平面将以人物中心为轴翻转</p>
<p><code>注意:</code></p>
<ol>
<li>翻转后根运动也将受影响</li>
</ol>
</blockquote>
<h4 id="Additive-Reference-Pose-Setting-附加引用姿势"><a href="#Additive-Reference-Pose-Setting-附加引用姿势" class="headerlink" title="Additive Reference Pose Setting / 附加引用姿势"></a>Additive Reference Pose Setting / 附加引用姿势</h4><blockquote>
<p><code>U3D Document : By using Additive Animation, you can build on and make alterations to any existing animation. </code></p>
<p>该设置可以以已存在的动画为基础，并在此基础上作出更改，更改将覆盖原绑定的值</p>
<p><code>U3D Document : Since Additive Animation is added to an existing animation, it’s stored as deltas from a Reference Pose. Deltas are small differences or changes.</code></p>
<p>因为附加动画已被附加至已存在的动画，所以附加动画以针对于参考/原动画姿势的增量形式存储</p>
<p><code>U3D Document : Make an animation be treated as Additive Animation :</code></p>
<p><code>1. In the Inspector, enable Additive Reference Pose</code></p>
<p><code>2. Select the frame number that should serve as the reference pose.</code></p>
<p>创建 Additive Animation 的方式是先勾选附加选项，然后选择作为参考姿势的帧，该帧上的值将被作为默认值，之后附加的动画将以此为参考进行增量式存储</p>
</blockquote>
<h4 id="Curves-曲线"><a href="#Curves-曲线" class="headerlink" title="Curves / 曲线"></a>Curves / 曲线</h4><blockquote>
<p><code>U3D Document : When Animation Clips are imported, their curves are locked and will appear as read-only. However, as part of the import process, more curves can be added so you can edit them. These curves can be used to store data that can vary over the course of the animation and should not be confused with the standard Animation Curves you have used when creating and editing Animation Clips.  </code></p>
<p>此曲线区别于动画曲线，该曲线用于存储动画播放过程中随之改变的数据，用于编辑</p>
<ol>
<li> Select the Add (+) button under the Curves foldout. </li>
<li> Name the curve, so its value can be found at runtime. </li>
<li> Make sure the associated Animator Controller has a parameter with the same name as your curve. </li>
</ol>
<p><code>注意:</code></p>
<ol>
<li>确保该曲线名称与该动画切片附加到的控制器某参数具有相同的名称</li>
</ol>
</blockquote>
<h4 id="Events-事件"><a href="#Events-事件" class="headerlink" title="Events / 事件"></a>Events / 事件</h4><blockquote>
<p><code>U3D Document : In the Animation Importer, where there is an option for the Animation Clip to have an Animation Event added.</code></p>
<p>导入动画模型时，可以为动画切片在没有具体游戏对象上下文的情况下添加事件</p>
<p><code>注意:</code></p>
<ol>
<li>注意添加事件调用方法名需要与之后将调用的方法一致</li>
</ol>
</blockquote>
<hr>
<p><strong>Questions:</strong> </p>
<ul>
<li>simulation data 仿真是个什么样的动画数据？</li>
<li><del>rather than just moving in absolute terms 什么意思？</del></li>
<li><del>Root Motion / 根运动</del></li>
<li><del>Curves / 曲线 曲线的名称和某控制器参数要相同？为什么要相同，是因为这个曲线控制的就是该参数嘛？</del></li>
</ul>
<hr>
<p>2022/1/11 15:42 - 2022/1/11 21:35</p>
<hr>
<h1 id="Model-Rig-模型Rig"><a href="#Model-Rig-模型Rig" class="headerlink" title="Model Rig /  模型Rig"></a>Model Rig /  模型Rig</h1><blockquote>
<p><code>U3D Document : Rigs are a way of defining the structure of the model being imported and are used to define how animations play.</code></p>
<p>Rig 定义了模型导入时的结构以及其所有附加动画的播放方式</p>
</blockquote>
<h2 id="Configuring-Generic-Rigs-配置-Generic-Rig"><a href="#Configuring-Generic-Rigs-配置-Generic-Rig" class="headerlink" title="Configuring Generic Rigs / 配置 Generic Rig"></a>Configuring Generic Rigs / 配置 Generic Rig</h2><ul>
<li><p>Animation Type setting / 动画类型设置</p>
<blockquote>
<ol>
<li>None</li>
<li>Legacy</li>
<li>Generic</li>
<li>Humaniod</li>
</ol>
</blockquote>
<p><strong>Humaniod Animation Type / 人形动画类型</strong></p>
<blockquote>
<p><code>1. The model has animations that are intended to be played through another Humanoid model with a different hierarchical structure.</code></p>
<p>当本模型动画的用途为被不同层级结构下的人形模型使用时，需要将模型动画类型设置为 Humaniod</p>
<p><code>2. You’re using the model to play animations that are from Humanoid models with a different hierarchical structure.</code></p>
<p>当本模型的动画使用的是不同层级结构下其他模型的动画时，需要将模型动画类型设置为 Humaniod</p>
<p><code>3. You want to use the built-in Humanoid features, such as arm and leg IK or target matching.</code></p>
<p>当使用内置人形功能时，需要将模型动画类型设置为 Humaniod</p>
</blockquote>
</li>
<li><p>Avatar Definition / Avatar 定义</p>
<blockquote>
<p><code>U3D Document : Avatars are an asset representation of the model’s Rig. They take different forms depending on whether the Rig is Generic or Humanoid.</code></p>
<p>Avatar 是资产，在 Project 窗口可见，代表了模型的 Rig，Avatar 类型由模型 Rig 类型决定</p>
</blockquote>
</li>
<li><p>Root Node / 根节点设置</p>
</li>
<li><p>Skin Weights / 蒙皮权重</p>
<blockquote>
<p><code>U3D Document : The Skin Weights setting allows you to adjust how many bones a vertex can be skinned to. </code></p>
<p>可以设置一个网格体顶点可以附加多少骨骼，默认为4个</p>
</blockquote>
</li>
<li><p>Optimize Game Objects / 优化游戏对象</p>
<blockquote>
<p><code>U3D Document : Models can have very complicated hierarchies. This can result in having many GameObjects that are there simply to define the positions of the vertices of a skinned mesh. </code></p>
<p>模型可能有复杂的层级结构，这将导致其附加有多个游戏对象仅用于表示蒙皮网格体的顶点位置</p>
<p><code>U3D Document : If Optimize GameObjects is enabled, all GameObjects that have no components on them are removed. The Skinned Mesh is then moved directly by the animation. </code></p>
<p>启用该设置将使模型上所有没有其他组件的游戏对象被移除，蒙皮骨骼的运动将由动画驱使</p>
<p><code>U3D Document : To keep the GameObject(s), you need to use the Expose Extra Transforms settings. </code></p>
<p>通过 Expose Extra Transforms 选项可以选择保留某些游戏对象而不被优化移除</p>
</blockquote>
</li>
<li><p>Generic Avatar Masks / Avatar 遮罩</p>
<blockquote>
<p><code>U3D Document : Avatar Masks are a way of preventing animation data from being written to its binding. </code></p>
<p>Avatar Masks 可以用于防止动画数据的值被写入到绑定</p>
<p><code>U3D Document : Transform data is not used from sources that have been masked.</code></p>
<p>变换数据将不会被写入到被遮罩的源</p>
<p><code>注意:</code></p>
<ol>
<li>It’s important to remember that Avatar Masks only mask Transform data. They do not mask data on the same GameObject as a masked Transform.</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Configuring-Humaniod-Rigs-配置-Humaniod-Rig"><a href="#Configuring-Humaniod-Rigs-配置-Humaniod-Rig" class="headerlink" title="Configuring Humaniod Rigs / 配置 Humaniod Rig"></a>Configuring Humaniod Rigs / 配置 Humaniod Rig</h2><blockquote>
<p><code>U3D Document : The core difference between Generic Rigs and Humanoid Rigs is their Avatars. Humanoid Rigs require Avatars to play their animations, which is not the case for Generic Rigs. This is because Humanoids are a special case; their Transform hierarchy is mapped to the bones of a human-like shape.</code></p>
<p>Humanoid Rigs 区别于 Generic Rigs 的点就是 Humanoid Avatars，Humanoid Rigs 要求由 Humanoid Avatars 播放动画，人形模型的 Transform 被映射到 human-like shape 上的骨骼</p>
</blockquote>
<h3 id="Animation-Playback-Process-人形动画播放过程"><a href="#Animation-Playback-Process-人形动画播放过程" class="headerlink" title="Animation Playback Process / 人形动画播放过程"></a>Animation Playback Process / 人形动画播放过程</h3><blockquote>
<p><code>U3D Document : Under normal circumstances, in order for an animation to be shared among multiple targets, each target must have an identical hierarchy with identical names to those on the Animation Clip. This is because the names of Transforms are used to construct the bindings of an Animation Clip. If the hierarchy through which an Animation Clip is being played doesn’t have a specific binding, the binding is just ignored. This means that if the names don’t match, the animation won’t play.</code></p>
<p>标准绑定方式 : 要实现动画切片在不同对象下的共享，需要使播放该切片的游戏对象群具有与动画切片相同的名称层级结构 (因为切片就是通过名称来建立的绑定)，即需要具有动画切片绑定要求的字段，如果没有该字段，绑定无法建立，则动画播放时将忽略这些绑定</p>
<p><code>U3D Document : When an imported model is a Humanoid, its Animation Clips are no longer played using just standard bindings. Instead, the parts of the Animation Clips that match the Humanoid definition are played through the Avatar. </code></p>
<p>Humanoid 动画绑定 : 当导入的模型为 Humanoid 时，将不再使用标准建立切片名称与对象动画化字段的直接绑定，而是先建立与 Avatar 的 Mapping/绑定，最后由 Avatar 将值写入到对象的字段上，完成动画的播放</p>
<p><code>U3D Document : At import time, Animation Clips from Humanoid models are converted from writing to Transforms directly to writing to Muscles instead. These are called Muscle Clips. At runtime, Muscle Clips are converted back to write to Transforms. </code></p>
<p>Humanoid 动画绑定 : 在导入时，会将人形模型的动画切片作转换，使绑定由 与对象字段的直接绑定 转换为 与肌肉 的绑定，转换后形成 Muscle Clips，再将值 写入到 / 绑定 到对象的动画化字段上</p>
<p><code>U3D Document : Because all humanoids have this mapping, any Humanoid Animation Clip can be played through any Humanoid model.</code></p>
<p>所有 humanoids 具有该映射(肌肉绑定)，因此该动画切片可以被所有人形模型共享</p>
</blockquote>
<p>On import : Animation Clip with Transform bindings → Humanoid Avatar → Muscle Clip</p>
<p>At runtime : Muscle Clip → Humanoid Avatar → set Transform properties</p>
<h3 id="Avatar-configuration-Avatar-配置"><a href="#Avatar-configuration-Avatar-配置" class="headerlink" title="Avatar configuration / Avatar 配置"></a>Avatar configuration / Avatar 配置</h3><h4 id="Mapping-绑定"><a href="#Mapping-绑定" class="headerlink" title="Mapping / 绑定"></a>Mapping / 绑定</h4><blockquote>
<p><code>U3D Document : The mapping defines exactly which of the model’s Transforms is linked to which of the pre-defined Humanoid bones.</code></p>
<p>定义模型的 Transforms 具体绑定到 Avatar 哪一个预定义的人形骨骼上</p>
<p><code>U3D Document : Each dot on the diagram refers to a bone. If the dot has a solid outline then the bone is required in order for the mapping to work. If the dot has a dotted outline, the bone is optional. The more optional bones you map, the higher the quality of the retargeting.</code></p>
<p>human-like shape 上的每一个点代表骨骼，实心代表必须建立人形模型与该骨骼的映射，非实心表示可选，可选骨骼越多，重定向质量越高</p>
</blockquote>
<ul>
<li><p>Automap 自动完成骨骼的映射</p>
</li>
<li><p>Animation Pose / 标准姿势</p>
<blockquote>
<p><code>U3D Document : They form a reference pose from which animations are measured. Each rotation and translation in an animation is compared to this reference pose when it’s converted to and from a Muscle Clip. Because this pose is so important, Unity uses a standard animation pose as the target all humanoid models should aim for: the T-pose.</code></p>
<p>Avatar 中每个 Transforms 将具有旋转与位置属性，他们将形成一个参考姿势，这些属性在进行 Avatar &lt;–&gt; Muscle Clip 之间的转换时会被参考，因此 Unity 使用 T-pose 作为默认参考姿势，建议在 Mapping 时将 pose 强制为 T-pose</p>
</blockquote>
</li>
</ul>
<h4 id="Muscles-amp-Settings-肌肉设置"><a href="#Muscles-amp-Settings-肌肉设置" class="headerlink" title="Muscles &amp; Settings / 肌肉设置"></a>Muscles &amp; Settings / 肌肉设置</h4><blockquote>
<p><code>U3D Document : Muscle definitions exist as a range within or beyond which a bone is expected to rotate on a given axis. </code></p>
<p>肌肉以范围的形式存在，代表骨骼绕指定轴可旋转的范围</p>
</blockquote>
<ul>
<li><p>Normalised Range / 统一化范围</p>
<blockquote>
<p><code>U3D Document : This range is normalised, which means that rotations at one end of the range would have a value of 0 and rotations at the other end of the range would have a value of 1.</code></p>
<p>标准的范围为 [0,1]</p>
<p><code>U3D Document : Transform rotations are converted into these normalised rotation ranges at import time. The normalised rotation ranges are then converted back into Transform rotations at runtime.</code></p>
<p>Muscle 将于 导入时 转换为 Normalised Range 统一范围，运行时再进一步根据具体 Muscle 范围定义转换为 Transform rotations 具体旋转，这样可以方便于重定向，因为不同人形模型的 Muscle 范围定义可能不同，当动画某一帧要求旋转指定角度时，需要先参照 Avatar 的 Muscle 的标准范围，再进一步转换为实际 Transform rotations</p>
</blockquote>
</li>
</ul>
<h4 id="Humanoid-Avatar-Masks-Avatar-遮罩"><a href="#Humanoid-Avatar-Masks-Avatar-遮罩" class="headerlink" title="Humanoid Avatar Masks / Avatar 遮罩"></a>Humanoid Avatar Masks / Avatar 遮罩</h4><blockquote>
<p><code>U3D Document : Avatar Masks are a way of preventing animation data from being written to its binding. </code></p>
<p>Avatar Masks 可以用于防止动画数据的值被写入到绑定</p>
<p><code>U3D Document : Transform data is not used from sources that have been masked.</code></p>
<p>变换数据将不会被写入到被遮罩的源</p>
<p><code>注意:</code></p>
<ol>
<li>It’s important to remember that Avatar Masks only mask Transform data. They do not mask data on the same GameObject as a masked Transform.</li>
</ol>
</blockquote>
<h1 id="Animation-Windows-动画窗口"><a href="#Animation-Windows-动画窗口" class="headerlink" title="Animation Windows / 动画窗口"></a>Animation Windows / 动画窗口</h1><h2 id="Keyframes-关键帧"><a href="#Keyframes-关键帧" class="headerlink" title="Keyframes / 关键帧"></a>Keyframes / 关键帧</h2><blockquote>
<p><code>U3D Document : These keyframes hold information on the value of the Animation Curve at a specific time, as well as how to interpolate the values in-between.</code></p>
<p>关键帧记录有曲线在特定时间下的特定值，以及在两值之间插值的方式</p>
</blockquote>
<h2 id="Keyframes-Tangents-关键帧切线"><a href="#Keyframes-Tangents-关键帧切线" class="headerlink" title="Keyframes Tangents / 关键帧切线"></a>Keyframes Tangents / 关键帧切线</h2><blockquote>
<p><code>U3D Document : The value of an Animation Curve at any given time is the interpolation between the previous and next Keyframe. The exact value of this interpolation is calculated using the tangents of the Keyframes.</code></p>
<p>关键帧切线可以用于计算两关键帧之间任意时刻的插值</p>
<p><code>U3D Document : Each Keyframe has two tangents: An in-tangent (on the left), An out-tangent (on the right)</code></p>
<p>每个关键帧有两个切线，一个为内切线(左侧)，一个为外切线(右侧)</p>
<p><code>U3D Document : The exceptions to this are the first and last keyframes: the in- and out-tangents of the first and last Keyframes are connected to each other for the purposes of editing looped animation.</code></p>
<p>但是第一个关键帧与最后一个关键帧的切线相互连接，便于编辑循环动画</p>
</blockquote>
<h2 id="Animation-Events-动画事件"><a href="#Animation-Events-动画事件" class="headerlink" title="Animation Events / 动画事件"></a>Animation Events / 动画事件</h2><blockquote>
<p><code>U3D Document : Animation Events call methods in MonoBehaviour scripts. In order for an Animation Event to call a method from a script, the script must be attached to the same GameObject as the Animator component through which the Animation Clip is playing.</code></p>
<p>动画事件调用 MonoBehaviour 脚本下的方法，为了保证事件能够调用到脚本中的方法，该方法必须被附加同一个游戏对象上</p>
</blockquote>
<h1 id="Animator-Component-动画器组件"><a href="#Animator-Component-动画器组件" class="headerlink" title="Animator Component / 动画器组件"></a>Animator Component / 动画器组件</h1><h2 id="Animator-Parameters-动画参数"><a href="#Animator-Parameters-动画参数" class="headerlink" title="Animator Parameters / 动画参数"></a>Animator Parameters / 动画参数</h2><blockquote>
<p><code>U3D Document : Examples of what the Parameter data can be used for include: </code><br><code>1. Defining Transition conditions</code><br><code>2. Controlling state properties</code><br><code>3. Controlling Blend Trees</code></p>
<p>动画参数可以用于定义转换条件，控制状态的属性，控制混合树</p>
</blockquote>
<ul>
<li><p>Floats</p>
</li>
<li><p>Integers</p>
</li>
<li><p>Booleans</p>
</li>
<li><p>Triggers / 触发器类型</p>
<blockquote>
<p><code>U3D Document : Trigger Parameters are exclusively used to start Transitions. </code></p>
<p>触发器参数专门用于启动某种过渡</p>
</blockquote>
</li>
</ul>
<h2 id="Animator-Component-Properties-Animator-属性"><a href="#Animator-Component-Properties-Animator-属性" class="headerlink" title="Animator Component Properties / Animator 属性"></a>Animator Component Properties / Animator 属性</h2><ul>
<li><p>Avatar Setting</p>
<blockquote>
<p><code>U3D Document : The Avatar setting of the Animator component is optional, unless you’re animating a character with a Humanoid rig.</code></p>
<p>只有具有 humaniod rig 的角色需要设置 Avatar </p>
</blockquote>
</li>
<li><p>Apply Root Motion</p>
<blockquote>
<p><code>U3D Document : The Apply Root Motion setting determines whether or not any change to the Position or Rotation of the Root node will be applied.</code></p>
<p>该设置在于动画中对根节点位置与旋转的更改是否应用到场景中</p>
</blockquote>
</li>
<li><p>Update Mode / 更新模式</p>
<blockquote>
<p><code>U3D Document : The Update Mode of an Animator component affects when the code of the Animator is executed to update the properties it controls.  </code></p>
<p>该模式在于控制 更新其控制的动画化属性的时机</p>
<ol>
<li>Normal (In time with the render system between the Update and LateUpdate method calls. )</li>
<li>Animate Physics (In time with the physics system after the FixedUpdate method call. )</li>
<li>Unscaled Time (In time with the render system, but is not affected by Time.timeScale. This means that the speed of the animation will not change. )</li>
</ol>
</blockquote>
</li>
<li><p>Culling Mode / 剔除模式</p>
<blockquote>
<p><code>U3D Document : This setting affects what can cause the Animator to pause its updates for efficiency.  </code></p>
<p>剔除模式控制为效率而暂停动画的方式</p>
<ol>
<li>Always Animate 不剔除</li>
<li>Cull Update Transforms 只要 Animator 下的渲染器边界位于摄像机视椎体之外，则停止该Animator的动画，但是仍保留根运动</li>
<li>Cull Completely 只要 Animator 下的渲染器边界位于摄像机视椎体之外，则停止该Animator的动画以及根运动</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="Animator-State-Settings-状态设置"><a href="#Animator-State-Settings-状态设置" class="headerlink" title="Animator State Settings / 状态设置"></a>Animator State Settings / 状态设置</h2><ul>
<li><p>Name and Tag / 名称与标签</p>
<blockquote>
<p><code> U3D Document : These are both strings that are purely used for identification.</code></p>
<p>字符串类型用于标识状态身份</p>
<p><code>U3D Document : the Name must be unique but the Tag doesn’t need to be.</code></p>
<p>Name 字符串需要唯一，Tag 字符串不需要唯一</p>
</blockquote>
</li>
<li><p>Motion / 运动</p>
<blockquote>
<p>可以为动画切片或者混合树</p>
</blockquote>
</li>
<li><p>Speed and Multiplier / 速度与乘数</p>
<blockquote>
<p><code>U3D Document : You can use the next group of settings to manipulate how the Motion is played. </code></p>
<p>用于操纵 Motion 的播放速度，Multiplier 可成倍变化，可设置初始值后通过参数调整</p>
</blockquote>
</li>
<li><p>Motion/Normalized Time / 归一化时间</p>
<blockquote>
<p><code>U3D Document : Another way to control how an Animator State plays is by directly controlling its Normalized Time. </code></p>
<p>Normalized Time 仍用于控制状态的播放方式</p>
<p><code>U3D Document : Normalized Time is the concept of having the current time of the Motion being measured between 0 and 1.</code></p>
<p>归一化时间使用[0,1]来表示播放状态，0时开始播放，1时播放完毕</p>
</blockquote>
</li>
<li><p>Cycle Offset / 周期偏移</p>
<blockquote>
<p><code>U3D Document : This setting works alongside Normalized Time, in that it sets the Normalized Time the State will start playing at. If you want to change this, you can set it to a Float or have it controlled by a Float Parameter.</code></p>
<p>配合 Motion Time 使用，使用浮点数参数来控制偏移量</p>
</blockquote>
</li>
<li><p>Humanoid Settings - Mirror / 镜像</p>
<blockquote>
<p><code>U3D Document : Mirror reflects an animation from left to right. </code></p>
</blockquote>
</li>
<li><p>Humanoid Settings - Foot IK / 足部IK</p>
<blockquote>
<p><code>U3D Document : Foot IK uses the Muscle Clip data to estimate when each foot is supposed to be planted on the ground. When using Foot IK, the foot’s position is locked. </code></p>
<p>Foot Ik 用于判定何时哪只脚固定到地面上，此时足部的位置将被锁定，一般用于防止应处于固定态的足部运动</p>
</blockquote>
</li>
<li><p>Additional Settings - Write Defaults / 写入默认值</p>
<blockquote>
<p><code>U3D Document : An Animator gathers all the bindings from all the Animation Clips it contains and writes to each of them every frame.</code></p>
<p>一个 Animator 将聚集所有动画切片的所有绑定，并且每帧将绑定的值写入对应属性</p>
<p><code>U3D Document : When the Motion of an Animator State doesn’t write to a particular binding, If you enable Write Defaults, the default value of that binding is written to it. If you disable it the binding is not written to, and therefore keeps its previous value.</code></p>
<p>但是 Animator 状态的绑定未写入时，若勾选该设置，则使用默认值写入绑定，否则，不写入绑定保持原值</p>
</blockquote>
</li>
<li><p>Additional Settings - List of Transitions / 优先级</p>
<blockquote>
<p><code>U3D Document : The list is the priority order for the Transitions, meaning that their conditions will be checked in the order that’s shown on the list.</code></p>
<p>可以用于设置状态机中状态过渡的优先级</p>
</blockquote>
</li>
</ul>
<h2 id="State-Transitions-Settings-状态过渡设置"><a href="#State-Transitions-Settings-状态过渡设置" class="headerlink" title="State Transitions Settings / 状态过渡设置"></a>State Transitions Settings / 状态过渡设置</h2><hr>
<p><strong>Questions :</strong> </p>
<ul>
<li><del>Avatar Masks 的具体设置不是很理解</del></li>
<li><del>Normalised Range 与 Transform rotations 的转换</del></li>
<li>You want to use the built-in Humanoid features, such as arm and leg IK or target matching. 谁使用内置人形功能？人形功能是什么样的功能？</li>
<li>Controlling state properties 参数的用途2，3</li>
<li>Unscaled Time 更新模式 没概念</li>
<li>Layer / 动画层 动画层的混合权重应用 没概念</li>
<li>Nested Blending / 绑定嵌套 没概念</li>
<li>过渡完成时 Current State 是否具有1的权重，当下一过渡发生时，才会具有1的权重？</li>
</ul>
<hr>
<p>2022/1/12 15:51</p>
<hr>
<h1 id="General-Animation-Scripting-通用动画脚本"><a href="#General-Animation-Scripting-通用动画脚本" class="headerlink" title="General Animation Scripting / 通用动画脚本"></a>General Animation Scripting / 通用动画脚本</h1><blockquote>
<p><code>U3D Document : Most of the scripting discussed here is for methods found on the Animator component. Finding a reference to the Animator component is an assumed step before using any of these methods.</code></p>
<p>动画脚本基于 Animator 组件，因此在获取 Animator 属性前，需要先获取 Animator 组件的引用</p>
</blockquote>
<h3 id="Controlling-Animator-Parameter-Values-控制动画参数值"><a href="#Controlling-Animator-Parameter-Values-控制动画参数值" class="headerlink" title="Controlling Animator Parameter Values / 控制动画参数值"></a>Controlling Animator Parameter Values / 控制动画参数值</h3><blockquote>
<p><code>U3D Document : One of the most common reasons you might need to get the value of an Animator parameter is if it’s not being set by script but instead by an imported animation.</code></p>
<p>一般获取动画参数的原因不在于获取通过脚本设置的参数值，而是通过导入模型设置的参数值</p>
<p><code>U3D Document : Imported animations have the option to use additional Animation Curves, and each of these additional Animation Curves must have a name. If this name is the same as a float Animator Parameter, then while the animation is being evaluated the parameter will have its value set to that of the Animation Curve. </code></p>
<p>因为导入模型附加有动画曲线，该曲线仍具有名称，若该名称与动画参数同名，那么参数的值该跟随曲线而变化</p>
<p><code>U3D Document : These Animation Curves are subject to weighting, so if two animations are being blended, the value of the Animator Parameter will be a blend between its values for each animation.</code></p>
<p>由于动画曲线具有混合权重，因此混合时动画参数也将被混合</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SetParametersExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span> Animator animator;</span><br><span class="line">   <span class="comment">// 一般使用动画参数名称的哈希值来作函数参数，防止同名混淆</span></span><br><span class="line">   <span class="comment">// Animator.StringToHash(string) 获取string的哈希值</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">int</span> speedParameterHash = Animator.StringToHash(<span class="string">&quot;Speed&quot;</span>);</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>   &#123;</span><br><span class="line">       <span class="comment">//animator.SetBool(string name, Bool value) / animator.GetBool(string name)</span></span><br><span class="line">	<span class="comment">//animator.SetFloat(...) / animator.GetFloat(...)</span></span><br><span class="line">	   <span class="comment">//animator.SetInteger(...) / animator.GetInteger(...)</span></span><br><span class="line">	<span class="comment">//animator.SetTrigger(...) / animator.GetTrigger(...)</span></span><br><span class="line">       <span class="comment">//string 参数可使用 int 类型的哈希值代替</span></span><br><span class="line">       animator.SetFloat(speedParameterHash, <span class="number">5f</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Controlling-Animator-Layer-Weights-控制动画层权重"><a href="#Controlling-Animator-Layer-Weights-控制动画层权重" class="headerlink" title="Controlling Animator Layer Weights / 控制动画层权重"></a>Controlling Animator Layer Weights / 控制动画层权重</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">animator.SetLayerWeight()</span><br><span class="line"><span class="built_in">float</span> shootingLayerWeight = animator.GetLayerWeight (<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Flow-Control-流程控制"><a href="#Flow-Control-流程控制" class="headerlink" title="Flow Control / 流程控制"></a>Flow Control / 流程控制</h3><blockquote>
<p><code>U3D Document : Although one of the main jobs of Animator Parameters is to control Transitions, sometimes you might prefer to take control of the flow of animations that play more individually.</code></p>
<p>较于通过动画参数控制过渡，可以通过某些方法直接控制播放的动画</p>
</blockquote>
<ul>
<li><p>Play and PlayInFixedTime</p>
<blockquote>
<p><code>U3D Document : Play a State of a given name. They just do it slightly differently. </code></p>
<p>播放指定名称下的状态</p>
<p><code>注意:</code></p>
<ol>
<li>两者区别仅在于第三个参数，Play 为归一化的时间，PlayInFixedTime 为秒</li>
</ol>
</blockquote>
</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FlowControlExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Animator animator;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">int</span> shootStateHash = Animator.StringToHash(<span class="string">&quot;Shoot&quot;</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">int</span> walkStateHash = Animator.StringToHash(<span class="string">&quot;Walk&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        animator.Play(<span class="string">&quot;Run&quot;</span>, <span class="number">0</span>, <span class="number">0.1f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            Parameters:</span></span><br><span class="line"><span class="comment">                string/int : 指定待播放状态的名称/名称哈希值</span></span><br><span class="line"><span class="comment">                int : 指定待播放状态所在动画层的索引</span></span><br><span class="line"><span class="comment">                float : 指定待播放状态的播放时机，以 Current 状态为基准</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(Input.GetKeyDown(KeyCode.Space))</span><br><span class="line">            animator.PlayInFixedTime(shootStateHash, <span class="number">1</span>, <span class="number">0f</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(Input.GetKeyDown(KeyCode.LeftShift))</span><br><span class="line">            animator.Play(walkStateHash, <span class="number">0.5f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>CrossFade and CrossFadeInFixedTime</p>
<blockquote>
<p><code>U3D Document : It works more like Transitions.</code></p>
<p>目前认为该方法用于创建无条件临时过渡</p>
</blockquote>
</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FlowControlExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Animator animator;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">int</span> shootStateHash = Animator.StringToHash(<span class="string">&quot;Shoot&quot;</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">int</span> walkStateHash = Animator.StringToHash(<span class="string">&quot;Walk&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        animator.Play(<span class="string">&quot;Run&quot;</span>, <span class="number">0</span>, <span class="number">0.1f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            Parameters:</span></span><br><span class="line"><span class="comment">                string / int : The name of the State to be cross faded to (as either a string or a hash of the State’s name)</span></span><br><span class="line"><span class="comment">                float : How long the fade should take / 过渡持续时间</span></span><br><span class="line"><span class="comment">                int : The index of the Layer of the State being cross-faded to / 动画层索引</span></span><br><span class="line"><span class="comment">                float : The offset through the State being transitioned to / Next 状态的偏移量</span></span><br><span class="line"><span class="comment">                float : The time through the fade to start at / 此参数必须为归一化时间</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.LeftShift))</span><br><span class="line">            animator.CrossFade(walkStateHash, <span class="number">1f</span>, <span class="number">0</span>, <span class="number">0.1f</span>, <span class="number">0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="MonoBehaviour-Messages-消息"><a href="#MonoBehaviour-Messages-消息" class="headerlink" title="MonoBehaviour Messages / 消息"></a>MonoBehaviour Messages / 消息</h3><ul>
<li><p>OnAnimatorMove()</p>
<blockquote>
<p><code>U3D Document : However, if a MonoBehaviour calls the OnAnimatorMove method, then it controls the Root Motion. </code></p>
<p>OnAnimatorMove 可以用于控制根运动，可以调用 animator.deltaPosition，animator.deltaRotation 来完成对根运动的设置</p>
<p><code>U3D Document : An empty OnAnimatorMove method will make an Animator behave as though it has no Root Motion. </code></p>
<p>若该方法为空，则 Animator 无根运动</p>
</blockquote>
</li>
<li><p>Update Mode / 更新模式</p>
<blockquote>
<p>Normal : Update() -&gt; OnAnimatorMove() -&gt; OnAnimatorIK() -&gt; LateUpdate()</p>
<p>Animate Physics : FixedUpdate() -&gt; OnAnimatorMove() -&gt; Internal Update(物理系统内置更新用于检测碰撞) -&gt; OnAnimatorIK()</p>
</blockquote>
</li>
</ul>
<h3 id="State-and-Animation-Clip-Information-获取状态与切片信息"><a href="#State-and-Animation-Clip-Information-获取状态与切片信息" class="headerlink" title="State and Animation Clip Information / 获取状态与切片信息"></a>State and Animation Clip Information / 获取状态与切片信息</h3><ul>
<li><p>animator.IsInTransition(…)</p>
<blockquote>
<p>可获取某一动画层是否处于过渡状态</p>
</blockquote>
</li>
<li><p>animator.GetCurrentAnimatorStateInfo(…) / animator.GetNextAnimatorStateInfo(…)</p>
<blockquote>
<p>可获取某动画层当前状态以及下一状态的信息，若无下一状态，则返回默认值</p>
</blockquote>
</li>
<li><p>AnimatorStateInfo 结构</p>
<blockquote>
<p><code>U3D Document : It contains concise information about the State such as: Length，Hashes for the name and tag，Speed.&quot; </code></p>
<p>其包含状态的某些信息，如状态长度，名称的哈希值，播放速度等</p>
</blockquote>
</li>
<li><p>animator.GetCurrentAnimatorClipInfo(…) / animator.GetNextAnimatorClipInfo(…)</p>
<blockquote>
<p><code>U3D Document : They both have an index parameter for the Animator Layer, but instead return an array of AnimatorClipInfos. </code></p>
<p>获取某动画层的所有状态信息，返回 AnimatorClipInfos 数组</p>
</blockquote>
</li>
<li><p>AnimatorClipInfos 结构</p>
<blockquote>
<p><code>U3D Document : These are structs with a reference to the Animation Clip being played and its Weight. This Weight is the blending weight, meaning it takes both Blend Trees and Transitions into account. It does not take the weights of Animator Layers into account.</code></p>
<p>AnimatorClipInfos 结构存放着动画切片的引用以及其权重，同时考虑了混合树与过渡的权重，但是 Layer 权重不考虑在内</p>
</blockquote>
</li>
</ul>
<h1 id="Humanoid-Specific-Animation-Scripting-人形动画脚本"><a href="#Humanoid-Specific-Animation-Scripting-人形动画脚本" class="headerlink" title="Humanoid-Specific Animation Scripting / 人形动画脚本"></a>Humanoid-Specific Animation Scripting / 人形动画脚本</h1><h2 id="Target-Matching-and-IK-目标匹配与IK"><a href="#Target-Matching-and-IK-目标匹配与IK" class="headerlink" title="Target Matching and IK / 目标匹配与IK"></a>Target Matching and IK / 目标匹配与IK</h2><blockquote>
<p><code>U3D Document : However, sometimes you might want to set the position or rotation of a bone near the bottom of the hierarchy (called the effector) separately. In this case, the rest of the hierarchy needs to change to accommodate the effector’s position or rotation. </code></p>
<p>可以通过目标匹配或IK，完成更改效应器(骨骼链末端骨骼)的位置与旋转，进而更新骨骼链其余上级骨骼来适应效应器的变换</p>
</blockquote>
<h3 id="Target-Matching-目标匹配"><a href="#Target-Matching-目标匹配" class="headerlink" title="Target Matching / 目标匹配"></a>Target Matching / 目标匹配</h3><blockquote>
<p><code>U3D Document : Target matching moves the root of the hierarchy so that the effector is in the correct position or rotation without changing the rest of the hierarchy. </code></p>
<p>目标匹配仅改变骨骼层级中根节点的位置与旋转来使效应器处于正确的位置与旋转，而不改变其余骨骼的位置与旋转</p>
</blockquote>
<ul>
<li><p>animator.MatchTarget(…)</p>
<blockquote>
<p><code>U3D Document : Target matching is done using the MatchTarget method of the Animator Controller. The method should be called once during the State where you wish to target-match at any time before you want the matching to start. </code></p>
<p>目标匹配通过 Animator 组件的 MatchTarget 方法完成，需要在某一状态播放下的某个时间点调用 MatchTarget 方法，启动匹配</p>
<p><code>U3D Document : The parameters for the MatchTarget method can be split into three groups, with two parameters each.</code></p>
<p>该方法有三组参数，分别为 Target Information ，Effector Information ，Information about when the target matching should happen.</p>
</blockquote>
</li>
<li><p>Target Information / 目标信息</p>
<blockquote>
<p><code>U3D Document : The target information parameters are simply the world-space position to be matched and the world space rotation to be matched.</code></p>
<p>匹配目标的全局位置与全局旋转</p>
</blockquote>
</li>
<li><p>Effector Information / 效应器信息</p>
<p><strong>AvatarTarget</strong></p>
<blockquote>
<p><code>U3D Document : The first of the effector information parameters is an enumeration to determine which body part is the effector. </code></p>
<p>AvatarTarget 用来定义 Humaniod Avatar 哪一个身体部位用作效应器进行匹配，为枚举类型(Root，Body，LeftFoot，RightFoot，LeftHand，RightHand)</p>
</blockquote>
<p><strong>MatchTargetWeightMask</strong></p>
<blockquote>
<p><code>U3D Document : The second of the effector information parameters is a struct called MatchTargetWeightMask. It determines what balance of the original position and the target position the effector should take. </code></p>
<p>MatchTargetWeightMask 为一种结构体，定义了原始位置与目标位置应该采取的平衡，其构造函数需要具有两个参数</p>
<p>MatchTargetWeightMask(Vector3 _1,float _2) </p>
<p>_1 : The positional weight (called positionXYZWeight) is a Vector3 that should have a value between 0 and 1 for each axis to control how much the effector should use that axis of the target position. / 浮点值类型用于规定效应器应使用多少目标位置的轴</p>
<p>_2 : The rotational weight (called rotationWeight) is a float allowing for linear interpolation between the original rotation and the target rotation. / 原始旋转与目标旋转的插值</p>
<p>注意:</p>
<ol>
<li>Root 枚举代表身体的质心</li>
</ol>
</blockquote>
</li>
<li><p>Information about when the target matching should happen / 时间参数</p>
<blockquote>
<p><code>U3D Document : The final two parameters are floats giving the Normalized Time of the State. They are when the target matching should start and when it should reach the target.</code></p>
<p>归一化的时间类型，表示发生目标匹配的时间与其匹配到目标的时间</p>
</blockquote>
</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">VaultTargetMatching</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Animator animator;</span><br><span class="line">    <span class="keyword">public</span> Transform wallHandPosition;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> takeOffTime = <span class="number">0.027f</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> handDownTime = <span class="number">0.371f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (animator.GetCurrentAnimatorStateInfo(<span class="number">0</span>).IsName(<span class="string">&quot;Vault&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            MatchTargetWeightMask mask = <span class="keyword">new</span> MatchTargetWeightMask(Vector3.one, <span class="number">0f</span>);</span><br><span class="line">            animator.MatchTarget(wallHandPosition.position, wallHandPosition.rotation, AvatarTarget.LeftHand, mask, takeOffTime, handDownTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Inverse-Kinematics-IK"><a href="#Inverse-Kinematics-IK" class="headerlink" title="Inverse Kinematics / IK"></a>Inverse Kinematics / IK</h2><blockquote>
<p><code>U3D Document : IK doesn’t move the root of the hierarchy, but it does change the pose of the character. There are many different algorithms used for IK, but what they all have in common is that they set the position or rotation of bones further up the hierarchy so that the effector is at its desired position or rotation. </code></p>
<p>IK 不同于目标匹配，IK 不改变根节点的位置与旋转，而是设置层级中上一骨骼的以便效应器能处于期望的位置与旋转</p>
<p><code>U3D Document : There are three important variables that are used with the two-bone inverse kinematics (IK) algorithm that the animator uses: The target position，The target rotation，The hint position.</code></p>
<p>双关节IK算法需要知道三个重要参数 The target position，The target rotation，The hint position.</p>
<p><code>U3D Document : The target position and rotation are the position and rotation that the hand or foot will try to reach. The hint position is the position that the elbow or knee for that limb will try to reach. </code></p>
<p>目标位置与目标旋转为手或者足部想要到达的位置和旋转，提示位置为肘或膝盖想要到达的位置</p>
<p><code>注意:</code></p>
<ol>
<li>The target position，The target rotation，The hint position 均有其权重，可以获取并设置 IK 相应状态与权重</li>
</ol>
</blockquote>
<h2 id="MonoBehaviour-Messages-消息-1"><a href="#MonoBehaviour-Messages-消息-1" class="headerlink" title="MonoBehaviour Messages / 消息"></a>MonoBehaviour Messages / 消息</h2><ul>
<li> OnAnimatorIK(…)</li>
</ul>
<blockquote>
<p><code>U3D Document : OnAnimatorIK is called once per update for every Animator Layer which has its IK Pass enabled. Each call has the Layer’s index passed as a parameter. This means you can deal with various uses of IK separately. </code></p>
<p>OnAnimatorIK 将在动画层 IK Pass 选中的情况下，每更新一次调用一次</p>
</blockquote>
<ul>
<li><p>Update Mode / 更新模式</p>
<blockquote>
<p>Normal : Update() -&gt; OnAnimatorMove() -&gt; OnAnimatorIK() -&gt; LateUpdate()</p>
<p>Animate Physics : FixedUpdate() -&gt; OnAnimatorMove() -&gt; Internal Update(物理系统内置更新用于检测碰撞) -&gt; OnAnimatorIK()</p>
</blockquote>
</li>
</ul>
<hr>
<p><strong>Questions :</strong> </p>
<ul>
<li>Play and PlayInFixedTime 执行时是不是强制需要具有当前状态到某个状态的过渡？</li>
<li>CrossFade 不就相当于设置了一个过渡？</li>
<li>Information about when the target matching should happen / 时间参数 到达目标的时间？是怎么界定的？</li>
<li>MatchTargetWeightMask 结构构造函数不清楚</li>
</ul>
<hr>
<p>2022/1/17 21:36</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">YunDid</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/03/22/Unity/Unity_%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/">http://example.com/2022/03/22/Unity/Unity_%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">YunDid's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Animation-Systems/">Animation Systems</a></div><div class="post_share"><div class="social-share" data-image="/img/ma3.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/03/22/Unreal/Ue4_%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F%E6%9C%AA%E5%AE%8C/"><img class="prev-cover" src="/img/ma3.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Ue4 - Animation System</div></div></a></div><div class="next-post pull-right"><a href="/2022/03/22/Unity/Unity_%E7%BC%96%E7%A8%8B/"><img class="next-cover" src="/img/ma3.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Unity - 编程进阶</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/03/22/Animation/CenterAI_神经状态机/" title="Siggraph Asia 2019 - 神经状态机"><img class="cover" src="/img/ma3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-22</div><div class="title">Siggraph Asia 2019 - 神经状态机</div></div></a></div><div><a href="/2022/03/22/Unreal/Ue4_动画系统未完/" title="Ue4 - Animation System"><img class="cover" src="/img/ma3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-22</div><div class="title">Ue4 - Animation System</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/1.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">YunDid</div><div class="author-info__description">欢迎来到 YunDid's Blog！有疑问可以到 “留言板” 提问！^_^</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">47</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/YunDid"><i class="fab fa-github"></i><span>博主的GitHub首页</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/YunDid" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:512862613@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">萌新一枚~</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Unity-Animation-Systems-Unity-%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.</span> <span class="toc-text">Unity Animation Systems &#x2F; Unity 动画系统</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#The-Current-Progress-%E5%BD%93%E5%89%8D%E8%BF%9B%E5%BA%A6"><span class="toc-number">2.</span> <span class="toc-text">The Current Progress &#x2F; 当前进度</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Animation-Data-%E5%8A%A8%E7%94%BB%E6%95%B0%E6%8D%AE"><span class="toc-number">3.</span> <span class="toc-text">Animation Data &#x2F; 动画数据</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Animation-Clip-%E5%8A%A8%E7%94%BB%E5%88%87%E7%89%87"><span class="toc-number">3.1.</span> <span class="toc-text">Animation Clip &#x2F; 动画切片</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Values-%E5%80%BC"><span class="toc-number">3.1.0.1.</span> <span class="toc-text">Values &#x2F; 值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bindings-%E7%BB%91%E5%AE%9A"><span class="toc-number">3.1.0.2.</span> <span class="toc-text">Bindings &#x2F; 绑定</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Binding-System-%E7%BB%91%E5%AE%9A%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.2.</span> <span class="toc-text">Binding System &#x2F; 绑定系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Animation-Mode-%E5%8A%A8%E7%94%BB%E5%8C%96%E6%96%B9%E5%BC%8F"><span class="toc-number">3.2.1.</span> <span class="toc-text">Animation Mode &#x2F; 动画化方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Animation-Blending-%E5%8A%A8%E7%94%BB%E6%B7%B7%E5%90%88"><span class="toc-number">4.</span> <span class="toc-text">Animation Blending &#x2F; 动画混合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Blending-Algorithms-%E6%B7%B7%E5%90%88%E7%AE%97%E6%B3%95"><span class="toc-number">4.1.</span> <span class="toc-text">Blending Algorithms &#x2F; 混合算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Features-Using-Blending-%E6%B7%B7%E5%90%88%E5%BA%94%E7%94%A8"><span class="toc-number">4.2.</span> <span class="toc-text">Features Using Blending &#x2F; 混合应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Nested-Blending-%E6%B7%B7%E5%90%88%E5%B5%8C%E5%A5%97"><span class="toc-number">4.3.</span> <span class="toc-text">Nested Blending &#x2F; 混合嵌套</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Animator-Controller-%E5%8A%A8%E7%94%BB%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">4.4.</span> <span class="toc-text">Animator Controller &#x2F; 动画控制器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Animator-Transition-%E7%8A%B6%E6%80%81%E8%BF%87%E6%B8%A1"><span class="toc-number">4.4.1.</span> <span class="toc-text">Animator Transition &#x2F; 状态过渡</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Current-and-Next-States-%E5%BD%93%E5%89%8D%E4%B8%8E%E4%B8%8B%E4%B8%80%E7%8A%B6%E6%80%81"><span class="toc-number">4.4.1.1.</span> <span class="toc-text">Current and Next States &#x2F; 当前与下一状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Transition-Settings-%E8%BF%87%E6%B8%A1%E8%AE%BE%E7%BD%AE"><span class="toc-number">4.4.1.2.</span> <span class="toc-text">Transition Settings &#x2F; 过渡设置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#State-Machines-%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="toc-number">4.4.2.</span> <span class="toc-text">State Machines &#x2F; 状态机</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#State-Machine-Transitions-%E7%8A%B6%E6%80%81%E6%9C%BA%E8%BF%87%E6%B8%A1"><span class="toc-number">4.4.2.1.</span> <span class="toc-text">State Machine Transitions &#x2F; 状态机过渡</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Animator-Layers-%E5%8A%A8%E7%94%BB%E5%B1%82"><span class="toc-number">4.4.3.</span> <span class="toc-text">Animator Layers &#x2F; 动画层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Animator-Layer-Blending-Layer-%E6%B7%B7%E5%90%88"><span class="toc-number">4.4.3.1.</span> <span class="toc-text">Animator Layer Blending &#x2F; Layer 混合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Sync-and-IK-Pass-%E5%90%8C%E6%AD%A5%E4%B8%8EIK"><span class="toc-number">4.4.3.2.</span> <span class="toc-text">Sync and IK Pass &#x2F; 同步与IK</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Model-Specific-Animation-%E6%A8%A1%E5%9E%8B%E5%8A%A8%E7%94%BB"><span class="toc-number">5.</span> <span class="toc-text">Model-Specific Animation &#x2F; 模型动画</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Fundamentals-%E5%9F%BA%E7%A1%80"><span class="toc-number">5.1.</span> <span class="toc-text">Fundamentals &#x2F; 基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Triangle-Mesh-%E4%B8%89%E8%A7%92%E7%BD%91%E6%A0%BC"><span class="toc-number">5.1.1.</span> <span class="toc-text">Triangle Mesh &#x2F; 三角网格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Forward-Kinematics-FK%E6%AD%A3%E5%90%91%E5%8A%A8%E5%8A%9B%E5%AD%A6"><span class="toc-number">5.1.2.</span> <span class="toc-text">Forward Kinematics &#x2F; FK正向动力学</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Inverse-Kinematics-IK%E9%80%86%E5%90%91%E5%8A%A8%E5%8A%9B%E5%AD%A6"><span class="toc-number">5.1.3.</span> <span class="toc-text">Inverse Kinematics &#x2F; IK逆向动力学</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Model-Specific-Import-Settings-%E6%A8%A1%E5%9E%8B%E5%AF%BC%E5%85%A5%E8%AE%BE%E7%BD%AE"><span class="toc-number">5.2.</span> <span class="toc-text">Model-Specific Import Settings &#x2F; 模型导入设置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Animation-Specific-Import-Settings-%E5%88%87%E7%89%87%E5%AF%BC%E5%85%A5%E8%AE%BE%E7%BD%AE"><span class="toc-number">5.3.</span> <span class="toc-text">Animation-Specific Import Settings &#x2F; 切片导入设置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Cutting-Imported-Animation-Clips-%E5%89%AA%E5%88%87%E5%8A%A8%E7%94%BB%E5%88%87%E7%89%87"><span class="toc-number">5.3.1.</span> <span class="toc-text">Cutting Imported Animation Clips &#x2F; 剪切动画切片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Timeline-%E6%97%B6%E9%97%B4%E8%BD%B4"><span class="toc-number">5.3.2.</span> <span class="toc-text">Timeline &#x2F; 时间轴</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Timeline-Settings-%E6%97%B6%E9%97%B4%E8%BD%B4%E8%AE%BE%E7%BD%AE"><span class="toc-number">5.3.3.</span> <span class="toc-text">Timeline Settings &#x2F; 时间轴设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Root-Motion-%E6%A0%B9%E8%BF%90%E5%8A%A8"><span class="toc-number">5.3.4.</span> <span class="toc-text">Root Motion &#x2F; 根运动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Additional-Settings-%E5%85%B6%E4%BB%96%E8%AE%BE%E7%BD%AE"><span class="toc-number">5.3.5.</span> <span class="toc-text">Additional Settings &#x2F; 其他设置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Mirror-Setting-%E9%95%9C%E5%83%8F%E8%AE%BE%E7%BD%AE"><span class="toc-number">5.3.5.1.</span> <span class="toc-text">Mirror Setting &#x2F; 镜像设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Additive-Reference-Pose-Setting-%E9%99%84%E5%8A%A0%E5%BC%95%E7%94%A8%E5%A7%BF%E5%8A%BF"><span class="toc-number">5.3.5.2.</span> <span class="toc-text">Additive Reference Pose Setting &#x2F; 附加引用姿势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Curves-%E6%9B%B2%E7%BA%BF"><span class="toc-number">5.3.5.3.</span> <span class="toc-text">Curves &#x2F; 曲线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Events-%E4%BA%8B%E4%BB%B6"><span class="toc-number">5.3.5.4.</span> <span class="toc-text">Events &#x2F; 事件</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Model-Rig-%E6%A8%A1%E5%9E%8BRig"><span class="toc-number">6.</span> <span class="toc-text">Model Rig &#x2F;  模型Rig</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Configuring-Generic-Rigs-%E9%85%8D%E7%BD%AE-Generic-Rig"><span class="toc-number">6.1.</span> <span class="toc-text">Configuring Generic Rigs &#x2F; 配置 Generic Rig</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Configuring-Humaniod-Rigs-%E9%85%8D%E7%BD%AE-Humaniod-Rig"><span class="toc-number">6.2.</span> <span class="toc-text">Configuring Humaniod Rigs &#x2F; 配置 Humaniod Rig</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Animation-Playback-Process-%E4%BA%BA%E5%BD%A2%E5%8A%A8%E7%94%BB%E6%92%AD%E6%94%BE%E8%BF%87%E7%A8%8B"><span class="toc-number">6.2.1.</span> <span class="toc-text">Animation Playback Process &#x2F; 人形动画播放过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Avatar-configuration-Avatar-%E9%85%8D%E7%BD%AE"><span class="toc-number">6.2.2.</span> <span class="toc-text">Avatar configuration &#x2F; Avatar 配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Mapping-%E7%BB%91%E5%AE%9A"><span class="toc-number">6.2.2.1.</span> <span class="toc-text">Mapping &#x2F; 绑定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Muscles-amp-Settings-%E8%82%8C%E8%82%89%E8%AE%BE%E7%BD%AE"><span class="toc-number">6.2.2.2.</span> <span class="toc-text">Muscles &amp; Settings &#x2F; 肌肉设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Humanoid-Avatar-Masks-Avatar-%E9%81%AE%E7%BD%A9"><span class="toc-number">6.2.2.3.</span> <span class="toc-text">Humanoid Avatar Masks &#x2F; Avatar 遮罩</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Animation-Windows-%E5%8A%A8%E7%94%BB%E7%AA%97%E5%8F%A3"><span class="toc-number">7.</span> <span class="toc-text">Animation Windows &#x2F; 动画窗口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Keyframes-%E5%85%B3%E9%94%AE%E5%B8%A7"><span class="toc-number">7.1.</span> <span class="toc-text">Keyframes &#x2F; 关键帧</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Keyframes-Tangents-%E5%85%B3%E9%94%AE%E5%B8%A7%E5%88%87%E7%BA%BF"><span class="toc-number">7.2.</span> <span class="toc-text">Keyframes Tangents &#x2F; 关键帧切线</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Animation-Events-%E5%8A%A8%E7%94%BB%E4%BA%8B%E4%BB%B6"><span class="toc-number">7.3.</span> <span class="toc-text">Animation Events &#x2F; 动画事件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Animator-Component-%E5%8A%A8%E7%94%BB%E5%99%A8%E7%BB%84%E4%BB%B6"><span class="toc-number">8.</span> <span class="toc-text">Animator Component &#x2F; 动画器组件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Animator-Parameters-%E5%8A%A8%E7%94%BB%E5%8F%82%E6%95%B0"><span class="toc-number">8.1.</span> <span class="toc-text">Animator Parameters &#x2F; 动画参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Animator-Component-Properties-Animator-%E5%B1%9E%E6%80%A7"><span class="toc-number">8.2.</span> <span class="toc-text">Animator Component Properties &#x2F; Animator 属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Animator-State-Settings-%E7%8A%B6%E6%80%81%E8%AE%BE%E7%BD%AE"><span class="toc-number">8.3.</span> <span class="toc-text">Animator State Settings &#x2F; 状态设置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#State-Transitions-Settings-%E7%8A%B6%E6%80%81%E8%BF%87%E6%B8%A1%E8%AE%BE%E7%BD%AE"><span class="toc-number">8.4.</span> <span class="toc-text">State Transitions Settings &#x2F; 状态过渡设置</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#General-Animation-Scripting-%E9%80%9A%E7%94%A8%E5%8A%A8%E7%94%BB%E8%84%9A%E6%9C%AC"><span class="toc-number">9.</span> <span class="toc-text">General Animation Scripting &#x2F; 通用动画脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Controlling-Animator-Parameter-Values-%E6%8E%A7%E5%88%B6%E5%8A%A8%E7%94%BB%E5%8F%82%E6%95%B0%E5%80%BC"><span class="toc-number">9.0.1.</span> <span class="toc-text">Controlling Animator Parameter Values &#x2F; 控制动画参数值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Controlling-Animator-Layer-Weights-%E6%8E%A7%E5%88%B6%E5%8A%A8%E7%94%BB%E5%B1%82%E6%9D%83%E9%87%8D"><span class="toc-number">9.0.2.</span> <span class="toc-text">Controlling Animator Layer Weights &#x2F; 控制动画层权重</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Flow-Control-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">9.0.3.</span> <span class="toc-text">Flow Control &#x2F; 流程控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MonoBehaviour-Messages-%E6%B6%88%E6%81%AF"><span class="toc-number">9.0.4.</span> <span class="toc-text">MonoBehaviour Messages &#x2F; 消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#State-and-Animation-Clip-Information-%E8%8E%B7%E5%8F%96%E7%8A%B6%E6%80%81%E4%B8%8E%E5%88%87%E7%89%87%E4%BF%A1%E6%81%AF"><span class="toc-number">9.0.5.</span> <span class="toc-text">State and Animation Clip Information &#x2F; 获取状态与切片信息</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Humanoid-Specific-Animation-Scripting-%E4%BA%BA%E5%BD%A2%E5%8A%A8%E7%94%BB%E8%84%9A%E6%9C%AC"><span class="toc-number">10.</span> <span class="toc-text">Humanoid-Specific Animation Scripting &#x2F; 人形动画脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Target-Matching-and-IK-%E7%9B%AE%E6%A0%87%E5%8C%B9%E9%85%8D%E4%B8%8EIK"><span class="toc-number">10.1.</span> <span class="toc-text">Target Matching and IK &#x2F; 目标匹配与IK</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Target-Matching-%E7%9B%AE%E6%A0%87%E5%8C%B9%E9%85%8D"><span class="toc-number">10.1.1.</span> <span class="toc-text">Target Matching &#x2F; 目标匹配</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Inverse-Kinematics-IK"><span class="toc-number">10.2.</span> <span class="toc-text">Inverse Kinematics &#x2F; IK</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MonoBehaviour-Messages-%E6%B6%88%E6%81%AF-1"><span class="toc-number">10.3.</span> <span class="toc-text">MonoBehaviour Messages &#x2F; 消息</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/04/10/Maching_learning/Maching%20learning/" title="机器学习 - 入门"><img src="/img/ma3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="机器学习 - 入门"/></a><div class="content"><a class="title" href="/2023/04/10/Maching_learning/Maching%20learning/" title="机器学习 - 入门">机器学习 - 入门</a><time datetime="2023-04-10T09:30:00.000Z" title="发表于 2023-04-10 17:30:00">2023-04-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/27/Matlab/Matlab/" title="Matlab 入门"><img src="/img/ma3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Matlab 入门"/></a><div class="content"><a class="title" href="/2023/02/27/Matlab/Matlab/" title="Matlab 入门">Matlab 入门</a><time datetime="2023-02-27T01:30:00.000Z" title="发表于 2023-02-27 09:30:00">2023-02-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/22/Animation/CenterAI_%E7%A5%9E%E7%BB%8F%E7%8A%B6%E6%80%81%E6%9C%BA/" title="Siggraph Asia 2019 - 神经状态机"><img src="/img/ma3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Siggraph Asia 2019 - 神经状态机"/></a><div class="content"><a class="title" href="/2022/03/22/Animation/CenterAI_%E7%A5%9E%E7%BB%8F%E7%8A%B6%E6%80%81%E6%9C%BA/" title="Siggraph Asia 2019 - 神经状态机">Siggraph Asia 2019 - 神经状态机</a><time datetime="2022-03-22T02:40:00.000Z" title="发表于 2022-03-22 10:40:00">2022-03-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/22/Unreal/Ue4_GamePlay%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3/" title="YumiGame - Ue4 - GamePlay"><img src="/img/ma3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="YumiGame - Ue4 - GamePlay"/></a><div class="content"><a class="title" href="/2022/03/22/Unreal/Ue4_GamePlay%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3/" title="YumiGame - Ue4 - GamePlay">YumiGame - Ue4 - GamePlay</a><time datetime="2022-03-22T02:30:00.000Z" title="发表于 2022-03-22 10:30:00">2022-03-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/22/Unreal/Ue4_%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F%E6%9C%AA%E5%AE%8C/" title="Ue4 - Animation System"><img src="/img/ma3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Ue4 - Animation System"/></a><div class="content"><a class="title" href="/2022/03/22/Unreal/Ue4_%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F%E6%9C%AA%E5%AE%8C/" title="Ue4 - Animation System">Ue4 - Animation System</a><time datetime="2022-03-22T02:28:00.000Z" title="发表于 2022-03-22 10:28:00">2022-03-22</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By YunDid</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><i class="fab fa-qq"></i> 512862613 | <i class="fab fa-weixin"></i> Mmm-myy1</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">簡</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'RUIbtPgCc0o0TGaeqMWlX9P5-gzGzoHsz',
      appKey: 'PaoiG1dlQjiDQAVRBexH6KkR',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="https://cdn.jsdelivr.net/npm/live2d-widget@^3.1.3/lib/L2Dwidget.min.js"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"superSample":2,"position":"left","width":150,"height":300,"hOffset":20,"vOffset":-90},"mobile":{"show":true,"scale":1},"react":{"opacityDefault":0.3,"opacityOnHover":0.3,"opacity":0.95},"log":false});</script></body></html>